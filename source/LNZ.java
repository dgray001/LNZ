/* autogenerated by Processing revision 1283 on 2022-07-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.concurrent.*;
import java.io.*;
import java.nio.file.*;
import java.awt.event.KeyEvent;
import processing.javafx.*;
import ddf.minim.*;
import ddf.minim.ugens.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class LNZ extends PApplet {










Global global;

 public void setup() {
  /* size commented out by preprocessor */;
  //pixelDensity(displayDensity());
  surface.setSize(Constants.initialInterface_size, Constants.initialInterface_size);
  surface.setLocation(PApplet.parseInt(0.5f * (displayWidth - Constants.initialInterface_size)),
    PApplet.parseInt(0.5f * (displayHeight - Constants.initialInterface_size)));
  frameRate(Constants.maxFPS);
  global = new Global(this);
  Profile p = new Profile();
  p.options.setVolumes(); // sets default volumes for initial interface
  background(global.color_background);
  global.menu = new InitialInterface();
  noCursor();
  mouseX = -50;
  mouseY = -50;
}

 public void draw() {
  int time_elapsed = millis() - global.lastFrameTime;
  if (time_elapsed < 5) { // hard throttle to keep framerate < 200
    return;
  }
  actuallyDraw();
}

 public void actuallyDraw() {
  int timeElapsed = global.frame();
  // FPS counter
  global.timer_FPS -= timeElapsed;
  if (global.timer_FPS < 0) {
    global.timer_FPS = Constants.frameUpdateTime;
    global.lastFPS = (Constants.frameAverageCache * global.lastFPS + PApplet.parseFloat(frameCount - global.frameCounter) *
      (1000.0f / Constants.frameUpdateTime)) / (Constants.frameAverageCache + 1);
    global.frameCounter = frameCount + 1;
  }
  // Player unit ellipse
  if (global.player_blinks_left > 0) {
    global.player_blink_time -= timeElapsed;
    if (global.player_blink_time < 0) {
      global.player_blink_time += Constants.level_questBlinkTime;
      global.player_blinks_left--;
      global.player_blinking = !global.player_blinking;
    }
  }
  // Program
  if (global.menu != null) {
    global.menu.LNZ_update(millis());
  }
  switch(global.state) {
    case INITIAL_INTERFACE:
      break;
    case ENTERING_MAINMENU:
      global.timer_exiting -= timeElapsed;
      background(30, 0, 0);
      if (global.timer_exiting < 0) {
        global.timer_exiting = Constants.exit_delay;
        global.state = ProgramState.MAINMENU_INTERFACE;
        global.menu = new MainMenuInterface();
        global.sounds.play_background("main");
        global.defaultCursor();
      }
      break;
    case MAINMENU_INTERFACE:
      break;
    case ENTERING_MAPEDITOR:
      background(60);
      global.state = ProgramState.MAPEDITOR_INTERFACE;
      global.menu = new MapEditorInterface();
      global.sounds.play_background("aoc");
      global.defaultCursor();
      break;
    case MAPEDITOR_INTERFACE:
      break;
    case ENTERING_TUTORIAL:
      background(60);
      global.state = ProgramState.TUTORIAL;
      global.menu = new TutorialInterface();
      global.sounds.play_background("none");
      global.defaultCursor();
      break;
    case TUTORIAL:
      break;
    case ENTERING_PLAYING:
      background(60);
      global.state = ProgramState.PLAYING;
      global.menu = new PlayingInterface();
      global.defaultCursor();
      break;
    case PLAYING:
      break;
    case ENTERING_MINIGAMES:
      background(60);
      global.state = ProgramState.MINIGAMES;
      global.menu = new MinigameInterface();
      global.defaultCursor();
      break;
    case MINIGAMES:
      break;
    case EXITING:
      global.timer_exiting -= timeElapsed;
      if (global.timer_exiting < 0) {
        exit();
      }
      break;
    default:
      break;
  }
  // global notification
  if (global.notification.peek() != null) {
    global.notification.peek().update(timeElapsed);
    if (global.notification.peek().finished) {
      global.notification.remove();
    }
  }
  // background music go to next track
  global.sounds.update();
  // cursor
  imageMode(CENTER);
  image(global.cursor, mouseX, mouseY, global.configuration.cursor_size, global.configuration.cursor_size);
  // check focused
  if (!focused && global.focused_last_frame) {
    global.loseFocus();
  }
  else if (focused && !global.focused_last_frame) {
    global.gainFocus();
  }
  global.focused_last_frame = focused;
  // check error message
  global.checkErrorMessge();
}

 public void mouseDragged() {
  if (global.menu != null) {
    global.menu.LNZ_mouseMove(mouseX, mouseY);
  }
  if (global.notification.peek() != null) {
    global.notification.peek().mouseMove(mouseX, mouseY);
  }
}
 public void mouseMoved() {
  if (global.menu != null) {
    global.menu.LNZ_mouseMove(mouseX, mouseY);
  }
  if (global.notification.peek() != null) {
    global.notification.peek().mouseMove(mouseX, mouseY);
  }
}

 public void mousePressed() {
  if (mouseButton == RIGHT) {
    global.holding_rightclick = true;
  }
  if (global.menu != null) {
    global.menu.LNZ_mousePress();
  }
  if (global.notification.peek() != null) {
    global.notification.peek().mousePress();
  }
}

 public void mouseReleased() {
  if (mouseButton == RIGHT) {
    global.holding_rightclick = false;
  }
  if (global.menu != null) {
    global.menu.LNZ_mouseRelease(mouseX, mouseY);
  }
}

 public void mouseWheel(MouseEvent e) {
  if (global.menu != null) {
    global.menu.LNZ_scroll(e.getCount());
  }
}

 public void keyPressed() {
  global.keyPressFX2D();
  if (global.menu != null) {
    global.menu.LNZ_keyPress();
  }
  // Prevent sketch from exiting on ESC
  if (key == ESC) {
    key = 0;
  }
}

 public void keyReleased() {
  global.keyReleaseFX2D();
  if (global.menu != null) {
    global.menu.LNZ_keyRelease();
  }
}
class Ability {
  private int ID = 0;
  private float timer_cooldown = 0;
  private float timer_other = 0;
  private Unit target_unit = null;
  private int target_key = -1;
  private int stacks = 0;
  private boolean toggle = false;
  private HashSet<Integer> currently_hit;

  Ability(int ID) {
    this.ID = ID;
    switch(this.ID) {
      // Ben Nelson
      case 101:
      case 102:
      case 104:
      case 105:
      case 106:
      case 107:
      case 109:
      case 110:
        break;
      case 103:
      case 108:
        this.currently_hit = new HashSet<Integer>();
        break;
      // Daniel Gray
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
        break;
      // Cathy Heck, zombie
      case 1001:
        this.currently_hit = new HashSet<Integer>();
        break;
      case 1002:
      case 1003:
        break;
      default:
        global.errorMessage("ERROR: Ability ID " + this.ID + " not found.");
        break;
    }
  }

   public String displayName() {
    switch(this.ID) {
      // Ben Nelson
      case 101:
        return "Fearless Leader";
      case 102:
        return "Mighty Pen";
      case 103:
        return "Nelson Glare";
      case 104:
        return "Senseless Grit";
      case 105:
        return "Rage of the Ben";
      case 106:
        return "Fearless Leader II";
      case 107:
        return "Mighty Pen II";
      case 108:
        return "Nelson Glare II";
      case 109:
        return "Senseless Grit II";
      case 110:
        return "Rage of the Ben II";
      // Daniel Gray
      case 111:
        return "Aposematic Camouflage";
      case 112:
        return "Tongue Lash";
      case 113:
        return "Amphibious Leap";
      case 114:
        return "Alkaloid Secretion";
      case 115:
        return "Anuran Appetite";
      case 116:
        return "Aposematic Camouflage II";
      case 117:
        return "Tongue Lash II";
      case 118:
        return "Amphibious Leap II";
      case 119:
        return "Alkaloid Secretion II";
      case 120:
        return "Anuran Appetite II";
      // Cathy Heck, zombie
      case 1001:
        return "Blow Smoke";
      case 1002:
        return "Condom Throw";
      case 1003:
        return "Title IX Charge";
      default:
        return "ERROR";
    }
  }

   public String description() {
    switch(this.ID) {
      // Ben Nelson
      case 101:
        return "Ben is our fearless leader so never backs down from a fight.\n" +
          "Each time you damage, are damaged, or receive a negative status " +
          "effect, gain " + Constants.ability_101_rageGain + "% rage, to a " +
          "maximum of 100. Also gain " + Constants.ability_101_rageGainKill +
          "% rage for a kill. After not increasing rage for " + (Constants.
          ability_101_cooldownTimer/1000) + "s your rage will decrease by 1% " +
          "every " + (Constants.ability_101_tickTimer/1000) + "s.\nGain +" +
          (100*Constants.ability_101_bonusAmount) + "% bonus tenacity and attack " +
          "speed for every rage you have.";
      case 102:
        return "Ben knows well the Pen is mightier than the Sword.\nThrow a " +
          "pen with " + Constants.ability_102_powerBase + " + (" + round(Constants.
          ability_102_powerRatio*100) + "% attack power + " + round(Constants.ability_102_powerRatio*
          100) + "% magic power) mixed power " + Constants.ability_102_distance + "m. If " +
          "Ben is holding a pen or pencil it has " + Constants.ability_102_powerBasePen +
          " (" + round(Constants.ability_102_powerRatioPen*100) + "% attack power + " + round(Constants.
          ability_102_powerRatioPen*100) + "% magic power) mixed power.\nIf Mighty Pen hits " +
          "a target Ben will heal for " + (Constants.ability_102_healRatio*100) +
          "% of damage dealt.";
      case 103:
        return "We all cower when Ben throws his glare our way.\nFace target " +
          "direction and glare at all enemies in a cone " + Constants.
          ability_103_range + "m long, lowering their attack and movement speed " +
          "by " + round((1-Constants.ability_103_debuff)*100) + "% for " + (Constants.
          ability_103_time/1000) + "s.\nEnemies in the center of the cone are " +
          "also silenced for the duration.";
      case 104:
        return "Ben's grit transcends all reason.\nPassive: Heal " + round(
          Constants.ability_104_passiveHealAmount*100) + "% missing health " +
          "every " + (Constants.ability_104_passiveHealTimer/1000) + "s.\nActive: " +
          "Heal " + round(Constants.ability_104_activeHealAmount*100) + "% " +
          "missing health and gain " + round((Constants.ability_104_speedBuff-1)*100) +
          "% move speed when targeting enemies for " + (Constants.
          ability_104_speedBuffTimer/1000) + "s.";
      case 105:
        return "Ben unleashes the totality of his rage.\nInstantly gain " +
          Constants.ability_105_rageGain + " rage, become invulnerable and " +
          "gain +" + round((Constants.ability_105_buffAmount-1)*100) + "% attack " +
          "for " + (Constants.ability_105_buffTime/1000) + "s.\nDuring Rage of " +
          "the Ben:\n - Your passive rage increases are increased by " + round(
          (Constants.ability_105_rageGainBonus-1)*100) + "%\n - You gain a " + round(
          (Constants.ability_105_fullRageBonus-1)*100) + "% bonus to tenacity and " +
          "attack speed if your rage is at 100%\n - You cannot cast Mighty Pen (a)";
      case 106:
        return "Ben is our fearless leader so never backs down from a fight.\n" +
          "Each time you damage, are damaged, or receive a negative status " +
          "effect, gain " + Constants.ability_106_rageGain + "% rage, to a " +
          "maximum of 100. Also gain " + Constants.ability_106_rageGainKill +
          "% rage for a kill. After not increasing rage for " + Constants.
          ability_106_cooldownTimer/1000 + "s your rage will decrease by 1% " +
          "every " + Constants.ability_106_tickTimer/1000 + "s.\nGain +" +
          Constants.ability_106_bonusAmount + "% bonus tenacity and attack " +
          "speed for every rage you have.";
      case 107:
        return "Ben knows well the Pen is mightier than the Sword.\nThrow a " +
          "pen with " + Constants.ability_107_powerBase + " + (" + round(Constants.
          ability_107_powerRatio*100) + "% attack power + " + round(Constants.ability_107_powerRatio*
          100) + "% magic power) mixed power " + Constants.ability_107_distance + "m. If " +
          "Ben is holding a pen or pencil it has " + Constants.ability_107_powerBasePen +
          " (" + round(Constants.ability_107_powerRatioPen*100) + "% attack power + " + round(Constants.
          ability_107_powerRatioPen*100) + "% magic power) mixed power.\nIf Mighty Pen hits " +
          "a target Ben will heal for " + round(Constants.ability_107_healRatio*100) +
          "% of damage dealt.";
      case 108:
        return "We all cower when Ben throws his glare our way.\nFace target " +
          "direction and glare at all enemies in a cone " + Constants.
          ability_108_range + "m long, lowering their attack and movement speed " +
          "by " + round((1-Constants.ability_108_debuff)*100) + "% for " + (Constants.
          ability_108_time/1000) + "s.\nEnemies in the center of the cone are " +
          "also silenced for the duration.";
      case 109:
        return "Ben's grit transcends all reason.\nPassive: Heal " + round(
          Constants.ability_109_passiveHealAmount*100) + "% missing health " +
          "every " + (Constants.ability_109_passiveHealTimer/1000) + "s.\nActive: " +
          "Heal " + round(Constants.ability_109_activeHealAmount*100) + "% " +
          "missing health and gain " + round((Constants.ability_109_speedBuff-1)*100) +
          "% move speed when targeting enemies for " + (Constants.
          ability_109_speedBuffTimer/1000) + "s.";
      case 110:
        return "Ben unleashes the totality of his rage.\nInstantly gain " +
          Constants.ability_110_rageGain + " rage, become invulnerable and " +
          "gain +" + round((Constants.ability_110_buffAmount-1)*100) + "% attack " +
          "for " + (Constants.ability_110_buffTime/1000) + "s.\nDuring Rage of " +
          "the Ben:\n - Your passive rage increases are increased by " + round(
          (Constants.ability_110_rageGainBonus-1)*100) + "%\n - You gain a " + round(
          (Constants.ability_110_fullRageBonus-1)*100) + "% bonus to tenacity and " +
          "attack speed if your rage is at 100%\n - You cannot cast Mighty Pen (a)";
      // Daniel Gray
      case 111:
        return "As a Frog-Human hybrid, Dan can express his inner frog enery.\n" +
          "If still for " + PApplet.parseInt(round(Constants.ability_111_stillTime)) +
          "s, enemies cannot see you without getting within " + Constants.
          ability_111_distance + "m.\nWhile Dan is camouflaged, attacking or " +
          "casting \'Tongue Lash\' or \'Amphibious Leap\' will have " + PApplet.parseInt(
          100.0f * (Constants.ability_111_powerBuff-1)) + "% more power.\n\nDan " +
          "also absorbs frog energy from his surroundings, regenerating a frog " +
          "energy every " + Constants.ability_111_regenTime + "ms.";
      case 112:
        return "Dan lashes out his frog-like tongue.\nLash your tongue " + Constants.
          ability_112_distance + "m and damage the first enemy it hits for " +
          Constants.ability_112_basePower + " + (" + round(Constants.ability_112_physicalRatio
          *100) + "% attack power + " + round(Constants.ability_112_magicalRatio*100) +
          "% magic power) magical power.\nThe enemy hit will also be slowed " +
          PApplet.parseInt((1-Constants.ability_112_slowAmount)*100) + "% for " + (Constants.
          ability_112_slowTime/1000) + "s.";
      case 113:
        return "Dan leaps like the frog he believes he is.\nJump " + Constants.
          ability_113_jumpDistance + "m and with " + Constants.ability_113_basePower +
          " + (" + round(Constants.ability_113_physicalRatio*100) + "% attack power " +
          "+ " + round(Constants.ability_113_magicalRatio*100) + "% magic power) " +
          "magical power deal splash damage and stun for " + (Constants.ability_113_stunTime/
          1000) + "s all enemies within a " + Constants.ability_113_splashRadius +
          "m radius of where you land.\nKills decrease the remaining cooldown of " +
          "\'Tongue Lash\' by " + ((1-Constants.ability_113_killCooldownReduction)*100) +
          "%.\nIf drenched, the jump distance is " + Constants.ability_113_drenchedJumpDistance +
          "m and the splash radius is " + Constants.ability_113_drenchedSplashRadius + "m.";
      case 114:
        return "Dan secretes poisonous alkaloids in all directions around him.\n" +
          "While this ability is active, Dan will deal " + round(100*
          Constants.ability_114_currHealth) + "% curr health and additional " +
          "damage with " + Constants.ability_114_basePower + " + (0% attack " +
          "power + " + round(Constants.ability_114_magicRatio*100) + "% magic " +
          "power) magical power to all enemies within " + round(10 * Constants.
          ability_114_range)/10.0f + "m of him every " + Constants.ability_114_tickTime +
          "ms.\nEnemies hit by \'Alkaloid Secretion\' will also be rotting for " +
          (Constants.ability_114_rotTime/1000.0f) + "s.\nThe mana cost is consumed " +
          "every time damage is dealt.";
      case 115:
        return "With a frog's appetite, Dan is sometimes more interested in " +
          "eating his enemies than actually killing them.\nDevour target enemy " +
          "within " + Constants.ability_115_range + "m, making them suppressed, " +
          "untargetable, and decayed while devoured.\nRecast this ability to spit " +
          "them out " + Constants.ability_115_regurgitateDistance + "m and deal " +
          "damage with " + Constants.ability_115_basePower + " + (" + round(100*Constants.
          ability_115_physicalRatio) + "% attack power + " + round(100*Constants.
          ability_115_magicalRatio) + "% magic power) magic damage.\nIf this ability " +
          "is not recast within " + (Constants.ability_115_maxTime/1000.0f) + "s " +
          "it will be automatically recast.";
      case 116:
        return "As a Frog-Human hybrid, Dan can express his inner frog enery.\n" +
          "If still for " + PApplet.parseInt(round(Constants.ability_116_stillTime)) +
          "s, enemies cannot see you without getting within " + Constants.
          ability_116_distance + "m.\nWhile Dan is camouflaged, attacking or " +
          "casting \'Tongue Lash\' or \'Amphibious Leap\' will have " + PApplet.parseInt(
          100.0f * (Constants.ability_116_powerBuff-1)) + "% more power.\n\nDan " +
          "also absorbs frog energy from his surroundings, regenerating a frog " +
          "energy every " + Constants.ability_116_regenTime + "ms.";
      case 117:
        return "Dan lashes out his frog-like tongue.\nLash your tongue " + Constants.
          ability_117_distance + "m and damage the first enemy it hits for " +
          Constants.ability_117_basePower + " + (" + round(Constants.ability_117_physicalRatio
          *100) + "% attack power + " + round(Constants.ability_117_magicalRatio*100) +
          "% magic power) magical power.\nThe enemy hit will also be slowed " +
          PApplet.parseInt((1-Constants.ability_112_slowAmount)*100) + "% for " + (Constants.
          ability_117_slowTime/1000) + "s.";
      case 118:
        return "Dan leaps like the frog he always wanted to be.\nJump " + Constants.
          ability_118_jumpDistance + "m and with " + Constants.ability_118_basePower +
          " + (" + round(Constants.ability_118_physicalRatio*100) + "% attack power " +
          "+ " + round(Constants.ability_118_magicalRatio*100) + "% magic power) " +
          "magical power deal splash damage and stun for " + (Constants.ability_118_stunTime/
          1000) + "s all enemies within a " + Constants.ability_118_splashRadius +
          "m radius of where you land.\nKills decrease the remaining cooldown of " +
          "\'Tongue Lash\' by " + ((1-Constants.ability_118_killCooldownReduction)*100) +
          "%.\nIf drenched, the jump distance is " + Constants.ability_118_drenchedJumpDistance +
          "m and the splash radius is " + Constants.ability_118_drenchedSplashRadius + "m.";
      case 119:
        return "Dan secretes poisonous alkaloids in all directions around him.\n" +
          "While this ability is active, Dan will deal " + round(100*
          Constants.ability_119_currHealth) + "% curr health and additional " +
          "damage with " + Constants.ability_119_basePower + " + (0% attack " +
          "power + " + round(Constants.ability_119_magicRatio*100) + "% magic " +
          "power) magical power to all enemies within " + round(10 * Constants.
          ability_119_range)/10.0f + " m of him every " + Constants.ability_114_tickTime +
          "ms.\nEnemies hit by \'Alkaloid Secretion\' will also be rotting for " +
          (Constants.ability_114_rotTime/1000.0f) + "s.\nThe mana cost is consumed " +
          "every time damage is dealt.";
      case 120:
        return "With a frog's appetite, Dan is sometimes more interested in " +
          "eating his enemies than actually killing them.\nDevour target enemy " +
          "within " + Constants.ability_115_range + "m, making them suppressed, " +
          "untargetable, and decayed while devoured.\nRecast this ability to spit " +
          "them out " + Constants.ability_115_regurgitateDistance + "m and deal " +
          "damage with " + Constants.ability_120_basePower + " + (" + round(100*Constants.
          ability_120_physicalRatio) + "% attack power + " + round(100*Constants.
          ability_120_magicalRatio) + "% magic power) magic damage.\nIf this ability " +
          "is not recast within " + (Constants.ability_120_maxTime/1000.0f) + "s " +
          "it will be automatically recast.";
      // Cathy Heck, zombie
      case 1001:
        return "Getting 2nd-hand smoke from Cathy Heck is particularly harmful" +
          ".\nBlow cigarette smoke in target direction in a cone " + Constants.
          ability_1001_range + "m long, dealing " + Constants.ability_1001_basePower +
          " + (0% attack power + " + round(100*Constants.ability_1001_magicRatio) +
          "% magic power) magic damage and making any enemies hit woozy for " +
          (Constants.ability_1001_woozyTime/1000.0f) + "s.";
      case 1002:
        return "Cathy Heck's primary goal is to prevent Franciscan men from " +
          "passing on their genes.\nThrow 8 condoms in every direction around " +
          "you after a brief wind up period, each dealing " + Constants.
          ability_1002_basePower + " + (0% attack power + " + round(100*
          Constants.ability_1002_magicRatio) + "% magic power) magic damage.";
      case 1003:
        return "Cathy's ultimatum is to hunt down unsuspecting men using all " +
          "power at her disposal, usually just a Title IX charge.\nSlap a Title " +
          "IX charge in front of you, dealing magic damage with " + Constants.
          ability_1003_basePower + " + (0% attack power + " + round(100*Constants.
          ability_1003_magicRatio) + "% magic power) + " + round(100*Constants.
          ability_1003_maxHealth) + "% max health power to enemies hit.\n" +
          "Enemies hit also are wilted, woozy, and slowed for " + (Constants.
          ability_1003_statusTime/1000.0f) + "s and stunned for " + (Constants.
          ability_1003_statusTime*0.3f/1000.0f) + "s.";
      default:
        return "-- error -- ";
    }
  }

   public int manaCost() {
    switch(this.ID) {
      // Ben Nelson
      case 102:
        return 25;
      case 103:
        return 0;
      case 104:
        return 0;
      case 105:
        return -40;
      case 107:
        return 25;
      case 108:
        return 0;
      case 109:
        return 0;
      case 110:
        return -60;
      // Daniel Gray
      case 112:
        return 10;
      case 113:
        return 20;
      case 114:
        return 2;
      case 115:
        return 60;
      case 117:
        return 15;
      case 118:
        return 30;
      case 119:
        return 3;
      case 120:
        return 90;
      default:
        return 0;
    }
  }

   public float timer_cooldown() {
    switch(this.ID) {
      // Ben Nelson
      case 102:
        return 6000;
      case 103:
        return 18000;
      case 104:
        return 15000;
      case 105:
        return 120000;
      case 107:
        return 5000;
      case 108:
        return 12000;
      case 109:
        return 10000;
      case 110:
        return 100000;
      // Daniel Gray
      case 111:
        return Constants.ability_111_stillTime;
      case 112:
        return 6000;
      case 113:
        return 18000;
      case 114:
        return 2000;
      case 115:
        return 120000;
      case 116:
        return Constants.ability_116_stillTime;
      case 117:
        return 5000;
      case 118:
        return 16000;
      case 119:
        return 1200;
      case 120:
        return 90000;
      default:
        return 0;
    }
  }

   public boolean turnsCaster() {
    switch(this.ID) {
      case 102:
      case 103:
      case 107:
      case 108:
      case 112:
      case 113:
      case 117:
      case 118:
      case 1001:
        return true;
      case 115:
      case 120:
        if (this.toggle) {
          return true;
        }
        else {
          return false;
        }
      default:
        return false;
    }
  }

   public boolean castsOnTarget() {
    switch(this.ID) {
      case 115: // Anuran Appetite
      case 120: // Anuran Appetite II
        if (this.toggle) {
          return false;
        }
        else {
          return true;
        }
      default:
        return false;
    }
  }

   public float castsOnTargetRange() {
    switch(this.ID) {
      case 115: // Anuran Appetite
      case 120: // Anuran Appetite II
        return Constants.ability_115_range;
      default:
        return 0;
    }
  }

   public boolean checkMana() {
    switch(this.ID) {
      case 101:
      case 102:
      case 103:
      case 106:
      case 107:
      case 108:
        return false;
      case 115:
      case 120:
        if (this.toggle) {
          return false;
        }
        else {
          return true;
        }
      case 1001:
      case 1002:
      case 1003:
        return false;
      default:
        return true;
    }
  }


   public PImage getImage() {
    int image_id = 0;
    switch(this.ID) {
      // Ben Nelson
      case 101:
      case 106:
        image_id = 101;
        break;
      case 102:
      case 107:
        image_id = 102;
        break;
      case 103:
      case 108:
        image_id = 103;
        break;
      case 104:
      case 109:
        image_id = 104;
        break;
      case 105:
      case 110:
        image_id = 105;
        break;
      // Daniel Gray
      case 111:
      case 116:
        image_id = 111;
        break;
      case 112:
      case 117:
        image_id = 112;
        break;
      case 113:
      case 118:
        image_id = 113;
        break;
      case 114:
      case 119:
        image_id = 114;
        break;
      case 115:
      case 120:
        image_id = 115;
        break;
      default:
        return global.images.getImage("transparent.png");
    }
    return global.images.getImage("abilities/" + image_id + ".png");
  }


   public void activate(Unit u, AbstractGameMap map) {
    this.activate(u, map, null);
  }
   public void activate(Unit u, AbstractGameMap map, Unit target_unit) {
    int ability_index = u.curr_action_id;
    u.curr_action_id = 0;
    switch(this.ID) {
      case 102: // Mighty Pen
      case 107: // Mighty Pen II
        if (u.rageOfTheBen()) {
          return;
        }
        break;
      default:
        break;
    }
    if (this.castsOnTarget()) {
      this.target_unit = target_unit;
      if (target_unit != null) {
        this.target_key = target_unit.map_key;
      }
      else {
        this.target_key = -1;
      }
      if (this.target_unit == null || this.target_unit.remove) {
        return;
      }
      if (u.distance(this.target_unit) > this.castsOnTargetRange()) {
        return;
      }
    }
    u.decreaseMana(this.manaCost());
    this.timer_cooldown = this.timer_cooldown();
    VisualEffect ve;
    switch(this.ID) {
      case 102: // Mighty Pen
        map.addProjectile(new Projectile(3001, u));
        global.sounds.trigger_units("items/throw", u.x - map.viewX, u.y - map.viewY);
        break;
      case 103: // Nelson Glare
        this.timer_other = Constants.ability_103_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        this.currently_hit.clear();
        global.sounds.trigger_units("units/ability/103", u.x - map.viewX, u.y - map.viewY);
        break;
      case 104: // Senseless Grit
        u.healPercent(Constants.ability_104_activeHealAmount, false);
        u.addStatusEffect(StatusEffectCode.SENSELESS_GRIT, Constants.ability_104_speedBuffTimer);
        global.sounds.trigger_units("units/ability/104", u.x - map.viewX, u.y - map.viewY);
        break;
      case 105: // Rage of the Ben
        u.increaseMana(Constants.ability_105_rageGain);
        u.addStatusEffect(StatusEffectCode.INVULNERABLE, Constants.ability_105_buffTime);
        u.addStatusEffect(StatusEffectCode.RAGE_OF_THE_BEN, Constants.ability_105_buffTime);
        global.sounds.trigger_units("units/ability/105", u.x - map.viewX, u.y - map.viewY);
        break;
      case 107: // Mighty Pen II
        map.addProjectile(new Projectile(3002, u));
        global.sounds.trigger_units("items/throw", u.x - map.viewX, u.y - map.viewY);
        break;
      case 108: // Nelson Glare II
        this.timer_other = Constants.ability_108_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        this.currently_hit.clear();
        global.sounds.trigger_units("units/ability/103", u.x - map.viewX, u.y - map.viewY);
        break;
      case 109: // Senseless Grit II
        u.healPercent(Constants.ability_109_activeHealAmount, false);
        u.addStatusEffect(StatusEffectCode.SENSELESS_GRITII, Constants.ability_109_speedBuffTimer);
        global.sounds.trigger_units("units/ability/104", u.x - map.viewX, u.y - map.viewY);
        break;
      case 110: // Rage of the Ben II
        u.increaseMana(Constants.ability_110_rageGain);
        u.addStatusEffect(StatusEffectCode.INVULNERABLE, Constants.ability_110_buffTime);
        u.addStatusEffect(StatusEffectCode.RAGE_OF_THE_BENII, Constants.ability_110_buffTime);
        global.sounds.trigger_units("units/ability/110", u.x - map.viewX, u.y - map.viewY);
        break;
      case 112: // Tongue Lash
        this.timer_other = Constants.ability_112_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        global.sounds.trigger_units("units/ability/112", u.x - map.viewX, u.y - map.viewY);
        break;
      case 113: // Amphibious Leap
        if (u.drenched()) {
          this.timer_other = Constants.ability_113_drenchedJumpDistance;
        }
        else {
          this.timer_other = Constants.ability_113_jumpDistance;
        }
        this.toggle = true;
        u.curr_action_unhaltable = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        global.sounds.trigger_units("units/ability/113", u.x - map.viewX, u.y - map.viewY);
        break;
      case 114: // Alkaloid Secretion
        if (u.alkaloidSecretion()) {
          u.removeStatusEffect(StatusEffectCode.ALKALOID_SECRETION);
          global.sounds.silence_units("units/ability/114");
        }
        else {
          u.addStatusEffect(StatusEffectCode.ALKALOID_SECRETION);
          global.sounds.trigger_units("units/ability/114_start", u.x - map.viewX, u.y - map.viewY);
          global.sounds.trigger_units("units/ability/114", u.x - map.viewX, u.y - map.viewY);
          u.increaseMana(this.manaCost());
          this.timer_cooldown = 0;
        }
        break;
      case 115: // Anuran Appetite
        if (this.toggle) {
          this.timer_other = 0;
          u.increaseMana(this.manaCost());
        }
        else {
          this.toggle = true;
          this.timer_cooldown = 0;
          this.timer_other = Constants.ability_115_maxTime;
          this.target_unit.addStatusEffect(StatusEffectCode.SUPPRESSED, Constants.ability_115_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.UNTARGETABLE, Constants.ability_115_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.INVULNERABLE, Constants.ability_115_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.INVISIBLE, Constants.ability_115_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.UNCOLLIDABLE, Constants.ability_115_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.DECAYED, Constants.ability_115_maxTime);
          global.sounds.trigger_units("units/ability/115", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 117: // Tongue Last II
        this.timer_other = Constants.ability_112_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        global.sounds.trigger_units("units/ability/112", u.x - map.viewX, u.y - map.viewY);
        break;
      case 118: // Amphibious Leap II
        if (u.drenched()) {
          this.timer_other = Constants.ability_118_drenchedJumpDistance;
        }
        else {
          this.timer_other = Constants.ability_118_jumpDistance;
        }
        this.toggle = true;
        u.curr_action_unhaltable = true;
        u.curr_action = UnitAction.CASTING;
        global.sounds.trigger_units("units/ability/113", u.x - map.viewX, u.y - map.viewY);
        break;
      case 119: // Alkaloid Secretion II
        if (u.alkaloidSecretionII()) {
          u.removeStatusEffect(StatusEffectCode.ALKALOID_SECRETIONII);
          global.sounds.silence_units("units/ability/114");
        }
        else {
          u.addStatusEffect(StatusEffectCode.ALKALOID_SECRETIONII);
          global.sounds.trigger_units("units/ability/114_start", u.x - map.viewX, u.y - map.viewY);
          global.sounds.trigger_units("units/ability/114", u.x - map.viewX, u.y - map.viewY);
          u.increaseMana(this.manaCost());
          this.timer_cooldown = 0;
        }
        break;
      case 120: // Anuran Appetite II
        if (this.toggle) {
          this.timer_other = 0;
          u.increaseMana(this.manaCost());
        }
        else {
          this.toggle = true;
          this.timer_cooldown = 0;
          this.timer_other = Constants.ability_120_maxTime;
          this.target_unit.addStatusEffect(StatusEffectCode.SUPPRESSED, Constants.ability_120_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.UNTARGETABLE, Constants.ability_120_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.INVULNERABLE, Constants.ability_120_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.INVISIBLE, Constants.ability_120_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.UNCOLLIDABLE, Constants.ability_120_maxTime);
          this.target_unit.addStatusEffect(StatusEffectCode.DECAYED, Constants.ability_120_maxTime);
          global.sounds.trigger_units("units/ability/115", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 1001: // Blow Smoke
        this.timer_other = Constants.ability_1001_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        this.currently_hit.clear();
        global.sounds.trigger_units("units/ability/1001", u.x - map.viewX, u.y - map.viewY);
        break;
      case 1002: // Condom Throw
        this.timer_other = Constants.ability_1002_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        global.sounds.trigger_units("units/ability/1002", u.x - map.viewX, u.y - map.viewY);
        break;
      case 1003: // Title IX Charge
        this.timer_other = Constants.ability_1003_castTime;
        this.toggle = true;
        u.curr_action = UnitAction.CASTING;
        u.curr_action_id = ability_index;
        //global.sounds.trigger_units("units/ability/1003_cast", u.x - map.viewX, u.y - map.viewY);
        break;
      default:
        global.errorMessage("ERROR: Can't activate ability with ID " + this.ID + ".");
        break;
    }
  }


   public void update(int timeElapsed, Unit u, AbstractGameMap map) {
    this.update(timeElapsed);
    float max_distance = 0;
    float box_width = 0;
    float box_height = 0;
    switch(this.ID) {
      case 101: // Fearless Leader I
        if (this.timer_other <= 0) {
          u.decreaseMana(1);
          this.timer_other = Constants.ability_101_tickTimer;
        }
        break;
      case 103: // Nelson Glare
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        max_distance = Constants.ability_103_range * (1 - this.timer_other
          / Constants.ability_103_castTime);
        for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
          Unit target = entry.getValue();
          if (target.alliance == u.alliance) {
            continue;
          }
          // already hit
          if (this.currently_hit.contains(target.map_key)) {
            continue;
          }
          float distance = u.centerDistance(target);
          if (distance > max_distance + target.size) {
            continue;
          }
          boolean silenced = true;
          if (distance > 0) {
            float angle = abs((float)Math.atan2(target.y - u.y, target.x - u.x) - u.facingA);
            float unit_angle = 2 * asin(0.5f * target.size / distance);
            if (angle > unit_angle + Constants.ability_103_coneAngle) {
              continue;
            }
            if (angle > unit_angle + 0.3f * Constants.ability_103_coneAngle) {
              silenced = false;
            }
          }
          this.currently_hit.add(target.map_key);
          target.addStatusEffect(StatusEffectCode.NELSON_GLARE, Constants.ability_103_time);
          if (silenced) {
            target.addStatusEffect(StatusEffectCode.SILENCED, Constants.ability_103_time);
          }
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
        }
        break;
      case 104: // Senseless Grit
        if (this.timer_other <= 0) {
          u.healPercent(Constants.ability_104_passiveHealAmount, false);
          this.timer_other = Constants.ability_104_passiveHealTimer;
        }
        break;
      case 106: // Fearless Leader II
        if (this.timer_other <= 0) {
          u.decreaseMana(1);
          this.timer_other = Constants.ability_106_tickTimer;
        }
        break;
      case 108: // Nelson Glare II
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        max_distance = Constants.ability_108_range * (1 - this.timer_other
          / Constants.ability_108_castTime);
        for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
          Unit target = entry.getValue();
          if (target.alliance == u.alliance) {
            continue;
          }
          // already hit
          if (this.currently_hit.contains(target.map_key)) {
            continue;
          }
          float distance = u.centerDistance(target);
          if (distance > max_distance + target.size) {
            continue;
          }
          boolean silenced = true;
          if (distance > 0) {
            float angle = abs((float)Math.atan2(target.y - u.y, target.x - u.x) - u.facingA);
            float unit_angle = 2 * asin(0.5f * target.size / distance);
            if (angle > unit_angle + Constants.ability_108_coneAngle) {
              continue;
            }
            if (angle > unit_angle + 0.3f * Constants.ability_108_coneAngle) {
              silenced = false;
            }
          }
          this.currently_hit.add(target.map_key);
          target.addStatusEffect(StatusEffectCode.NELSON_GLAREII, Constants.ability_108_time);
          if (silenced) {
            target.addStatusEffect(StatusEffectCode.SILENCED, Constants.ability_108_time);
          }
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
        }
        break;
      case 109: // Senseless Grit II
        if (this.timer_other <= 0) {
          u.healPercent(Constants.ability_109_passiveHealAmount, false);
          this.timer_other = Constants.ability_109_passiveHealTimer;
        }
        break;
      case 111: // Aposematic Camouflage
        if (this.timer_other <= 0) {
          u.increaseMana(1);
          this.timer_other = Constants.ability_111_regenTime;
        }
        if (u.curr_action == UnitAction.NONE) {
          if (this.timer_cooldown <= 0 && !u.aposematicCamouflage() && !u.visible()) {
            u.addStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGE);
            global.sounds.trigger_units("units/ability/111", u.x - map.viewX, u.y - map.viewY);
          }
        }
        else {
          this.timer_cooldown = this.timer_cooldown();
        }
        break;
      case 112: // Tongue Lash
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        box_width = Constants.ability_112_distance * (1 - this.timer_other / Constants.ability_112_castTime);
        box_height = u.size;
        for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
          Unit target = entry.getValue();
          if (target.alliance == u.alliance) {
            continue;
          }
          PVector distance = new PVector(target.x - u.x, target.y - u.y);
          distance.rotate(-u.facingA);
          if (distance.x + target.size > 0 && distance.y + target.size > -0.5f *
            box_height && distance.x - target.size < box_width && distance.y -
            target.size < 0.5f * box_height) {
            // collision
            float power = Constants.ability_112_basePower + u.power(Constants.
              ability_112_physicalRatio, Constants.ability_112_magicalRatio);
            if (u.aposematicCamouflageII()) {
              power *= Constants.ability_116_powerBuff;
            }
            else if (u.aposematicCamouflage()) {
              power *= Constants.ability_111_powerBuff;
            }
            float damage = target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration());
            target.damage(u, damage);
            target.refreshStatusEffect(StatusEffectCode.TONGUE_LASH, Constants.ability_112_slowTime);
            this.toggle = false;
            u.stopAction();
            global.sounds.trigger_units("units/ability/112_hit", u.x - map.viewX, u.y - map.viewY);
            break;
          }
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
        }
        break;
      case 113: // Amphibious Leap
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        this.timer_other -= u.last_move_distance;
        if (u.distanceFromPoint(u.curr_action_x, u.curr_action_y) < u.last_move_distance) {
          this.timer_other = 0;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
          float splash_radius = 0;
          if (u.drenched()) {
            map.addVisualEffect(4004, u.x, u.y);
            splash_radius = Constants.ability_113_drenchedSplashRadius;
          }
          else {
            map.addVisualEffect(4003, u.x, u.y);
            splash_radius = Constants.ability_113_splashRadius;
          }
          float power = Constants.ability_113_basePower + u.power(Constants.
            ability_113_physicalRatio, Constants.ability_113_magicalRatio);
          for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
            Unit target = entry.getValue();
            if (target.alliance == u.alliance) {
              continue;
            }
            if (u.distance(target) > splash_radius) {
              continue;
            }
            target.damage(u, target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration()));
            target.refreshStatusEffect(StatusEffectCode.STUNNED, Constants.ability_113_stunTime);
          }
          global.sounds.trigger_units("units/ability/113_land", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 114: // Alkaloid Secretion
        if (!u.alkaloidSecretion()) {
          break;
        }
        if (this.timer_other <= 0) {
          if (u.currMana() < this.manaCost()) {
            u.removeStatusEffect(StatusEffectCode.ALKALOID_SECRETION);
            break;
          }
          else {
            u.decreaseMana(this.manaCost());
          }
          this.timer_other = Constants.ability_114_tickTime;
          float power = Constants.ability_114_basePower + u.power(0, Constants.ability_114_magicRatio);
          for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
            Unit target = entry.getValue();
            if (target.alliance == u.alliance) {
              continue;
            }
            if (u.distance(target) > Constants.ability_114_range) {
              continue;
            }
            target.damage(u, Constants.ability_114_currHealth * target.curr_health);
            target.damage(u, target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration()));
            target.refreshStatusEffect(StatusEffectCode.ROTTING, Constants.ability_114_rotTime);
          }
          map.addVisualEffect(4007, u.x, u.y);
          global.sounds.trigger_units("units/ability/114", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 115: // Anuran Appetite
        if (!this.toggle) {
          break;
        }
        if (this.target_unit == null || this.target_unit.remove || u.remove) {
          this.toggle = false;
          break;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          this.target_unit.removeStatusEffect(StatusEffectCode.SUPPRESSED);
          this.target_unit.removeStatusEffect(StatusEffectCode.UNTARGETABLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.INVULNERABLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.INVISIBLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.UNCOLLIDABLE);
          this.target_unit.x = u.frontX();
          this.target_unit.y = u.frontY();
          this.target_unit.setFacing(u.facingX, u.facingY);
          this.target_unit.curr_action = UnitAction.MOVING;
          this.target_unit.curr_action_id = 1;
          this.target_unit.curr_action_unstoppable = true;
          this.target_unit.curr_action_unhaltable = true;
          this.target_unit.curr_action_x = this.target_unit.x + u.facingX * Constants.ability_115_regurgitateDistance;
          this.target_unit.curr_action_y = this.target_unit.y + u.facingY * Constants.ability_115_regurgitateDistance;
          float power = Constants.ability_115_basePower + u.power(Constants.
            ability_115_physicalRatio, Constants.ability_115_magicalRatio);
          this.target_unit.damage(u, this.target_unit.calculateDamageFrom(power,
            DamageType.MAGICAL, Element.BROWN, u.piercing(), u.penetration()));
          global.sounds.trigger_units("units/ability/115_spit", u.x - map.viewX, u.y - map.viewY);
          global.sounds.silence_units("units/ability/115");
        }
        break;
      case 116: // Aposematic Camouflage II
        if (this.timer_other <= 0) {
          u.increaseMana(1);
          this.timer_other = Constants.ability_116_regenTime;
        }
        if (u.curr_action == UnitAction.NONE) {
          if (this.timer_cooldown <= 0 && !u.aposematicCamouflageII() && !u.visible()) {
            u.addStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGEII);
            global.sounds.trigger_units("units/ability/111", u.x - map.viewX, u.y - map.viewY);
          }
        }
        else {
          this.timer_cooldown = this.timer_cooldown();
        }
        break;
      case 117: // Tongue Lash II
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        box_width = Constants.ability_117_distance * (1 - this.timer_other / Constants.ability_112_castTime);
        box_height = u.size;
        for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
          Unit target = entry.getValue();
          if (target.alliance == u.alliance) {
            continue;
          }
          PVector distance = new PVector(target.x - u.x, target.y - u.y);
          distance.rotate(-u.facingA);
          if (distance.x + target.size > 0 && distance.y + target.size > -0.5f *
            box_height && distance.x - target.size < box_width && distance.y -
            target.size < 0.5f * box_height) {
            // collision
            float power = Constants.ability_117_basePower + u.power(Constants.
              ability_117_physicalRatio, Constants.ability_117_magicalRatio);
            float damage = target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration());
            if (u.aposematicCamouflageII()) {
              power *= Constants.ability_116_powerBuff;
            }
            else if (u.aposematicCamouflage()) {
              power *= Constants.ability_111_powerBuff;
            }
            target.damage(u, damage);
            target.refreshStatusEffect(StatusEffectCode.TONGUE_LASH, Constants.ability_117_slowTime);
            this.toggle = false;
            u.stopAction();
            global.sounds.trigger_units("units/ability/112_hit", u.x - map.viewX, u.y - map.viewY);
            break;
          }
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
        }
        break;
      case 118: // Amphibious Leap II
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        this.timer_other -= u.last_move_distance;
        if (u.distanceFromPoint(u.curr_action_x, u.curr_action_y) < u.last_move_distance) {
          this.timer_other = 0;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
          float splash_radius = 0;
          if (u.drenched()) {
            map.addVisualEffect(4006, u.x, u.y);
            splash_radius = Constants.ability_118_drenchedSplashRadius;
          }
          else {
            map.addVisualEffect(4005, u.x, u.y);
            splash_radius = Constants.ability_118_splashRadius;
          }
          float power = Constants.ability_118_basePower + u.power(Constants.
            ability_118_physicalRatio, Constants.ability_118_magicalRatio);
          for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
            Unit target = entry.getValue();
            if (target.alliance == u.alliance) {
              continue;
            }
            if (u.distance(target) > splash_radius) {
              continue;
            }
            target.damage(u, target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration()));
            target.refreshStatusEffect(StatusEffectCode.STUNNED, Constants.ability_118_stunTime);
          }
          global.sounds.trigger_units("units/ability/113_land", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 119: // Alkaloid Secretion II
        if (!u.alkaloidSecretionII()) {
          break;
        }
        if (this.timer_other <= 0) {
          if (u.currMana() < this.manaCost()) {
            u.removeStatusEffect(StatusEffectCode.ALKALOID_SECRETIONII);
            break;
          }
          else {
            u.decreaseMana(this.manaCost());
          }
          this.timer_other = Constants.ability_114_tickTime;
          float power = Constants.ability_119_basePower + u.power(0, Constants.ability_119_magicRatio);
          for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
            Unit target = entry.getValue();
            if (target.alliance == u.alliance) {
              continue;
            }
            if (u.distance(target) > Constants.ability_119_range) {
              continue;
            }
            target.damage(u, Constants.ability_119_currHealth * target.curr_health);
            target.damage(u, target.calculateDamageFrom(power, DamageType.MAGICAL,
              Element.BROWN, u.piercing(), u.penetration()));
            target.refreshStatusEffect(StatusEffectCode.ROTTING, Constants.ability_114_rotTime);
          }
          map.addVisualEffect(4008, u.x, u.y);
          global.sounds.trigger_units("units/ability/114", u.x - map.viewX, u.y - map.viewY);
        }
        break;
      case 120: // Anuran Appetite II
        if (!this.toggle) {
          break;
        }
        if (this.target_unit == null || this.target_unit.remove || u.remove) {
          this.toggle = false;
          break;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          this.target_unit.removeStatusEffect(StatusEffectCode.SUPPRESSED);
          this.target_unit.removeStatusEffect(StatusEffectCode.UNTARGETABLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.INVULNERABLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.INVISIBLE);
          this.target_unit.removeStatusEffect(StatusEffectCode.UNCOLLIDABLE);
          this.target_unit.x = u.frontX();
          this.target_unit.y = u.frontY();
          this.target_unit.setFacing(u.facingX, u.facingY);
          this.target_unit.curr_action = UnitAction.MOVING;
          this.target_unit.curr_action_id = 1;
          this.target_unit.curr_action_unstoppable = true;
          this.target_unit.curr_action_unhaltable = true;
          this.target_unit.curr_action_x = this.target_unit.x + u.facingX * Constants.ability_115_regurgitateDistance;
          this.target_unit.curr_action_y = this.target_unit.y + u.facingY * Constants.ability_115_regurgitateDistance;
          float power = Constants.ability_120_basePower + u.power(Constants.
            ability_120_physicalRatio, Constants.ability_120_magicalRatio);
          this.target_unit.damage(u, this.target_unit.calculateDamageFrom(power,
            DamageType.MAGICAL, Element.BROWN, u.piercing(), u.penetration()));
          global.sounds.trigger_units("units/ability/115_spit", u.x - map.viewX, u.y - map.viewY);
          global.sounds.silence_units("units/ability/115");
        }
        break;
      case 1001: // Blow Smoke
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        max_distance = Constants.ability_1001_range * (1 - this.timer_other
          / Constants.ability_1001_castTime);
        for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
          Unit target = entry.getValue();
          if (target.alliance == u.alliance) {
            continue;
          }
          // already hit
          if (this.currently_hit.contains(target.map_key)) {
            continue;
          }
          float distance = u.centerDistance(target);
          if (distance > max_distance + target.size) {
            continue;
          }
          if (distance > 0) {
            float angle = abs((float)Math.atan2(target.y - u.y, target.x - u.x) - u.facingA);
            float unit_angle = 2 * asin(0.5f * target.size / distance);
            if (angle > unit_angle + Constants.ability_1001_coneAngle) {
              continue;
            }
          }
          this.currently_hit.add(target.map_key);
          float power = Constants.ability_1001_basePower + u.power(0, Constants.ability_1001_magicRatio);
          target.damage(u, target.calculateDamageFrom(power,
            DamageType.MAGICAL, Element.GRAY, u.piercing(), u.penetration()));
          target.addStatusEffect(StatusEffectCode.WOOZY, Constants.ability_1001_woozyTime);
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
        }
        break;
      case 1002: // Condom Throw
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
          Projectile p = new Projectile(3003, u);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(0.25f * PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(0.5f * PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(0.75f * PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(-0.25f * PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(-0.5f * PI);
          map.addProjectile(p);
          p = new Projectile(3003, u);
          p.turn(-0.75f * PI);
          map.addProjectile(p);
        }
        break;
      case 1003: // Title IX Charge
        if (!this.toggle) {
          break;
        }
        if (u.curr_action != UnitAction.CASTING) {
          this.toggle = false;
          break;
        }
        if (this.timer_other <= 0) {
          this.toggle = false;
          u.stopAction();
          //global.sounds.trigger_units("units/ability/1003_slap", u.x - map.viewX, u.y - map.viewY);
          for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
            Unit target = entry.getValue();
            if (target.alliance == u.alliance) {
              continue;
            }
            PVector distance = new PVector(target.x - u.x, target.y - u.y);
            distance.rotate(-u.facingA);
            if (distance.x + target.size > 0 && distance.y + target.size > -0.5f *
              Constants.ability_1003_size_h && distance.x - target.size < Constants.
              ability_1003_size_w && distance.y - target.size < 0.5f * Constants.ability_1003_size_h) {
              // collision
              float power = Constants.ability_1003_basePower + u.power(0, Constants.
                ability_1003_magicRatio) + target.health() * Constants.ability_1003_maxHealth;
              float damage = target.calculateDamageFrom(power, DamageType.MAGICAL,
                Element.GRAY, u.piercing(), u.penetration());
              target.damage(u, damage);
              target.refreshStatusEffect(StatusEffectCode.STUNNED, 0.3f * Constants.ability_1003_statusTime);
              target.refreshStatusEffect(StatusEffectCode.WILTED, Constants.ability_1003_statusTime);
              target.refreshStatusEffect(StatusEffectCode.WOOZY, Constants.ability_1003_statusTime);
              target.refreshStatusEffect(StatusEffectCode.SLOWED, Constants.ability_1003_statusTime);
              this.toggle = false;
              break;
            }
          }
        }
        break;

      default:
        break;
    }
  }


   public void update(int timeElapsed) {
    if (this.timer_cooldown > 0) {
      this.timer_cooldown -= timeElapsed;
      if (this.timer_cooldown < 0) {
        this.timer_cooldown = 0;
      }
    }
    switch(this.ID) {
      case 113: // Amphibious Leap
      case 118: // Amphiibous Leap II
        break;
      default:
        if (this.timer_other > 0) {
          this.timer_other -= timeElapsed;
          if (this.timer_other < 0) {
            this.timer_other = 0;
          }
        }
        break;
    }
  }


   public void addStack() {
    this.stacks++;
    switch(this.ID) {
      default:
        global.errorMessage("ERROR: Ability ID " + this.ID + " can't add stack.");
        break;
    }
  }


   public String fileString() {
    String fileString = "\nnew: Ability: " + this.ID;
    fileString += "\ntimer_cooldown: " + this.timer_cooldown;
    fileString += "\ntimer_other: " + this.timer_other;
    fileString += "\ntarget_key: " + this.target_key;
    fileString += "\nstacks: " + this.stacks;
    fileString += "\ntoggle: " + this.toggle;
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "timer_cooldown":
        this.timer_cooldown = toFloat(data);
        break;
      case "timer_other":
        this.timer_other = toFloat(data);
        break;
      case "target_key":
        this.target_key = toInt(data);
        break;
      case "stacks":
        this.stacks = toInt(data);
        break;
      case "toggle":
        this.toggle = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for Ability data.");
        break;
    }
  }
}
enum AchievementCode {
  COMPLETED_TUTORIAL, KILLED_JOHN_RANKIN;

  private static final List<AchievementCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String display_name() {
    return AchievementCode.display_name(this);
  }
  public static String display_name(AchievementCode code) {
    switch(code) {
      case COMPLETED_TUTORIAL:
        return "Completed Tutorial";
      case KILLED_JOHN_RANKIN:
        return "Killed John Rankin";
      default:
        return "-- Error --";
    }
  }

  public String file_name() {
    return AchievementCode.file_name(this);
  }
  public static String file_name(AchievementCode code) {
    switch(code) {
      case COMPLETED_TUTORIAL:
        return "Completed_Tutorial";
      case KILLED_JOHN_RANKIN:
        return "Killed_John_Rankin";
      default:
        return "ERROR";
    }
  }

  public static AchievementCode achievementCode(String display_name) {
    for (AchievementCode code : AchievementCode.VALUES) {
      if (AchievementCode.display_name(code).equals(display_name) ||
        AchievementCode.file_name(code).equals(display_name)) {
        return code;
      }
    }
    return null;
  }
  public static AchievementCode achievementCode(int id) {
    for (AchievementCode code : AchievementCode.VALUES) {
      if (AchievementCode.id(code) == id) {
        return code;
      }
    }
    return null;
  }

  public int tokens() {
    return AchievementCode.tokens(this);
  }
  public static int tokens(AchievementCode code) {
    switch(code) {
      default:
        return 1;
    }
  }

  public int id() {
    return AchievementCode.id(this);
  }
  public static int id(AchievementCode code) {
    switch(code) {
      case COMPLETED_TUTORIAL:
        return 0;
      case KILLED_JOHN_RANKIN:
        return 1;
      default:
        return -1;
    }
  }
}
enum AreaLocation {
  NONE, FERNWOOD_FOREST;

  private static final List<AreaLocation> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String displayName() {
    return AreaLocation.displayName(this);
  }
  public static String displayName(AreaLocation area_location) {
    switch(area_location) {
      case FERNWOOD_FOREST:
        return "Fernwood State Forest";
      default:
        return "Error";
    }
  }

  public String fileName() {
    return AreaLocation.fileName(this);
  }
  public static String fileName(AreaLocation area_location) {
    switch(area_location) {
      case FERNWOOD_FOREST:
        return "FERNWOOD_FOREST";
      default:
        return "NONE";
    }
  }

  public static AreaLocation areaLocation(String area_location_name) {
    for (AreaLocation area_location : AreaLocation.VALUES) {
      if (area_location == AreaLocation.NONE) {
        continue;
      }
      if (AreaLocation.displayName(area_location).equals(area_location_name) ||
        AreaLocation.fileName(area_location).equals(area_location_name)) {
        return area_location;
      }
    }
    return AreaLocation.NONE;
  }

  public Biome getBiome(float noise_value) {
    return AreaLocation.getBiome(this, noise_value);
  }
  private static Biome getBiome(AreaLocation location, float noise_value) {
    switch(location) {
      case FERNWOOD_FOREST:
        return AreaLocation.fernwoodForestBiome(noise_value);
    }
    return Biome.NONE;
  }

  private static Biome fernwoodForestBiome(float noise_value) {
    if (noise_value > 0.7f) {
      return Biome.MAPLE_FOREST3;
    }
    else if (noise_value > 0.45f) {
      return Biome.MAPLE_FOREST2;
    }
    else if (noise_value > 0.33f) {
      return Biome.MAPLE_FOREST1;
    }
    else {
      return Biome.CLEARING;
    }
  }
}


static class BiomeReturn {
  int terrain_code = 0;
  boolean spawn_feature = false;
  int feature_id = 0;

  BiomeReturn() {}
}


enum Biome {
  NONE, MAPLE_FOREST1, MAPLE_FOREST2, MAPLE_FOREST3, CLEARING, GRASS;

  private static final List<Biome> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String displayName() {
    return Biome.displayName(this);
  }
  public static String displayName(Biome biome) {
    switch(biome) {
      case MAPLE_FOREST1:
        return "Maple Forest, open";
      case MAPLE_FOREST2:
        return "Maple Forest";
      case MAPLE_FOREST3:
        return "Maple Forest, dense";
      case CLEARING:
        return "Clearing";
      case GRASS:
        return "GRASS";
      default:
        return "Error";
    }
  }

  public String fileName() {
    return Biome.fileName(this);
  }
  public static String fileName(Biome biome) {
    switch(biome) {
      case MAPLE_FOREST1:
        return "MAPLE_FOREST1";
      case MAPLE_FOREST2:
        return "MAPLE_FOREST2";
      case MAPLE_FOREST3:
        return "MAPLE_FOREST3";
      case CLEARING:
        return "CLEARING";
      case GRASS:
        return "GRASS";
      default:
        return "";
    }
  }

  public static Biome biome(String biome_name) {
    for (Biome biome : Biome.VALUES) {
      if (biome == Biome.NONE) {
        continue;
      }
      if (Biome.displayName(biome).equals(biome_name) ||
        Biome.fileName(biome).equals(biome_name)) {
        return biome;
      }
    }
    return Biome.NONE;
  }
}


 public BiomeReturn processPerlinNoise(Biome biome, float noise_value) {
  switch(biome) {
    case MAPLE_FOREST1:
      return mapleForestProcessPerlinNoise(1, noise_value);
    case MAPLE_FOREST2:
      return mapleForestProcessPerlinNoise(2, noise_value);
    case MAPLE_FOREST3:
      return mapleForestProcessPerlinNoise(3, noise_value);
    case CLEARING:
      return clearingProcessPerlinNoise(noise_value);
    case GRASS:
      return grassProcessPerlinNoise(noise_value);
  }
  return new BiomeReturn();
}

private BiomeReturn mapleForestProcessPerlinNoise(int forest_density, float noise_value) {
  BiomeReturn biome_return = new BiomeReturn();
  switch(forest_density) {
    case 1: // low density forest
      if (noise_value > 0.85f) { // dark dirt
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 163; // dark dirt
        }
        else {
          biome_return.terrain_code = 162; // gray dirt
        }
      }
      else if (noise_value > 0.55f) { // dirty
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 162; // gray dirt
        }
        else if (randomChance(noise_value)) {
          biome_return.terrain_code = 161; // light dirt
        }
        else {
          biome_return.terrain_code = 154; // dead grass
        }
      }
      else { // grassy
        if (randomChance(map(noise_value, 0.25f, 0.45f, 0.1f, 0.9f))) {
          biome_return.terrain_code = 154; // dead grass
        }
        else if (randomChance(1 - noise_value)) {
          biome_return.terrain_code = 153; // dark grass
        }
        else {
          biome_return.terrain_code = 161; // light dirt
        }
      }
      break;
    case 2: // medium density forest
      if (noise_value > 0.78f) { // dark dirt
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 163; // dark dirt
        }
        else {
          biome_return.terrain_code = 162; // gray dirt
        }
      }
      else if (noise_value > 0.45f) { // dirty
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 162; // gray dirt
        }
        else if (randomChance(noise_value)) {
          biome_return.terrain_code = 161; // light dirt
        }
        else {
          biome_return.terrain_code = 154; // dead grass
        }
      }
      else { // grassy
        if (randomChance(map(noise_value, 0.25f, 0.45f, 0.1f, 0.9f))) {
          biome_return.terrain_code = 154; // dead grass
        }
        else if (randomChance(1 - noise_value)) {
          biome_return.terrain_code = 153; // dark grass
        }
        else {
          biome_return.terrain_code = 161; // light dirt
        }
      }
      break;
    case 3: // high density forest
      if (noise_value > 0.66f) { // dark dirt
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 163; // dark dirt
        }
        else {
          biome_return.terrain_code = 162; // gray dirt
        }
      }
      else if (noise_value > 0.35f) { // dirty
        if (randomChance(noise_value)) {
          biome_return.terrain_code = 162; // gray dirt
        }
        else if (randomChance(noise_value)) {
          biome_return.terrain_code = 161; // light dirt
        }
        else {
          biome_return.terrain_code = 154; // dead grass
        }
      }
      else { // grassy
        if (randomChance(map(noise_value, 0.25f, 0.45f, 0.1f, 0.9f))) {
          biome_return.terrain_code = 154; // dead grass
        }
        else if (randomChance(1 - noise_value)) {
          biome_return.terrain_code = 153; // dark grass
        }
        else {
          biome_return.terrain_code = 161; // light dirt
        }
      }
      break;
  }
  float feature_spawn_chance = 0;
  switch(biome_return.terrain_code) {
    case 153: // Grass, dark
      feature_spawn_chance = 0.04f;
      break;
    case 154: // Grass, dead
      feature_spawn_chance = 0.08f;
      break;
    case 161: // Dirt, light
      feature_spawn_chance = 0.12f;
      break;
    case 162: // Dirt, gray
      feature_spawn_chance = 0.16f;
      break;
    case 163: // Dirt, dark
      feature_spawn_chance = 0.2f;
      break;
  }
  if (randomChance(feature_spawn_chance)) {
    biome_return.spawn_feature = true;
    float random_num = random(1.0f);
    // random tree / bush (favoring maple trees, light bushes)
    if (random_num > 0.8f) {
      biome_return.feature_id = 441;
    }
    else if (random_num > 0.75f) {
      biome_return.feature_id = 442;
    }
    else if (random_num > 0.5f) {
      biome_return.feature_id = 421;
    }
    else if (random_num > 0.2f) {
      biome_return.feature_id = 444;
    }
    else if (random_num > 0.13f) {
      biome_return.feature_id = 447;
    }
    else if (random_num > 0.1f) {
      biome_return.feature_id = 424;
    }
    else if (random_num > 0.08f) {
      biome_return.feature_id = 422;
    }
    else if (random_num > 0.06f) {
      biome_return.feature_id = 423;
    }
    else if (random_num > 0.03f) {
      biome_return.feature_id = 445;
    }
    else {
      biome_return.feature_id = 446;
    }
  }
  return biome_return;
}


private BiomeReturn clearingProcessPerlinNoise(float noise_value) {
  BiomeReturn biome_return = new BiomeReturn();
  if (noise_value > 0.8f) { // dirty
    if (randomChance(1 - noise_value)) {
      biome_return.terrain_code = 162; // gray dirt
    }
    else {
      biome_return.terrain_code = 161; // light dirt
    }
  }
  else if (noise_value > 0.5f) { // dirt to grass
    if (randomChance(noise_value - 0.5f)) {
      biome_return.terrain_code = 161; // light dirt
    }
    else if (randomChance(noise_value - 0.35f)) {
      biome_return.terrain_code = 153; // dark grass
      if (randomChance(0.25f)) {
        biome_return.terrain_code = 154; // dead grass
      }
    }
    else {
      biome_return.terrain_code = 151; // light grass
      if (randomChance(0.25f)) {
        biome_return.terrain_code = 154; // dead grass
      }
    }
  }
  else { // grassy
    if (randomChance(noise_value - 0.35f)) {
      biome_return.terrain_code = 153; // dark grass
      if (randomChance(0.25f)) {
        biome_return.terrain_code = 154; // dead grass
      }
    }
    else if (randomChance(noise_value - 0.15f)) {
      biome_return.terrain_code = 151; // light grass
      if (randomChance(0.25f)) {
        biome_return.terrain_code = 154; // dead grass
      }
    }
    else {
      biome_return.terrain_code = 152; // green grass
      if (randomChance(0.25f)) {
        biome_return.terrain_code = 154; // dead grass
      }
    }
  }
  float tree_bush_spawn_chance = 0;
  switch(biome_return.terrain_code) {
    case 153: // Grass, dark
      tree_bush_spawn_chance = 0.02f;
      break;
    case 154: // Grass, dead
      tree_bush_spawn_chance = 0.04f;
      break;
    case 161: // Dirt, light
      tree_bush_spawn_chance = 0.06f;
      break;
    case 162: // Dirt, gray
      tree_bush_spawn_chance = 0.08f;
      break;
  }
  if (randomChance(tree_bush_spawn_chance)) {
    biome_return.spawn_feature = true;
    float random_num = random(1.0f);
    // random tree / bush (favoring maple trees, light bushes)
    if (random_num > 0.7f) {
      biome_return.feature_id = 441;
    }
    else if (random_num > 0.6f) {
      biome_return.feature_id = 442;
    }
    else if (random_num > 0.4f) {
      biome_return.feature_id = 421;
    }
    else if (random_num > 0.15f) {
      biome_return.feature_id = 444;
    }
    else if (random_num > 0.11f) {
      biome_return.feature_id = 447;
    }
    else if (random_num > 0.08f) {
      biome_return.feature_id = 424;
    }
    else if (random_num > 0.06f) {
      biome_return.feature_id = 422;
    }
    else if (random_num > 0.04f) {
      biome_return.feature_id = 423;
    }
    else if (random_num > 0.02f) {
      biome_return.feature_id = 445;
    }
    else {
      biome_return.feature_id = 446;
    }
    return biome_return;
  }
  switch(biome_return.terrain_code) {
    case 151: // Grass, light
    case 153: // Grass, dark
      if (randomChance(0.57f - noise_value)) { // dandelions
        biome_return.spawn_feature = true;
        biome_return.feature_id = 401;
      }
      break;
    case 152: // Grass, green
      if (randomChance(0.63f - noise_value)) { // dandelions
        biome_return.spawn_feature = true;
        biome_return.feature_id = 401;
      }
      break;
  }
  return biome_return;
}


private BiomeReturn grassProcessPerlinNoise(float noise_value) {
  BiomeReturn biome_return = new BiomeReturn();
  if (noise_value > 0.8f) {
    biome_return.terrain_code = 154;
  }
  else if (noise_value > 0.6f) {
    biome_return.terrain_code = 151;
  }
  else {
    biome_return.terrain_code = 152;
  }
  return biome_return;
}
static class Constants {

  // Program constants
  static final String credits =
  "Liberal Nazi Zombies" +
  "\nCreated by Daniel Gray" +
  "\nAlpha v0.7.7u: 20220708" +
  "\n\nLines: 54330 (v0.7.7s)" +
  "\nImages: 1264 (v0.7.7)" +
  "\nSounds: 341 (v0.7.7)" +
  "";
  static final String version_history =
  "Liberal Nazi Zombies" +
  "\nCreated by Daniel Gray" +
  "\n202205: v0.7: Alpha Version" +
  "\n202203: v0.6: Advanced Mechanics" +
  "\n202202: v0.5: Recreated Logic" +
  "\n202201: v0.4: Recreated Program" +
  "\n2019: v0.3: Legacy Version" +
  "";
  static final int frameUpdateTime = 401; // prime number
  static final int frameAverageCache = 3;
  static final int maxFPS = 120;
  static final int exit_delay = 300;
  static final float default_cursor_size = 35;
  static final float small_number = 0.001f; // for float miscalculations
  static final float inverse_root_two = 0.70710678f;
  static final float root_two = 1.41421356f;
  static final float errorForm_width = 400;
  static final float errorForm_height = 400;
  static final int color_black = -16777216;
  static final int color_fog = 1688906410;
  static final int color_transparent = 65793;
  static final int notification_slide_time = 200;
  static final int notification_display_time = 3000;
  static final float notification_achievement_width = 220;
  static final float notification_achievement_height = 120;
  static final float esc_button_height = 30;
  static final float escFormWidth = 350;
  static final float escFormHeight = 350;

  // Initial Interface
  static final int initialInterface_size = 400;
  static final int initialInterface_buttonWidth = 80;
  static final int initialInterface_buttonGap = 25;

  // Profile
  static final float profile_treeForm_width = 300;
  static final float profile_treeForm_height = 340;
  static final float profile_tree_nodeHeight = 80;
  static final float profile_heroesFormWidth = 850;
  static final float profile_heroesFormHeight = 600;
  static final float profile_heroFormWidth = 400;
  static final float profile_heroFormHeight = 500;

  // MainMenu Interface
  static final float profileForm_width = 400;
  static final float profileForm_height = 500;
  static final float newProfileForm_width = 400;
  static final float newProfileForm_height = 500;
  static final float optionsForm_widthOffset = 300;
  static final float optionsForm_heightOffset = 100;
  static final float optionsForm_threshhold_master = 0.12f;
  static final float optionsForm_threshhold_other = 0.15f;
  static final float achievementsForm_widthOffset = 300;
  static final float achievementsForm_heightOffset = 100;
  static final float banner_maxWidthRatio = 0.8f;
  static final float banner_maxHeightRatio = 0.2f;
  static final float creditsForm_width = 300;
  static final float creditsForm_height = 320;
  static final float playButton_scaleFactor = 1.7f;
  static final float profileButton_offset = 45;
  static final float profileButton_growfactor = 1.6f;

  // Options
  static final int options_defaultVolume = 40;
  static final int options_defaultMusicVolume = 30;
  static final float options_volumeMin = 0.01f;
  static final int options_volumeMax = 100;
  static final float options_volumeGainMultiplier = 8;

  // MapEditor Interface
  static final float mapEditor_panelMinWidth = 220;
  static final float mapEditor_panelMaxWidth = 400;
  static final float mapEditor_panelStartWidth = 300;
  static final float mapEditor_buttonGapSize = 10;
  static final float mapEditor_listBoxGap = 5;
  static final float mapEditor_formWidth = 400;
  static final float mapEditor_formHeight = 500;
  static final float mapEditor_formWidth_small = 250;
  static final float mapEditor_formHeight_small = 250;
  static final float mapEditor_rightClickBoxWidth = 100;
  static final float mapEditor_rightClickBoxMaxHeight = 100;

  // Minigame Interface
  static final float minigames_panelWidth = 180;
  static final float minigames_minigameButtonWidth = 65;
  static final float minigames_edgeGap = 5;
  static final float minigames_buttonGap = 15;
  static final float minigames_scrollbarWidth = 18;
  static final float minigames_chessPanelsSize = 400;

  // Help strings
  static final String help_mapEditor_maps = "Maps\n\nThis view displays the " +
    "maps you've made. Double-click a map to edit it, or right click one to " +
    "see more options.";
  static final String help_mapEditor_areas = "Areas\n\nThis view ...";
  static final String help_mapEditor_levels = "Levels\n\nThis view displays the " +
    "levels you've made. Double-click a level to edit it, or right click one to " +
    "see more options.";
  static final String help_mapEditor_terrain = "Terrain\n\nIn this view you " +
    "can select terrain to add to the map.\n\nHotkeys:\n z: Toggle grid\n x: " +
    "Toggle fog\n c: Toggle rectangle mode\n v: Toggle square mode\n b: Edit " +
    "selected object on map.";
  static final String help_mapEditor_features = "Features\n\nIn this view you " +
    "can select features to add to the map.\n\nHotkeys:\n z: Toggle grid\n x: " +
    "Toggle fog\n c: Toggle rectangle mode\n v: Toggle square mode\n b: Edit " +
    "selected object on map.";
  static final String help_mapEditor_units = "Units\n\nIn this view you " +
    "can select units to add to the map.\n\nHotkeys:\n z: Toggle grid\n x: " +
    "Toggle fog\n c: Toggle rectangle mode\n v: Toggle square mode\n b: Edit " +
    "selected object on map.";
  static final String help_mapEditor_items = "Items\n\nIn this view you " +
    "can select items to add to the map.\n\nHotkeys:\n z: Toggle grid\n x: " +
    "Toggle fog\n c: Toggle rectangle mode\n v: Toggle square mode\n b: Edit " +
    "selected object on map.";
  static final String help_mapEditor_levelInfo = "Level Editor\n\nIn this " +
    "view you see an overview of your level and the maps in it.\nDouble-click " +
    "a map to view it.\n\nHotkeys:\n z: Toggle grid\n x: Toggle fog\n c: Toggle " +
    "rectangle mode\n v: Toggle square mode\n s: Save last rectangle\n S: Set " +
    "player start/respawn location";
  static final String help_mapEditor_levelMaps = "Maps\n\nIn this view you " +
    "can see the maps that can be added to your level.\nDouble-click a map " +
    "to add it to your level.\n\nHotkeys:\n z: Toggle grid\n x: Toggle fog\n c: " +
    "Toggle rectangle mode\n v: Toggle square mode\n s: Save last rectangle\n S: " +
    "Set player start/respawn location\n d: Remove selected map from level";
  static final String help_mapEditor_linkers = "Linkers\n\nIn this view you " +
    "see the linkers in your level.\n\nHotkeys:\n z: Toggle grid\n x: Toggle " +
    "fog\n c: Toggle rectangle mode\n v: Toggle square mode\n s: Save last " +
    "rectangle\n S: Set player start/respawn location\n a: Add linker from current " +
    "rectangles\n d: Delete selected linker from level";
  static final String help_mapEditor_triggers = "Triggers\n\nIn this view " +
    "you see the triggers in your level.\nDouble-click a trigger to open the " +
    "trigger editor.\n\nHotkeys:\n z: Toggle grid\n x: Toggle fog\n c: Toggle " +
    "rectangle mode\n v: Toggle square mode\n s: Save last rectangle\n S: Set " +
    "player start/respawn location\n a: Add a new trigger to level\n d: Delete selected " +
    "trigger from level";
  static final String help_mapEditor_triggerEditor = "Trigger Editor\n\nIn " +
    "this view you can edit the trigger you selected.\n\nHotkeys:\n z: " +
    "Toggle grid\n x: Toggle fog\n c: Toggle rectangle mode\n v: Toggle square " +
    "mode\n s: Save last rectangle\n S: Set player start/respawn location\n d: Delete " +
    "selected trigger component from trigger";
  static final String help_mapEditor_conditionEditor = "Condition Editor\n\nIn " +
    "this view you can edit the condition you selected.\n\nHotkeys:\n z: " +
    "Toggle grid\n x: Toggle fog\n c: Toggle rectangle mode\n v: Toggle square " +
    "mode\n s: Save last rectangle\n S: Set player start/respawn location\n a: Add " +
    "current rectangle to condition\n d: Delete selected trigger component " +
    "from trigger";
  static final String help_mapEditor_effectEditor = "Effect Editor\n\nIn " +
    "this view you can edit the effect you selected.\n\nHotkeys:\n z: " +
    "Toggle grid\n x: Toggle fog\n c: Toggle rectangle mode\n v: Toggle square " +
    "mode\n s: Save last rectangle\n S: Set player start/respawn location\n a: Add " +
    "current rectangle to effect\n d: Delete selected trigger component " +
    "from trigger";

  // GameMap
  static final float map_borderSize = 30;
  static final int map_terrainResolutionDefault = 70;
  static final int map_fogResolution = 4;
  static final float map_defaultZoom = 100;
  static final float map_minZoom = 60;
  static final float map_maxZoom = 150;
  static final float map_scrollZoomFactor = -1.5f;
  static final float map_minCameraSpeed = 0.001f;
  static final float map_maxCameraSpeed = 0.1f;
  static final float map_defaultCameraSpeed = 0.01f;
  static final float map_defaultHeaderMessageTextSize = 28;
  static final int map_headerMessageFadeTime = 250;
  static final int map_headerMessageShowTime = 3000;
  static final float map_selectedObjectTitleTextSize = 22;
  static final float map_selectedObjectPanelGap = 4;
  static final float map_selectedObjectImageGap = 8;
  static final float map_moveLogicCap = 0.12f; // longest movable distance at one logical go
  static final float map_tierImageHeight = 50;
  static final float map_statusImageHeight = 30;
  static final int map_maxHeaderMessages = 5;
  static final float map_defaultMaxSoundDistance = 8;
  static final float map_timer_refresh_fog_default = 350;
  static final float map_timer_refresh_fog_min = 50;
  static final float map_timer_refresh_fog_max = 950;
  static final int map_maxHeight = 10;
  static final float map_lightDecay = 0.8f; // per square
  static final int map_lightUpdateIterations = 4; // per refresh
  static final int map_chunkWidth = 30;
  static final int map_noiseOffsetX = 123456;
  static final int map_noiseOffsetY = 654321;
  static final int map_noiseOctaves = 8;
  static final float map_chunkPerlinMultiplier = 0.2f;
  static final float map_mapPerlinMultiplier = 0.05f;

  // Features
  static final float feature_defaultInteractionDistance = 0.3f;
  static final int feature_woodenTableHealth = 4;
  static final int feature_woodenDeskHealth = 10;
  static final int feature_woodenChairHealth = 2;
  static final int feature_furnitureInteractionTime = 200;
  static final int feature_couchHealth = 4;
  static final int feature_woodenBenchSmallHealth = 4;
  static final int feature_woodenBenchLargeHealth = 8;
  static final int feature_bedHealth = 8;
  static final int feature_wardrobeHealth = 10;
  static final int feature_signCooldown = 2000;
  static final String feature_signDescriptionDelimiter = "***";
  static final int feature_showerStallCooldown = 6000;
  static final int feature_urinalCooldown = 6000;
  static final int feature_toiletCooldown = 10000;
  static final int feature_pickleJarCooldown = 2000;
  static final int feature_movableBrickWallInteractionTime = 1500;
  static final int feature_gravelInteractionTime = 300;
  static final float feature_gravelMaxNumberRocks = 4;
  static final int feature_wireFenceInteractionTime = 400;
  static final int feature_treeInteractionTime = 350;
  static final int feature_treeHealth = 8;
  static final int feature_treeBigHealth = 12;
  static final float feature_treeDropChance = 0.5f;
  static final float feature_treeChanceEndBranches = 0.6f;
  static final int feature_bushInteractionTime = 350;
  static final int feature_bushHealth = 3;
  static final float feature_bushDropChance = 0.5f;
  static final float feature_vendingEatMoneyChance = 0.3f;
  static final int feature_bedSleepTimer = 5000;
  static final float feature_workbenchMinimumToolsButtonWidth = 350;

  // Units
  static final float unit_defaultSize = 0.35f;
  static final int unit_defaultHeight = 5;
  static final float unit_defaultSight = 6.5f;
  static final float unit_sneakSpeed = 0.5f;
  static final float unit_moveCollisionStopActionTime = 300;
  static final float unit_small_facing_threshhold = 0.01f;
  static final float unit_defaultBaseAttackCooldown = 1200;
  static final float unit_defaultBaseAttackTime = 300;
  static final float unit_defaultBaseAttackRange = 0.2f;
  static final float unit_weaponDisplayScaleFactor = 0.8f;
  static final float unit_attackAnimation_ratio1 = 0.6f;
  static final float unit_attackAnimation_ratio2 = 0.85f;
  static final float unit_attackAnimation_amount1 = 0.33f * PI;
  static final float unit_attackAnimation_amount2 = -0.5f * PI;
  static final float unit_attackAnimation_amount3 = Constants.unit_attackAnimation_amount1 + Constants.unit_attackAnimation_amount2;
  static final float unit_attackAnimation_multiplier1 =
    Constants.unit_attackAnimation_amount1 / Constants.unit_attackAnimation_ratio1;
  static final float unit_attackAnimation_multiplier2 = Constants.unit_attackAnimation_amount2 /
    (Constants.unit_attackAnimation_ratio2 - Constants.unit_attackAnimation_ratio1);
   public static final float unit_attackAnimationAngle(float timerRatio) {
    if (timerRatio < Constants.unit_attackAnimation_ratio1) {
      return timerRatio * Constants.unit_attackAnimation_multiplier1;
    }
    else if (timerRatio < Constants.unit_attackAnimation_ratio2) {
      return Constants.unit_attackAnimation_amount1 + (timerRatio -
        Constants.unit_attackAnimation_ratio1) * Constants.unit_attackAnimation_multiplier2;
    }
    else {
      return Constants.unit_attackAnimation_amount3 * (1 - timerRatio) / (1 - Constants.unit_attackAnimation_ratio2);
    }
  }
  static final float unit_healthbarWidth = 0.9f;
  static final float unit_healthbarHeight = 0.15f;
  static final float unit_healthbarDamageAnimationTime = 150;
  static final float unit_fallTimer = 100;
  static final int unit_maxAgility = 5;
  static final int unit_noDamageFallHeight = 3;
  static final float unit_fallDamageMultiplier = 0.015f;
  static final int unit_timer_talk = 9000;
  static final int unit_timer_target_sound = 4000;
  static final int unit_timer_walk = 380;
  static final int unit_timer_resolve_floor_height_cooldown = 400;
  static final int unit_update_pathfinding_timer = 500;
  static final float unit_footgearDurabilityDistance = 100;

  // Resistances
  static final float resistance_default = 1;
  static final float resistance_blue_blue = 0.85f;
  static final float resistance_blue_red = 0.8f;
  static final float resistance_blue_brown = 1.2f;
  static final float resistance_red_red = 0.85f;
  static final float resistance_red_cyan = 0.8f;
  static final float resistance_red_blue = 1.2f;
  static final float resistance_cyan_cyan = 0.85f;
  static final float resistance_cyan_orange = 0.8f;
  static final float resistance_cyan_red = 1.2f;
  static final float resistance_orange_orange = 0.85f;
  static final float resistance_orange_brown = 0.8f;
  static final float resistance_orange_cyan = 1.2f;
  static final float resistance_brown_brown = 0.85f;
  static final float resistance_brown_blue = 0.8f;
  static final float resistance_brown_orange = 1.2f;
  static final float resistance_purple_purple = 0.85f;
  static final float resistance_purple_yellow = 0.8f;
  static final float resistance_purple_magenta = 1.2f;
  static final float resistance_yellow_yellow = 0.85f;
  static final float resistance_yellow_magenta = 0.8f;
  static final float resistance_yellow_purple = 1.2f;
  static final float resistance_magenta_magenta = 0.85f;
  static final float resistance_magenta_purple = 0.8f;
  static final float resistance_magenta_yellow = 1.2f;

  // Status Effects
  static final float status_hunger_tickTimer = 1400;
  static final float status_hunger_dot = 0.02f;
  static final float status_hunger_damageLimit = 0.5f;
  static final float status_hunger_weakPercentage = 0.1f;
  static final float status_weak_multiplier = 0.9f;
  static final float status_thirst_tickTimer = 1400;
  static final float status_thirst_dot = 0.02f;
  static final float status_thirst_damageLimit = 0.35f;
  static final float status_thirst_woozyPercentage = 0.07f;
  static final float status_thirst_confusedPercentage = 0.07f;
  static final float status_woozy_tickMaxTimer = 10000;
  static final float status_woozy_maxAmount = HALF_PI;
  static final float status_confused_tickMaxTimer = 10000;
  static final float status_confused_maxAmount = 3;
  static final float status_bleed_tickTimer = 1200;
  static final float status_bleed_dot = 0.02f;
  static final float status_bleed_damageLimit = 0.1f;
  static final float status_bleed_hemorrhagePercentage = 0.1f;
  static final float status_hemorrhage_tickTimer = 900;
  static final float status_hemorrhage_dot = 0.04f;
  static final float status_hemorrhage_damageLimit = 0;
  static final float status_hemorrhage_bleedPercentage = 0.7f;
  static final float status_wilted_multiplier = 0.8f;
  static final float status_withered_multiplier = 0.7f;
  static final float status_running_multiplier = 1.35f;
  static final float status_slowed_multiplier = 0.7f;
  static final float status_relaxed_multiplier = 0.85f;
  static final float status_relaxed_healMultiplier = 0.01f;
  static final float status_drenched_multiplier = 1.3f;
  static final float status_drenched_tickTimer = 1200;
  static final float status_drenched_dot = 0.025f;
  static final float status_drenched_damageLimit = 0.2f;
  static final float status_drowning_tickTimer = 500;
  static final float status_drowning_dot = 0.05f;
  static final float status_drowning_damageLimit = 0;
  static final float status_drowning_damageLimitBlue = 0.05f;
  static final float status_drowning_drenchedPercentage = 0.7f;
  static final float status_burnt_tickTimer = 1200;
  static final float status_burnt_dot = 0.025f;
  static final float status_burnt_damageLimit = 0;
  static final float status_burnt_damageLimitRed = 0.1f;
  static final float status_burnt_charredPercentage = 0.1f;
  static final float status_charred_tickTimer = 600;
  static final float status_charred_dot = 0.03f;
  static final float status_charred_damageLimit = 0;
  static final float status_charred_damageLimitRed = 0.05f;
  static final float status_chilled_speedMultiplier = 0.5f;
  static final float status_chilled_speedMultiplierCyan = 0.8f;
  static final float status_chilled_cooldownMultiplier = 0.5f;
  static final float status_chilled_cooldownMultiplierCyan = 0.8f;
  static final float status_frozen_tickTimer = 1600;
  static final float status_frozen_dot = 0.025f;
  static final float status_frozen_damageLimit = 0.1f;
  static final float status_sick_damageMultiplier = 1.15f;
  static final float status_sick_defenseMultiplier = 0.85f;
  static final float status_diseased_damageMultiplier = 1.3f;
  static final float status_diseased_defenseMultiplier = 0.7f;
  static final float status_rotting_tickTimer = 1000;
  static final float status_rotting_dot = 0.015f;
  static final float status_rotting_damageLimit = 0.1f;
  static final float status_rotting_damageLimitBrown = 0.2f;
  static final float status_rotting_damageLimitBlue = 0.0f;
  static final float status_rotting_decayedPercentage = 0.1f;
  static final float status_decayed_tickTimer = 1000;
  static final float status_decayed_dot = 0.025f;
  static final float status_decayed_damageLimit = 0;
  static final float status_decayed_damageLimitBrown = 0.1f;

  // AI
  static final float ai_chickenMoveDistance = 2;
  static final float ai_chickenTimer1 = 3000;
  static final float ai_chickenTimer2 = 45000;

  // Items
  static final int item_disappearTimer = 300000; // 5 minutes
  static final float item_defaultSize = 0.25f;
  static final int item_bounceConstant = 800;
  static final float item_bounceOffset = 0.15f;
  static final int item_starPieceFrames = 4;
  static final float item_starPieceAnimationTime = 450;
  static final float item_defaultInteractionDistance = 0.3f;
  static final float item_stackTextSizeRatio = 0.25f;
  static final int item_cigarLitTime = 200000;

  // Projectiles
  static final float projectile_defaultSize = 0.25f;
  static final float projectile_threshholdSpeed = 3;
  static final float projectile_grenadeExplosionRadius = 2;
  static final float projectile_mustangAndSallyExplosionRadius = 2.6f;
  static final float projectile_rpgExplosionRadius = 1.6f;
  static final float projectile_rpgIIExplosionRadius = 1.8f;
  static final float projectile_rayGunExplosionRadius = 1;
  static final float projectile_rayGunIIExplosionRadius = 1.2f;

  // Gifs
  static final int gif_move_frames = 35;
  static final int gif_move_time = 1200;
  static final int gif_poof_frames = 8;
  static final int gif_poof_time = 900;
  static final int gif_amphibiousLeap_frames = 10;
  static final int gif_amphibiousLeap_time = 400;
  static final int gif_quizmoQuestion_frames = 3;
  static final int gif_quizmoQuestion_time = 400;
  static final int gif_explosionBig_frames = 23;
  static final int gif_explosionBig_time = 850;
  static final int gif_explosionCrackel_frames = 17;
  static final int gif_explosionCrackel_time = 600;
  static final int gif_explosionFire_frames = 23;
  static final int gif_explosionFire_time = 600;
  static final int gif_explosionNormal_frames = 14;
  static final int gif_explosionNormal_time = 550;
  static final int gif_explosionGreen_frames = 102;
  static final int gif_explosionGreen_time = 650;
  static final int gif_fire_frames = 31;
  static final int gif_fire_time = 2500;
  static final int gif_lava_frames = 37;
  static final int gif_lava_time = 3200;
  static final int gif_drenched_frames = 4;
  static final int gif_drenched_time = 500;
  static final int gif_arrow_frames = 3;
  static final int gif_arrow_time = 350;
  static final int gif_loading_frames = 30;
  static final int gif_loading_time = 950;

  // Hero
  static final float hero_defaultInventoryButtonSize = 50;
  static final int hero_inventoryMaxRows = 6;
  static final int hero_inventoryMaxCols = 9;
  static final int hero_inventoryDefaultStartSlots = 0;
  static final float hero_experienceNextLevel_level = 1.4f;
  static final float hero_experienceNextLevel_power = 2.0f;
  static final float hero_experienceNextLevel_tier = 3.0f;
  static final float hero_killExponent = 1.5f;
  static final int hero_maxLevel = 100;
  static final float hero_defaultInventoryBarHeight = 120;
  static final float hero_inventoryBarGap = 10;
  static final float hero_abilityDescriptionMinWidth = 250;
  static final int hero_maxHunger = 100;
  static final int hero_maxThirst = 100;
  static final int hero_hungerTimer = 9000;
  static final int hero_thirstTimer = 5000;
  static final int hero_abilityNumber = 5;
  static final int hero_hungerThreshhold = 20;
  static final int hero_thirstThreshhold = 20;
  static final float hero_statusDescription_width = 160;
  static final float hero_statusDescription_height = 120;
  static final float hero_leftPanelBarHeight = 10;
  static final float hero_leftPanelButtonHoverTimer = 400;
  static final float hero_treeButtonDefaultRadius = 60;
  static final float hero_treeButtonCenterRadius = 90;
  static final float hero_treeForm_width = 300;
  static final float hero_treeForm_height = 340;
  static final float hero_manabarHeight = 0.05f;
  static final float hero_experienceRespawnMultiplier = 0.3f;
  static final float hero_passiveHealPercent = 0.005f;
  static final int hero_multicraftTimer = 50;
  static final float hero_scaling_health = 0.6f;
  static final float hero_scaling_attack = 0.08f;
  static final float hero_scaling_magic = 0.04f;
  static final float hero_scaling_defense = 0.02f;
  static final float hero_scaling_resistance = 0.01f;
  static final float hero_scaling_piercing = 0.00001f;
  static final float hero_scaling_penetration = 0.000006f;

  // Upgrade
  static final int upgrade_inventoryI = 2;
  static final int upgrade_inventoryII = 4;
  static final int upgrade_inventory_bar_slots = 3;
  static final float upgrade_healthI = 2.5f;
  static final float upgrade_attackI = 1.5f;
  static final float upgrade_defenseI = 0.8f;
  static final float upgrade_piercingI = 0.05f;
  static final float upgrade_speedI = 0.3f;
  static final float upgrade_sightI = 1.5f;
  static final float upgrade_tenacityI = 0.05f;
  static final int upgrade_agilityI = 1;
  static final float upgrade_magicI = 5;
  static final float upgrade_resistanceI = 3;
  static final float upgrade_penetrationI = 0.05f;
  static final float upgrade_healthII = 25;
  static final float upgrade_attackII = 12;
  static final float upgrade_defenseII = 6.2f;
  static final float upgrade_piercingII = 0.07f;
  static final float upgrade_speedII = 0.5f;
  static final float upgrade_sightII = 2;
  static final float upgrade_tenacityII = 0.07f;
  static final int upgrade_agilityII = 1;
  static final float upgrade_magicII = 20;
  static final float upgrade_resistanceII = 7;
  static final float upgrade_penetrationII = 0.07f;
  static final float upgrade_healthIII = 120;

  // Abilities
  // Ben Nelson
  static final int ability_101_rageGain = 2;
  static final int ability_101_rageGainKill = 6;
  static final float ability_101_cooldownTimer = 4000;
  static final float ability_101_tickTimer = 500;
  static final float ability_101_bonusAmount = 0.0025f;
  static final float ability_102_powerBase = 1;
  static final float ability_102_powerRatio = 0.35f;
  static final float ability_102_distance = 5;
  static final float ability_102_powerBasePen = 5;
  static final float ability_102_powerRatioPen = 0.7f;
  static final float ability_102_healRatio = 0.2f;
  static final float ability_103_range = 2;
  static final float ability_103_castTime = 800;
  static final float ability_103_coneAngle = 0.15f * PI;
  static final float ability_103_debuff = 0.85f;
  static final float ability_103_time = 3000;
  static final float ability_104_passiveHealAmount = 0.01f;
  static final float ability_104_passiveHealTimer = 2000;
  static final float ability_104_activeHealAmount = 0.2f;
  static final float ability_104_speedBuff = 1.25f;
  static final float ability_104_speedBuffTimer = 3000;
  static final int ability_105_rageGain = 40;
  static final float ability_105_buffAmount = 1.4f;
  static final float ability_105_buffTime = 4500;
  static final float ability_105_rageGainBonus = 1.8f;
  static final float ability_105_fullRageBonus = 1.3f;
  static final float ability_105_shakeConstant = 4;
  static final int ability_106_rageGain = 5;
  static final int ability_106_rageGainKill = 10;
  static final float ability_106_cooldownTimer = 6000;
  static final float ability_106_tickTimer = 800;
  static final float ability_106_bonusAmount = 0.004f;
  static final float ability_107_powerBase = 10;
  static final float ability_107_powerRatio = 0.5f;
  static final float ability_107_distance = 5;
  static final float ability_107_powerBasePen = 50;
  static final float ability_107_powerRatioPen = 1;
  static final float ability_107_healRatio = 0.3f;
  static final float ability_108_range = 3;
  static final float ability_108_castTime = 800;
  static final float ability_108_coneAngle = 0.15f * PI;
  static final float ability_108_debuff = 0.75f;
  static final float ability_108_time = 5000;
  static final float ability_109_passiveHealAmount = 0.01f;
  static final float ability_109_passiveHealTimer = 1500;
  static final float ability_109_activeHealAmount = 0.25f;
  static final float ability_109_speedBuff = 1.35f;
  static final float ability_109_speedBuffTimer = 4500;
  static final int ability_110_rageGain = 60;
  static final float ability_110_buffAmount = 1.5f;
  static final float ability_110_buffTime = 7000;
  static final float ability_110_rageGainBonus = 1.6f;
  static final float ability_110_fullRageBonus = 1.5f;
  static final float ability_110_shakeConstant = 6;
  // Daniel Gray
  static final float ability_111_stillTime = 3500;
  static final float ability_111_distance = 0.2f;
  static final float ability_111_powerBuff = 1.4f;
  static final float ability_111_regenTime = 1400;
  static final float ability_112_basePower = 5;
  static final float ability_112_physicalRatio = 0.15f;
  static final float ability_112_magicalRatio = 0.4f;
  static final float ability_112_distance = 2;
  static final float ability_112_castTime = 500;
  static final float ability_112_slowAmount = 0.7f;
  static final float ability_112_slowTime = 3000;
  static final float ability_113_jumpDistance = 2;
  static final float ability_113_jumpHeight = 5;
  static final float ability_113_jumpSpeed = 4.5f;
  static final float ability_113_basePower = 3;
  static final float ability_113_physicalRatio = 0.1f;
  static final float ability_113_magicalRatio = 0.7f;
  static final float ability_113_stunTime = 1000;
  static final float ability_113_splashRadius = 0.5f;
  static final float ability_113_killCooldownReduction = 0.5f;
  static final float ability_113_drenchedJumpDistance = 3;
  static final float ability_113_drenchedSplashRadius = 0.8f;
  static final float ability_114_currHealth = 0.01f;
  static final float ability_114_basePower = 1;
  static final float ability_114_magicRatio = 0.05f;
  static final float ability_114_range = 0.8f;
  static final float ability_114_rotTime = 1200;
  static final float ability_114_tickTime = 500;
  static final float ability_115_range = 0.4f;
  static final float ability_115_maxTime = 3500;
  static final float ability_115_basePower = 8;
  static final float ability_115_physicalRatio = 0.1f;
  static final float ability_115_magicalRatio = 0.7f;
  static final float ability_115_regurgitateSpeed = 5;
  static final float ability_115_regurgitateDistance = 2.5f;
  static final float ability_116_stillTime = 2000;
  static final float ability_116_distance = 0.1f;
  static final float ability_116_powerBuff = 1.7f;
  static final float ability_116_regenTime = 1200;
  static final float ability_117_basePower = 15;
  static final float ability_117_physicalRatio = 0.20f;
  static final float ability_117_magicalRatio = 0.8f;
  static final float ability_117_distance = 2.5f;
  static final float ability_117_slowTime = 4000;
  static final float ability_118_jumpDistance = 2.5f;
  static final float ability_118_basePower = 12;
  static final float ability_118_physicalRatio = 0.2f;
  static final float ability_118_magicalRatio = 1.2f;
  static final float ability_118_stunTime = 1200;
  static final float ability_118_splashRadius = 0.6f;
  static final float ability_118_killCooldownReduction = 0.2f;
  static final float ability_118_drenchedJumpDistance = 4;
  static final float ability_118_drenchedSplashRadius = 1;
  static final float ability_119_currHealth = 0.015f;
  static final float ability_119_basePower = 2;
  static final float ability_119_magicRatio = 0.08f;
  static final float ability_119_range = 1;
  static final float ability_120_maxTime = 5000;
  static final float ability_120_basePower = 15;
  static final float ability_120_physicalRatio = 0.2f;
  static final float ability_120_magicalRatio = 1.4f;
  // Cathy Heck
  static final float ability_1001_range = 2.7f;
  static final float ability_1001_castTime = 600;
  static final float ability_1001_coneAngle = 0.12f * PI;
  static final float ability_1001_tanConeAngle = 2 * (float)Math.tan(Constants.ability_1001_coneAngle);
  static final float ability_1001_basePower = 2;
  static final float ability_1001_magicRatio = 0.8f;
  static final float ability_1001_woozyTime = 5000;
  static final float ability_1002_castTime = 600;
  static final float ability_1002_range = 30;
  static final float ability_1002_basePower = 6;
  static final float ability_1002_magicRatio = 1.1f;
  static final float ability_1003_basePower = 10;
  static final float ability_1003_magicRatio = 1.4f;
  static final float ability_1003_maxHealth = 0.05f;
  static final float ability_1003_statusTime = 2500;
  static final float ability_1003_castTime = 500;
  static final float ability_1003_size_w = 1.7f;
  static final float ability_1003_size_h = 1.24f;

  // Level
  static final float level_questBoxHeightRatio = 0.25f;
  static final float level_decisionFormWidth = 500;
  static final float level_decisionFormHeight = 500;
  static final float level_vendingFormWidth = 300;
  static final float level_vendingFormHeight = 600;
  static final float level_quizmoFormWidth = 400;
  static final float level_quizmoFormHeight = 650;
  static final float level_quizmoTimeDelay = 900;
  static final float level_khalilFormWidth = 550;
  static final float level_khalilFormHeight = 750;
  static final float level_vehicleFormWidth = 450;
  static final float level_vehicleFormHeight = 380;
  static final int level_questBlinkTime = 500;
  static final int level_questBlinks = 3;
  static final float level_timeConstants = 0.00002f; // 20 minute day / night cycles
  static final float level_dayLightLevel = 9.5f;
  static final float level_nightLightLevel = 3.5f;
  static final float level_zombieSpawnLightThreshhold = 5;
  static final int level_defaultRespawnTimer = 5000;
}
class IntegerCoordinate {
  private int x;
  private int y;
  private int hashCode;
  IntegerCoordinate(int x, int y) {
    this.x = x;
    this.y = y;
    this.hashCode = Objects.hash(x, y);
  }
   public IntegerCoordinate copy() {
    return new IntegerCoordinate(this.x, this.y);
  }
  @Override
  public boolean equals(Object coordinate_object) {
    if (this == coordinate_object) {
      return true;
    }
    if (coordinate_object == null || this.getClass() != coordinate_object.getClass()) {
      return false;
    }
    IntegerCoordinate coordinate = (IntegerCoordinate)coordinate_object;
    if (this.x == coordinate.x && this.y == coordinate.y) {
      return true;
    }
    return false;
  }
  @Override
  public int hashCode() {
    return this.hashCode;
  }
   public IntegerCoordinate[] adjacentCoordinates() {
    IntegerCoordinate[] adjacent_coordinates = new IntegerCoordinate[4];
    adjacent_coordinates[0] = new IntegerCoordinate(this.x + 1, this.y);
    adjacent_coordinates[1] = new IntegerCoordinate(this.x - 1, this.y);
    adjacent_coordinates[2] = new IntegerCoordinate(this.x, this.y + 1);
    adjacent_coordinates[3] = new IntegerCoordinate(this.x, this.y - 1);
    return adjacent_coordinates;
  }
   public IntegerCoordinate[] cornerCoordinates() {
    IntegerCoordinate[] corner_coordinates = new IntegerCoordinate[4];
    corner_coordinates[0] = new IntegerCoordinate(this.x + 1, this.y + 1);
    corner_coordinates[1] = new IntegerCoordinate(this.x - 1, this.y + 1);
    corner_coordinates[2] = new IntegerCoordinate(this.x + 1, this.y - 1);
    corner_coordinates[3] = new IntegerCoordinate(this.x - 1, this.y - 1);
    return corner_coordinates;
  }
   public IntegerCoordinate[] adjacentAndCornerCoordinates() {
    IntegerCoordinate[] adjacent_and_corner_coordinates = new IntegerCoordinate[8];
    adjacent_and_corner_coordinates[0] = new IntegerCoordinate(this.x + 1, this.y);
    adjacent_and_corner_coordinates[1] = new IntegerCoordinate(this.x - 1, this.y);
    adjacent_and_corner_coordinates[2] = new IntegerCoordinate(this.x, this.y + 1);
    adjacent_and_corner_coordinates[3] = new IntegerCoordinate(this.x, this.y - 1);
    adjacent_and_corner_coordinates[4] = new IntegerCoordinate(this.x + 1, this.y + 1);
    adjacent_and_corner_coordinates[5] = new IntegerCoordinate(this.x - 1, this.y + 1);
    adjacent_and_corner_coordinates[6] = new IntegerCoordinate(this.x + 1, this.y - 1);
    adjacent_and_corner_coordinates[7] = new IntegerCoordinate(this.x - 1, this.y - 1);
    return adjacent_and_corner_coordinates;
  }
   public IntegerCoordinate[] knightMoves() {
    IntegerCoordinate[] knight_moves = new IntegerCoordinate[8];
    knight_moves[0] = new IntegerCoordinate(this.x + 1, this.y + 2);
    knight_moves[1] = new IntegerCoordinate(this.x + 1, this.y - 2);
    knight_moves[2] = new IntegerCoordinate(this.x - 1, this.y + 2);
    knight_moves[3] = new IntegerCoordinate(this.x - 1, this.y - 2);
    knight_moves[4] = new IntegerCoordinate(this.x + 2, this.y + 1);
    knight_moves[5] = new IntegerCoordinate(this.x + 2, this.y - 1);
    knight_moves[6] = new IntegerCoordinate(this.x - 2, this.y + 1);
    knight_moves[7] = new IntegerCoordinate(this.x - 2, this.y - 1);
    return knight_moves;
  }
}

// This function not fully tested, especially when error == 0
 public HashSet<IntegerCoordinate> squaresIntersectedByLine(FloatCoordinate p1, FloatCoordinate p2) {
  HashSet<IntegerCoordinate> intersections = new HashSet<IntegerCoordinate>();
  // declare parameters
  float dx = abs(p1.x - p2.x);
  float dy = abs(p1.y - p2.y);
  int x = round(floor(p1.x));
  int y = round(floor(p1.y));
  int n = 1;
  int x_increase = 0;
  int y_increase = 0;
  float error = 0;
  boolean infinite_error = false;
  boolean negative_infinite_error = false;
  // count intersections with grid lines
  if (dx == 0) {
    infinite_error = true;
  }
  else if (p2.x > p1.x) {
    x_increase = 1;
    n += round(floor(p2.x));
    error = (floor(p1.x) + 1 - p1.x) * dy;
  }
  else {
    x_increase = -1;
    n += x - round(floor(p2.x));
    error = (p1.x - floor(p1.x)) * dy;
  }
  if (dy == 0) {
    if (infinite_error) {
      infinite_error = false;
    }
    else {
      negative_infinite_error = true;
    }
  }
  else if (p2.y > p1.y) {
    y_increase = 1;
    n += round(floor(p2.y)) - y;
    error -= (floor(p1.y) + 1 - p1.y) * dx;
  }
  else {
    y_increase = -1;
    n += y - round(floor(p2.y));
    error -= (p1.y - floor(p1.y)) * dx;
  }
  // traverse line
  for (; n > 0; n--) {
    intersections.add(new IntegerCoordinate(x, y));
    if (infinite_error || (error > 0 && !negative_infinite_error)) {
      y += y_increase;
      error -= dx;
    }
    else {
      x += x_increase;
      error += dy;
    }
  }
  return intersections;
}

class FloatCoordinate {
  private float x;
  private float y;
  FloatCoordinate(float x, float y) {
    this.x = x;
    this.y = y;
  }
   public boolean equals(FloatCoordinate coordinate) {
    if (abs(this.x - coordinate.x) < Constants.small_number && abs(this.y - coordinate.y) < Constants.small_number) {
      return true;
    }
    return false;
  }
}
enum ToolCode {
 SAW, MECHANICAL_SAW, WOOD_GLUE, PAINTBRUSH, CLAMP, FASTENER, DRIVER, MECHANICAL_FASTENER,
 MECHANICAL_DRIVER;

  private static final List<ToolCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String displayName() {
    return ToolCode.displayName(this);
  }
  public static String displayName(ToolCode code) {
    if (code == null) {
      return "Null";
    }
    switch(code) {
      case SAW:
        return "Saw";
      case MECHANICAL_SAW:
        return "Mechanical Saw";
      case WOOD_GLUE:
        return "Wood Glue";
      case PAINTBRUSH:
        return "Paintbrush";
      case CLAMP:
        return "Clamp";
      case FASTENER:
        return "Fastener";
      case DRIVER:
        return "Driver";
      case MECHANICAL_FASTENER:
        return "Mechanical Fastener";
      case MECHANICAL_DRIVER:
        return "Mechanical Driver";
      default:
        return "ERROR";
    }
  }

  public static ToolCode toolCodeFrom(String s) {
    for (ToolCode code : ToolCode.VALUES) {
      if (ToolCode.displayName(code).equals(s)) {
        return code;
      }
    }
    return null;
  }

  public static ArrayList<ToolCode> toolCodesFrom(Item i) {
    ArrayList<ToolCode> codes = new ArrayList<ToolCode>();
    if (i == null || i.remove) {
      return codes;
    }
    switch(i.ID) {
      case 2971: // paintbrush
        codes.add(ToolCode.PAINTBRUSH);
        break;
      case 2972: // clamp
        codes.add(ToolCode.CLAMP);
        break;
      case 2973: // wrench
        break;
      case 2974: // rope
        break;
      case 2975: // hammer
        codes.add(ToolCode.DRIVER);
        break;
      case 2976: // window breaker
        break;
      case 2977: // ax
        break;
      case 2978: // wire clippers
        break;
      case 2979: // saw
        codes.add(ToolCode.SAW);
        break;
      case 2980: // drill
        codes.add(ToolCode.DRIVER);
        codes.add(ToolCode.MECHANICAL_DRIVER);
        break;
      case 2981: // roundsaw
        codes.add(ToolCode.SAW);
        codes.add(ToolCode.MECHANICAL_SAW);
        break;
      case 2982: // beltsander
        break;
      case 2983: // chainsaw
        codes.add(ToolCode.SAW);
        codes.add(ToolCode.MECHANICAL_SAW);
        break;
      case 2984: // woodglue
        codes.add(ToolCode.WOOD_GLUE);
        break;
      case 2985: // nails
        codes.add(ToolCode.FASTENER);
        break;
      case 2986: // screws
        codes.add(ToolCode.FASTENER);
        codes.add(ToolCode.MECHANICAL_FASTENER);
        break;
      default:
        break;
    }
    return codes;
  }

  public static ArrayList<ToolCode> toolCodesFrom(Item ... items) {
    Set<ToolCode> codes = new HashSet<ToolCode>();
    for (Item i : items) {
      for (ToolCode code : ToolCode.toolCodesFrom(i)) {
        codes.add(code);
      }
    }
    return new ArrayList<ToolCode>(codes);
  }
}


class CraftingRecipe {
  private final int[][] ingredients;
  private final int output;
  private final int amount;
  private final ToolCode[] tools;
  CraftingRecipe(int[][] ingredients, int output, int amount, ToolCode[] tools) {
    this.ingredients = ingredients;
    this.output = output;
    this.amount = amount;
    this.tools = tools;
  }
   public boolean hasTools(ArrayList<ToolCode> codes) {
    for (ToolCode code : this.tools) {
      if (!codes.contains(code)) {
        return false;
      }
    }
    return true;
  }
   public void useTools(ArrayList<Item> tools_available) {
    for (ToolCode code : this.tools) {
      boolean no_tool = true;
      for (Item i : tools_available) {
        if (i == null || i.remove) {
          continue;
        }
        if (ToolCode.toolCodesFrom(i).contains(code)) {
          i.lowerDurability();
          no_tool = false;
          break;
        }
      }
      if (no_tool) {
        global.log("WARNING: No tool contained ToolCode " + code + " when crafting " + this.output + ".");
      }
    }
  }
}


 public int[][] reduceItemGrid(int[][] item_grid) {
  if (item_grid == null) {
    return null;
  }
  for (int i = 0; i < item_grid.length; i++) {
    boolean empty = true;
    for (int j = 0; j < item_grid[i].length; j++) {
      if (item_grid[i][j] != 0) {
        empty = false;
      }
    }
    if (empty) {
      item_grid = Arrays.copyOfRange(item_grid, 1, item_grid.length);
      i--;
    }
    else {
      break;
    }
  }
  for (int i = item_grid.length - 1; i >= 0; i--) {
    boolean empty = true;
    for (int j = 0; j < item_grid[i].length; j++) {
      if (item_grid[i][j] != 0) {
        empty = false;
      }
    }
    if (empty) {
      item_grid = Arrays.copyOfRange(item_grid, 0, item_grid.length - 1);
    }
    else {
      break;
    }
  }
  if (item_grid.length == 0) {
    return item_grid;
  }
  for (int i = 0; i < item_grid[0].length; i++) {
    boolean empty = true;
    try {
      for (int j = 0; j < item_grid.length; j++) {
        if (item_grid[j][i] != 0) {
          empty = false;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {
      global.errorMessage("ERROR: Input item grid is corrupted: " + Arrays.deepToString(item_grid));
    }
    if (empty) {
      for (int j = 0; j < item_grid.length; j++) {
        item_grid[j] = Arrays.copyOfRange(item_grid[j], 1, item_grid[j].length);
      }
      i--;
    }
    else {
      break;
    }
  }
  if (item_grid.length == 0) {
    return item_grid;
  }
  for (int i = item_grid[0].length - 1; i >= 0; i--) {
    boolean empty = true;
    try {
      for (int j = 0; j < item_grid.length; j++) {
        if (item_grid[j][i] != 0) {
          empty = false;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {
      global.errorMessage("ERROR: Input item grid is corrupted: " + Arrays.deepToString(item_grid));
    }
    if (empty) {
      for (int j = 0; j < item_grid.length; j++) {
        item_grid[j] = Arrays.copyOfRange(item_grid[j], 0, item_grid[j].length - 1);
      }
    }
    else {
      break;
    }
  }
  return item_grid;
}


 public HashMap<Integer, CraftingRecipe> getAllCraftingRecipes() {
  HashMap<Integer, CraftingRecipe> all_recipes = new HashMap<Integer, CraftingRecipe>();
  int[][] ingredients;

  // ### Household Crafting
  // Candlestick from broken candlestick
  ingredients = new int[][]{{2161}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2162, 1, new ToolCode[]{ToolCode.WOOD_GLUE, ToolCode.CLAMP}));
  // Candle
  ingredients = new int[][]{{0, 2809, 0}, {2810, 2809, 2810}, {2810, 2810, 2810}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2163, 1, new ToolCode[]{}));
  // lords day candle
  ingredients = new int[][]{{2163}, {2162}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2164, 1, new ToolCode[]{}));
  // Crumpled paper from paper
  ingredients = new int[][]{{2913}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2916, 1, new ToolCode[]{}));

  // ### Materials
  // wooden planks
  ingredients = new int[][]{{2969}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2816, 2, new ToolCode[]{ToolCode.MECHANICAL_SAW}));
  // wooden piece
  ingredients = new int[][]{{2816}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2818, 4, new ToolCode[]{ToolCode.SAW}));
  // wooden handle
  ingredients = new int[][]{{2818}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2817, 1, new ToolCode[]{ToolCode.SAW}));

  // ### Melee Weapons
  // wooden sword
  ingredients = new int[][]{{2818}, {2818}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2205, 1, new ToolCode[]{ToolCode.WOOD_GLUE, ToolCode.CLAMP}));
  // wooden spear
  ingredients = new int[][]{{2818}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2207, 1, new ToolCode[]{ToolCode.WOOD_GLUE, ToolCode.CLAMP}));
  // talc sword
  ingredients = new int[][]{{2802}, {2802}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2206, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // talc spear
  ingredients = new int[][]{{2802}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2208, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // gypsum sword
  ingredients = new int[][]{{2812}, {2812}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2212, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // gypsum spear
  ingredients = new int[][]{{2812}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2213, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // calcite sword
  ingredients = new int[][]{{2822}, {2822}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2221, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // calcite spear
  ingredients = new int[][]{{2822}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2222, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // fluorite sword
  ingredients = new int[][]{{2832}, {2832}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2231, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // fluorite spear
  ingredients = new int[][]{{2832}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2232, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // apatite sword
  ingredients = new int[][]{{2842}, {2842}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2241, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // apatite spear
  ingredients = new int[][]{{2842}, {2817}, {2817}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2242, 1, new ToolCode[]{ToolCode.FASTENER, ToolCode.DRIVER}));
  // orthoclase sword
  ingredients = new int[][]{{2852}, {2852}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2251, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // orthoclase spear
  ingredients = new int[][]{{2852}, {2843}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2252, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // quartz sword
  ingredients = new int[][]{{2862}, {2862}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2261, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // quartz spear
  ingredients = new int[][]{{2862}, {2843}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2262, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // topaz sword
  ingredients = new int[][]{{2872}, {2872}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2271, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // topaz spear
  ingredients = new int[][]{{2872}, {2843}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2272, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // corundum sword
  ingredients = new int[][]{{2882}, {2882}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2281, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // corundum spear
  ingredients = new int[][]{{2882}, {2843}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2282, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // diamond sword
  ingredients = new int[][]{{2892}, {2892}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2291, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));
  // diamond spear
  ingredients = new int[][]{{2892}, {2843}, {2843}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2292, 1, new ToolCode[]{ToolCode.MECHANICAL_FASTENER, ToolCode.MECHANICAL_DRIVER}));

  // ### Headgear
  // Talc Helmet
  ingredients = new int[][]{{2802, 2802, 2802}, {2802, 0, 2802}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2401, 1, new ToolCode[]{}));
  // Gypsum Helmet
  ingredients = new int[][]{{2812, 2812, 2812}, {2812, 0, 2812}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2411, 1, new ToolCode[]{}));
  // Calcite Helmet
  ingredients = new int[][]{{2822, 2822, 2822}, {2822, 0, 2822}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2421, 1, new ToolCode[]{}));
  // Fluorite Helmet
  ingredients = new int[][]{{2832, 2832, 2832}, {2832, 0, 2832}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2431, 1, new ToolCode[]{}));
  // Apatite Helmet
  ingredients = new int[][]{{2842, 2842, 2842}, {2842, 0, 2842}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2441, 1, new ToolCode[]{}));
  // Orthoclase Helmet
  ingredients = new int[][]{{2852, 2852, 2852}, {2852, 0, 2852}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2451, 1, new ToolCode[]{}));
  // Quartz Helmet
  ingredients = new int[][]{{2862, 2862, 2862}, {2862, 0, 2862}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2461, 1, new ToolCode[]{}));
  // Topaz Helmet
  ingredients = new int[][]{{2872, 2872, 2872}, {2872, 0, 2872}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2471, 1, new ToolCode[]{}));
  // Corundum Helmet
  ingredients = new int[][]{{2882, 2882, 2882}, {2882, 0, 2882}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2481, 1, new ToolCode[]{}));
  // Diamond Helmet
  ingredients = new int[][]{{2892, 2892, 2892}, {2892, 0, 2892}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2491, 1, new ToolCode[]{}));

  // ### Chestgear
  // Talc Chestplate
  ingredients = new int[][]{{2802, 0, 2802}, {2802, 2802, 2802}, {2802, 2802, 2802}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2501, 1, new ToolCode[]{}));
  // Gypsum Chestplate
  ingredients = new int[][]{{2812, 0, 2812}, {2812, 2812, 2812}, {2812, 2812, 2812}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2511, 1, new ToolCode[]{}));
  // Calcite Chestplate
  ingredients = new int[][]{{2822, 0, 2822}, {2822, 2822, 2822}, {2822, 2822, 2822}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2521, 1, new ToolCode[]{}));
  // Fluorite Chestplate
  ingredients = new int[][]{{2832, 0, 2832}, {2832, 2832, 2832}, {2832, 2832, 2832}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2531, 1, new ToolCode[]{}));
  // Apatite Chestplate
  ingredients = new int[][]{{2842, 0, 2842}, {2842, 2842, 2842}, {2842, 2842, 2842}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2541, 1, new ToolCode[]{}));
  // Orthoclase Chestplate
  ingredients = new int[][]{{2852, 0, 2852}, {2852, 2852, 2852}, {2852, 2852, 2852}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2551, 1, new ToolCode[]{}));
  // Quartz Chestplate
  ingredients = new int[][]{{2862, 0, 2862}, {2862, 2862, 2862}, {2862, 2862, 2862}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2561, 1, new ToolCode[]{}));
  // Topaz Chestplate
  ingredients = new int[][]{{2872, 0, 2872}, {2872, 2872, 2872}, {2872, 2872, 2872}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2571, 1, new ToolCode[]{}));
  // Corundum Chestplate
  ingredients = new int[][]{{2882, 0, 2882}, {2882, 2882, 2882}, {2882, 2882, 2882}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2581, 1, new ToolCode[]{}));
  // Diamond Chestplate
  ingredients = new int[][]{{2892, 0, 2892}, {2892, 2892, 2892}, {2892, 2892, 2892}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2591, 1, new ToolCode[]{}));

  // ### Leggear
  // Talc Greaves
  ingredients = new int[][]{{2802, 2802, 2802}, {2802, 0, 2802}, {2802, 0, 2802}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2601, 1, new ToolCode[]{}));
  // Gypsum Greaves
  ingredients = new int[][]{{2812, 2812, 2812}, {2812, 0, 2812}, {2812, 0, 2812}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2611, 1, new ToolCode[]{}));
  // Calcite Greaves
  ingredients = new int[][]{{2822, 2822, 2822}, {2822, 0, 2822}, {2822, 0, 2822}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2621, 1, new ToolCode[]{}));
  // Fluorite Greaves
  ingredients = new int[][]{{2832, 2832, 2832}, {2832, 0, 2832}, {2832, 0, 2832}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2631, 1, new ToolCode[]{}));
  // Apatite Greaves
  ingredients = new int[][]{{2842, 2842, 2842}, {2842, 0, 2842}, {2842, 0, 2842}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2641, 1, new ToolCode[]{}));
  // Orthoclase Greaves
  ingredients = new int[][]{{2852, 2852, 2852}, {2852, 0, 2852}, {2852, 0, 2852}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2651, 1, new ToolCode[]{}));
  // Quartz Greaves
  ingredients = new int[][]{{2862, 2862, 2862}, {2862, 0, 2862}, {2862, 0, 2862}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2661, 1, new ToolCode[]{}));
  // Topaz Greaves
  ingredients = new int[][]{{2872, 2872, 2872}, {2872, 0, 2872}, {2872, 0, 2872}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2671, 1, new ToolCode[]{}));
  // Corundum Greaves
  ingredients = new int[][]{{2882, 2882, 2882}, {2882, 0, 2882}, {2882, 0, 2882}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2681, 1, new ToolCode[]{}));
  // Diamond Greaves
  ingredients = new int[][]{{2892, 2892, 2892}, {2892, 0, 2892}, {2892, 0, 2892}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2691, 1, new ToolCode[]{}));

  // ### Footgear
  // Talc Boots
  ingredients = new int[][]{{2802, 0, 2802}, {2802, 0, 2802}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2701, 1, new ToolCode[]{}));
  // Gypsum Boots
  ingredients = new int[][]{{2812, 0, 2812}, {2812, 0, 2812}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2711, 1, new ToolCode[]{}));
  // Calcite Boots
  ingredients = new int[][]{{2822, 0, 2822}, {2822, 0, 2822}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2721, 1, new ToolCode[]{}));
  // Fluorite Boots
  ingredients = new int[][]{{2832, 0, 2832}, {2832, 0, 2832}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2731, 1, new ToolCode[]{}));
  // Apatite Boots
  ingredients = new int[][]{{2842, 0, 2842}, {2842, 0, 2842}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2741, 1, new ToolCode[]{}));
  // Orthoclase Boots
  ingredients = new int[][]{{2852, 0, 2852}, {2852, 0, 2852}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2751, 1, new ToolCode[]{}));
  // Quartz Boots
  ingredients = new int[][]{{2862, 0, 2862}, {2862, 0, 2862}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2761, 1, new ToolCode[]{}));
  // Topaz Boots
  ingredients = new int[][]{{2872, 0, 2872}, {2872, 0, 2872}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2771, 1, new ToolCode[]{}));
  // Corundum Boots
  ingredients = new int[][]{{2882, 0, 2882}, {2882, 0, 2882}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2781, 1, new ToolCode[]{}));
  // Diamond Boots
  ingredients = new int[][]{{2892, 0, 2892}, {2892, 0, 2892}};
  all_recipes.putIfAbsent(Arrays.deepHashCode(ingredients), new CraftingRecipe(
    ingredients, 2791, 1, new ToolCode[]{}));

  return all_recipes;
}
class DImg {

  PImage img = null;
  int imgMode = CORNERS;
  int gridX = 1;
  int gridY = 1;

  // Constructor for blank image
  DImg(int x, int y) {
    this.img = createImage(x, y, ARGB);
  }
  DImg(PImage img) {
    this.img = img;
  }

   public void mode(int imgMode) {
    switch(imgMode) {
      case CORNERS:
      case CORNER:
      case CENTER:
        this.imgMode = imgMode;
        break;
      default:
        print("ERROR: imgMode invalid");
        break;
    }
  }

   public void setGrid(int x, int y) {
    if (x < 1 || y < 1) {
      return;
    }
    this.gridX = x;
    this.gridY = y;
  }

   public int gridWidth() { // pixels / grid unit
    return round(this.img.width / this.gridX);
  }
   public int gridHeight() {
    return round(this.img.height / this.gridY);
  }

  // Display functions
   public void display(float x, float y) {
    imageMode(this.imgMode);
    image(this.img, x, y);
  }
   public void display(float xi, float yi, float xf, float yf) {
    imageMode(this.imgMode);
    image(this.img, xi, yi, xf, yf);
  }

  // Return part of an image
   public PImage getImageSection(PImage img, int x, int y, int w, int h) {
    return img.get(x, y, w, h);
  }

  // Add image to part of this using width / height
   public synchronized void addImage(PImage newImg, int x, int y, int w, int h) {
    this.addImage(newImg, 0, 0, newImg.width, newImg.height, x, y, w, h);
  }
   public synchronized void addImage(PImage newImg, int newImgX, int newImgY, int newImgW, int newImgH, int x, int y, int w, int h) {
    if (x < 0) {
      w += x;
      int scaled_dif = round(-x * PApplet.parseFloat(newImg.width) / this.img.width);
      newImgX += scaled_dif;
      newImgW -= scaled_dif;
      x = 0;
    }
    if (y < 0) {
      h += y;
      int scaled_dif = round(-y * PApplet.parseFloat(newImg.height) / this.img.height);
      newImgY += scaled_dif;
      newImgH -= scaled_dif;
      y = 0;
    }
    if (x + w > this.img.width) {
      int scaled_dif = round((x + w - this.img.width) * PApplet.parseFloat(newImg.width) / w);
      w = this.img.width - x;
      newImgW -= scaled_dif;
    }
    if (y + h > this.img.height) {
      int scaled_dif = round((y + h - this.img.height) * PApplet.parseFloat(newImg.height) / h);
      h = this.img.height - y;
      newImgH -= scaled_dif;
    }
    if (w < 1 || h < 1 || newImgW < 1 || newImgH < 1) {
      return;
    }
    // sometimes throws ArrayIndexOutOfBoundsException when passed bad data
    // shouldn't ever throw error though, could be rounding error or ??
    //println(newImg.width, newImg.height, newImgX, newImgY, newImgW, newImgH, this.img.width, this.img.height, x, y, w, h);
    this.img.blend(newImg, newImgX, newImgY, newImgW, newImgH, x, y, w, h, BLEND);
  }
  // Add image to part of this using percent of width / height
   public void addImagePercent(PImage newImg, float xP, float yP, float wP, float hP) {
    if (xP < 0.0f || yP < 0.0f || wP < 0.0f || hP < 0.0f || xP > 1.0f || yP > 1.0f || wP > 1.0f || hP > 1.0f) {
      global.log("DImg: addImagePercent coordinates out of range");
      return;
    }
    this.img.blend(newImg, 0, 0, newImg.width, newImg.height,
      round(this.img.width * xP), round(this.img.height * yP),
      round(this.img.width * wP), round(this.img.height * hP), BLEND);
  }
  // Add image to grid squares
   public void addImageGrid(PImage newImg, int x, int y) {
    this.addImageGrid(newImg, x, y, 1, 1);
  }
   public void addImageGrid(PImage newImg, int x, int y, int w, int h) {
    this.addImageGrid(newImg, 0, 0, newImg.width, newImg.height, x, y, w, h);
  }
   public void addImageGrid(PImage newImg, int newImgX, int newImgY, int newImgW, int newImgH, int x, int y, int w, int h) {
    this.addImage(newImg, newImgX, newImgY, newImgW, newImgH,
      round(this.img.width * (PApplet.parseFloat(x) / this.gridX)),
      round(this.img.height * (PApplet.parseFloat(y) / this.gridY)),
      round(w * (PApplet.parseFloat(this.img.width) / this.gridX)),
      round(h * (PApplet.parseFloat(this.img.height) / this.gridY)));
  }

  // make grid a specific color
   public void colorGrid(int c, int x, int y) {
    this.colorGrid(c, x, y, 1, 1);
  }
   public void colorGrid(int c, int x, int y, int w, int h) {
    this.img.loadPixels();
    for (int i = 0; i < h * this.img.height / this.gridY; i++) {
      for (int j = 0; j < w * this.img.width / this.gridX; j++) {
        int index = (y * this.img.height / this.gridY + i) * this.img.width +
          (x * this.img.width / this.gridX + j);
        try {
          this.img.pixels[index] = c;
        } catch(IndexOutOfBoundsException e) {}
      }
    }
    this.img.updatePixels();
  }

  // my own copy function which accounts for transparency
   public void copyImage(PImage newImg, float x, float y, float w, float h) {
    this.img.loadPixels();
    float scaling_width = newImg.width / w;
    float scaling_height = newImg.height / h;
    for (int i = 0; i < h; i++) {
      int imgY = PApplet.parseInt(scaling_height * i + 0.5f);
      for (int j = 0; j < w; j++) {
        int imgX = PApplet.parseInt(scaling_width * j + 0.5f);

        int index = PApplet.parseInt((i + y) * this.img.width + (j + x));
        int img_index = imgY * newImg.width + imgX;
        try {
          float r_source = newImg.pixels[img_index] >> 16 & 0xFF;
          float g_source = newImg.pixels[img_index] >> 8 & 0xFF;
          float b_source = newImg.pixels[img_index] & 0xFF;
          float a_source = alpha(newImg.pixels[img_index]);
          float r_target = this.img.pixels[index] >> 16 & 0xFF;
          float g_target = this.img.pixels[index] >> 8 & 0xFF;
          float b_target = this.img.pixels[index] & 0xFF;
          float a_target = alpha(this.img.pixels[index]);

          float factor_source = a_source / 255.0f;
          float factor_target = (1 - factor_source) * a_target / 255.0f;
          float r_final = constrain(factor_source * r_source + factor_target * r_target, 0, 255);
          float g_final = constrain(factor_source * g_source + factor_target * g_target, 0, 255);
          float b_final = constrain(factor_source * b_source + factor_target * b_target, 0, 255);
          float a_final = constrain(a_source + a_target, 0, 255);

          this.img.pixels[index] = ccolor(r_final, g_final, b_final, a_final);
        } catch(IndexOutOfBoundsException e) {}
      }
    }
    this.img.updatePixels();
  }

  // image piece
   public PImage getImagePiece(int xi, int yi, int w, int h) {
    if (xi < 0) {
      w += xi;
      xi = 0;
    }
    if (yi < 0) {
      h += yi;
      yi = 0;
    }
    if (xi + w > this.img.width) {
      w = this.img.width - xi;
    }
    if (yi + h > this.img.height) {
      h = this.img.height - yi;
    }
    if (w <= 0 || h <= 0) {
      return createImage(1, 1, ARGB);
    }
    PImage return_image = createImage(w, h, ARGB);
    return_image.loadPixels();
    for (int i = 0; i < h; i++) {
      for (int j = 0; j < w; j++) {
        int index = (yi + i) * this.img.width + (xi + j);
        if (index < 0 || index >= this.img.pixels.length) {
          continue;
        }
        int return_index = i * w + j;
        return_image.pixels[return_index] = this.img.pixels[index];
      }
    }
    return_image.updatePixels();
    return return_image;
  }
   public PImage getImageGridPiece(int x, int y) {
    return this.getImageGridPiece(x, y, 1, 1);
  }
   public PImage getImageGridPiece(int x, int y, int w, int h) {
    if (x < 0 || y < 0 || x >= this.gridX || y >= this.gridY) {
      global.log("DImg: getImageGridPiece coordinate out of range");
      return createImage(1, 1, RGB);
    }
    if (w < 1 || h < 1 || x + w > this.gridX || y + h > this.gridY) {
      global.log("DImg: getImageGridPiece coordinate out of range");
      return createImage(1, 1, RGB);
    }
    return this.getImagePiece(x * this.img.width / this.gridX, y * this.img.height / this.gridY,
      w * this.img.width / this.gridX, h * this.img.height / this.gridY);
  }

  // convolution
   public void convolution(float[][] matrix) {
    if (matrix.length % 2 != 1 || matrix[0].length % 2 != 1) {
      global.log("DImg: convolution matrix invalid size.");
      return;
    }
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        float r_total = 0;
        float g_total = 0;
        float b_total = 0;
        for (int i_offset = 0; i_offset < matrix[0].length; i_offset++) {
          for (int j_offset = 0; j_offset < matrix.length; j_offset++) {
            int i_corrected = constrain(i + i_offset - matrix[0].length / 2, 0, this.img.height);
            int j_corrected = constrain(j + j_offset - matrix.length / 2, 0, this.img.width);
            int index_offset = constrain(i_corrected * this.img.width + j_corrected, 0, this.img.pixels.length - 1);
            float factor = matrix[i_offset][j_offset];
            r_total += factor * (this.img.pixels[index_offset] >> 16 & 0xFF);
            g_total += factor * (this.img.pixels[index_offset] >> 8 & 0xFF);
            b_total += factor * (this.img.pixels[index_offset] & 0xFF);
          }
        }
        r_total = constrain(r_total, 0, 255);
        g_total = constrain(g_total, 0, 255);
        b_total = constrain(b_total, 0, 255);
        this.img.pixels[index] = color(r_total, g_total, b_total);
      }
    }
    this.img.updatePixels();
  }
   public void blur() {
    this.convolution(new float[][]{{1.0f/9, 1.0f/9, 1.0f/9}, {1.0f/9, 1.0f/9, 1.0f/9}, {1.0f/9, 1.0f/9, 1.0f/9}});
  }
   public void sharpen() {
    this.convolution(new float[][]{{-1, -1, -1}, {-1, 9, -1}, {-1, -1, -1}});
  }

  // Brighten
   public void brighten(float factor) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        int c = this.img.pixels[index];
        float r = constrain((c >> 16 & 0xFF) * factor, 0, 255);
        float g = constrain((c >> 8 & 0xFF) * factor, 0, 255);
        float b = constrain((c & 0xFF) * factor, 0, 255);
        float a = alpha(c);
        this.img.pixels[index] = color(r, g, b, a);
      }
    }
    this.img.updatePixels();
  }

   public void brightenGradient(float factor, float gradientDistance, float x, float y) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        float distance = sqrt((i - y) * (i - y) + (j - x) * (j - x));
        float curr_factor = factor;
        if (distance < gradientDistance) {
          curr_factor = 1 + (factor - 1) * distance / gradientDistance;
        }
        int c = this.img.pixels[index];
        float r = constrain((c >> 16 & 0xFF) * curr_factor, 0, 255);
        float g = constrain((c >> 8 & 0xFF) * curr_factor, 0, 255);
        float b = constrain((c & 0xFF) * curr_factor, 0, 255);
        int col = ccolor(round(r), round(g), round(b), 255);
        this.img.pixels[index] = col;
      }
    }
    this.img.updatePixels();
  }

  // transparent
   public void makeTransparent() {
    this.makeTransparent(1);
  }
   public void makeTransparent(int alpha) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        float r = this.img.pixels[index] >> 16 & 0xFF;
        float g = this.img.pixels[index] >> 8 & 0xFF;
        float b = this.img.pixels[index] & 0xFF;
        this.img.pixels[index] = ccolor(round(r), round(g), round(b), alpha);
      }
    }
    this.img.updatePixels();
  }
   public void transparencyGradientFromPoint(float x, float y, float distance) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        float r = this.img.pixels[index] >> 16 & 0xFF;
        float g = this.img.pixels[index] >> 8 & 0xFF;
        float b = this.img.pixels[index] & 0xFF;
        float curr_distance = sqrt((i - y) * (i - y) + (j - x) * (j - x));
        float alpha = 255;
        if (curr_distance < distance) {
          alpha = 255 * curr_distance / distance;
        }
        this.img.pixels[index] = ccolor(r, g, b, alpha);
      }
    }
    this.img.updatePixels();
  }

  // color pixels
   public void colorPixels(int c) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        this.img.pixels[index] = c;
      }
    }
    this.img.updatePixels();
  }

   public void colorPixel(int x, int y, int c) {
    this.img.loadPixels();
    int index = x + y * this.img.width;
    if (index < 1 || index >= this.img.pixels.length) {
      return;
    }
    this.img.pixels[index] = c;
    this.img.updatePixels();
  }
}


 public PImage createPImage(int c, int w, int h) {
  DImg dimg = new DImg(w, h);
  dimg.colorPixels(c);
  return dimg.img;
}


 public int ccolor(int gray) {
  return ccolor(gray, gray, gray, 255);
}
 public int ccolor(int gray, int a) {
  return ccolor(gray, gray, gray, a);
}
 public int ccolor(int r, int g, int b) {
  return ccolor(r, g, b, 255);
}
 public int ccolor(float r, float g, float b, float a) {
  return ccolor(round(r), round(g), round(b), round(a));
}
 public int ccolor(int r, int g, int b, int a) {
  return (a << 24) | (r << 16) | (g << 8) | b;
}


// resize image using nearest-neighbor interpolation
 public PImage resizeImage(PImage img, int w, int h) {
  if (w <= 0 || h <= 0) {
    return createImage(1, 1, ARGB);
  }
  float scaling_width = img.width / PApplet.parseFloat(w);
  float scaling_height = img.height / PApplet.parseFloat(h);
  PImage return_image = createImage(w, h, ARGB);
  return_image.loadPixels();
  for (int i = 0; i < h; i++) {
    int imgY = round(floor(scaling_height * i + 0.5f));
    for (int j = 0; j < w; j++) {
      int imgX = round(floor(scaling_width * j + 0.5f)); // must floor to avoid artifacts
      int index = i * w + j;
      int img_index = imgY * img.width + imgX;
      try {
        return_image.pixels[index] = img.pixels[img_index];
      } catch(Exception e) {}
    }
  }
  return_image.updatePixels();
  return return_image;
}
enum Element {
  GRAY("Gray"), BLUE("Blue"), RED("Red"), CYAN("Cyan"), ORANGE("Orange"),
    BROWN("Brown"), PURPLE("Purple"), YELLOW("Yellow"), MAGENTA("Magenta");

  private static final List<Element> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String element_name;
  private Element(String element_name) {
    this.element_name = element_name;
  }
  public String element_name() {
    return this.element_name;
  }
  public static String element_name(Element element) {
    return element.element_name();
  }

  public static Element element(String element_name) {
    for (Element element : Element.VALUES) {
      if (element.element_name().equals(element_name)) {
        return element;
      }
    }
    return Element.GRAY;
  }

  public float resistanceFactorTo(Element element) {
    return Element.resistanceFactorTo(this, element);
  }
  public static float resistanceFactorTo(Element target, Element source) {
    switch(target) {
      case BLUE:
        switch(source) {
          case BLUE:
            return Constants.resistance_blue_blue;
          case RED:
            return Constants.resistance_blue_red;
          case BROWN:
            return Constants.resistance_blue_brown;
          default:
            return Constants.resistance_default;
        }
      case RED:
        switch(source) {
          case RED:
            return Constants.resistance_red_red;
          case CYAN:
            return Constants.resistance_red_cyan;
          case BLUE:
            return Constants.resistance_red_blue;
          default:
            return Constants.resistance_default;
        }
      case CYAN:
        switch(source) {
          case CYAN:
            return Constants.resistance_cyan_cyan;
          case ORANGE:
            return Constants.resistance_cyan_orange;
          case RED:
            return Constants.resistance_cyan_red;
          default:
            return Constants.resistance_default;
        }
      case ORANGE:
        switch(source) {
          case ORANGE:
            return Constants.resistance_orange_orange;
          case BROWN:
            return Constants.resistance_orange_brown;
          case CYAN:
            return Constants.resistance_orange_cyan;
          default:
            return Constants.resistance_default;
        }
      case BROWN:
        switch(source) {
          case BROWN:
            return Constants.resistance_brown_brown;
          case BLUE:
            return Constants.resistance_brown_blue;
          case ORANGE:
            return Constants.resistance_brown_orange;
          default:
            return Constants.resistance_default;
        }
      case PURPLE:
        switch(source) {
          case PURPLE:
            return Constants.resistance_purple_purple;
          case YELLOW:
            return Constants.resistance_purple_yellow;
          case MAGENTA:
            return Constants.resistance_purple_magenta;
          default:
            return Constants.resistance_default;
        }
      case YELLOW:
        switch(source) {
          case YELLOW:
            return Constants.resistance_yellow_yellow;
          case MAGENTA:
            return Constants.resistance_yellow_magenta;
          case PURPLE:
            return Constants.resistance_yellow_purple;
          default:
            return Constants.resistance_default;
        }
      case MAGENTA:
        switch(source) {
          case MAGENTA:
            return Constants.resistance_magenta_magenta;
          case PURPLE:
            return Constants.resistance_magenta_purple;
          case YELLOW:
            return Constants.resistance_magenta_yellow;
          default:
            return Constants.resistance_default;
        }
      default:
        return Constants.resistance_default;
    }
  }
}
abstract class Button {
  // state
  protected boolean hidden = false;
  protected boolean disabled = false;
  protected boolean hovered = false;
  protected boolean clicked = false;
  protected boolean button_focused = false;
  // colors
  protected int color_disabled = ccolor(220, 180);
  protected int color_default = ccolor(220);
  protected int color_hover = ccolor(170);
  protected int color_click = ccolor(120);
  protected int color_text = ccolor(0);
  protected int color_stroke = ccolor(0);
  protected int color_focused = ccolor(170, 180);
  // config
  protected String message = "";
  protected boolean show_message = false;
  protected float text_size = 14;
  protected boolean show_stroke = true;
  protected float stroke_weight = 0.5f;
  protected boolean stay_dehovered = false;
  protected boolean adjust_for_text_descent = false;
  protected boolean hover_check_after_release = true;
  protected boolean use_time_elapsed = false;
  protected boolean force_left_button = true;
  // timer
  protected int hold_timer = 0;
  protected int lastUpdateTime = millis();

  Button() {
  }

   public void disable() {
    this.disabled = true;
    this.hovered = false;
    this.clicked = false;
    this.button_focused = false;
  }

   public void setColors(int c_dis, int c_def, int c_hov, int c_cli, int c_tex) {
    this.color_disabled = c_dis;
    this.color_default = c_def;
    this.color_hover = c_hov;
    this.color_click = c_cli;
    this.color_text = c_tex;
  }

   public void setStroke(int c_str, float stroke_weight) {
    this.color_stroke = c_str;
    this.stroke_weight = stroke_weight;
    this.show_stroke = true;
  }
   public void noStroke() {
    this.show_stroke = false;
  }

   public int fillColor() {
    if (this.disabled) {
      return this.color_disabled;
    }
    else if (this.clicked) {
      return this.color_click;
    }
    else if (this.hovered) {
      return this.color_hover;
    }
    else {
      return this.color_default;
    }
  }

   public void setFill() {
    fill(this.fillColor());
    stroke(this.color_stroke);
    if (this.show_stroke) {
      if (this.button_focused) {
        strokeWeight(2 * this.stroke_weight);
      }
      else {
        strokeWeight(this.stroke_weight);
      }
    }
    else {
      if (this.button_focused) {
        strokeWeight(0.8f * this.stroke_weight);
      }
      else {
        strokeWeight(0.0001f);
        noStroke();
      }
    }
  }

   public void writeText() {
    if (!this.show_message) {
      return;
    }
    fill(this.color_text);
    textAlign(CENTER, CENTER);
    textSize(this.text_size);
    if (this.adjust_for_text_descent) {
      text(this.message, this.xCenter(), this.yCenter() - textDescent());
    }
    else {
      text(this.message, this.xCenter(), this.yCenter());
    }
  }


   public void stayDehovered() {
    this.stay_dehovered = true;
    this.hovered = false;
  }

   public void update(int millis) {
    if (!this.hidden) {
      drawButton();
      if (this.clicked) {
        if (this.use_time_elapsed) {
          this.hold_timer += millis;
        }
        else {
          this.hold_timer += millis - this.lastUpdateTime;
        }
      }
    }
    if (!this.use_time_elapsed) {
      this.lastUpdateTime = millis;
    }
  }

   public void mouseMove(float mX, float mY) {
    if (this.disabled) {
      return;
    }
    boolean prev_hover = this.hovered;
    this.hovered = this.mouseOn(mX, mY);
    if (this.stay_dehovered) {
      if (this.hovered) {
        this.hovered = false;
      }
      else {
        this.stay_dehovered = false;
      }
    }
    if (prev_hover && !this.hovered) {
      this.dehover();
    }
    else if (!prev_hover && this.hovered) {
      this.hover();
    }
  }

   public void mousePress() {
    if (this.disabled) {
      return;
    }
    if (this.force_left_button && mouseButton != LEFT) {
      return;
    }
    if (this.hovered) {
      this.clicked = true;
      this.click();
    }
    else {
      this.clicked = false;
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.disabled) {
      return;
    }
    if (this.force_left_button && mouseButton != LEFT) {
      return;
    }
    if (this.clicked) {
      this.clicked = false;
      this.hold_timer = 0;
      this.release();
    }
    this.clicked = false;
    if (this.hover_check_after_release) {
      this.mouseMove(mX, mY);
    }
  }

   public void keyPress() {
    if (key == CODED) {
    }
    else {
      switch(key) {
        case RETURN:
        case ENTER:
          if (this.button_focused) {
            this.clicked = true;
            this.click();
          }
          break;
      }
    }
  }

   public void keyRelease() {
    if (key == CODED) {
    }
    else {
      switch(key) {
        case RETURN:
        case ENTER:
          if (this.button_focused) {
            if (this.clicked) {
              this.clicked = false;
              this.hold_timer = 0;
              this.release();
            }
          }
          break;
      }
    }
  }

   public abstract float xCenter();
   public abstract float yCenter();
   public abstract float button_width();
   public abstract float button_height();
   public abstract void drawButton();
   public abstract void moveButton(float xMove, float yMove);
   public abstract boolean mouseOn(float mX, float mY);
   public abstract void hover();
   public abstract void dehover();
   public abstract void click();
   public abstract void release();
}



abstract class RectangleButton extends Button {
  protected float xi;
  protected float yi;
  protected float xf;
  protected float yf;
  protected int roundness = 8;
  protected float xCenter;
  protected float yCenter;
  protected boolean raised_border = false;
  protected boolean raised_body = false;
  protected boolean shadow = false;
  protected float shadow_amount = 5;

  RectangleButton(float xi, float yi, float xf, float yf) {
    super();
    this.setLocation(xi, yi, xf, yf);
  }

   public float xCenter() {
    return this.xCenter;
  }

   public float yCenter() {
    return this.yCenter;
  }

   public float button_width() {
    return this.xf - this.xi;
  }

   public float button_height() {
    return this.yf - this.yi;
  }

   public void drawButton() {
    rectMode(CORNERS);
    if (this.shadow) {
      fill(ccolor(0, 180));
      rect(this.xi + this.shadow_amount, this.yi + this.shadow_amount,
        this.xf + this.shadow_amount, this.yf + this.shadow_amount, this.roundness);
    }
    this.setFill();
    if (this.shadow && this.clicked && !this.disabled) {
      translate(this.shadow_amount, this.shadow_amount);
    }
    if (this.raised_body && !this.disabled) {
      fill(ccolor(255, 0));
      rect(this.xi, this.yi, this.xf, this.yf, this.roundness);
      stroke(ccolor(255, 0));
      if (this.clicked) {
        fill(darken(this.fillColor()));
        rect(this.xi, this.yi, this.xf, this.yCenter());
        fill(brighten(this.fillColor()));
        rect(this.xi, this.yCenter(), this.xf, this.yf);
      }
      else {
        fill(brighten(this.fillColor()));
        rect(this.xi, this.yi, this.xf, this.yCenter(), this.roundness);
        fill(darken(this.fillColor()));
        rect(this.xi, this.yCenter(), this.xf, this.yf, this.roundness);
      }
    }
    else {
      rect(this.xi, this.yi, this.xf, this.yf, this.roundness);
    }
    this.writeText();
    if (this.shadow && this.clicked && !this.disabled) {
      translate(-this.shadow_amount, -this.shadow_amount);
    }
    if (this.raised_border && !this.disabled) {
      strokeWeight(1);
      if (this.clicked) {
        stroke(ccolor(0));
        line(this.xi, this.yi, this.xf, this.yi);
        line(this.xi, this.yi, this.xi, this.yf);
        stroke(ccolor(255));
        line(this.xf, this.yf, this.xf, this.yi);
        line(this.xf, this.yf, this.xi, this.yf);
      }
      else {
        stroke(ccolor(255));
        line(this.xi, this.yi, this.xf, this.yi);
        line(this.xi, this.yi, this.xi, this.yf);
        stroke(ccolor(0));
        line(this.xf, this.yf, this.xf, this.yi);
        line(this.xf, this.yf, this.xi, this.yf);
      }
    }
    if (this.button_focused) {
      noFill();
      strokeWeight(this.stroke_weight);
      stroke(this.color_stroke);
      rect(this.xi + 0.1f * this.button_width(), this.yi + 0.1f * this.button_height(),
        this.xf - 0.1f * this.button_width(), this.yf - 0.1f * this.button_height(), this.roundness);
    }
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.xCenter = this.xi + 0.5f * (this.xf - this.xi);
    this.yCenter = this.yi + 0.5f * (this.yf - this.yi);
  }
   public void setXLocation(float xi, float xf) {
    this.setLocation(xi, this.yi, xf, this.yf);
  }
   public void setYLocation(float yi, float yf) {
    this.setLocation(this.xi, yi, this.xf, yf);
  }

   public void moveButton(float xMove, float yMove) {
    this.xi += xMove;
    this.yi += yMove;
    this.xf += xMove;
    this.yf += yMove;
    this.xCenter = this.xi + 0.5f * (this.xf - this.xi);
    this.yCenter = this.yi + 0.5f * (this.yf - this.yi);
  }

   public void stretchButton(float amount, int direction) {
    switch(direction) {
      case UP:
        this.setLocation(this.xi, this.yi - amount, this.xf, this.yf);
        break;
      case DOWN:
        this.setLocation(this.xi, this.yi, this.xf, this.yf + amount);
        break;
      case LEFT:
        this.setLocation(this.xi - amount, this.yi, this.xf, this.yf);
        break;
      case RIGHT:
        this.setLocation(this.xi, this.yi, this.xf + amount, this.yf);
        break;
      default:
        break;
    }
  }

   public boolean mouseOn(float mX, float mY) {
    if (mX >= this.xi && mY >= this.yi &&
      mX <= this.xf && mY <= this.yf) {
      return true;
    }
    return false;
  }
}


abstract class CheckBox extends RectangleButton {
  protected boolean checked = false;
  protected int color_check = ccolor(0);
  protected float offset = 0;

  CheckBox(float xi, float yi, float size) {
    this(xi, yi, xi + size, xi + size);
  }
  CheckBox(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
    this.setColors(color(170, 170), ccolor(170, 0), ccolor(170, 50), ccolor(170, 120), ccolor(0));
    this.roundness = 0;
    this.stroke_weight = 2;
  }

  @Override public 
  void setLocation(float xi, float yi, float xf, float yf) {
    super.setLocation(xi, yi, xf, yf);
    this.offset = 0.1f * (xf  - xi);
  }

  @Override public 
  void drawButton() {
    super.drawButton();
    if (this.checked) {
      strokeWeight(this.stroke_weight);
      stroke(this.color_stroke);
      line(this.xi + offset, this.yi + offset, this.xf - offset, this.yf - offset);
      line(this.xi + offset, this.yf - offset, this.xf - offset, this.yi + offset);
    }
  }

   public void click() {
    this.checked = !this.checked;
  }
}


abstract class ImageButton extends RectangleButton {
  protected PImage img;
  protected int color_tint = ccolor(255);
  protected boolean overshadow_colors = false;

  ImageButton(PImage img, float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
    this.img = img;
  }

  @Override public 
  void drawButton() {
    tint(this.color_tint);
    imageMode(CORNERS);
    image(this.img, this.xi, this.yi, this.xf, this.yf);
    noTint();
    this.writeText();
    if (this.overshadow_colors) {
      fill(this.fillColor());
      stroke(this.fillColor());
      rectMode(CORNERS);
      rect(this.xi, this.yi, this.xf, this.yf);
    }
  }

   public void setImg(PImage img) {
    this.img = img;
    this.img.resize(PApplet.parseInt(this.button_width()), PApplet.parseInt(this.button_height()));
  }
}


abstract class ToggleButton extends ImageButton {
  protected int toggle_index = 0;
  protected boolean click_toggle = true;
  protected PImage[] images;

  ToggleButton(PImage[] images, float xi, float yi, float xf, float yf) {
    super(images[0], xi, yi, xf, yf);
    this.images = images;
  }

   public void setToggle(int toggle_index) {
    this.toggle_index = toggle_index;
    if (this.toggle_index < 0) {
      this.toggle_index = 0;
    }
    if (this.toggle_index >= this.images.length) {
      this.toggle_index = this.images.length - 1;
    }
  }

   public void toggle() {
    this.toggle_index++;
    if (this.toggle_index >= this.images.length) {
      this.toggle_index = 0;
    }
    this.setImg(this.images[this.toggle_index]);
  }

   public void click() {
    if (this.click_toggle) {
      this.toggle();
    }
  }

   public void release() {
    if (!this.hovered || this.click_toggle) {
      return;
    }
    this.toggle();
  }
}


abstract class RippleRectangleButton extends ImageButton {
  class Pixel {
    private int x;
    private int y;
    private float x_pixel;
    private float y_pixel;
    Pixel(int x, int y, float x_pixel, float y_pixel) {
      this.x = x;
      this.y = y;
      this.x_pixel = x_pixel;
      this.y_pixel = y_pixel;
    }
     public float distance(float mX, float mY) {
      return sqrt((mX - this.x_pixel) * (mX - this.x_pixel) +
        (mY - this.y_pixel) * (mY - this.y_pixel));
    }
  }

  protected int rippleTime = 250;
  protected int rippleTimer = 0;
  protected int number_buckets = 50;
  protected HashMap<Integer, ArrayList<Pixel>> buckets;
  protected float last_mX = 0;
  protected float last_mY = 0;
  protected float clickX = 0;
  protected float clickY = 0;
  protected float maxRippleDistance;

  RippleRectangleButton(float xi, float yi, float xf, float yf) {
    super(createImage(PApplet.parseInt(xf - xi), PApplet.parseInt(yf - yi), ARGB), xi, yi, xf, yf);
    this.refreshColor();
    this.maxRippleDistance = max(this.button_width(), this.button_height());
  }

  @Override public 
  void setLocation(float xi, float yi, float xf, float yf) {
    super.setLocation(xi, yi, xf, yf);
    this.maxRippleDistance = max(this.button_width(), this.button_height());
    if (this.button_width() > 0 && this.button_height() > 0) {
      this.setImg(createImage(PApplet.parseInt(xf - xi), PApplet.parseInt(yf - yi), ARGB));
      this.refreshColor();
    }
  }

  @Override public 
  void update(int millis) {
    int timeElapsed = millis - this.lastUpdateTime;
    if (this.use_time_elapsed) {
      timeElapsed = millis;
    }
    super.update(millis);
    if (this.rippleTimer > 0) {
      this.rippleTimer -= timeElapsed;
      if (this.rippleTimer <= 0) {
        this.refreshColor();
      }
      else {
        this.colorPixels();
      }
    }
  }

   public void refreshColor() {
    DImg dimg = new DImg(this.img);
    dimg.colorPixels(this.fillColor());
    this.img = dimg.img;
    this.rippleTimer = 0;
  }

   public void initializeRipple() {
    this.buckets = new HashMap<Integer, ArrayList<Pixel>>();
    for (int i = 0; i < this.number_buckets; i++) {
      this.buckets.put(i, new ArrayList<Pixel>());
    }
    float keyMultiplier = PApplet.parseFloat(this.rippleTime) / this.number_buckets;
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        float x = this.xi + this.button_width() * j / this.img.width;
        float y = this.yi + this.button_height() * i / this.img.height;
        Pixel p = new Pixel(j, i, x, y);
        float distance = p.distance(this.clickX, this.clickY);
        int timer = PApplet.parseInt(floor(this.rippleTime * (1 - distance / this.maxRippleDistance) / keyMultiplier));
        if (this.buckets.containsKey(timer)) {
          this.buckets.get(timer).add(p);
        }
      }
    }
    this.rippleTimer = this.rippleTime;
  }

   public void colorPixels() {
    DImg dimg = new DImg(this.img);
    float currDistance = this.maxRippleDistance * (this.rippleTime - this.rippleTimer) / this.rippleTime;
    float keyMultiplier = PApplet.parseFloat(this.rippleTime) / this.number_buckets;
    for (Map.Entry<Integer, ArrayList<Pixel>> entry : this.buckets.entrySet()) {
      if (entry.getKey() * keyMultiplier > this.rippleTimer) {
        for (Pixel p : entry.getValue()) {
          dimg.colorPixel(p.x, p.y, this.color_click);
        }
        entry.getValue().clear();
      }
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.last_mX = mX;
    this.last_mY = mY;
    super.mouseMove(mX, mY);
  }

   public void hover() {
    this.refreshColor();
  }

   public void dehover() {
    this.refreshColor();
  }

   public void click() {
    this.clickX = this.last_mX;
    this.clickY = this.last_mY;
    this.initializeRipple();
  }

   public void release() {
    this.refreshColor();
  }
}


abstract class IconButton extends RippleRectangleButton {
  protected int background_color = ccolor(255);
  protected PImage icon;
  protected float icon_width = 0;

  IconButton(float xi, float yi, float xf, float yf, PImage icon) {
    super(xi, yi, xf, yf);
    this.icon = icon;
    this.icon_width = yf - yi;
  }

  @Override public 
  void setLocation(float xi, float yi, float xf, float yf) {
    super.setLocation(xi, yi, xf, yf);
    this.icon_width = yf - yi;
  }

  @Override public 
  void update(int millis) {
    rectMode(CORNERS);
    if (this.show_stroke) {
      stroke(this.color_stroke);
      strokeWeight(this.stroke_weight);
    }
    else {
      noStroke();
    }
    fill(this.background_color);
    rect(this.xi, this.yi, this.xf, this.yf);
    imageMode(CORNER);
    image(this.icon, this.xi, this.yi, this.icon_width, this.icon_width);
    super.update(millis);
  }

  @Override public 
  void writeText() {
    if (this.show_message) {
      fill(this.color_text);
      textAlign(LEFT, CENTER);
      textSize(this.text_size);
      if (this.adjust_for_text_descent) {
        text(this.message, this.xi + this.icon_width + 1, this.yCenter() - textDescent());
      }
      else {
        text(this.message, this.xi + this.icon_width + 1, this.yCenter());
      }
    }
  }
}


abstract class IconInverseButton extends IconButton {
  IconInverseButton(float xi, float yi, float xf, float yf, PImage icon) {
    super(xi, yi, xf, yf, icon);
  }

  @Override public 
  void update(int millis) {
    super.update(millis);
    imageMode(CORNER);
    image(this.icon, this.xi, this.yi, this.icon_width, this.icon_width);
    if (this.disabled) {
      rectMode(CORNERS);
      if (this.show_stroke) {
        stroke(this.color_stroke);
        strokeWeight(this.stroke_weight);
      }
      else {
        noStroke();
      }
      fill(this.background_color);
      rect(this.xi, this.yi, this.xf, this.yf);
    }
  }
}


abstract class RippleCircleButton extends RippleRectangleButton {
  private ArrayList<Pixel> transparentPixels = new ArrayList<Pixel>();

  RippleCircleButton(float xc, float yc, float r) {
    super(xc - r, yc - r, xc + r, yc + r);
    this.findTransparentPixels();
    this.refreshColor();
  }

  @Override public 
  void setLocation(float xi, float yi, float xf, float yf) {
    super.setLocation(xi, yi, xf, yf);
    this.findTransparentPixels();
  }

   public void findTransparentPixels() {
    this.transparentPixels = new ArrayList<Pixel>();
    float r = 0.5f * (this.xf - this.xi);
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        float distance = sqrt((r - i) * (r - i) + (r - j) * (r - j));
        if (distance > r) {
          this.transparentPixels.add(new Pixel(j, i, 0, 0));
        }
      }
    }
  }

   public void colorTransparentPixels() {
    if (this.transparentPixels == null) {
      return;
    }
    this.img.loadPixels();
    for (Pixel p : this.transparentPixels) {
      int index = p.x + p.y * this.img.width;
      try {
        this.img.pixels[index] = ccolor(1, 0);
      } catch(ArrayIndexOutOfBoundsException e) {}
    }
    this.img.updatePixels();
  }

  @Override public 
  void refreshColor() {
    super.refreshColor();
    this.colorTransparentPixels();
  }

  @Override public 
  void colorPixels() {
    super.colorPixels();
    this.colorTransparentPixels();
  }
}




abstract class EllipseButton extends Button {
  protected float xc;
  protected float yc;
  protected float xr;
  protected float yr;

  EllipseButton(float xc, float yc, float xr, float yr) {
    super();
    this.xc = xc;
    this.yc = yc;
    this.xr = xr;
    this.yr = yr;
  }

   public float xCenter() {
    return this.xc;
  }

   public float yCenter() {
    return this.yc;
  }

   public float button_width() {
    return 2 * this.xr;
  }

   public float button_height() {
    return 2 * this.yr;
  }

   public void drawButton() {
    this.setFill();
    ellipseMode(RADIUS);
    ellipse(this.xc, this.yc, this.xr, this.yr);
    this.writeText();
    if (this.button_focused) {
      noFill();
      strokeWeight(this.stroke_weight);
      stroke(this.color_stroke);
      ellipse(this.xc + 0.1f * this.xr, this.yc + 0.1f * this.yr,
        this.xr - 0.1f * this.xr, this.yr - 0.1f * this.yr);
    }
  }

   public void setLocation(float xc, float yc, float xr, float yr) {
    this.xc = xc;
    this.yc = yc;
    this.xr = xr;
    this.yr = yr;
  }

   public void moveButton(float xMove, float yMove) {
    this.xc += xMove;
    this.yc += yMove;
  }

   public boolean mouseOn(float mX, float mY) {
    if (this.xr == 0 || this.yr == 0) {
      return false;
    }
    float xRatio = (mX - this.xc) / this.xr;
    float yRatio = (mY - this.yc) / this.yr;
    if (xRatio * xRatio + yRatio * yRatio <= 1) {
      return true;
    }
    return false;
  }
}



abstract class CircleButton extends EllipseButton {
  CircleButton(float xc, float yc, float r) {
    super(xc, yc, r, r);
  }
   public float radius() {
    return this.xr;
  }

   public void setLocation(float xc, float yc, float radius) {
    super.setLocation(xc, yc, radius, radius);
  }
}



abstract class RadioButton extends CircleButton {
  protected boolean checked = false;
  protected int color_active = ccolor(0);

  RadioButton(float xc, float yc, float r) {
    super(xc, yc, r);
    this.setColors(color(170, 120), ccolor(170, 0), ccolor(170, 40), ccolor(170, 80), ccolor(0));
  }

  @Override public 
  void drawButton() {
    super.drawButton();
    if (this.checked) {
      fill(this.color_active);
      ellipseMode(RADIUS);
      circle(this.xCenter(), this.yCenter(), 0.6f * this.radius());
    }
    if (this.clicked) {
      fill(this.color_active, 135);
      ellipseMode(RADIUS);
      circle(this.xCenter(), this.yCenter(), 1.4f * this.radius());
    }
  }

   public void click() {
    this.checked = !this.checked;
  }
}




abstract class TriangleButton extends Button {
  protected float x1;
  protected float y1;
  protected float x2;
  protected float y2;
  protected float x3;
  protected float y3;
  protected float dotvv;
  protected float dotuu;
  protected float dotvu;
  protected float constant;
  protected float xCenter;
  protected float yCenter;

  TriangleButton(float x1, float y1, float x2, float y2, float x3, float y3) {
    super();
    this.setLocation(x1, y1, x2, y2, x3, y3);
  }

   public void setLocation(float x1, float y1, float x2, float y2, float x3, float y3) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.x3 = x3;
    this.y3 = y3;
    this.dotvv = (x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1);
    this.dotuu = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    this.dotvu = (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1);
    this.constant = this.dotvv * this.dotuu - this.dotvu * this.dotvu;
    this.xCenter = (x1 + x2 + x3) / 3.0f;
    this.yCenter = (y1 + y2 + y3) / 3.0f;
  }

   public float xCenter() {
    return this.xCenter;
  }

   public float yCenter() {
    return this.yCenter;
  }

   public float button_width() {
    return max(this.x1, this.x2, this.x3) - min(this.x1, this.x2, this.x3);
  }

   public float button_height() {
    return max(this.y1, this.y2, this.y3) - min(this.y1, this.y2, this.y3);
  }

   public void drawButton() {
    this.setFill();
    triangle(this.x1, this.y1, this.x2, this.y2, this.x3, this.y3);
    this.writeText();
  }

   public void moveButton(float xMove, float yMove) {
    this.x1 += xMove;
    this.y1 += yMove;
    this.x2 += xMove;
    this.y2 += yMove;
    this.x3 += xMove;
    this.y3 += yMove;
  }

   public boolean mouseOn(float mX, float mY) {
    float dotvp = (this.x3 - this.x1) * (mX - this.x1) + (this.y3 - this.y1) * (mY - this.y1);
    float dotup = (this.x2 - this.y1) * (mX - this.x1) + (this.y2 - this.y1) * (mY - this.y1);
    if (this.constant == 0) {
      return false;
    }
    float t1 = (this.dotuu * dotvp - this.dotvu * dotup) / this.constant;
    float t2 = (this.dotvv * dotup - this.dotvu * dotvp) / this.constant;
    if (t1 >= 0 && t2 >= 0 && t1 + t2 < 1) {
      return true;
    }
    return false;
  }
}




abstract class ArcButton extends Button {
  class TestButton extends TriangleButton {
    TestButton(float x1, float y1, float x2, float y2, float x3, float y3) {
      super(x1, y1, x2, y2, x3, y3);
    }
     public void hover() {}
     public void dehover() {}
     public void click() {}
     public void release() {}
  }

  protected float xc;
  protected float yc;
  protected float xr;
  protected float yr;
  protected float start;
  protected float stop;
  protected boolean pie = true; // false for open arc
  protected float xStart;
  protected float xStop;
  protected float yStart;
  protected float yStop;

  ArcButton(float xc, float yc, float xr, float yr, float start, float stop) {
    super();
    this.setLocation(xc, yc, xr, yr, start, stop);
  }

   public void setLocation(float xc, float yc, float xr, float yr, float start, float stop) {
    this.xc = xc;
    this.yc = yc;
    this.xr = xr;
    this.yr = yr;
    this.start = start;
    this.stop = stop;
    // fix angles if not in range [0, TWO_PI]
    this.xStart = cos(this.start);
    this.xStop = cos(this.stop);
    this.yStart = sin(this.start);
    this.yStop = sin(this.stop);
  }

   public float xCenter() {
    return this.xc;
  }

   public float yCenter() {
    return this.yc;
  }

   public float button_width() {
    return 2 * this.xr;
  }

   public float button_height() {
    return 2 * this.yr;
  }

   public void drawButton() {
    this.setFill();
    ellipseMode(RADIUS);
    if (this.pie) {
      arc(this.xc, this.yc, this.xr, this.yr, this.start, this.stop, PIE);
    }
    else {
      arc(this.xc, this.yc, this.xr, this.yr, this.start, this.stop, CHORD);
    }
    this.writeText();
  }

   public void moveButton(float xMove, float yMove) {
    this.xc += xMove;
    this.yc += yMove;
  }

   public boolean mouseOn(float mX, float mY) {
    if (this.xr == 0 || this.yr == 0) {
      return false;
    }
    // in ellipse
    float xRatio = (mX - this.xc) / this.xr;
    float yRatio = (mY - this.yc) / this.yr;
    float hypotenuse = xRatio * xRatio + yRatio * yRatio;
    if (hypotenuse > 1) {
      return false;
    }
    hypotenuse = sqrt(hypotenuse);
    // in arc
    float angle = asin(yRatio / hypotenuse);
    if (xRatio < 0) { // Q2 or Q3
      angle = PI - angle;
    }
    else if (yRatio < 0) { // Q4
      angle += TWO_PI;
    }
    if (angle > this.start && angle < this.stop) {
      if (this.pie) {
        return true;
      }
      else {
        TestButton excludedArea = new TestButton(0, 0, this.xStart, this.yStart, this.xStop, this.yStop);
        if (!excludedArea.mouseOn(xRatio, yRatio)) {
          return true;
        }
      }
    }
    return false;
  }
}




// shaped like the 'Find Match' button in League
abstract class LeagueButton extends ArcButton {
  protected float trapezoid_height;
  protected float trapezoid_shift;
  protected float trapezoid_xi;
  protected float trapezoid_xf;
  protected float trapezoid_bottom;
  protected PVector[] vertices = new PVector[4]; // trapezoid vertices

  LeagueButton(float xBottom, float yBottom, float xRadius, float yRadius, float radians, float trapezoid_height, float trapezoid_shift) {
    super(xBottom, yBottom - yRadius, xRadius, yRadius, HALF_PI - 0.5f * radians, HALF_PI + 0.5f * radians);
    this.pie = false;
    this.trapezoid_height = trapezoid_height;
    this.trapezoid_shift = trapezoid_shift;
    this.trapezoid_xi = xStop * this.xr + this.xc;
    this.trapezoid_xf = xStart * this.xr + this.xc;
    this.trapezoid_bottom = yStop * this.yr + this.yc;
    this.vertices[0] = new PVector(this.trapezoid_xi, this.trapezoid_bottom);
    this.vertices[1] = new PVector(this.trapezoid_xi + this.trapezoid_shift, this.trapezoid_bottom - this.trapezoid_height);
    this.vertices[2] = new PVector(this.trapezoid_xf - this.trapezoid_shift, this.trapezoid_bottom - this.trapezoid_height);
    this.vertices[3] = new PVector(this.trapezoid_xf, this.trapezoid_bottom);
  }

  @Override public 
  void drawButton() {
    this.setFill();
    ellipseMode(RADIUS);
    arc(this.xc, this.yc, this.xr, this.yr, this.start, this.stop, OPEN);
    beginShape();
    for (PVector p : this.vertices) {
      vertex(p.x, p.y);
    }
    endShape();
    stroke(this.fillColor());
    strokeWeight(1);
    line(this.trapezoid_xi+2, this.trapezoid_bottom-1, this.trapezoid_xf-2, this.trapezoid_bottom-1);
    if (this.show_message) {
      fill(this.color_text);
      textSize(this.text_size);
      textAlign(CENTER, BOTTOM);
      text(this.message, this.xc, this.trapezoid_bottom);
    }
  }

   public boolean mouseOn(float mX, float mY) {
    boolean collision = false;
    for (int i = 0; i < this.vertices.length; i++) {
      PVector p1 = this.vertices[i];
      PVector p2;
      if (i + 1 == this.vertices.length) {
        p2 = this.vertices[0];
      }
      else {
        p2 = this.vertices[i + 1];
      }
      if ( ((p1.y > mY) != (p2.y > mY)) && (mX < (p2.x - p1.x) * (mY - p1.y) / (p2.y - p1.y) + p1.x) ) {
        collision = !collision;
      }
    }
    if (collision) {
      return true;
    }
    if (super.mouseOn(mX, mY)) {
      return true;
    }
    return false;
  }
}






class ScrollBar {
  abstract class ScrollBarButton extends RectangleButton {
    protected int time_hold = 350;
    protected int time_click = 80;
    protected boolean held = false;

    ScrollBarButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
      this.raised_border = true;
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      if (this.clicked) {
        if (this.held) {
          if (this.hold_timer > this.time_click) {
            this.hold_timer -= this.time_click;
            this.click();
          }
        }
        else {
          if (this.hold_timer > this.time_hold) {
            this.hold_timer -= this.time_hold;
            this.held = true;
            this.click();
          }
        }
      }
    }

     public void hover() {
    }
     public void dehover() {
    }
     public void release() {
      this.held = false;
    }
  }

  class ScrollBarUpButton extends ScrollBarButton {
    float arrowWidth = 0;
    float arrowRatio = 0.1f;
    float cushionRatio = 1.5f;
    ScrollBarUpButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      refreshArrowWidth();
      this.raised_border = true;
    }
    @Override public 
    void setLocation(float xi, float yi, float xf, float yf) {
      super.setLocation(xi, yi, xf, yf);
      this.refreshArrowWidth();
    }
     public void refreshArrowWidth() {
      if (ScrollBar.this.vertical) {
        this.arrowWidth = this.arrowRatio * this.button_height();
      }
      else {
        this.arrowWidth = this.arrowRatio * this.button_width();
      }
    }
    @Override public 
    void drawButton() {
      super.drawButton();
      stroke(ccolor(0));
      strokeWeight(this.arrowWidth);
      if (ScrollBar.this.vertical) {
        line(this.xi + this.cushionRatio * this.arrowWidth, this.yf - this.cushionRatio * this.arrowWidth,
          this.xCenter(), this.yi + this.cushionRatio * this.arrowWidth);
        line(this.xf - this.cushionRatio * this.arrowWidth, this.yf - this.cushionRatio * this.arrowWidth,
          this.xCenter(), this.yi + this.cushionRatio * this.arrowWidth);
      }
      else {
        line(this.xf - this.cushionRatio * this.arrowWidth, this.yi + this.cushionRatio * this.arrowWidth,
          this.xi + this.cushionRatio * this.arrowWidth, this.yCenter());
        line(this.xf - this.cushionRatio * this.arrowWidth, this.yf - this.cushionRatio * this.arrowWidth,
          this.xi + this.cushionRatio * this.arrowWidth, this.yCenter());
      }
    }
    @Override public 
    void dehover() {
      this.clicked = false;
    }
     public void click() {
      ScrollBar.this.decreaseValue(1);
    }
  }

  class ScrollBarDownButton extends ScrollBarButton {
    float arrowWidth = 0;
    float arrowRatio = 0.1f;
    float cushionRatio = 1.5f;
    ScrollBarDownButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      refreshArrowWidth();
      this.raised_border = true;
    }
    @Override public 
    void setLocation(float xi, float yi, float xf, float yf) {
      super.setLocation(xi, yi, xf, yf);
      this.refreshArrowWidth();
    }
     public void refreshArrowWidth() {
      if (ScrollBar.this.vertical) {
        this.arrowWidth = this.arrowRatio * this.button_height();
      }
      else {
        this.arrowWidth = this.arrowRatio * this.button_width();
      }
    }
    @Override public 
    void drawButton() {
      super.drawButton();
      stroke(ccolor(0));
      strokeWeight(this.arrowWidth);
      if (ScrollBar.this.vertical) {
        line(this.xi + this.cushionRatio * this.arrowWidth, this.yi + this.cushionRatio * this.arrowWidth,
          this.xCenter(), this.yf - this.cushionRatio * this.arrowWidth);
        line(this.xf - this.cushionRatio * this.arrowWidth, this.yi + this.cushionRatio * this.arrowWidth,
          this.xCenter(), this.yf - this.cushionRatio * this.arrowWidth);
      }
      else {
        line(this.xi + this.cushionRatio * this.arrowWidth, this.yi + this.cushionRatio * this.arrowWidth,
          this.xf - this.cushionRatio * this.arrowWidth, this.yCenter());
        line(this.xi + this.cushionRatio * this.arrowWidth, this.yf - this.cushionRatio * this.arrowWidth,
          this.xf - this.cushionRatio * this.arrowWidth, this.yCenter());
      }
    }
    @Override public 
    void dehover() {
      this.clicked = false;
    }
     public void click() {
      ScrollBar.this.increaseValue(1);
    }
  }

  class ScrollBarUpSpaceButton extends ScrollBarButton {
    ScrollBarUpSpaceButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.setColors(color(180), ccolor(235), ccolor(235), ccolor(0), ccolor(0));
      this.raised_border = false;
    }
     public void click() {
      ScrollBar.this.decreaseValuePercent(0.1f);
    }
    @Override public 
    void release() {
      super.release();
      this.hovered = false;
    }
  }

  class ScrollBarDownSpaceButton extends ScrollBarButton {
    ScrollBarDownSpaceButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.setColors(color(180), ccolor(235), ccolor(235), ccolor(0), ccolor(0));
      this.raised_border = false;
    }
     public void click() {
      ScrollBar.this.increaseValuePercent(0.1f);
    }
    @Override public 
    void release() {
      super.release();
      this.hovered = false;
    }
  }

  class ScrollBarBarButton extends ScrollBarButton {
    protected float val = 0;
    protected float last_val = 0;
    ScrollBarBarButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
    }
    @Override public 
    void update(int millis) {
      if (!this.hidden) {
        drawButton();
      }
      if (this.clicked && ScrollBar.this.value_size != 0) {
        this.hold_timer += millis - this.lastUpdateTime;
      }
      this.lastUpdateTime = millis;
    }
    @Override public 
    void mouseMove(float mX, float mY) {
      super.mouseMove(mX, mY);
      if (ScrollBar.this.vertical) {
        this.last_val = mY;
      }
      else {
        this.last_val = mX;
      }
      if (this.clicked && ScrollBar.this.value_size != 0) {
        if (ScrollBar.this.vertical) {
          ScrollBar.this.increaseValue((mY - this.yi - this.val) / ScrollBar.this.value_size);
        }
        else {
          ScrollBar.this.increaseValue((mX - this.xi - this.val) / ScrollBar.this.value_size);
        }
      }
    }
     public void click() {
      if (ScrollBar.this.vertical) {
        this.val = this.last_val - this.yi;
      }
      else {
        this.val = this.last_val - this.xi;
      }
    }
  }

  protected ScrollBarUpButton button_up = new ScrollBarUpButton(0, 0, 0, 0);
  protected ScrollBarDownButton button_down = new ScrollBarDownButton(0, 0, 0, 0);
  protected ScrollBarUpSpaceButton button_upspace = new ScrollBarUpSpaceButton(0, 0, 0, 0);
  protected ScrollBarDownSpaceButton button_downspace = new ScrollBarDownSpaceButton(0, 0, 0, 0);
  protected ScrollBarBarButton button_bar = new ScrollBarBarButton(0, 0, 0, 0);

  protected float minValue = 0;
  protected float maxValue = 0;
  protected float value = 0;

  protected float xi;
  protected float yi;
  protected float xf;
  protected float yf;
  protected boolean vertical;
  protected float bar_size = 0;
  protected float min_size = 0;
  protected float value_size = 0;
  protected float step_size = 10; // constant

  ScrollBar(boolean vertical) {
    this(0, 0, 0, 0, vertical);
  }
  ScrollBar(float xi, float yi, float xf, float yf, boolean vertical) {
    this.vertical = vertical;
    this.setLocation(xi, yi, xf, yf);
  }

   public void setButtonColors(int c_dis, int c_def, int c_hov, int c_cli, int c_tex) {
    this.button_up.setColors(c_dis, c_def, c_hov, c_cli, c_tex);
    this.button_down.setColors(c_dis, c_def, c_hov, c_cli, c_tex);
    this.button_bar.setColors(c_dis, c_def, c_hov, c_cli, c_tex);
  }

   public void useElapsedTime() {
    this.button_up.use_time_elapsed = true;
    this.button_down.use_time_elapsed = true;
    this.button_upspace.use_time_elapsed = true;
    this.button_downspace.use_time_elapsed = true;
    this.button_bar.use_time_elapsed = true;
  }

   public void move(float xMove, float yMove) {
    this.xi += xMove;
    this.yi += yMove;
    this.xf += xMove;
    this.yf += yMove;
    this.button_up.moveButton(xMove, yMove);
    this.button_down.moveButton(xMove, yMove);
    this.button_upspace.moveButton(xMove, yMove);
    this.button_downspace.moveButton(xMove, yMove);
    this.button_bar.moveButton(xMove, yMove);
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    if (this.vertical) {
      this.bar_size = this.xf - this.xi;
      if (3 * this.bar_size > this.yf - this.yi) {
        this.bar_size = (this.yf - this.yi) / 3.0f;
        this.min_size = 0.5f * this.bar_size;
      }
      else {
        this.min_size = min(this.bar_size, (this.yf - this.yi) / 9.0f);
      }
      this.button_up.setLocation(this.xi, this.yi, this.xf, this.yi + this.bar_size);
      this.button_down.setLocation(this.xi, this.yf - this.bar_size, this.xf, this.yf);
    }
    else {
      this.bar_size = this.yf - this.yi;
      if (3 * this.bar_size > this.xf - this.xi) {
        this.bar_size = (this.xf - this.xi) / 3.0f;
        this.min_size = 0.5f * this.bar_size;
      }
      else {
        this.min_size = min(this.bar_size, (this.xf - this.xi) / 9.0f);
      }
      this.button_up.setLocation(this.xi, this.yi, this.xi + this.bar_size, this.yf);
      this.button_down.setLocation(this.xf - this.bar_size, this.yi, this.xf, this.yf);
    }
    this.refreshBarButtonSizes();
  }

   public void refreshBarButtonSizes() {
    float bar_height = 0;
    if (this.vertical) {
      bar_height = this.yf - this.yi - 2 * this.bar_size;
    }
    else {
      bar_height = this.xf - this.xi - 2 * this.bar_size;
    }
    float bar_button_size = max(this.min_size, bar_height - this.step_size * (this.maxValue - this.minValue));
    if (this.maxValue == this.minValue) {
      this.value_size = 0;
    }
    else {
      this.value_size = (bar_height - bar_button_size) / (this.maxValue - this.minValue);
    }
    this.refreshBarButtons();
  }

   public void refreshBarButtons() {
    if (this.vertical) {
      float cut_one = this.yi + this.bar_size + this.value_size * (this.value - this.minValue);
      float cut_two = this.yf - this.bar_size - this.value_size * (this.maxValue - this.value);
      this.button_upspace.setLocation(this.xi, this.yi + this.bar_size, this.xf, cut_one);
      this.button_downspace.setLocation(this.xi, cut_two, this.xf, this.yf - this.bar_size);
      this.button_bar.setLocation(this.xi, cut_one, this.xf, cut_two);
    }
    else {
      float cut_one = this.xi + this.bar_size + this.value_size * (this.value - this.minValue);
      float cut_two = this.xf - this.bar_size - this.value_size * (this.maxValue - this.value);
      this.button_upspace.setLocation(this.xi + this.bar_size, this.yi, cut_one, this.yf);
      this.button_downspace.setLocation(cut_two, this.yi, this.xf - this.bar_size, this.yf);
      this.button_bar.setLocation(cut_one, this.yi, cut_two, this.yf);
    }
  }

   public void updateMinValue(float minValue) {
    this.minValue = minValue;
    if (this.minValue > this.maxValue) {
      this.minValue = this.maxValue;
    }
    if (this.value < this.minValue) {
      this.value = this.minValue;
    }
    this.refreshBarButtonSizes();
  }
   public void increaseMinValue(float amount) {
    this.updateMinValue(this.minValue + amount);
  }
   public void decreaseMinValue(float amount) {
    this.updateMinValue(this.minValue - amount);
  }

   public void updateMaxValue(float maxValue) {
    this.maxValue = maxValue;
    if (this.maxValue < this.minValue) {
      this.maxValue = this.minValue;
    }
    if (this.value > this.maxValue) {
      this.value = this.maxValue;
    }
    this.refreshBarButtonSizes();
  }
   public void increaseMaxValue(float amount) {
    this.updateMaxValue(this.maxValue + amount);
  }
   public void decreaseMaxValue(float amount) {
    this.updateMaxValue(this.maxValue - amount);
  }

   public void updateValue(float value) {
    this.value = value;
    if (this.value < this.minValue) {
      this.value = this.minValue;
    }
    else if (this.value > this.maxValue) {
      this.value = this.maxValue;
    }
    this.refreshBarButtons();
  }
   public void scrollMax() {
    this.value = this.maxValue;
    this.refreshBarButtons();
  }
   public void scrollMin() {
    this.value = this.minValue;
    this.refreshBarButtons();
  }

   public void increaseValue(float amount) {
    this.updateValue(this.value + amount);
  }
   public void decreaseValue(float amount) {
    this.updateValue(this.value - amount);
  }
   public void increaseValuePercent(float percent) {
    this.updateValue(this.value + percent * (this.maxValue - this.minValue));
  }
   public void decreaseValuePercent(float percent) {
    this.updateValue(this.value - percent * (this.maxValue - this.minValue));
  }

   public void update(int millis) {
    this.button_up.update(millis);
    this.button_down.update(millis);
    this.button_upspace.update(millis);
    this.button_downspace.update(millis);
    this.button_bar.update(millis);
  }

   public void mouseMove(float mX, float mY) {
    this.button_up.mouseMove(mX, mY);
    this.button_down.mouseMove(mX, mY);
    this.button_upspace.mouseMove(mX, mY);
    this.button_downspace.mouseMove(mX, mY);
    this.button_bar.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.button_up.mousePress();
    this.button_down.mousePress();
    this.button_upspace.mousePress();
    this.button_downspace.mousePress();
    this.button_bar.mousePress();
  }

   public boolean clicked() {
    return (this.button_up.clicked || this.button_down.clicked ||
      this.button_upspace.clicked || this.button_downspace.clicked ||
      this.button_bar.clicked);
  }

   public void mouseRelease(float mX, float mY) {
    this.button_up.mouseRelease(mX, mY);
    this.button_down.mouseRelease(mX, mY);
    this.button_upspace.mouseRelease(mX, mY);
    this.button_downspace.mouseRelease(mX, mY);
    this.button_bar.mouseRelease(mX, mY);
  }
}



class TextBox {
  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;
  protected boolean hovered = false;
  protected int lastUpdateTime = 0;
  protected boolean use_time_elapsed = false;

  protected ScrollBar scrollbar = new ScrollBar(true);
  protected float scrollbar_max_width = 50;
  protected float scrollbar_min_width = 25;

  protected boolean wordWrap = true;
  protected ScrollBar scrollbar_horizontal;
  protected ArrayList<String> text_lines_display = new ArrayList<String>();

  protected String text_ref = "";
  protected ArrayList<String> text_lines = new ArrayList<String>();
  protected float text_size = 15;
  protected float text_leading = 0;

  protected String text_title_ref = null;
  protected String text_title = null;
  protected float title_size = 22;

  protected int color_background = ccolor(250);
  protected int color_header = ccolor(200);
  protected int color_stroke = ccolor(0);
  protected int color_text = ccolor(0);
  protected int color_title = ccolor(0);

  TextBox() {
    this(0, 0, 0, 0);
  }
  TextBox(float xi, float yi, float xf, float yf) {
    this.setLocation(xi, yi, xf, yf);
  }

   public void useElapsedTime() {
    this.scrollbar.useElapsedTime();
    if (this.scrollbar_horizontal != null) {
      this.scrollbar_horizontal.useElapsedTime();
    }
    this.use_time_elapsed = true;
  }

   public void setXLocation(float xi, float xf) {
    this.setLocation(xi, this.yi, xf, this.yf);
  }
   public void setYLocation(float yi, float yf) {
    this.setLocation(this.xi, yi, this.xf, yf);
  }
   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.refreshTitle();
  }

   public void setTextSize(float text_size) {
    this.text_size = text_size;
    this.refreshText();
  }

   public void setTitleSize(float title_size) {
    this.title_size = title_size;
    this.refreshTitle();
  }

   public void refreshTitle() {
    this.setTitleText(this.text_title_ref);
  }

   public void setTitleText(String title) {
    this.text_title_ref = title;
    float scrollbar_width = min(this.scrollbar_max_width, 0.05f * (this.xf - this.xi));
    scrollbar_width = max(this.scrollbar_min_width, scrollbar_width);
    scrollbar_width = min(0.05f * (this.xf - this.xi), scrollbar_width);
    if (title == null) {
      this.text_title = null;
      this.scrollbar.setLocation(xf - scrollbar_width, this.yi, this.xf, this.yf);
    }
    else {
      this.text_title = "";
      textSize(this.title_size);
      for (int i = 0; i < title.length(); i++) {
        char nextChar = title.charAt(i);
        if (textWidth(this.text_title + nextChar) < this.xf - this.xi - 3) {
          this.text_title += nextChar;
        }
        else {
          break;
        }
      }
      this.scrollbar.setLocation(this.xf - scrollbar_width, this.yi + 1 + textAscent() + textDescent(), this.xf, this.yf);
    }
    if (!this.wordWrap) {
      this.scrollbar_horizontal.setLocation(this.xi, this.yf - this.scrollbar.bar_size, this.xf - this.scrollbar.bar_size, this.yf);
    }
    this.refreshText();
  }

   public void setWordWrap(boolean wordWrap) {
    this.wordWrap = wordWrap;
    if (!wordWrap) {
      this.scrollbar_horizontal = new ScrollBar(false);
      this.scrollbar_horizontal.setLocation(this.xi, this.yf - this.scrollbar.bar_size, this.xf - this.scrollbar.bar_size, this.yf);
    }
    this.refreshText();
  }

   public void refreshText() {
    this.setText(this.text_ref);
  }

   public void clearText() {
    this.setText("");
  }

   public void addText(String text) {
    this.setText(this.text_ref + text);
  }

   public void setText(String text) {
    this.text_ref = text;
    this.text_lines.clear();
    this.text_lines_display.clear();
    float currY = this.yi + 1;
    if (this.text_title_ref != null) {
      textSize(this.title_size);
      currY += textAscent() + textDescent() + 2;
    }
    textSize(this.text_size);
    float text_height = textAscent() + textDescent();
    float effective_xf = this.xf - this.xi - 3 - this.scrollbar.bar_size;
    int lines_above = 0;
    String[] lines = split(text, '\n');
    String currLine = "";
    boolean firstWord = true;
    int max_line_length = 0;
    for (int i = 0; i < lines.length; i++) {
      if (this.wordWrap) {
        String[] words = split(lines[i], ' ');
        for (int j = 0; j < words.length; j++) {
          String word = " ";
          if (firstWord) {
            word = "";
          }
          word += words[j];
          if (textWidth(currLine + word) < effective_xf) {
            currLine += word;
            firstWord = false;
          }
          else if (firstWord) {
            for (int k = 0; k < word.length(); k++) {
              char nextChar = word.charAt(k);
              if (textWidth(currLine + nextChar) < effective_xf) {
                currLine += nextChar;
              }
              else {
                this.text_lines.add(currLine);
                currLine = "" + nextChar;
                firstWord = true;
                if (currY + text_height + 1 > this.yf) {
                  lines_above++;
                }
                currY += text_height + this.text_leading;
              }
            }
            firstWord = false;
          }
          else {
            this.text_lines.add(currLine);
            currLine = words[j];
            firstWord = false;
            if (currY + text_height + 1 > this.yf) {
              lines_above++;
            }
            currY += text_height + this.text_leading;
          }
        }
        this.text_lines.add(currLine);
        currLine = "";
        firstWord = true;
        if (currY + text_height + 1 > this.yf) {
          lines_above++;
        }
        currY += text_height + this.text_leading;
      }
      else {
        this.text_lines.add(lines[i]);
        for (int j = 0; j < lines[i].length(); j++) {
          char nextChar = lines[i].charAt(j);
          if (textWidth(currLine + nextChar) < effective_xf) {
            currLine += nextChar;
          }
          else {
            if (lines[i].length() - j > max_line_length) {
              max_line_length = lines[i].length() - j;
            }
            break;
          }
        }
        currLine = "";
        if (currY + text_height + 1 > this.yf) {
          lines_above++;
        }
        currY += text_height + this.text_leading;
      }
    }
    this.scrollbar.updateMaxValue(lines_above);
    if (!this.wordWrap) {
      this.scrollbar_horizontal.updateMaxValue(max_line_length);
    }
  }

   public String truncateLine(String line) {
    String return_line = "";
    float effective_xf = this.xf - this.xi - 3 - this.scrollbar.bar_size;
    for (int i = PApplet.parseInt(floor(this.scrollbar_horizontal.value)); i < line.length(); i++) {
      char nextChar = line.charAt(i);
      if (textWidth(return_line + nextChar) < effective_xf) {
        return_line += nextChar;
      }
      else {
        break;
      }
    }
    return return_line;
  }

   public void update(int millis) {
    rectMode(CORNERS);
    fill(this.color_background);
    stroke(this.color_stroke);
    strokeWeight(1);
    rect(this.xi, this.yi, this.xf, this.yf);
    float currY = this.yi + 1;
    if (this.text_title_ref != null) {
      fill(this.color_header);
      textSize(this.title_size);
      rect(this.xi, this.yi, this.xf, this.yi + textAscent() + textDescent() + 1);
      fill(this.color_title);
      textAlign(CENTER, TOP);
      text(this.text_title, this.xi + 0.5f * (this.xf - this.xi), currY);
      currY += textAscent() + textDescent() + 2;
    }
    fill(this.color_text);
    textAlign(LEFT, TOP);
    textSize(this.text_size);
    float text_height = textAscent() + textDescent();
    for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.text_lines.size(); i++, currY += text_height + this.text_leading) {
      if (currY + text_height + 1 > this.yf) {
        break;
      }
      if (this.wordWrap) {
        text(this.text_lines.get(i), this.xi + 2, currY);
      }
      else {
        text(this.truncateLine(this.text_lines.get(i)), this.xi + 2, currY);
      }
    }
    if (this.scrollbar.maxValue != this.scrollbar.minValue) {
      this.scrollbar.update(millis);
    }
    if (!this.wordWrap) {
      if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
        this.scrollbar_horizontal.update(millis);
      }
    }
    this.lastUpdateTime = millis;
  }

   public void mouseMove(float mX, float mY) {
    this.scrollbar.mouseMove(mX, mY);
    if (!this.wordWrap) {
      if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
        this.scrollbar_horizontal.mouseMove(mX, mY);
      }
    }
    if (mX >= this.xi && mX <= this.xf && mY >= this.yi && mY <= this.yf) {
      this.hovered = true;
    }
    else {
      this.hovered = false;
    }
  }

   public void mousePress() {
    this.scrollbar.mousePress();
    if (!this.wordWrap) {
      if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
        this.scrollbar_horizontal.mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    this.scrollbar.mouseRelease(mX, mY);
    if (!this.wordWrap) {
      if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
        this.scrollbar_horizontal.mouseRelease(mX, mY);
      }
    }
  }

   public void scroll(int amount) {
    if (this.hovered) {
      this.scrollbar.increaseValue(amount);
      if (!this.wordWrap && this.scrollbar.maxValue == this.scrollbar.minValue) {
        if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
          this.scrollbar_horizontal.increaseValue(amount);
        }
      }
    }
  }

   public void scrollBottom() {
    this.scrollbar.updateValue(this.scrollbar.maxValue);
  }

   public void keyPress() {
  }
}


abstract class ListTextBox extends TextBox {
  protected ArrayList<String> text_lines_ref;
  protected int line_hovered = -1;
  protected int line_clicked = -1;
  protected int hover_color = ccolor(180, 180, 200, 60);
  protected int highlight_color = ccolor(100, 100, 250, 120);
  protected int doubleclickTimer = 0;
  protected int doubleclickTime = 400;
  protected boolean can_unclick_outside_box = true;

  ListTextBox() {
    this(0, 0, 0, 0);
  }
  ListTextBox(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
  }

  @Override public 
  void clearText() {
    this.setText("");
    this.text_lines.clear();
  }

  @Override public 
  void setText(String text) {
    this.text_ref = text;
    this.text_lines.clear();
    this.text_lines_ref = new ArrayList<String>();
    float currY = this.yi + 1;
    if (this.text_title_ref != null) {
      textSize(this.title_size);
      currY += textAscent() + textDescent() + 2;
    }
    textSize(this.text_size);
    float text_height = textAscent() + textDescent();
    float effective_xf = this.xf - this.xi - 3 - this.scrollbar.bar_size;
    int lines_above = 0;
    String[] lines = split(text, '\n');
    for (String line : lines) {
      this.text_lines_ref.add(line);
      String currLine = "";
      for (int i = 0; i < line.length(); i++) {
        char nextChar = line.charAt(i);
        if (textWidth(currLine + nextChar) < effective_xf) {
          currLine += nextChar;
        }
        else {
          break;
        }
      }
      this.text_lines.add(currLine);
      if (currY + text_height + 1 > this.yf) {
        lines_above++;
      }
      currY += text_height + this.text_leading;
    }
    this.scrollbar.updateMaxValue(lines_above);
  }

   public void addLine(String line) {
    if (this.text_ref == null || this.text_ref.equals("")) {
      this.setText(line);
    }
    else {
      this.addText("\n" + line);
    }
  }

   public String highlightedLine() {
    if (this.line_clicked < 0 || this.line_clicked >= this.text_lines_ref.size()) {
      return null;
    }
    return this.text_lines_ref.get(this.line_clicked);
  }

  @Override public 
  void update(int millis) {
    int time_elapsed = millis - this.lastUpdateTime;
    if (this.use_time_elapsed) {
      time_elapsed = millis;
    }
    super.update(millis);
    if (this.doubleclickTimer > 0) {
      this.doubleclickTimer -= time_elapsed;
    }
    float currY = this.yi + 1;
    if (this.text_title_ref != null) {
      textSize(this.title_size);
      currY += textAscent() + textDescent() + 2;
    }
    textSize(this.text_size);
    float text_height = textAscent() + textDescent();
    if (this.line_hovered >= floor(this.scrollbar.value)) {
      float hovered_yi = currY + (this.line_hovered - floor(this.scrollbar.value)) * (text_height + this.text_leading);
      if (hovered_yi + text_height + 1 < this.yf) {
        rectMode(CORNERS);
        fill(this.hover_color);
        strokeWeight(0.001f);
        stroke(this.hover_color);
        rect(this.xi + 1, hovered_yi, this.xf - 2 - this.scrollbar.bar_size, hovered_yi + text_height);
      }
    }
    if (this.line_clicked >= floor(this.scrollbar.value)) {
      float clicked_yi = currY + (this.line_clicked - floor(this.scrollbar.value)) * (text_height + this.text_leading);
      if (clicked_yi + text_height + 1 < this.yf) {
        rectMode(CORNERS);
        fill(this.highlight_color);
        strokeWeight(0.001f);
        stroke(this.highlight_color);
        rect(this.xi + 1, clicked_yi, this.xf - 2 - this.scrollbar.bar_size, clicked_yi + text_height);
      }
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.scrollbar.mouseMove(mX, mY);
    if (mX > this.xi && mX < this.xf && mY > this.yi && mY < this.yf) {
      this.hovered = true;
      float currY = this.yi + 1;
      if (this.text_title_ref != null) {
        textSize(this.title_size);
        currY += textAscent() + textDescent() + 2;
      }
      textSize(this.text_size);
      float line_height = textAscent() + textDescent() + this.text_leading;
      int target_line = PApplet.parseInt(floor(this.scrollbar.value) + floor((mY - currY) / line_height));
      int lines_shown = this.text_lines.size() - PApplet.parseInt(this.scrollbar.maxValue);
      if (target_line < 0 || mX > (this.xf - this.scrollbar.bar_size) || target_line >= this.text_lines_ref.size() ||
        target_line - PApplet.parseInt(floor(this.scrollbar.value)) >= lines_shown) {
        this.line_hovered = -1;
      }
      else {
        this.line_hovered = target_line;
      }
    }
    else {
      this.hovered = false;
      this.line_hovered = -1;
    }
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    if (this.line_hovered > -1) {
      if (this.doubleclickTimer > 0  && this.line_clicked == this.line_hovered) {
        this.line_clicked = this.line_hovered;
        this.doubleclick();
        this.doubleclickTimer = 0;
      }
      else {
        this.line_clicked = this.line_hovered;
        this.click();
        this.doubleclickTimer = this.doubleclickTime;
      }
    }
    else if (this.can_unclick_outside_box || this.hovered) {
      this.line_clicked = this.line_hovered;
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    if (this.line_hovered < 0 && !this.scrollbar.clicked() && (this.can_unclick_outside_box || this.hovered)) {
      this.line_clicked = this.line_hovered;
    }
    super.mouseRelease(mX, mY);
  }

   public void jump_to_line() {
    this.jump_to_line(false);
  }
   public void jump_to_line(boolean hard_jump) {
    if (this.line_clicked < 0) {
      return;
    }
    if (hard_jump || this.line_clicked < PApplet.parseInt(floor(this.scrollbar.value))) {
      this.scrollbar.updateValue(this.line_clicked);
      return;
    }
    int lines_shown = this.text_lines.size() - PApplet.parseInt(this.scrollbar.maxValue);
    if (this.line_clicked >= PApplet.parseInt(this.scrollbar.value) + lines_shown) {
      this.scrollbar.increaseValue(1 + this.line_clicked - PApplet.parseInt(this.scrollbar.value) - lines_shown);
    }
    else if (this.line_clicked < PApplet.parseInt(this.scrollbar.value)) {
      this.scrollbar.decreaseValue(PApplet.parseInt(this.scrollbar.value) - this.line_clicked);
    }
  }

  @Override public 
  void keyPress() {
    if (!this.hovered) {
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case UP:
          if (this.line_clicked > 0) {
            this.line_clicked--;
            this.jump_to_line(false);
          }
          break;
        case DOWN:
          if (this.line_clicked < this.text_lines_ref.size() - 1) {
            this.line_clicked++;
            this.jump_to_line(false);
          }
          break;
        default:
          break;
      }
    }
  }

   public abstract void click(); // click on line
   public abstract void doubleclick(); // doubleclick on line
}


abstract class MaxListTextBox extends ListTextBox {
  protected float y_curr = 0;

  MaxListTextBox() {
    this(0, 0, 0, 0);
  }
  MaxListTextBox(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
  }

  @Override public 
  void setText(String text) {
    super.setText(text);
    float currY = this.yi + 3;
    if (this.text_title_ref != null) {
      textSize(this.title_size);
      currY += textAscent() + textDescent() + 2;
    }
    textSize(this.text_size);
    float text_height = textAscent() + textDescent();
    this.y_curr = min(this.yf, currY + this.text_lines_ref.size() * (text_height + this.text_leading));
  }

  @Override public 
  void update(int millis) {
    float y_max = this.yf;
    this.yf = y_curr;
    super.update(millis);
    this.yf = y_max;
  }
}


class DropDownList extends ListTextBox {
  protected boolean active = false;
  protected boolean show_highlight = false;
  protected String hint_text = "";

  DropDownList() {
    this(0, 0, 0, 0);
  }
  DropDownList(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
  }

  @Override public 
  void update(int millis) {
    if (this.active) {
      super.update(millis);
    }
    else {
      textAlign(LEFT, TOP);
      textSize(this.text_size);
      float text_height = textAscent() + textDescent();
      rectMode(CORNERS);
      fill(this.color_background);
      stroke(this.color_stroke);
      strokeWeight(1);
      rect(this.xi, this.yi, this.xf - 1 - this.scrollbar.bar_size, this.yi + 3 + text_height);
      if (this.line_clicked >= 0) {
        fill(this.color_text);
        text(this.text_lines.get(this.line_clicked), this.xi + 2, this.yi + 1);
      }
      else {
        fill(this.color_text, 150);
        text(this.hint_text, this.xi + 2, this.yi + 1);
      }
      if (this.show_highlight) {
        fill(this.highlight_color);
        strokeWeight(0.0001f);
        stroke(this.highlight_color);
        rect(this.xi + 1, this.yi + 1, this.xf - 2 - this.scrollbar.bar_size, this.yi + 1 + text_height);
      }
    }
  }

  @Override public 
  void mousePress() {
    if (this.active) {
      if (this.hovered) {
        int last_line_clicked = this.line_clicked;
        super.mousePress();
        this.line_clicked = last_line_clicked;
      }
      else {
        this.show_highlight = false;
        this.active = false;
      }
    }
    else {
      int last_line_clicked = this.line_clicked;
      super.mousePress();
      if (this.line_clicked == PApplet.parseInt(floor(this.scrollbar.value))) {
        if (this.show_highlight) {
          this.active = true;
          this.line_clicked = last_line_clicked;
          this.jump_to_line(true);
        }
        else {
          this.line_clicked = last_line_clicked;
          this.show_highlight = true;
        }
      }
      else {
        this.line_clicked = last_line_clicked;
        this.show_highlight = false;
      }
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    int last_line_clicked = this.line_clicked;
    super.mouseRelease(mX, mY);
    this.line_clicked = last_line_clicked;
  }

  @Override public 
  void keyPress() {
    if (!this.show_highlight && !this.active) {
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case UP:
          if (this.line_clicked > 0) {
            this.line_clicked--;
            this.jump_to_line(false);
          }
          break;
        case DOWN:
          if (this.line_clicked < this.text_lines_ref.size() - 1) {
            this.line_clicked++;
            this.jump_to_line(false);
          }
          break;
        default:
          break;
      }
    }
    else {
      switch(key) {
        case ENTER:
        case RETURN:
          if (this.active) {
            this.doubleclick();
          }
          else {
            this.active = true;
            this.jump_to_line(true);
          }
          break;
        case ESC:
          this.doubleclick();
          this.show_highlight = false;
          break;
        default:
          break;
      }
    }
  }

   public void click() {}

   public void doubleclick() {
    if (this.active) {
      this.active = false;
      this.show_highlight = true;
    }
  }
}




class InputBox extends RectangleButton {
  protected String text = "";
  protected String hint_text = "";
  protected int hint_color = ccolor(80);
  protected boolean typing = false;
  protected String display_text = "";

  protected int location_display = 0;
  protected int location_cursor = 0;

  protected float cursor_weight = 1;
  protected int cursor_blink_time = 450;
  protected int cursor_blink_timer = 0;
  protected boolean cursor_blinking = true;

  protected float lastMouseX = 0;

  InputBox(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
    this.roundness = 0;
    this.setColors(color(170), ccolor(220), ccolor(220), ccolor(255), ccolor(0));
  }

   public void refreshText() {
    this.setText(this.text);
  }
   public void setText(String text) {
    if (text == null) {
      text = "";
    }
    this.text = text;
    this.updateDisplayText();
    if (this.location_cursor > this.text.length()) {
      this.location_cursor = this.text.length();
    }
    if (this.location_cursor > this.location_display + this.display_text.length()) {
      this.location_display = this.location_cursor - this.display_text.length();
      this.updateDisplayText();
    }
  }

   public void setTextSize(float text_size) {
    this.text_size = text_size;
    this.refreshText();
  }

  @Override public 
  void setLocation(float xi, float yi, float xf, float yf) {
    super.setLocation(xi, yi, xf, yf);
    this.updateDisplayText();
  }

  @Override public 
  void stretchButton(float amount, int direction) {
    super.stretchButton(amount, direction);
    this.updateDisplayText();
  }

   public void updateDisplayText() {
    if (this.text == null) {
      this.text = "";
    }
    this.display_text = "";
    textSize(this.text_size);
    float maxWidth = this.xf - this.xi - 2 - textWidth(' ');
    boolean decreaseDisplayLocation = true;
    for (int i = this.location_display; i < this.text.length(); i++ ) {
      if (textWidth(this.display_text + this.text.charAt(i)) > maxWidth) {
        decreaseDisplayLocation = false;
        break;
      }
      this.display_text += this.text.charAt(i);
    }
    if (decreaseDisplayLocation && this.location_display <= this.text.length()) {
      while(this.location_display > 0 && textWidth(this.text.charAt(
        this.location_display - 1) + this.display_text) <= maxWidth) {
        this.location_display--;
        this.display_text = this.text.charAt(this.location_display) + this.display_text;
      }
    }
    // if say increased text size
    if (this.location_cursor - this.location_display > this.display_text.length()) {
      int dif = this.location_cursor - this.location_display - this.display_text.length();
      this.location_display += dif;
      int end_index = this.location_display + this.display_text.length();
      if (end_index > this.text.length()) {
        end_index = this.text.length();
      }
      if (this.location_display > this.text.length()) {
        this.location_display = this.text.length();
      }
      this.display_text = this.text.substring(this.location_display, end_index);
    }
  }

   public void resetBlink() {
    this.cursor_blinking = true;
    this.cursor_blink_timer = 0;
  }

  @Override public 
  int fillColor() {
    if (this.disabled) {
      return this.color_disabled;
    }
    else if (this.typing) {
      return this.color_click;
    }
    else {
      return this.color_default;
    }
  }

  @Override public 
  void drawButton() {
    super.drawButton();
    textAlign(LEFT, TOP);
    if (this.text.equals("")) {
      textSize(this.text_size - 2);
      fill(this.hint_color);
      text(this.hint_text, this.xi + 2, this.yi + 1);
    }
    else {
      textSize(this.text_size);
      fill(this.color_text);
      text(this.display_text, this.xi + 2, this.yi + 1);
    }
    if (this.typing && this.cursor_blinking) {
      strokeWeight(this.cursor_weight);
      fill(this.color_stroke);
      float x_cursor = this.xi + 2 + textWidth(this.display_text.substring(
        0, this.location_cursor - this.location_display));
      line(x_cursor, this.yi + 2, x_cursor, this.yf - 2);
    }
  }

  @Override public 
  void update(int millis) {
    int timeElapsed = millis - this.lastUpdateTime;
    super.update(millis);
    if (this.typing) {
      this.cursor_blink_timer += timeElapsed;
      if (this.cursor_blink_timer > this.cursor_blink_time) {
        this.cursor_blink_timer -= this.cursor_blink_time;
        this.cursor_blinking = !this.cursor_blinking;
      }
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.lastMouseX = mX;
    super.mouseMove(mX, mY);
  }

   public void dehover() {
  }

   public void hover() {
  }

  @Override public 
  void mousePress() {
    this.typing = false;
    super.mousePress();
  }
   public void click() {
    this.typing = true;
    this.resetBlink();
    textSize(this.text_size);
    String display_text_copy = this.display_text;
    while (display_text_copy.length() > 0 && this.lastMouseX < this.xi + 2 + textWidth(display_text_copy)) {
      display_text_copy = display_text_copy.substring(0, display_text_copy.length() - 1);
    }
    this.location_cursor = location_display + display_text_copy.length();
  }

   public void release() {
  }

   public void keyPress() {
    if (!this.typing) {
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.location_cursor--;
          if (this.location_cursor < 0) {
            this.location_cursor = 0;
          }
          else if (this.location_cursor < this.location_display) {
            this.location_display--;
            this.updateDisplayText();
          }
          break;
        case RIGHT:
          this.location_cursor++;
          if (this.location_cursor > this.text.length()) {
            this.location_cursor = this.text.length();
          }
          else if (this.location_cursor > this.location_display + this.display_text.length()) {
            this.location_display++;
            this.updateDisplayText();
          }
          break;
        case KeyEvent.VK_HOME:
          this.location_cursor = 0;
          this.location_display = 0;
          this.updateDisplayText();
          break;
        case KeyEvent.VK_END:
          this.location_cursor = this.text.length();
          this.location_display = this.text.length();
          this.updateDisplayText();
          break;
        default:
          break;
      }
    }
    else {
      switch(key) {
        case BACKSPACE:
          if (this.location_cursor > 0) {
            this.location_cursor--;
            if (this.location_cursor < this.location_display) {
              this.location_display--;
            }
            this.setText(this.text.substring(0, this.location_cursor) +
              this.text.substring(this.location_cursor + 1, this.text.length()));
          }
          break;
        case TAB:
          break;
        case ENTER:
        case RETURN:
          break;
        case ESC:
          this.typing = false;
          break;
        case DELETE:
          break;
        default:
          this.location_cursor++;
          if (this.location_cursor > this.location_display + this.display_text.length()) {
            this.location_display++;
          }
          this.setText(this.text.substring(0, this.location_cursor - 1) + key +
            this.text.substring(this.location_cursor - 1, this.text.length()));
          this.updateDisplayText();
          break;
      }
    }
    this.resetBlink();
  }

   public void keyRelease() {
    if (!this.typing) {
      return;
    }
    this.resetBlink();
  }
}




class Slider  {
  class SliderButton extends CircleButton {
    protected boolean active = false;
    protected float active_grow_factor = 1.3f;
    protected int active_color = ccolor(0, 50, 0);
    protected float lastX = 0;
    protected float changeFactor = 1;

    SliderButton() {
      super(0, 0, 0);
      this.setColors(color(170), ccolor(255, 0), ccolor(255, 0), ccolor(255, 0), ccolor(0));
      strokeWeight(2);
    }

    @Override public 
    float radius() {
      if (this.active) {
        return this.active_grow_factor * super.radius();
      }
      else {
        return super.radius();
      }
    }

     public int lineColor() {
      if (this.disabled) {
        return this.color_disabled;
      }
      else if (this.active) {
        return this.active_color;
      }
      return this.color_stroke;
    }

    @Override public 
    void drawButton() {
      ellipseMode(RADIUS);
      if (this.disabled) {
        fill(this.color_disabled);
      }
      else if (this.active) {
        fill(this.active_color);
      }
      else {
        noFill();
      }
      stroke(this.lineColor());
      strokeWeight(Slider.this.line_thickness);
      circle(this.xc, this.yc, this.radius());
    }

     public void mouseMove(float mX, float mY) {
      super.mouseMove(mX, mY);
      if (this.active && this.clicked) {
        this.moveButton(mX - this.lastX, 0);
        this.changeFactor = 1; // how much value actually changed (accounting for step_size)
        Slider.this.refreshValue();
        this.lastX += this.changeFactor * (mX - this.lastX);
      }
      else {
        this.lastX = mX;
      }
    }

     public void mousePress() {
      super.mousePress();
      if (!this.hovered) {
        this.active = false;
      }
    }

     public void scroll(int amount) {
      if (!this.active) {
        return;
      }
      Slider.this.step(amount);
    }

     public void keyPress() {
      if (!this.active) {
        return;
      }
      if (key == CODED) {
        switch(keyCode) {
          case LEFT:
            Slider.this.step(-1);
            break;
          case RIGHT:
            Slider.this.step(1);
            break;
          default:
            break;
        }
      }
    }

     public void hover() {}
     public void dehover() {}
     public void release() {}

     public void click() {
      this.active = true;
    }
  }

  protected float xi;
  protected float yi;
  protected float xf;
  protected float yf;
  protected float yCenter;

  protected float min_value = 0;
  protected float max_value = 0;
  protected float step_size = -1;
  protected boolean no_step = true;
  protected float value = 0;

  protected SliderButton button = new SliderButton();
  protected float offset;
  protected float line_thickness = 3;

  protected boolean hovered = false;

  protected String label = "";
  protected boolean show_label = false;
  protected boolean round_label = true;
  protected boolean only_label_ends = false;
  protected boolean show_label_in_middle = false;

  Slider() {
    this(0, 0, 0, 0);
  }
  Slider(float xi, float yi, float xf, float yf) {
    this.setLocation(xi, yi, xf, yf);
  }

   public void disable() {
    this.button.active = false;
    this.button.disabled = true;
  }

   public void enable() {
    this.button.disabled = false;
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.yCenter = yi + 0.5f * (yf - yi);
    this.button.setLocation(xi, this.yCenter, 0.5f * (yf - yi) / this.button.active_grow_factor);
    this.offset = this.button.xr * this.button.active_grow_factor;
    this.refreshButton();
  }

  // called when slider changes value or size (this never changes value)
   public void refreshButton() {
    if (this.min_value == this.max_value) {
      this.button.moveButton(this.xi + this.offset - this.button.xCenter(), 0);
      return;
    }
    float targetX = this.xi + this.offset + (this.xf - 2 * this.offset - this.xi) *
      (this.value - this.min_value) / (this.max_value - this.min_value);
    this.button.moveButton(targetX - this.button.xCenter(), 0);
  }

  // called when button changes value (this changes value so calls refreshButton)
   public void refreshValue() {
    float targetValue = this.min_value + (this.button.xCenter() - this.xi - this.offset)
      * (this.max_value - this.min_value) / (this.xf - 2 * this.offset - this.xi);
    boolean hitbound = false;
    if (targetValue >= this.max_value) {
      float change = targetValue - this.value;
      if (change > 0) {
        this.button.changeFactor = (this.max_value - this.value) / change;
      }
      targetValue = this.max_value;
      hitbound = true;
    }
    else if (targetValue <= this.min_value) {
      float change = targetValue - this.value;
      if (change < 0) {
        this.button.changeFactor = (this.min_value - this.value) / change;
      }
      targetValue = this.min_value;
      hitbound = true;
    }
    float change = targetValue - this.value;
    if (!this.no_step && !hitbound && this.step_size != 0 && change != 0) {
      float new_change = this.step_size * (round(change / this.step_size));
      this.button.changeFactor = new_change/change;
      change = new_change;
    }
    this.value += change;
    this.refreshButton();
  }

   public void bounds(float min, float max, float step) {
    if (min > max) {
      min = max;
    }
    this.min_value = min;
    this.max_value = max;
    this.step_size = step;
    if (this.value < min) {
      this.value = min;
    }
    else if (this.value > max) {
      this.value = max;
    }
    if (step > 0) {
      this.no_step = false;
    }
    else {
      this.no_step = true;
    }
  }

   public void step(int amount) {
    if (this.no_step) {
      this.value += 0.1f * (this.max_value - this.min_value) * amount;
    }
    else {
      this.value += this.step_size * amount;
    }
    if (this.value > this.max_value) {
      this.value = this.max_value;
    }
    else if (this.value < this.min_value) {
      this.value = this.min_value;
    }
    this.refreshButton();
  }

   public void setValue(float value) {
    this.value = value;
    if (this.value > this.max_value) {
      this.value = this.max_value;
    }
    else if (this.value < this.min_value) {
      this.value = this.min_value;
    }
    this.refreshButton();
  }

   public void update(int millis) {
    if (this.show_label) {
      textSize(this.button.yr);
      textAlign(CENTER, BOTTOM);
    }
    if (!this.no_step && this.max_value != this.min_value) {
      strokeWeight(0.5f * this.line_thickness);
      stroke(this.button.active_color);
      fill(this.button.active_color);
      boolean not_switched_color = true;
      boolean on_end = true;
      for (float i = this.min_value; i <= this.max_value; i += this.step_size) {
        if (i + this.step_size > this.max_value) {
          on_end = true;
        }
        float targetX = this.xi + this.offset + (this.xf - 2 * this.offset - this.xi) *
          (i - this.min_value) / (this.max_value - this.min_value);
        if (not_switched_color && targetX > this.button.xCenter()) {
          stroke(this.button.color_stroke);
          fill(this.button.color_stroke);
          not_switched_color = false;
        }
        if (this.show_label && (!this.only_label_ends || on_end)) {
          line(targetX, this.button.yc - 3, targetX, this.button.yc + this.button.yr - 1);
          String label_text = "";
          if (this.round_label) {
            if (on_end || this.show_label_in_middle) {
              label_text = round(i) + this.label;
            }
            else {
              label_text = Integer.toString(round(i));
            }
          }
          else {
            if (on_end || this.show_label_in_middle) {
              label_text = i + this.label;
            }
            else {
              label_text = Float.toString(i);
            }
          }
          text(label_text, targetX, this.button.yc);
        }
        else {
          line(targetX, this.button.yc - this.button.yr + 1, targetX, this.button.yc + this.button.yr - 1);
        }
        on_end = false;
      }
    }
    else if (this.show_label) {
      String label_min = "";
      String label_max = "";
      if (this.round_label) {
        label_min = round(this.min_value) + this.label;
        label_max = round(this.max_value) + this.label;
      }
      else {
        label_min = this.min_value + this.label;
        label_max = this.max_value + this.label;
      }
      fill(this.button.active_color);
      text(label_min, this.xi + this.offset, this.button.yc);
      fill(this.button.color_stroke);
      text(label_max, this.xf - this.offset, this.button.yc);
    }
    strokeWeight(this.line_thickness);
    stroke(this.button.active_color);
    line(min(this.xi + this.offset, this.button.xc - this.button.radius()),
      this.yCenter, this.button.xc - this.button.radius(), this.yCenter);
    stroke(this.button.color_stroke);
    line(this.button.xc + this.button.radius(), this.yCenter,
      max(this.xf - this.offset, this.button.xc + this.button.radius()), this.yCenter);
    this.button.update(millis);
  }

   public void mouseMove(float mX, float mY) {
    this.button.mouseMove(mX, mY);
    if (mX > this.xi && mY > this.yi && mX < this.xf && mY < this.yf) {
      this.hovered = true;
    }
    else {
      this.hovered = false;
    }
  }

   public void mousePress() {
    this.button.mousePress();
    if (this.hovered && !this.button.disabled) {
      this.button.active = true;
      this.button.clicked = true;
      this.button.moveButton(this.button.lastX - this.button.xCenter(), 0);
      Slider.this.refreshValue();
    }
  }

   public void mouseRelease(float mX, float mY) {
    this.button.mouseRelease(mX, mY);
  }

   public void scroll(int amount) {
    this.button.scroll(amount);
  }

   public void keyPress() {
    this.button.keyPress();
  }
}




enum FormFieldSubmit {
  NONE, SUBMIT, CANCEL, BUTTON;
}

abstract class FormField {
  protected String message;
  protected float field_width = 0;

  FormField(String message) {
    this.message = message;
  }

   public float getWidth() {
    return this.field_width;
  }
   public void setWidth(float new_width) {
    this.field_width = new_width;
    this.updateWidthDependencies();
  }

   public void setValue(int newValue) {
    this.setValue(Integer.toString(newValue));
  }
   public void setValue(float newValue) {
    this.setValue(Float.toString(newValue));
  }
   public void setValue(boolean newValue) {
    this.setValue(Boolean.toString(newValue));
  }

   public abstract void enable();
   public abstract void disable();

   public abstract boolean focusable();
   public abstract void focus();
   public abstract void defocus();
   public abstract boolean focused();

   public abstract void updateWidthDependencies();
   public abstract float getHeight();
   public abstract String getValue();
   public abstract void setValue(String newValue);
   public void setValueIfNotFocused(String newValue) {
    if (!this.focused()) {
      this.setValue(newValue);
    }
  }

   public abstract FormFieldSubmit update(int millis);
   public abstract void mouseMove(float mX, float mY);
   public abstract void mousePress();
   public abstract void mouseRelease(float mX, float mY);
   public abstract void keyPress();
   public abstract void keyRelease();
   public abstract void scroll(int amount);

   public abstract void submit();
}


// Spacer
class SpacerFormField extends FormField {
  protected float spacer_height;

  SpacerFormField(float spacer_height) {
    super("");
    this.spacer_height = spacer_height;
  }

   public void enable() {}
   public void disable() {}
   public void updateWidthDependencies() {}

   public boolean focusable() {
    return false;
  }
   public void focus() {}
   public void defocus() {}
   public boolean focused() {
    return false;
  }

   public float getHeight() {
    return this.spacer_height;
  }

   public String getValue() {
    return this.message;
  }
   public void setValue(String newValue) {
    this.message = newValue;
  }

   public FormFieldSubmit update(int millis) {
    return FormFieldSubmit.NONE;
  }
   public void mouseMove(float mX, float mY) {}
   public void mousePress() {}
   public void mouseRelease(float mX, float mY) {}
   public void scroll(int amount) {}
   public void keyPress() {}
   public void keyRelease() {}
   public void submit() {}
}


// One line message
class MessageFormField extends FormField {
  protected String display_message; // can be different if truncated
  protected float default_text_size = 22;
  protected float minimum_text_size = 8;
  protected float text_size = 0;
  protected int text_color = ccolor(0);
  protected int text_align = LEFT;
  protected float left_edge = 1;

  MessageFormField(String message) {
    this(message, LEFT);
  }
  MessageFormField(String message, int text_align) {
    super(message);
    this.display_message = message;
    this.text_align = text_align;
  }

   public void setTextSize(float new_text_size) {
    this.setTextSize(new_text_size, false);
  }
   public void setTextSize(float new_text_size, boolean force) {
    this.default_text_size = new_text_size;
    if (force) {
      this.minimum_text_size = new_text_size;
    }
    this.updateWidthDependencies();
  }

   public void enable() {}
   public void disable() {}

   public boolean focusable() {
    return false;
  }
   public void focus() {}
   public void defocus() {}
   public boolean focused() {
    return false;
  }

   public void updateWidthDependencies() {
    float max_width = this.field_width - 2;
    this.text_size = this.default_text_size;
    textSize(this.text_size);
    this.display_message = this.message;
    while(textWidth(this.display_message) > max_width) {
      this.text_size -= 0.2f;
      textSize(this.text_size);
      if (this.text_size < this.minimum_text_size) {
        this.text_size = this.minimum_text_size;
        textSize(this.text_size);
        String truncated_string = "";
        for (int i = 0 ; i < this.display_message.length(); i++) {
          char c = this.display_message.charAt(i);
          if (textWidth(truncated_string + c) <= max_width) {
            truncated_string += c;
          }
          else {
            this.display_message = truncated_string;
            break;
          }
        }
        break;
      }
    }
  }

   public float getHeight() {
    textSize(this.text_size);
    return textAscent() + textDescent() + 2;
  }

   public String getValue() {
    return this.message;
  }
   public void setValue(String newValue) {
    this.message = newValue;
    this.updateWidthDependencies();
  }

   public FormFieldSubmit update(int millis) {
    textSize(this.text_size);
    textAlign(this.text_align, TOP);
    fill(this.text_color);
    switch(this.text_align) {
      case RIGHT:
        text(this.display_message, this.field_width - 1, 1);
        break;
      case CENTER:
        text(this.display_message, 0.5f * this.field_width, 1);
        break;
      case LEFT:
      default:
        text(this.display_message, this.left_edge, 1);
        break;
    }
    return FormFieldSubmit.NONE;
  }

   public void mouseMove(float mX, float mY) {
  }

   public void mousePress() {}
   public void mouseRelease(float mX, float mY) {}
   public void scroll(int amount) {}
   public void keyPress() {}
   public void keyRelease() {}
   public void submit() {}
}


// Multi-line message
class TextBoxFormField extends FormField {
  protected TextBox textbox = new TextBox(0, 0, 0, 0);

  TextBoxFormField(String message, float box_height) {
    super(message);
    this.textbox.setText(message);
    this.textbox.setLocation(0, 0, 0, box_height);
    this.textbox.color_background = ccolor(255, 0);
    this.textbox.color_header = ccolor(255, 0);
    this.textbox.color_stroke = ccolor(255, 0);
  }

   public void enable() {}
   public void disable() {}

   public boolean focusable() {
    return false;
  }
   public void focus() {}
   public void defocus() {}
   public boolean focused() {
    return false;
  }

   public void updateWidthDependencies() {
    this.textbox.setLocation(0, 0, this.field_width, this.getHeight());
  }
   public float getHeight() {
    return this.textbox.yf - this.textbox.yi;
  }

   public String getValue() {
    return this.textbox.text_ref;
  }
   public void setValue(String newValue) {
    this.textbox.setText(newValue);
  }

   public FormFieldSubmit update(int millis) {
    this.textbox.update(millis);
    return FormFieldSubmit.NONE;
  }

   public void mouseMove(float mX, float mY) {
    this.textbox.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.textbox.mousePress();
  }

   public void mouseRelease(float mX, float mY) {
    this.textbox.mouseRelease(mX, mY);
  }

   public void scroll(int amount) {
    this.textbox.scroll(amount);
  }

   public void keyPress() {
    this.textbox.keyPress();
  }
   public void keyRelease() {}
   public void submit() {}
}


// String input
class StringFormField extends MessageFormField {
  protected InputBox input = new InputBox(0, 0, 0, 0);

  StringFormField(String message) {
    this(message, "");
  }
  StringFormField(String message, String hint) {
    super(message);
    if (hint != null) {
      this.input.hint_text = hint;
    }
  }

  @Override public 
  boolean focusable() {
    if (this.input.typing) {
      return false;
    }
    return true;
  }
  @Override public 
  void focus() {
    this.input.typing = true;
  }
  @Override public 
  void defocus() {
    this.input.typing = false;
  }
  @Override public 
  boolean focused() {
    return this.input.typing;
  }

   public void updateWidthDependencies() {
    float temp_field_width = this.field_width;
    this.field_width = 0.5f * this.field_width;
    super.updateWidthDependencies();
    this.field_width = temp_field_width;
    this.input.setTextSize(this.text_size);
    textSize(this.text_size);
    this.input.setLocation(textWidth(this.message), 0, this.field_width, textAscent() + textDescent() + 2);
  }

  @Override public 
  String getValue() {
    return this.input.text;
  }
  @Override public 
  void setValue(String newValue) {
    this.input.setText(newValue);
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    this.input.update(millis);
    return super.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.input.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    this.input.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    this.input.mouseRelease(mX, mY);
  }

  @Override public 
  void keyPress() {
    this.input.keyPress();
  }
  @Override public 
  void keyRelease() {
    this.input.keyRelease();
  }
}


class IntegerFormField extends StringFormField {
  protected int min_value = 0;
  protected int max_value = 0;

  IntegerFormField(String message) {
    this(message, "");
  }
  IntegerFormField(String message, String hint) {
    this(message, hint, Integer.MIN_VALUE + 1, Integer.MAX_VALUE - 1);
  }
  IntegerFormField(String message, int min, int max) {
    this(message, "", min, max);
  }
  IntegerFormField(String message, String hint, int min, int max) {
    super(message, hint);
    this.min_value = min;
    this.max_value = max;
  }

   public int validateInt(int value) {
    if (this.min_value == this.max_value) {
      return value;
    }
    if (value < this.min_value) {
      value = this.min_value;
    }
    else if (value > this.max_value) {
      value = this.max_value;
    }
    return value;
  }

  @Override public 
  String getValue() {
    int return_value = toInt(this.input.text);
    return_value = this.validateInt(return_value);
    return Integer.toString(return_value);
  }

   public void submit() {
    if (this.focused()) {
      return;
    }
    int value = this.validateInt(toInt(this.input.text));
    this.input.setText(Integer.toString(value));
  }
}


class FloatFormField extends StringFormField {
  protected float min_value = 0;
  protected float max_value = 0;

  FloatFormField(String message) {
    this(message, "");
  }
  FloatFormField(String message, String hint) {
    this(message, hint, 0, 0);
  }
  FloatFormField(String message, float min, float max) {
    this(message, "", min, max);
  }
  FloatFormField(String message, String hint, float min, float max) {
    super(message, hint);
    this.min_value = min;
    this.max_value = max;
  }

  @Override public 
  String getValue() {
    float return_value = toFloat(this.input.text);
    if (return_value < this.min_value) {
      return_value = this.min_value;
    }
    else if (return_value > this.max_value) {
      return_value = this.max_value;
    }
    return Float.toString(return_value);
  }

   public void submit() {
    if (this.focused()) {
      return;
    }
    float value = toFloat(this.input.text);
    if (value > this.max_value) {
      value = this.max_value;
    }
    else if (value < this.min_value) {
      value = this.min_value;
    }
    this.input.setText(Float.toString(value));
  }
}


class BooleanFormField extends StringFormField {
  BooleanFormField(String message) {
    this(message, "");
  }
  BooleanFormField(String message, String hint) {
    super(message, hint);
  }

   public void submit() {
    if (this.focused()) {
      return;
    }
    this.input.setText(Boolean.toString(toBoolean(this.input.text)));
  }
}


// Array of radio buttons
class RadiosFormField extends MessageFormField {
  class DefaultRadioButton extends RadioButton {
    DefaultRadioButton(String message) {
      super(0, 0, 0);
      this.message = message;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void release() {
    }
  }

  protected ArrayList<RadioButton> radios = new ArrayList<RadioButton>();
  protected float radio_padding = 6;
  protected int index_selected = -1;
  protected boolean message_first = false;

  RadiosFormField(String message) {
    super(message);
  }

   public void addRadio() {
    this.addRadio("");
  }
   public void addRadio(String message) {
    this.addRadio(new DefaultRadioButton(message));
  }
   public void addDisabledRadio(String message) {
    DefaultRadioButton radio = new DefaultRadioButton(message);
    radio.disabled = true;
    radio.color_text = ccolor(80);
    this.addRadio(radio);
  }
   public void addRadio(RadioButton radio) {
    this.radios.add(radio);
    this.updateWidthDependencies();
  }

  @Override public 
  void updateWidthDependencies() {
    super.updateWidthDependencies();
    float currY = super.getHeight() + this.radio_padding;
    textSize(this.text_size - 2);
    for (RadioButton radio : this.radios) {
      radio.text_size = this.text_size - 2;
      float radius = 0.5f * min(0.8f * (textAscent() + textDescent() + 2),
        abs(this.field_width - textWidth(radio.message) - 2 * this.radio_padding));
      float xc = radius + this.radio_padding;
      if (message_first) {
        xc += textWidth(radio.message) + this.radio_padding;
      }
      float yc = currY + 0.5f * (textAscent() + textDescent() + 2);
      radio.setLocation(xc, yc, radius);
      currY += textAscent() + textDescent() + 2 + this.radio_padding;
    }
  }

  @Override public 
  float getHeight() {
    float field_height = super.getHeight();
    field_height += this.radios.size() * this.radio_padding;
    boolean first = true;
    for (RadioButton radio : this.radios) {
      textSize(radio.text_size);
      field_height += textAscent() + textDescent() + 2;
    }
    return field_height;
  }

  @Override public 
  String getValue() {
    return Integer.toString(this.index_selected);
  }
  @Override public 
  void setValue(String newValue) {
    if (isInt(newValue)) {
      this.index_selected = toInt(newValue);
      this.uncheckOthers();
    }
  }
   public void setMessage(String message) {
    super.setValue(message);
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    FormFieldSubmit returnValue = super.update(millis);
    for (RadioButton radio : this.radios) {
      textSize(radio.text_size);
      textAlign(LEFT, TOP);
      fill(radio.color_text);
      if (this.message_first) {
        text(radio.message, this.radio_padding, radio.yCenter() - radio.radius() + 1);
      }
      else {
        text(radio.message, radio.button_width() + 2 * this.radio_padding, radio.yCenter() - radio.radius() + 1);
      }
      radio.update(millis);
    }
    return returnValue;
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    for (RadioButton radio : this.radios) {
      radio.mouseMove(mX, mY);
    }
  }

  @Override public 
  void mousePress() {
    for (int i = 0; i < this.radios.size(); i++) {
      RadioButton radio = this.radios.get(i);
      boolean pressed = radio.checked;
      radio.mousePress();
      if (!pressed && radio.checked) {
        this.index_selected = i;
        this.uncheckOthers();
      }
      else if (pressed && !radio.checked) {
        this.index_selected = -1;
        this.uncheckOthers();
      }
    }
  }

   public void uncheckOthers() {
    for (int i = 0; i < this.radios.size(); i++) {
      if (i == this.index_selected) {
        continue;
      }
      this.radios.get(i).checked = false;
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    for (RadioButton radio : this.radios) {
      radio.mouseRelease(mX, mY);
    }
  }
}


// Single checkbox
class CheckboxFormField extends MessageFormField {
  class DefaultCheckBox extends CheckBox {
    DefaultCheckBox() {
      super(0, 0, 0, 0);
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void release() {
    }
  }

  protected CheckBox checkbox = new DefaultCheckBox();

  CheckboxFormField(String message) {
    super(message);
  }

  @Override public 
  void updateWidthDependencies() {
    float temp_field_width = this.field_width;
    this.field_width = 0.75f * this.field_width;
    super.updateWidthDependencies();
    this.field_width = temp_field_width;
    textSize(this.text_size);
    float checkboxsize = min(0.8f * this.getHeight(), this.field_width - textWidth(this.message));
    float xi = textWidth(this.message);
    float yi = 0.5f * (this.getHeight() - checkboxsize);
    this.checkbox.setLocation(xi, yi, xi + checkboxsize, yi + checkboxsize);
  }

  @Override public 
  String getValue() {
    return Boolean.toString(this.checkbox.checked);
  }
  @Override public 
  void setValue(String newValue) {
    if (isBoolean(newValue)) {
      this.checkbox.checked = toBoolean(newValue);
    }
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    this.checkbox.update(millis);
    return super.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.checkbox.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    this.checkbox.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    this.checkbox.mouseRelease(mX, mY);
  }
}


class ToggleFormFieldInput {
  private String message;
  private PImage img;
  ToggleFormFieldInput(String message, PImage img) {
    this.message = message;
    this.img = img;
  }
}


// Toggle between discreet list of things
class ToggleFormField extends MessageFormField {
  class FormFieldToggleButton extends ToggleButton {
    FormFieldToggleButton(PImage[] images) {
      super(images, 0, 0, 0, 0);
      this.use_time_elapsed = true;
      this.overshadow_colors = true;
      this.setColors(color(170, 170), ccolor(1, 0), ccolor(100, 80), ccolor(200, 160), ccolor(0));
    }
    @Override public 
    void toggle() {
      super.toggle();
      ToggleFormField.this.toggle();
    }
     public void hover() {
    }
     public void dehover() {
    }
  }

  protected FormFieldToggleButton toggle;
  protected ArrayList<String> messages = new ArrayList<String>();

  ToggleFormField(ArrayList<ToggleFormFieldInput> message_to_images) {
    super("");
    PImage[] imgs = new PImage[message_to_images.size()];
    for (int i = 0; i < message_to_images.size(); i++) {
      this.messages.add(message_to_images.get(i).message);
      imgs[i] = message_to_images.get(i).img;
    }
    this.toggle = new FormFieldToggleButton(imgs);
    this.toggle();
  }

   public void toggle() {
    super.setValue(this.messages.get(this.toggle.toggle_index));
    this.updateWidthDependencies();
  }

  @Override public 
  void updateWidthDependencies() {
    float temp_field_width = this.field_width;
    this.field_width = 0.75f * this.field_width;
    super.updateWidthDependencies();
    this.field_width = temp_field_width;
    textSize(this.text_size);
    float togglesize = min(0.95f * this.getHeight(), this.field_width - textWidth(this.message) - 2);
    float xi = textWidth(this.message);
    float yi = 0.5f * (this.getHeight() - togglesize);
    this.toggle.setLocation(1, yi, togglesize, yi + togglesize);
    this.left_edge = 2 + togglesize;
  }

  @Override public 
  String getValue() {
    return Integer.toString(this.toggle.toggle_index);
  }
  @Override public 
  void setValue(String newValue) {
    if (isInt(newValue)) {
      this.toggle.setToggle(toInt(newValue));
      this.toggle();
    }
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    this.toggle.update(millis);
    return super.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.toggle.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    this.toggle.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    this.toggle.mouseRelease(mX, mY);
  }
}


// Slider
class SliderFormField extends MessageFormField {
  class DefaultCheckBox extends CheckBox {
    DefaultCheckBox() {
      super(0, 0, 0, 0);
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void release() {
    }
  }

  protected Slider slider = new Slider();
  protected CheckBox checkbox = null;
  protected float max_slider_height = 30;
  protected float threshhold = 0.2f;

  SliderFormField(String message, float max) {
    this(message, 0, max, -1);
  }
  SliderFormField(String message, float min, float max) {
    this(message, min, max, -1);
  }
  SliderFormField(String message, float min, float max, float step) {
    super(message);
    this.text_align = RIGHT;
    this.slider.bounds(min, max, step);
    this.slider.setValue(min);
  }

   public void addCheckbox(String message) {
    this.checkbox = new DefaultCheckBox();
    this.checkbox.message = message;
    this.updateWidthDependencies();
  }

   public void addLabel(String label, boolean round_label) {
    this.addLabel(label, round_label, this.slider.only_label_ends);
  }
   public void addLabel(String label, boolean round_label, boolean only_label_ends) {
    this.slider.show_label = true;
    this.slider.label = label;
    this.slider.round_label = round_label;
    this.slider.only_label_ends = only_label_ends;
  }

  @Override public 
  void disable() {
    this.slider.disable();
    if (this.checkbox != null) {
      this.checkbox.checked = true;
    }
  }
  @Override public 
  void enable() {
    this.slider.enable();
    if (this.checkbox != null) {
      this.checkbox.checked = false;
    }
  }

  @Override public 
  boolean focusable() {
    if (this.slider.button.active) {
      return false;
    }
    return true;
  }
  @Override public 
  void focus() {
    this.slider.button.active = true;
  }
  @Override public 
  void defocus() {
    this.slider.button.active = false;
  }
  @Override public 
  boolean focused() {
    return this.slider.button.active;
  }

  @Override public 
  void updateWidthDependencies() {
    float temp_field_width = this.field_width;
    this.field_width = this.threshhold * this.field_width;
    super.updateWidthDependencies();
    float buffer_width = 0.02f * this.field_width;
    this.field_width = temp_field_width;
    float sliderheight = min(this.getHeight(), this.max_slider_height);
    if (this.checkbox != null) {
      this.checkbox.text_size = 0.75f * this.text_size;
      textSize(this.checkbox.text_size);
      float checkboxsize = 0.8f * (textAscent() + textDescent() + 2);
      buffer_width += textWidth(this.checkbox.message) + 0.02f * this.field_width;
      float xi = this.threshhold * this.field_width + buffer_width;
      float yi = 0.5f * (this.getHeight() - checkboxsize);
      this.checkbox.setLocation(xi, yi, xi + checkboxsize, yi + checkboxsize);
      buffer_width += checkboxsize + 0.02f * this.field_width;
    }
    float xi = this.threshhold * this.field_width + buffer_width;
    float yi = 0.5f * (this.getHeight() - sliderheight);
    this.slider.setLocation(xi, yi, this.field_width, yi + sliderheight);
  }

  @Override public 
  String getValue() {
    if (this.checkbox != null && this.checkbox.checked) {
      return Float.toString(this.slider.value) + ":disabled";
    }
    return Float.toString(this.slider.value);
  }
  @Override public 
  void setValue(String newValue) {
    if (isFloat(newValue)) {
      this.slider.setValue(toFloat(newValue));
    }
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    this.slider.update(millis);
    float temp_field_width = this.field_width;
    this.field_width = this.threshhold * this.field_width;
    super.update(millis);
    this.field_width = temp_field_width;
    if (this.checkbox != null) {
      textSize(this.checkbox.text_size);
      fill(this.checkbox.color_text);
      textAlign(RIGHT, CENTER);
      text(this.checkbox.message, this.checkbox.xi - 1, this.checkbox.yCenter());
      this.checkbox.update(millis);
    }
    return FormFieldSubmit.NONE;
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.slider.mouseMove(mX, mY);
    if (this.checkbox != null) {
      this.checkbox.mouseMove(mX, mY);
    }
  }

  @Override public 
  void mousePress() {
    this.slider.mousePress();
    if (this.checkbox != null) {
      this.checkbox.mousePress();
      if (this.checkbox.checked) {
        this.disable();
      }
      else {
        this.enable();
      }
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    this.slider.mouseRelease(mX, mY);
    if (this.checkbox != null) {
      this.checkbox.mouseRelease(mX, mY);
    }
  }

  @Override public 
  void scroll(int amount) {
    this.slider.scroll(amount);
  }

  @Override public 
  void keyPress() {
    this.slider.keyPress();
  }
}


// Submit button (submits and cancels)
class SubmitFormField extends FormField {
  class SubmitButton extends RectangleButton {
    SubmitButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
      this.raised_body = true;
      this.raised_border = true;
      this.adjust_for_text_descent = true;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
      if (this.hovered || this.button_focused) {
        SubmitFormField.this.submitted = true;
      }
    }
  }

  protected RectangleButton button = new SubmitButton(0, 0, 0, 30);
  protected boolean submitted = false;
  protected boolean submit_button = true;
  protected boolean extend_width = false;
  protected boolean align_left = false;

  SubmitFormField(String message) {
    this(message, true);
  }
  SubmitFormField(String message, boolean submit_button) {
    super(message);
    this.button.message = message;
    this.button.show_message = true;
    this.submit_button = submit_button;
  }

   public void setButtonHeight(float new_height) {
    if (new_height < 0) {
      new_height = 0;
    }
    this.button.setYLocation(0, new_height);
  }

   public void disable() {
    this.button.disabled = true;
  }
   public void enable() {
    this.button.disabled = false;
  }

   public boolean focusable() {
    if (this.button.button_focused) {
      return false;
    }
    return true;
  }
   public void focus() {
    this.button.button_focused = true;
  }
   public void defocus() {
    this.button.button_focused = false;
  }
   public boolean focused() {
    return this.button.button_focused;
  }

   public void updateWidthDependencies() {
    textSize(this.button.text_size);
    float desiredWidth = textWidth(this.button.message) + textWidth("  ");
    if (desiredWidth > this.field_width || this.extend_width) {
      this.button.setXLocation(0, this.field_width);
    }
    else if (this.align_left) {
      this.button.setXLocation(4, desiredWidth + 4);
    }
    else {
      this.button.setXLocation(0.5f * (this.field_width - desiredWidth),
        0.5f * (this.field_width + desiredWidth));
    }
  }

   public float getHeight() {
    return this.button.yf - this.button.yi;
  }

   public String getValue() {
    return this.message;
  }
  @Override public 
  void setValue(String newValue) {
    if (isBoolean(newValue)) {
      this.submit_button = toBoolean(newValue);
    }
  }

   public FormFieldSubmit update(int millis) {
    this.button.update(millis);
    if (this.submitted) {
      this.submitted = false;
      if (this.submit_button) {
        return FormFieldSubmit.SUBMIT;
      }
      else {
        return FormFieldSubmit.CANCEL;
      }
    }
    return FormFieldSubmit.NONE;
  }

   public void mouseMove(float mX, float mY) {
    this.button.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.button.mousePress();
  }

   public void mouseRelease(float mX, float mY) {
    this.button.mouseRelease(mX, mY);
  }

   public void scroll(int amount) {
  }

   public void keyPress() {
    this.button.keyPress();
  }
   public void keyRelease() {
    this.button.keyRelease();
  }
   public void submit() {}
}


class ButtonFormField extends SubmitFormField {
  ButtonFormField(String message) {
    super(message, true);
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    if (super.update(millis) != FormFieldSubmit.NONE) {
      return FormFieldSubmit.BUTTON;
    }
    return FormFieldSubmit.NONE;
  }
}


class SubmitCancelFormField extends FormField {
  class SubmitCancelButton extends RectangleButton {
    protected boolean submit;

    SubmitCancelButton(float xi, float yi, float xf, float yf, boolean submit) {
      super(xi, yi, xf, yf);
      this.submit = submit;
      this.roundness = 0;
      this.raised_body = true;
      this.raised_border = true;
      this.adjust_for_text_descent = true;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
      if (this.hovered || this.button_focused) {
        if (this.submit) {
          SubmitCancelFormField.this.submitted = true;
        }
        else {
          SubmitCancelFormField.this.canceled = true;
        }
      }
    }
  }

  protected SubmitCancelButton button1 = new SubmitCancelButton(0, 0, 0, 30, true);
  protected SubmitCancelButton button2 = new SubmitCancelButton(0, 0, 0, 30, false);
  protected boolean submitted = false;
  protected boolean canceled = false;
  protected float gapSize = 10;

  SubmitCancelFormField(String message1, String message2) {
    super(message1);
    this.button1.message = message1;
    this.button1.show_message = true;
    this.button2.message = message2;
    this.button2.show_message = true;
  }

   public void setButtonHeight(float new_height) {
    if (new_height < 0) {
      new_height = 0;
    }
    this.button1.setYLocation(0, new_height);
    this.button2.setYLocation(0, new_height);
  }

   public void disable() {
    this.button1.disabled = true;
    this.button2.disabled = true;
  }
   public void enable() {
    this.button1.disabled = false;
    this.button2.disabled = false;
  }

   public boolean focusable() {
    if (this.button2.button_focused) {
      return false;
    }
    return true;
  }
   public void focus() {
    if (this.button1.button_focused) {
      this.button1.button_focused = false;
      this.button2.button_focused = true;
    }
    else {
      this.button1.button_focused = true;
      this.button2.button_focused = false;
    }
  }
   public void defocus() {
    this.button1.button_focused = false;
    this.button2.button_focused = false;
  }
   public boolean focused() {
    if (this.button1.button_focused || this.button2.button_focused) {
      return true;
    }
    return false;
  }

   public void updateWidthDependencies() {
    textSize(this.button1.text_size);
    float desiredWidth1 = textWidth(this.button1.message) + textWidth("  ");
    textSize(this.button2.text_size);
    float desiredWidth2 = textWidth(this.button2.message) + textWidth("  ");
    if (this.gapSize > this.field_width) {
      this.button1.setXLocation(0, 0);
      this.button2.setXLocation(0, 0);
    }
    else if (desiredWidth1 + this.gapSize + desiredWidth2 > this.field_width) {
      this.button1.setXLocation(0, 0.5f * (this.field_width - this.gapSize));
      this.button2.setXLocation(0.5f * (this.field_width + gapSize), this.field_width);
    }
    else if (2 * max(desiredWidth1, desiredWidth2) + this.gapSize > this.field_width) {
      this.button1.setXLocation(0.5f * (this.field_width - this.gapSize) - desiredWidth1, 0.5f * (this.field_width - this.gapSize));
      this.button2.setXLocation(0.5f * (this.field_width + this.gapSize), 0.5f * (this.field_width + this.gapSize) + desiredWidth2);
    }
    else {
      this.button1.setXLocation(0.5f * (this.field_width - this.gapSize) - max(desiredWidth1, desiredWidth2), 0.5f * (this.field_width - this.gapSize));
      this.button2.setXLocation(0.5f * (this.field_width + this.gapSize), 0.5f * (this.field_width + this.gapSize) + max(desiredWidth1, desiredWidth2));
    }
  }

   public float getHeight() {
    return max(this.button1.yf - this.button1.yi, this.button2.yf - this.button2.yi);
  }

   public String getValue() {
    return this.message;
  }
  @Override public 
  void setValue(String newValue) {
    this.message = newValue;
  }

   public FormFieldSubmit update(int millis) {
    this.button1.update(millis);
    this.button2.update(millis);
    if (this.submitted) {
      this.submitted = false;
      return FormFieldSubmit.SUBMIT;
    }
    else if (this.canceled) {
      this.canceled = false;
      return FormFieldSubmit.CANCEL;
    }
    return FormFieldSubmit.NONE;
  }

   public void mouseMove(float mX, float mY) {
    this.button1.mouseMove(mX, mY);
    this.button2.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.button1.mousePress();
    this.button2.mousePress();
  }

   public void mouseRelease(float mX, float mY) {
    this.button1.mouseRelease(mX, mY);
    this.button2.mouseRelease(mX, mY);
  }

   public void scroll(int amount) {
  }

   public void keyPress() {
    this.button1.keyPress();
    this.button2.keyPress();
  }
   public void keyRelease() {
    this.button1.keyRelease();
    this.button2.keyRelease();
  }
   public void submit() {}
}



class ButtonsFormField extends SubmitCancelFormField {
  protected int last_button_pressed = -1;

  ButtonsFormField(String message1, String message2) {
    super(message1, message2);
  }

  @Override public 
  String getValue() {
    return Integer.toString(this.last_button_pressed);
  }
  @Override public 
  void setValue(String newValue) {
    if (isInt(newValue)) {
      this.last_button_pressed = toInt(newValue);
    }
    else {
      this.last_button_pressed = -1;
    }
  }

  @Override public 
  FormFieldSubmit update(int millis) {
    this.button1.update(millis);
    this.button2.update(millis);
    if (this.submitted) {
      this.submitted = false;
      this.last_button_pressed = 0;
      return FormFieldSubmit.BUTTON;
    }
    else if (this.canceled) {
      this.canceled = false;
      this.last_button_pressed = 1;
      return FormFieldSubmit.BUTTON;
    }
    this.last_button_pressed = -1;
    return FormFieldSubmit.NONE;
  }
}



abstract class Form {
  class CancelButton extends RectangleButton {
    CancelButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
      this.setColors(color(170), ccolor(240, 30, 30), ccolor(255, 60, 60), ccolor(180, 0, 0), ccolor(0));
      this.color_stroke = ccolor(0, 1);
    }
    @Override public 
    void drawButton() {
      super.drawButton();
      stroke(ccolor(0));
      strokeWeight(1.5f);
      float offset = 0.05f * this.button_width();
      line(this.xi + offset, this.yi + offset, this.xf - offset, this.yf - offset);
      line(this.xi + offset, this.yf - offset, this.xf - offset, this.yi + offset);
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
      if (this.hovered) {
        Form.this.cancelForm();
      }
    }
  }

  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;
  protected boolean hovered = false;
  protected CancelButton cancel;

  protected ScrollBar scrollbar = new ScrollBar(0, 0, 0, 0, true);
  protected float scrollbar_max_width = 40;
  protected float scrollbar_min_width = 20;
  protected float scrollbar_width_multiplier = 0.05f;

  protected ArrayList<FormField> fields = new ArrayList<FormField>();
  protected float fieldCushion = 20;
  protected float yStart = 0;

  protected String text_title_ref = null;
  protected String text_title = null;
  protected float title_size = 22;

  protected int color_background = ccolor(210);
  protected int color_header = ccolor(170);
  protected int color_stroke = ccolor(0);
  protected int color_title = ccolor(0);

  protected boolean draggable = false;
  protected boolean hovered_header = false;
  protected boolean dragging = false;
  protected float dragX = 0;
  protected float dragY = 0;
  protected float max_x = width;
  protected float min_x = 0;
  protected float max_y = height;
  protected float min_y = 0;

  Form() {
    this(0, 0, 0, 0);
  }
  Form(float xi, float yi, float xf, float yf) {
    this.setLocation(xi, yi, xf, yf);
  }

   public void cancelButton() {
    textSize(this.title_size);
    this.cancelButton(textAscent() + textDescent() + 1);
  }
   public void cancelButton(float size) {
    this.cancel = new CancelButton(this.xf - size, this.yi + 1, this.xf, this.yi + size);
    this.refreshTitle();
  }

   public float form_width() {
    return this.xf - this.xi;
  }
   public float form_height() {
    return this.yf - this.yi;
  }

   public float xCenter() {
    return this.xi + 0.5f * (this.xf - this.xi);
  }
   public float yCenter() {
    return this.yi + 0.5f * (this.yf - this.yi);
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.refreshTitle();
    for (FormField field : this.fields) {
      field.setWidth(this.xf - this.xi - 3 - this.scrollbar.bar_size);
    }
  }
   public void setXLocation(float xi, float xf) {
    this.xi = xi;
    this.xf = xf;
    this.refreshTitle();
    for (FormField field : this.fields) {
      field.setWidth(this.xf - this.xi - 3 - this.scrollbar.bar_size);
    }
  }
   public void setYLocation(float yi, float yf) {
    this.yi = yi;
    this.yf = yf;
    this.refreshTitle();
  }

   public void moveForm(float xMove, float yMove) {
    this.xi += xMove;
    this.yi += yMove;
    this.xf += xMove;
    this.yf += yMove;
    this.scrollbar.move(xMove, yMove);
    if (this.cancel != null) {
      this.cancel.moveButton(xMove, yMove);
    }
    this.yStart += yMove;
    if (this.xi >= this.max_x || this.xf <= this.min_x || (this.cancel != null && this.xf <= this.cancel.button_width())
      || this.yi >= this.max_y || this.yStart <= this.min_y) {
      this.toCenter();
      this.dragging = false;
    }
  }

   public void toCenter() {
    float xMove = 0.5f * (width - this.form_width()) - this.xi;
    float yMove = 0.5f * (height - this.form_height()) - this.yi;
    this.moveForm(xMove, yMove);
  }

   public void refreshTitle() {
    this.setTitleText(this.text_title_ref);
  }
   public void setTitleSize(float title_size) {
    this.title_size = title_size;
    this.refreshTitle();
    if (this.cancel != null) {
      textSize(this.title_size);
      if (this.cancel.button_height() > textAscent() + textDescent() + 1) {
        this.cancelButton();
      }
    }
  }
   public void setTitleText(String title) {
    this.text_title_ref = title;
    float scrollbar_width = min(this.scrollbar_max_width, this.scrollbar_width_multiplier * (this.xf - this.xi));
    scrollbar_width = max(this.scrollbar_min_width, scrollbar_width);
    scrollbar_width = min(this.scrollbar_width_multiplier * (this.xf - this.xi), scrollbar_width);
    if (title == null) {
      this.text_title = null;
      this.scrollbar.setLocation(this.xf - scrollbar_width, this.yi, this.xf, this.yf);
      this.yStart = this.yi + 1;
    }
    else {
      this.text_title = "";
      textSize(this.title_size);
      for (int i = 0; i < title.length(); i++) {
        char nextChar = title.charAt(i);
        if (textWidth(this.text_title + nextChar) < this.xf - this.xi - 3) {
          this.text_title += nextChar;
        }
        else {
          break;
        }
      }
      this.yStart = this.yi + 2 + textAscent() + textDescent();
      this.scrollbar.setLocation(xf - scrollbar_width, this.yStart, this.xf, this.yf);
    }
  }

   public void setFieldCushion(float fieldCushion) {
    this.fieldCushion = fieldCushion;
    this.refreshScrollbar();
  }


   public void addField(FormField field) {
    field.setWidth(this.xf - this.xi - 3 - this.scrollbar.bar_size);
    this.fields.add(field);
    this.refreshScrollbar();
  }

   public void removeField(int index) {
    if (index < 0 || index >= this.fields.size()) {
      return;
    }
    this.fields.remove(index);
    this.refreshScrollbar();
  }

   public void clearFields() {
    this.fields.clear();
    this.refreshScrollbar();
  }

   public void refreshScrollbar() {
    float currY = this.yStart;
    for (int i = 0; i < this.fields.size(); i++) {
      currY += this.fields.get(i).getHeight();
      if (i > 0) {
        currY += this.fieldCushion;
      }
      if (currY + 2 > this.yf) {
        this.scrollbar.updateMaxValue(this.fields.size());
        return;
      }
    }
    this.scrollbar.updateMaxValue(0);
  }


   public void update(int millis) {
    rectMode(CORNERS);
    fill(this.color_background);
    stroke(this.color_stroke);
    strokeWeight(1);
    rect(this.xi, this.yi, this.xf, this.yf);
    if (this.text_title_ref != null) {
      fill(this.color_header);
      textSize(this.title_size);
      rect(this.xi, this.yi, this.xf, this.yi + textAscent() + textDescent() + 1);
      fill(this.color_title);
      textAlign(CENTER, TOP);
      float center = this.xi + 0.5f * (this.xf - this.xi);
      if (this.cancel != null) {
        center -= 0.5f * this.cancel.button_width();
      }
      text(this.text_title, center, this.yi + 1);
    }
    if (this.cancel != null) {
      this.cancel.update(millis);
    }
    float currY = this.yStart;
    translate(this.xi + 1, 0);
    for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.fields.size(); i++) {
      if (currY + this.fields.get(i).getHeight() > this.yf) {
        break;
      }
      translate(0, currY);
      FormFieldSubmit submit = this.fields.get(i).update(millis);
      if (submit == FormFieldSubmit.SUBMIT) {
        this.submitForm();
      }
      else if (submit == FormFieldSubmit.CANCEL) {
        this.cancelForm();
      }
      else if (submit == FormFieldSubmit.BUTTON) { // alternate button
        this.buttonPress(i);
      }
      translate(0, -currY);
      currY += this.fields.get(i).getHeight() + this.fieldCushion;
    }
    translate(-this.xi - 1, 0);
    if (this.scrollbar.maxValue != this.scrollbar.minValue) {
      this.scrollbar.update(millis);
    }
  }

   public void mouseMove(float mX, float mY) {
    this.scrollbar.mouseMove(mX, mY);
    if (this.cancel != null) {
      this.cancel.mouseMove(mX, mY);
    }
    if (this.dragging) {
      this.moveForm(mouseX - this.dragX, mouseY - this.dragY);
      this.dragX = mouseX;
      this.dragY = mouseY;
    }
    this.hovered_header = false;
    if (mX > this.xi && mX < this.xf && mY > this.yi && mY < this.yf) {
      this.hovered = true;
      if (this.text_title_ref != null) {
        if (mY < this.yStart) {
          if (this.cancel == null || !this.cancel.hovered) {
            this.hovered_header = true;
          }
        }
      }
    }
    else {
      this.hovered = false;
    }
    mX -= this.xi + 1;
    mY -= this.yStart;
    float currY = this.yStart;
    for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.fields.size(); i++) {
      if (currY + this.fields.get(i).getHeight() > this.yf) {
        break;
      }
      this.fields.get(i).mouseMove(mX, mY);
      mY -= this.fields.get(i).getHeight() + this.fieldCushion;
      currY += this.fields.get(i).getHeight() + this.fieldCushion;
    }
  }

   public void mousePress() {
    this.scrollbar.mousePress();
    if (this.cancel != null) {
      this.cancel.mousePress();
    }
    for (int i = 0; i < PApplet.parseInt(floor(this.scrollbar.value)); i++) {
      this.fields.get(i).defocus();
    }
    float currY = this.yStart;
    for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.fields.size(); i++) {
      if (currY + this.fields.get(i).getHeight() > this.yf) {
        this.fields.get(i).defocus();
        continue;
      }
      this.fields.get(i).mousePress();
      currY += this.fields.get(i).getHeight() + this.fieldCushion;
    }
    if (this.hovered_header && this.draggable) {
      this.dragging = true;
      this.dragX = mouseX;
      this.dragY = mouseY;
    }
  }

   public void mouseRelease(float mX, float mY) {
    this.scrollbar.mouseRelease(mX, mY);
    if (this.cancel != null) {
      this.cancel.mouseRelease(mX, mY);
    }
    mX -= this.xi + 1;
    mY -= this.yStart;
    float currY = this.yStart;
    for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.fields.size(); i++) {
      if (currY + this.fields.get(i).getHeight() > this.yf) {
        break;
      }
      this.fields.get(i).mouseRelease(mX, mY);
      mY -= this.fields.get(i).getHeight() + this.fieldCushion;
      currY += this.fields.get(i).getHeight() + this.fieldCushion;
    }
    this.dragging = false;
  }

   public void scroll(int amount) {
    if (this.hovered) {
      this.scrollbar.increaseValue(amount);
    }
    for (FormField field : this.fields) {
      field.scroll(amount);
    }
  }

   public void keyPress() {
    for (FormField field : this.fields) {
      field.keyPress();
    }
    if (key != CODED && key == TAB) {
      this.focusNextField();
    }
  }

   public void focusNextField() {
    int field_focused = 0;
    for (int i = 0; i < this.fields.size(); i++) {
      if (this.fields.get(i).focused()) {
        field_focused = i;
        break;
      }
    }
    ClockInt index = new ClockInt(0, this.fields.size() - 1, field_focused);
    for (int i = 0; i < this.fields.size(); i++, index.add(1)) {
      if (this.fields.get(index.value).focusable()) {
        this.fields.get(index.value).focus();
        break;
      }
    }
    if (index.value != field_focused) {
      this.fields.get(field_focused).defocus();
    }
  }

   public void keyRelease() {
    for (FormField field : this.fields) {
      field.keyRelease();
    }
  }


   public void submitForm() {
    for (FormField field : this.fields) {
      field.submit();
    }
    this.submit();
  }

   public void cancelForm() {
    this.cancel();
  }

   public abstract void submit();
   public abstract void cancel();
   public abstract void buttonPress(int i);
}





class ClockInt {
  protected int min;
  protected int max;
  protected int value;

  ClockInt(int max) {
    this(0, max, PApplet.parseInt(random(max)));
  }
  ClockInt(int max, int start) {
    this(0, max, start);
  }
  ClockInt(int min, int max, int start) {
    if (min > max) {
      this.min = max;
      this.max = min;
    }
    else {
      this.min = min;
      this.max = max;
    }
    this.value = start;
    this.resolve();
  }

   public void resolve() {
    this.value = this.min + (this.value - this.min) % (this.max - this.min + 1);
  }

   public void add(int amount) {
    this.value += amount;
    this.resolve();
  }

   public void set(int amount) {
    this.value = amount;
    this.resolve();
  }
}


class ClockFloat {
  protected float min;
  protected float max;
  protected float value;

  ClockFloat(float max) {
    this(0, max, random(max));
  }
  ClockFloat(float max, float start) {
    this(0, max, start);
  }
  ClockFloat(float min, float max, float start) {
    if (min > max) {
      this.min = max;
      this.max = min;
    }
    else {
      this.min = min;
      this.max = max;
    }
    this.value = start;
    this.resolve();
  }

   public void resolve() {
    if (this.min == this.max) {
      this.value = this.min;
    }
    else {
      this.value = this.min + (this.value - this.min) % (this.max - this.min);
    }
  }

   public void add(float amount) {
    this.value += amount;
    this.resolve();
  }

   public void set(float amount) {
    this.value = amount;
    this.resolve();
  }
}

class BounceInt {
  protected int min;
  protected int max;
  protected int value;
  protected boolean moving_forward = true;

  BounceInt(int max) {
    this(0, max, PApplet.parseInt(random(max)));
  }
  BounceInt(int max, int start) {
    this(0, max, start);
  }
  BounceInt(int min, int max, int start) {
    if (min > max) {
      this.min = max;
      this.max = min;
    }
    else {
      this.min = min;
      this.max = max;
    }
    this.value = start;
    this.resolve();
  }

   public void resolve() {
    while(true) {
      if (this.moving_forward) {
        if (this.value > this.max) {
          this.moving_forward = false;
          this.value = this.max + this.max - this.value;
          continue;
        }
        else {
          break;
        }
      }
      else {
        if (this.value < this.min) {
          this.moving_forward = true;
          this.value = this.min + this.min - this.value;
          continue;
        }
        else {
          break;
        }
      }
    }
  }

   public void add(int amount) {
    if (this.moving_forward) {
      this.value += amount;
    }
    else {
      this.value -= amount;
    }
    this.resolve();
  }

   public void set(int amount) {
    this.value = amount;
    this.resolve();
  }
}

class BounceFloat {
  protected float min;
  protected float max;
  protected float value;
  protected boolean moving_forward = true;

  BounceFloat(float max) {
    this(0, max, random(max));
  }
  BounceFloat(float max, float start) {
    this(0, max, start);
  }
  BounceFloat(float min, float max, float start) {
    if (min > max) {
      this.min = max;
      this.max = min;
    }
    else {
      this.min = min;
      this.max = max;
    }
    this.value = start;
    this.resolve();
  }

   public void resolve() {
    while(true) {
      if (this.moving_forward) {
        if (this.value > this.max) {
          this.moving_forward = false;
          this.value = this.max + this.max - this.value;
          continue;
        }
        else {
          break;
        }
      }
      else {
        if (this.value < this.min) {
          this.moving_forward = true;
          this.value = this.min + this.min - this.value;
          continue;
        }
        else {
          break;
        }
      }
    }
  }

   public void add(float amount) {
    if (this.moving_forward) {
      this.value += amount;
    }
    else {
      this.value -= amount;
    }
    this.resolve();
  }

   public void set(float amount) {
    this.value = amount;
    this.resolve();
  }
}




class Panel {
  class PanelButton extends RectangleButton {
    protected float image_rotation = 0;
    protected float image_rotation_speed = 0.01f;
    protected float image_rotation_target = 0;
    protected PImage icon;
    protected boolean removed = false;

    PanelButton() {
      super(0, 0, 0, 0);
      this.setColors(color(220), ccolor(1, 0), ccolor(170, 80), ccolor(170, 180), ccolor(0));
      this.noStroke();
      this.roundness = 0;
      this.hover_check_after_release = false;
    }

    @Override public 
    void update(int millis) {
      if (this.removed) {
        return;
      }
      super.update(millis);
      if (this.icon != null) {
        float rotate_change = (millis - Panel.this.lastUpdateTime) * this.image_rotation_speed;
        if (this.image_rotation < this.image_rotation_target) {
          this.image_rotation += rotate_change;
          if (this.image_rotation > this.image_rotation_target) {
            this.image_rotation = this.image_rotation_target;
          }
        }
        else if (this.image_rotation > this.image_rotation_target) {
          this.image_rotation -= rotate_change;
          if (this.image_rotation < this.image_rotation_target) {
            this.image_rotation = this.image_rotation_target;
          }
        }
        translate(this.xCenter(), this.yCenter());
        rotate(this.image_rotation);
        imageMode(CENTER);
        image(this.icon, 0, 0, this.button_width(), this.button_height());
        rotate(-this.image_rotation);
        translate(-this.xCenter(), -this.yCenter());
      }
    }

     public void hover() {}
     public void dehover() {}
     public void click() {}
     public void release() {
      if (this.removed) {
        return;
      }
      if (this.hovered) {
        Panel.this.collapse();
        this.hovered = false;
      }
    }
  }


  protected int location;
  protected float size_min;
  protected float size_max;
  protected float size_curr;
  protected float size;

  protected boolean hovered = false;
  protected boolean cant_resize = false;
  protected boolean clicked = false;
  protected float hovered_delta = 5;

  protected boolean open = true;
  protected boolean collapsing = false;
  protected float collapse_speed = 1.2f;
  protected int lastUpdateTime = 0;
  protected PImage img;

  protected PanelButton button = new PanelButton();
  protected float panelButtonSize = 30;

  protected int color_background = ccolor(220);

  Panel(int location, float size) {
    this(location, size, size, size);
  }
  Panel(int location, float size_min, float size_max, float size) {
    switch(location) {
      case LEFT:
      case RIGHT:
      case UP:
      case DOWN:
        this.location = location;
        break;
      default:
        this.location = LEFT;
        break;
    }
    this.size_min = size_min;
    this.size_max = size_max;
    this.size_curr = size;
    this.size = size;
    this.resetButtonLocation();
  }


   public void resetButtonLocation() {
    switch(this.location) {
      case LEFT:
        this.button.setLocation(this.size, 0, this.size + this.panelButtonSize, this.panelButtonSize);
        if (this.open) {
          this.button.image_rotation_target = -HALF_PI;
        }
        else {
          this.button.image_rotation_target = HALF_PI;
        }
        break;
      case RIGHT:
        this.button.setLocation(width - this.size - this.panelButtonSize, 0, width - this.size, this.panelButtonSize);
        if (this.open) {
          this.button.image_rotation_target = HALF_PI;
        }
        else {
          this.button.image_rotation_target = -HALF_PI;
        }
        break;
      case UP:
        this.button.setLocation(width - this.panelButtonSize, this.size, width, this.size + this.panelButtonSize);
          if (this.open) {
            this.button.image_rotation_target = 0;
          }
          else {
            this.button.image_rotation_target = PI;
          }
        break;
      case DOWN:
        this.button.setLocation(width - this.panelButtonSize, height - this.size - this.panelButtonSize, width, height - this.size);
          if (this.open) {
            this.button.image_rotation_target = PI;
          }
          else {
            this.button.image_rotation_target = 0;
          }
        break;
    }
  }
   public void addIcon(PImage icon) {
    this.button.icon = icon;
  }
   public void removeButton() {
    this.button.removed = true;
  }

   public void changeSize(float size_delta) {
    if (this.size_curr + size_delta > this.size_max) {
      this.size_curr = this.size_max;
    }
    else if (this.size_curr + size_delta < this.size_min) {
      this.size_curr = this.size_min;
    }
    else {
      this.size_curr += size_delta;
    }
    if (this.open) {
      this.size = this.size_curr;
    }
    this.resetButtonLocation();
  }


   public void collapse() {
    this.collapsing = true;
    switch(this.location) {
      case LEFT:
        this.img = getCurrImage(0, 0, PApplet.parseInt(round(this.size_curr)), height);
        break;
      case RIGHT:
        this.img = getCurrImage(width - PApplet.parseInt(round(this.size_curr)), 0, width, height);
        break;
      case UP:
        this.img = getCurrImage(0, 0, width, PApplet.parseInt(round(this.size_curr)));
        break;
      case DOWN:
        this.img = getCurrImage(0, height - PApplet.parseInt(round(this.size_curr)), width, height);
        break;
    }
  }


   public void update(int millis) {
    int timeElapsed = millis - this.lastUpdateTime;
    this.button.update(millis);
    rectMode(CORNER);
    fill(this.color_background);
    noStroke();
    switch(this.location) {
      case LEFT:
        rect(0, 0, this.size, height);
        break;
      case RIGHT:
        rect(width - this.size, 0, this.size, height);
        break;
      case UP:
        rect(0, 0, width, this.size);
        break;
      case DOWN:
        rect(0, height - this.size, width, this.size);
        break;
    }
    if (this.collapsing) {
      this.button.clicked = false;
      this.button.hovered = false;
      float buttonMove = 0;
      boolean buttonReset = false;
      if (this.open) {
        buttonMove = -this.collapse_speed * timeElapsed;
        this.size += buttonMove;
        if (this.size < 0) {
          this.size = 0;
          this.open = false;
          this.collapsing = false;
          this.resetButtonLocation();
          buttonReset = true;
        }
        if (this.img != null) {
          imageMode(CORNER);
          switch(this.location) {
            case LEFT:
              image(this.img, this.size - this.size_curr, 0);
              break;
            case RIGHT:
              image(this.img, width - this.size, 0);
              break;
            case UP:
              image(this.img, 0, this.size - this.size_curr);
              break;
            case DOWN:
              image(this.img, 0, height - this.size);
              break;
          }
        }
      }
      else {
        buttonMove = this.collapse_speed * timeElapsed;
        this.size += buttonMove;
        if (this.size > this.size_curr) {
          this.size = this.size_curr;
          this.open = true;
          this.collapsing = false;
          this.resetButtonLocation();
          buttonReset = true;
        }
      }
      if (!buttonReset) {
        switch(this.location) {
          case LEFT:
            this.button.moveButton(buttonMove, 0);
            break;
          case RIGHT:
            this.button.moveButton(-buttonMove, 0);
            break;
          case UP:
            this.button.moveButton(0, buttonMove);
            break;
          case DOWN:
            this.button.moveButton(0, -buttonMove);
            break;
        }
      }
    }
    this.lastUpdateTime = millis;
  }

   public void mouseMove(float mX, float mY) {
    this.button.mouseMove(mX, mY);
    if (this.cant_resize) {
      return;
    }
    if (!this.open || this.button.hovered) {
      this.hovered = false;
      return;
    }
    switch(this.location) {
      case LEFT:
        if (this.clicked) {
          this.changeSize(mX - this.size);
        }
        else if (abs(mX - this.size) < this.hovered_delta) {
          this.hovered = true;
        }
        else {
          this.hovered = false;
        }
        break;
      case RIGHT:
        if (this.clicked) {
          this.changeSize(width - this.size - mX);
        }
        else if (abs(mX - width + this.size) < this.hovered_delta) {
          this.hovered = true;
        }
        else {
          this.hovered = false;
        }
        break;
      case UP:
        if (this.clicked) {
          this.changeSize(mY - this.size);
        }
        else if (abs(mY - this.size) < this.hovered_delta) {
          this.hovered = true;
        }
        else {
          this.hovered = false;
        }
        break;
      case DOWN:
        if (this.clicked) {
          this.changeSize(height - this.size - mY);
        }
        else if (abs(mY - height + this.size) < this.hovered_delta) {
          this.hovered = true;
        }
        else {
          this.hovered = false;
        }
        break;
    }
  }

   public void mousePress() {
    this.button.mousePress();
    if (this.hovered && mouseButton == LEFT) {
      this.clicked = true;
    }
  }

   public void mouseRelease(float mX, float mY) {
    this.button.mouseRelease(mX, mY);
    this.clicked = false;
    this.mouseMove(mX, mY);
  }
}
class EditFeatureForm extends EditMapObjectForm {
  protected Feature feature;

  EditFeatureForm(Feature feature) {
    super(feature);
    this.feature = feature;
    this.addField(new IntegerFormField("Number: ", "number", Integer.MIN_VALUE + 1, Integer.MAX_VALUE - 1));
    this.addField(new CheckboxFormField("Toggle:  "));
    switch(this.feature.ID) {
      case 151: // Sign, green
      case 152:
      case 153:
      case 154:
      case 155: // Sign, gray
      case 156:
      case 157:
      case 158:
        this.addField(new StringFormField("Message: ", "enter the message for the sign"));
        break;
      default:
        break;
    }
    this.addField(new SubmitFormField("Finished", false));
    this.updateForm();
  }

   public void updateObject() {
    this.feature.number = toInt(this.fields.get(1).getValue());
    this.feature.toggle = toBoolean(this.fields.get(2).getValue());
    switch(this.feature.ID) {
      case 151: // Sign, green
      case 152:
      case 153:
      case 154:
      case 155: // Sign, gray
      case 156:
      case 157:
      case 158:
        try {
          this.feature.description = split(this.feature.description, Constants.
            feature_signDescriptionDelimiter)[0] + Constants.
            feature_signDescriptionDelimiter + this.fields.get(3).getValue();
        } catch(Exception e) {}
        break;
      default:
        break;
    }
  }

   public void updateForm() {
    this.fields.get(1).setValueIfNotFocused(Integer.toString(this.feature.number));
    this.fields.get(2).setValueIfNotFocused(Boolean.toString(this.feature.toggle));
    switch(this.feature.ID) {
      case 151: // Sign, green
      case 152:
      case 153:
      case 154:
      case 155: // Sign, gray
      case 156:
      case 157:
      case 158:
        try {
          this.fields.get(3).setValueIfNotFocused(split(this.feature.description,
            Constants.feature_signDescriptionDelimiter)[1]);
        } catch(Exception e) {}
        break;
      default:
        break;
    }
  }
}




class Feature extends MapObject {
  protected int sizeX = 0;
  protected int sizeY = 0;
  protected int sizeZ = 0;

  protected int number = 0;
  protected boolean toggle = false;
  protected Inventory inventory = null;
  protected ArrayList<Item> items = null;

  protected int map_key = -10;
  protected boolean refresh_map_image = false;

  Feature(int ID) {
    super(ID);
    switch(ID) {
      // fog
      case 1:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 2:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 3:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 4:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 5:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 6:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 7:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 8:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 9:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;
      case 10:
        this.setStrings("Fog", "Fog", "");
        this.setSize(1, 1, 0);
        break;

      // Unique
      case 11:
        this.setStrings("Traveling Buddy", "NPC", "");
        this.setSize(2, 1, 6);
        break;
      case 12:
        this.setStrings("Chuck Quizmo", "NPC", "");
        this.setSize(1, 1, 5);
        break;
      case 21:
        this.setStrings("Workbench", "Tool", "");
        this.setSize(1, 1, 3);
        this.inventory = new WorkbenchInventory(this);
        this.items = new ArrayList<Item>();
        break;
      case 22:
        this.setStrings("Ender Chest", "Tool", "");
        this.setSize(1, 1, 3);
        this.inventory = global.profile.ender_chest;
        break;

      // Furniture
      case 101:
        this.setStrings("Wooden Table", "Furniture", "");
        this.setSize(2, 2, 3);
        this.number = Constants.feature_woodenTableHealth;
        break;
      case 102:
        this.setStrings("Wooden Desk", "Furniture", "");
        this.setSize(2, 1, 4);
        this.inventory = new DeskInventory();
        this.number = Constants.feature_woodenDeskHealth;
        break;
      case 103:
        this.setStrings("Wooden Desk", "Furniture", "");
        this.setSize(1, 2, 4);
        this.inventory = new DeskInventory();
        this.number = Constants.feature_woodenDeskHealth;
        break;
      case 104:
        this.setStrings("Wooden Desk", "Furniture", "");
        this.setSize(2, 1, 4);
        this.inventory = new DeskInventory();
        this.number = Constants.feature_woodenDeskHealth;
        break;
      case 105:
        this.setStrings("Wooden Desk", "Furniture", "");
        this.setSize(1, 2, 4);
        this.inventory = new DeskInventory();
        this.number = Constants.feature_woodenDeskHealth;
        break;
      case 106:
        this.setStrings("Wooden Table", "Furniture", "");
        this.setSize(2, 1, 4);
        this.number = Constants.feature_woodenTableHealth;
        break;
      case 107:
        this.setStrings("Wooden Table", "Furniture", "");
        this.setSize(1, 2, 4);
        this.number = Constants.feature_woodenTableHealth;
        break;
      case 108:
        this.setStrings("Ping Pong Table", "Furniture", "");
        this.setSize(2, 2, 3);
        this.number = Constants.feature_woodenTableHealth;
        break;
      case 111:
      case 112:
      case 113:
      case 114:
        this.setStrings("Wooden Chair", "Furniture", "");
        this.setSize(1, 1, 2);
        this.number = Constants.feature_woodenChairHealth;
        break;
      case 115:
        this.setStrings("Coordinator Chair", "Furniture", "");
        this.setSize(1, 1, 2);
        this.toggle = true;
        this.number = Constants.feature_couchHealth;
        break;
      case 121:
      case 122:
        this.setStrings("Couch", "Furniture", "");
        this.setSize(3, 1, 2);
        this.toggle = true;
        this.number = Constants.feature_couchHealth;
        break;
      case 123:
      case 124:
        this.setStrings("Couch", "Furniture", "");
        this.setSize(1, 3, 2);
        this.toggle = true;
        this.number = Constants.feature_couchHealth;
        break;
      case 125:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(2, 1, 2);
        this.number = Constants.feature_woodenBenchSmallHealth;
        break;
      case 126:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(1, 2, 2);
        this.number = Constants.feature_woodenBenchSmallHealth;
        break;
      case 127:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(2, 3, 3);
        this.number = Constants.feature_woodenBenchLargeHealth;
        break;
      case 128:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(3, 2, 3);
        this.number = Constants.feature_woodenBenchLargeHealth;
        break;
      case 129:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(2, 1, 2);
        this.number = Constants.feature_woodenBenchSmallHealth;
        break;
      case 130:
        this.setStrings("Bench", "Furniture", "");
        this.setSize(1, 2, 2);
        this.number = Constants.feature_woodenBenchSmallHealth;
        break;
      case 131:
      case 132:
        this.setStrings("Bed", "Furniture", "");
        this.setSize(2, 3, 3);
        this.toggle = true;
        this.number = Constants.feature_bedHealth;
        break;
      case 133:
      case 134:
        this.setStrings("Bed", "Furniture", "");
        this.setSize(3, 2, 3);
        this.toggle = true;
        this.number = Constants.feature_woodenTableHealth;
        break;
      case 141:
        this.setStrings("Wardrobe", "Furniture", "");
        this.setSize(2, 1, 9);
        this.toggle = true;
        this.number = Constants.feature_wardrobeHealth;
        break;
      case 142:
        this.setStrings("Wardrobe", "Furniture", "");
        this.setSize(1, 2, 9);
        this.toggle = true;
        this.number = Constants.feature_wardrobeHealth;
        break;
      case 151:
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
        this.setStrings("Sign", "Sign", Constants.feature_signDescriptionDelimiter);
        this.setSize(1, 1, 0);
        break;
      case 161:
        this.setStrings("Water Fountain", "Furniture", "");
        this.setSize(1, 1, 4);
        break;
      case 162:
        this.setStrings("Sink", "Furniture", "");
        this.setSize(1, 1, 4);
        break;
      case 163:
        this.setStrings("Shower Stall", "Furniture", "");
        this.setSize(1, 1, -1);
        break;
      case 164:
        this.setStrings("Urinal", "Furniture", "");
        this.setSize(1, 1, 5);
        break;
      case 165:
        this.setStrings("Toilet", "Furniture", "");
        this.setSize(1, 1, 2);
        break;
      case 171:
        this.setStrings("Stove", "Appliance", "");
        this.setSize(1, 1, 4);
        this.inventory = new StoveInventory();
        break;
      case 172:
        this.setStrings("Vending Machine", "Appliance", "");
        this.setSize(1, 1, 7);
        break;
      case 173:
        this.setStrings("Vending Machine", "Appliance", "");
        this.setSize(1, 1, 7);
        break;
      case 174:
        this.setStrings("Minifridge", "Appliance", "");
        this.setSize(1, 1, 3);
        this.inventory = new MinifridgeInventory();
        break;
      case 175:
        this.setStrings("Refridgerator", "Appliance", "");
        this.setSize(1, 1, 7);
        this.inventory = new RefridgeratorInventory();
        break;
      case 176:
        this.setStrings("Washer", "Appliance", "");
        this.setSize(1, 1, 4);
        this.inventory = new WasherInventory();
        break;
      case 177:
        this.setStrings("Dryer", "Appliance", "");
        this.setSize(1, 1, 4);
        this.inventory = new DryerInventory();
        break;
      case 178:
        this.setStrings("Microwave", "Appliance", "");
        this.setSize(1, 1, 1);
        this.inventory = new MicrowaveInventory();
        break;
      case 179:
        this.setStrings("TV", "Appliance", "");
        this.setSize(1, 1, 2);
        break;
      case 180:
        this.setStrings("Lamp", "Appliance", "");
        this.setSize(1, 2, 0);
        break;
      case 181:
        this.setStrings("Garbage Can", "Furniture", "");
        this.setSize(1, 1, 4);
        this.inventory = new GarbageInventory();
        break;
      case 182:
        this.setStrings("Recycle Can", "Furniture", "");
        this.setSize(1, 1, 4);
        this.inventory = new RecycleInventory();
        break;
      case 183:
        this.setStrings("Crate", "Furniture", "");
        this.setSize(1, 1, 2);
        this.inventory = new CrateInventory();
        break;
      case 184:
        this.setStrings("Cardboard Box", "Furniture", "");
        this.setSize(1, 1, 2);
        this.inventory = new CardboardBoxInventory();
        break;
      case 185:
        this.setStrings("Pickle Jar", "Furniture", "");
        this.setSize(1, 1, 1);
        break;
      case 186:
        this.setStrings("Outside Light Source", "Furniture", "");
        this.setSize(1, 1, 0);
        this.toggle = true;
        break;
      case 187:
        this.setStrings("Invisible Light Source", "Furniture", "");
        this.setSize(1, 1, 0);
        this.toggle = true;
        break;
      case 188:
        this.setStrings("Invisible Light Source", "Furniture", "");
        this.setSize(2, 1, 0);
        this.toggle = true;
        break;
      case 189:
        this.setStrings("Invisible Light Source", "Furniture", "");
        this.setSize(1, 2, 0);
        this.toggle = true;
        break;
      case 190:
        this.setStrings("Invisible Light Source", "Furniture", "");
        this.setSize(2, 2, 0);
        this.toggle = true;
        break;
      case 191:
      case 192:
      case 193:
      case 194:
        this.setStrings("Railing", "Furniture", "");
        this.setSize(1, 1, 5);
        break;
      case 195:
      case 196:
      case 197:
      case 198:
        this.setStrings("Light Switch", "Appliance", "");
        this.setSize(1, 1, 0);
        this.toggle = true;
        break;
      case 201:
        this.setStrings("Steel Cross", "Statue", "");
        this.setSize(2, 2, 100);
        break;
      case 202:
        this.setStrings("Mary Statue", "Statue", "");
        this.setSize(1, 1, 6);
        break;
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
        this.setStrings("Wire Fence", "Fence", "");
        this.setSize(1, 1, 7);
        break;
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
        this.setStrings("Barbed Wire Fence", "Fence", "");
        this.setSize(1, 1, 9);
        break;
      case 251:
        this.setStrings("Parking Bumper", "Outdoors", "");
        this.setSize(3, 1, 1);
        break;
      case 252:
        this.setStrings("Parking Bumper", "Outdoors", "");
        this.setSize(1, 3, 1);
        break;
      case 253:
        this.setStrings("Gazebo", "Outdoors", "");
        this.setSize(4, 4, 7);
        break;

      // Walls
      case 301:
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
        this.setStrings("Brick Wall", "Wall", "");
        this.setSize(1, 1, 100);
        break;
      case 311:
      case 312:
        this.setStrings("Pillar", "Wall", "");
        this.setSize(1, 1, 100);
        break;
      case 321:
        this.setStrings("Window", "Window", "");
        this.setSize(1, 1, 0);
        break;
      case 322:
      case 323:
        this.setStrings("Window", "Window", "");
        this.setSize(1, 1, 100);
        break;
      case 331:
      case 332:
      case 333:
      case 334:
      case 335:
      case 336:
      case 337:
      case 338:
        this.setStrings("Wooden Door", "Door", "");
        this.setSize(1, 1, 0);
        break;
      case 339:
      case 340:
      case 341:
      case 342:
      case 343:
      case 344:
      case 345:
      case 346:
        this.setStrings("Wooden Door", "Door", "");
        this.setSize(1, 1, 100);
        break;
      case 351:
      case 352:
      case 353:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
        this.setStrings("Steel Door", "Door", "");
        this.setSize(1, 1, 0);
        break;
      case 359:
      case 360:
      case 361:
      case 362:
      case 363:
      case 364:
      case 365:
      case 366:
        this.setStrings("Steel Door", "Door", "");
        this.setSize(1, 1, 100);
        break;

      // Nature
      case 401:
        this.setStrings("Dandelion", "Nature", "");
        this.setSize(1, 1, 0);
        break;
      case 411:
      case 412:
        this.setStrings("Gravel", "Nature", "");
        this.setSize(1, 1, 0);
        this.number = PApplet.parseInt(ceil(random(Constants.feature_gravelMaxNumberRocks)));
        break;
      case 421:
      case 422:
      case 423:
      case 424:
      case 426:
        this.setStrings("Tree", "Nature", "");
        this.setSize(2, 2, 20);
        this.toggle = true;
        this.number = Constants.feature_treeHealth;
        break;
      case 425:
        this.setStrings("Tree", "Nature", "");
        this.setSize(3, 3, 30);
        this.toggle = true;
        this.number = Constants.feature_treeBigHealth;
        break;
      case 431:
        this.setStrings("Rock", "Nature", "");
        this.setSize(3, 2, 7);
        break;
      case 441:
      case 442:
      case 443:
        this.setStrings("Bush", "Nature", "");
        this.setSize(1, 1, 5);
        this.number = Constants.feature_bushHealth;
        break;
      case 444:
      case 445:
      case 446:
      case 447:
      case 449:
        this.setStrings("Tree", "Nature", "");
        this.setSize(3, 3, 30);
        this.toggle = true;
        this.number = Constants.feature_treeBigHealth;
        break;
      case 448:
        this.setStrings("Tree", "Nature", "");
        this.setSize(4, 4, 40);
        this.toggle = true;
        this.number = round(1.4f * Constants.feature_treeBigHealth);
        break;

      // Vehicles
      case 501:
        this.setStrings("Honda CR-V", "Car", "");
        this.setSize(6, 3, 5);
        break;
      case 502:
        this.setStrings("Ford F-150", "Car", "");
        this.setSize(5, 3, 5);
        break;
      case 503:
        this.setStrings("VW Jetta", "Car", "");
        this.setSize(5, 2, 5);
        break;
      case 504:
        this.setStrings("VW Bug", "Car", "");
        this.setSize(4, 3, 5);
        break;
      case 505:
        this.setStrings("Lamborghini", "Car", "");
        this.setSize(4, 3, 5);
        break;
      case 511:
        this.setStrings("Civilian Helicopter", "Helicopter", "");
        this.setSize(5, 5, 11);
        break;
      case 512:
        this.setStrings("Medical Helicopter", "Helicopter", "");
        this.setSize(5, 4, 11);
        break;
      case 513:
        this.setStrings("Military Helicopter", "Helicopter", "");
        this.setSize(5, 4, 11);
        break;

      default:
        global.errorMessage("ERROR: Feature ID " + ID + " not found.");
        break;
    }
  }
  Feature(int ID, float x, float y) {
    this(ID);
    this.x = x;
    this.y = y;
  }
  Feature(int ID, float x, float y, boolean toggle) {
    this(ID);
    this.x = x;
    this.y = y;
    this.toggle = toggle;
  }

   public String display_name() {
    return this.display_name;
  }
   public String display_name_editor() {
    return this.display_name() + " (" + this.map_key + ")";
  }
   public String type() {
    return this.type;
  }
   public String description() {
    switch(this.ID) {
      case 21: // workbench
        String workbench_description = "Tools Available:";
        for (Item i : this.items) {
          if (i == null || i.remove) {
            continue;
          }
          workbench_description += "\n" + i.display_name() + " (" + i.durability + ")";
        }
        return workbench_description;
      case 151: // sign
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
        return trim(split(this.description, Constants.feature_signDescriptionDelimiter)[0]);
      default:
        return this.description;
    }
  }
   public String selectedObjectTextboxText() {
    String text = "-- " + this.type() + " --\n";
    if (this.car()) {
      text += "\nGas: " + 0.1f * this.number + "/" + round(0.1f * this.gasTankSize()) + " gallons";
    }
    return text + "\n\n" + this.description();
  }

   public void setLocation(float x, float y) {
    this.x = floor(x);
    this.y = floor(y);
  }

   public void setSize(int sizeX, int sizeY, int sizeZ) {
    this.sizeX = sizeX;
    this.sizeY = sizeY;
    this.sizeZ = sizeZ;
  }

   public float xi() {
    return this.x;
  }
   public float yi() {
    return this.y;
  }
   public float xf() {
    return this.x + this.sizeX;
  }
   public float yf() {
    return this.y + this.sizeY;
  }
   public float xCenter() {
    return this.x + 0.5f * this.sizeX;
  }
   public float yCenter() {
    return this.y + 0.5f * this.sizeY;
  }
   public float width() {
    return this.sizeX;
  }
   public float height() {
    return this.sizeY;
  }
   public float xRadius() {
    return 0.5f * this.sizeX;
  }
   public float yRadius() {
    return 0.5f * this.sizeY;
  }

   public boolean displaysImage() {
    switch(this.ID) {
      case 186:
      case 187:
      case 188:
      case 189:
      case 190:
        return false;
      default:
        return true;
    }
  }

   public PImage getImage() {
    String path = "features/";
    switch(this.ID) {
      case 1:
        path += "fog0.png";
        break;
      case 2:
        path += "fog1.png";
        break;
      case 3:
        path += "fog2.png";
        break;
      case 4:
        path += "fog3.png";
        break;
      case 5:
        path += "fog4.png";
        break;
      case 6:
        path += "fog5.png";
        break;
      case 7:
        path += "fog6.png";
        break;
      case 8:
        path += "fog7.png";
        break;
      case 9:
        path += "fog8.png";
        break;
      case 10:
        path += "fog9.png";
        break;
      case 11:
        path += "khalil.jpg";
        break;
      case 12:
        path += "chuck_quizmo.png";
        break;
      case 21:
        path += "workbench.jpg";
        break;
      case 22:
        path += "ender_chest_closed.png";
        break;
      case 101:
        path += "table.png";
        break;
      case 102:
        path += "desk_up.png";
        break;
      case 103:
        path += "desk_left.png";
        break;
      case 104:
        path += "desk_down.png";
        break;
      case 105:
        path += "desk_right.png";
        break;
      case 106:
        path += "table_small_up.png";
        break;
      case 107:
        path += "table_small_left.png";
        break;
      case 108:
        path += "table_blue.png";
        break;
      case 111:
        path += "chair_up.png";
        break;
      case 112:
        path += "chair_down.png";
        break;
      case 113:
        path += "chair_left.png";
        break;
      case 114:
        path += "chair_right.png";
        break;
      case 115:
        path += "chair_green.png";
        break;
      case 121:
        path += "couch_up.png";
        break;
      case 122:
        path += "couch_down.png";
        break;
      case 123:
        path += "couch_left.png";
        break;
      case 124:
        path += "couch_right.png";
        break;
      case 125:
        path += "bench_small_up.png";
        break;
      case 126:
        path += "bench_small_left.png";
        break;
      case 127:
        path += "bench_large_up.png";
        break;
      case 128:
        path += "bench_large_left.png";
        break;
      case 129:
        path += "bench_small_down.png";
        break;
      case 130:
        path += "bench_small_right.png";
        break;
      case 131:
        path += "bed_up.png";
        break;
      case 132:
        path += "bed_down.png";
        break;
      case 133:
        path += "bed_left.png";
        break;
      case 134:
        path += "bed_right.png";
        break;
      case 141:
        path += "wardrobe_up.png";
        break;
      case 142:
        path += "wardrobe_left.png";
        break;
      case 151:
        path += "sign_green_up.png";
        break;
      case 152:
        path += "sign_green_down.png";
        break;
      case 153:
        path += "sign_green_left.png";
        break;
      case 154:
        path += "sign_green_right.png";
        break;
      case 155:
        path += "sign_gray_up.png";
        break;
      case 156:
        path += "sign_gray_down.png";
        break;
      case 157:
        path += "sign_gray_left.png";
        break;
      case 158:
        path += "sign_gray_right.png";
        break;
      case 161:
        path += "water_fountain.png";
        break;
      case 162:
        path += "sink.png";
        break;
      case 163:
        path += "shower_stall.png";
        break;
      case 164:
        path += "urinal.png";
        break;
      case 165:
        path += "toilet.png";
        break;
      case 171:
        path += "stove.png";
        break;
      case 172:
        path += "vending_machine_food.png";
        break;
      case 173:
        path += "vending_machine_drink.png";
        break;
      case 174:
        path += "minifridge.png";
        break;
      case 175:
        path += "fridge.png";
        break;
      case 176:
        path += "washer.png";
        break;
      case 177:
        path += "dryer.png";
        break;
      case 178:
        path += "microwave.png";
        break;
      case 179:
        path += "tv.png";
        break;
      case 180:
        if (this.toggle) {
          path += "lamp_on.png";
        }
        else {
          path += "lamp.png";
        }
        break;
      case 181:
        path += "garbage_can.png";
        break;
      case 182:
        path += "recycle_can.png";
        break;
      case 183:
        path += "crate.png";
        break;
      case 184:
        path += "cardboard_box.png";
        break;
      case 185:
        path += "pickle_jar.png";
        break;
      case 186:
      case 187:
      case 188:
      case 189:
      case 190:
        path = "transparent.png";
        break;
      case 191:
        path += "railing_green_up.png";
        break;
      case 192:
        path += "railing_green_left.png";
        break;
      case 193:
        path += "railing_red_up.png";
        break;
      case 194:
        path += "railing_red_left.png";
        break;
      case 195:
        if (this.toggle) {
          path += "switch_up_on.png";
        }
        else {
          path += "switch_up_off.png";
        }
        break;
      case 196:
        if (this.toggle) {
          path += "switch_down_on.png";
        }
        else {
          path += "switch_down_off.png";
        }
        break;
      case 197:
        if (this.toggle) {
          path += "switch_left_on.png";
        }
        else {
          path += "switch_left_off.png";
        }
        break;
      case 198:
        if (this.toggle) {
          path += "switch_right_on.png";
        }
        else {
          path += "switch_right_off.png";
        }
        break;
      case 201:
        path += "steel_cross.png";
        break;
      case 202:
        path += "mary_statue.png";
        break;
      case 211:
        path += "fence_gray_up.png";
        break;
      case 212:
        path += "fence_gray_left.png";
        break;
      case 213:
        path += "fence_gray_upleft.png";
        break;
      case 214:
        path += "fence_gray_leftdown.png";
        break;
      case 215:
        path += "fence_gray_downright.png";
        break;
      case 216:
        path += "fence_gray_rightup.png";
        break;
      case 217:
        path += "fence_gray_diagonal_upleft.png";
        break;
      case 218:
        path += "fence_gray_diagonal_upright.png";
        break;
      case 219:
        path += "fence_gray_up_downleft.png";
        break;
      case 220:
        path += "fence_gray_up_downright.png";
        break;
      case 221:
        path += "fence_gray_down_upleft.png";
        break;
      case 222:
        path += "fence_gray_down_upright.png";
        break;
      case 223:
        path += "fence_gray_left_rightup.png";
        break;
      case 224:
        path += "fence_gray_left_rightdown.png";
        break;
      case 225:
        path += "fence_gray_right_leftup.png";
        break;
      case 226:
        path += "fence_gray_right_leftdown.png";
        break;
      case 231:
        path += "fence_green_up.png";
        break;
      case 232:
        path += "fence_green_left.png";
        break;
      case 233:
        path += "fence_green_upleft.png";
        break;
      case 234:
        path += "fence_green_leftdown.png";
        break;
      case 235:
        path += "fence_green_downright.png";
        break;
      case 236:
        path += "fence_green_rightup.png";
        break;
      case 237:
        path += "fence_green_diagonal_upleft.png";
        break;
      case 238:
        path += "fence_green_diagonal_upright.png";
        break;
      case 239:
        path += "fence_green_up_downleft.png";
        break;
      case 240:
        path += "fence_green_up_downright.png";
        break;
      case 241:
        path += "fence_green_down_upleft.png";
        break;
      case 242:
        path += "fence_green_down_upright.png";
        break;
      case 243:
        path += "fence_green_left_rightup.png";
        break;
      case 244:
        path += "fence_green_left_rightdown.png";
        break;
      case 245:
        path += "fence_green_right_leftup.png";
        break;
      case 246:
        path += "fence_green_right_leftdown.png";
        break;
      case 251:
        path += "parking_bumper_up.png";
        break;
      case 252:
        path += "parking_bumper_left.png";
        break;
      case 253:
        path += "gazebo.png";
        break;
      case 301:
        path = "terrain/brickWall_blue.jpg";
        break;
      case 302:
        path = "terrain/brickWall_gray.jpg";
        break;
      case 303:
        path = "terrain/brickWall_green.jpg";
        break;
      case 304:
        path = "terrain/brickWall_pink.jpg";
        break;
      case 305:
        path = "terrain/brickWall_red.jpg";
        break;
      case 306:
        path = "terrain/brickWall_yellow.jpg";
        break;
      case 307:
        path = "terrain/brickWall_white.jpg";
        break;
      case 311:
        path += "pillar_gray.png";
        break;
      case 312:
        path += "pillar_red.jpg";
        break;
      case 321:
        path += "window_open.jpg";
        break;
      case 322:
        path += "window_closed.jpg";
        break;
      case 323:
        path += "window_locked.jpg";
        break;
      case 331:
        path += "door_open_up_lefthinges.png";
        break;
      case 332:
        path += "door_open_up_righthinges.png";
        break;
      case 333:
        path += "door_open_left_uphinges.png";
        break;
      case 334:
        path += "door_open_left_downhinges.png";
        break;
      case 335:
        path += "door_open_diagonalleft_uphinges.png";
        break;
      case 336:
        path += "door_open_diagonalleft_downhinges.png";
        break;
      case 337:
        path += "door_open_diagonalright_uphinges.png";
        break;
      case 338:
        path += "door_open_diagonalright_downhinges.png";
        break;
      case 339:
        path += "door_closed_up.png";
        break;
      case 340:
        path += "door_closed_left.png";
        break;
      case 341:
        path += "door_closed_diagonalleft.png";
        break;
      case 342:
        path += "door_closed_diagonalright.png";
        break;
      case 343:
        path += "door_locked_up.png";
        break;
      case 344:
        path += "door_locked_left.png";
        break;
      case 345:
        path += "door_locked_diagonalleft.png";
        break;
      case 346:
        path += "door_locked_diagonalright.png";
        break;
      case 351:
        path += "steeldoor_open_up_lefthinges.png";
        break;
      case 352:
        path += "steeldoor_open_up_righthinges.png";
        break;
      case 353:
        path += "steeldoor_open_left_uphinges.png";
        break;
      case 354:
        path += "steeldoor_open_left_downhinges.png";
        break;
      case 355:
        path += "steeldoor_open_diagonalleft_uphinges.png";
        break;
      case 356:
        path += "steeldoor_open_diagonalleft_downhinges.png";
        break;
      case 357:
        path += "steeldoor_open_diagonalright_uphinges.png";
        break;
      case 358:
        path += "steeldoor_open_diagonalright_downhinges.png";
        break;
      case 359:
        path += "steeldoor_closed_up.png";
        break;
      case 360:
        path += "steeldoor_closed_left.png";
        break;
      case 361:
        path += "steeldoor_closed_diagonalleft.png";
        break;
      case 362:
        path += "steeldoor_closed_diagonalright.png";
        break;
      case 363:
        path += "steeldoor_locked_up.png";
        break;
      case 364:
        path += "steeldoor_locked_left.png";
        break;
      case 365:
        path += "steeldoor_locked_diagonalleft.png";
        break;
      case 366:
        path += "steeldoor_locked_diagonalright.png";
        break;
      case 401:
        path += "dandelion.png";
        break;
      case 411:
        path += "gravel_pebbles.jpg";
        break;
      case 412:
        path += "gravel_rocks.jpg";
        break;
      case 421:
      case 444:
        path += "tree_maple.png";
        break;
      case 422:
      case 445:
        path += "tree_unknown.png";
        break;
      case 423:
      case 446:
        path += "tree_cedar.png";
        break;
      case 424:
      case 447:
        path += "tree_dead.png";
        break;
      case 425:
      case 448:
        path += "tree_large.png";
        break;
      case 426:
      case 449:
        path += "tree_pine.png";
        break;
      case 431:
        path += "rock.png";
        break;
      case 441:
        path += "bush_light.png";
        break;
      case 442:
        path += "bush_dark.png";
        break;
      case 443:
        path += "bush_evergreen.png";
        break;
      case 501:
        path += "car_hondacrv.png";
        break;
      case 502:
        path += "car_fordf150.png";
        break;
      case 503:
        path += "car_vwjetta.png";
        break;
      case 504:
        path += "car_vwbug.png";
        break;
      case 505:
        path += "car_lamborghini.png";
        break;
      case 511:
        path += "helicopter_civilian.png";
        break;
      case 512:
        path += "helicopter_medical.png";
        break;
      case 513:
        path += "helicopter_military.png";
        break;
      default:
        global.errorMessage("ERROR: Feature ID " + ID + " not found.");
        path += "default.png";
        break;
    }
    return global.images.getImage(path);
  }


   public boolean ignoreSquare(int i, int j) {
    switch(this.ID) {
      case 448: // Tree large, large
        if (i == 0 || i == 3) {
          if (j == 0 || j == 3) {
            return true;
          }
        }
        break;
      case 501: // Honda CRV
        if (i == 0 && j == 0) {
          return true;
        }
        if (i == 1 && j == 0) {
          return true;
        }
        if (i == 0 && j == 2) {
          return true;
        }
        if (i == 2 && j == 2) {
          return true;
        }
        if (i == 3 && j == 2) {
          return true;
        }
        if (i == 4 && j == 2) {
          return true;
        }
        if (i == 5 && j == 2) {
          return true;
        }
        break;
      case 502: // Ford F150
        if (i == 0 && j == 0) {
          return true;
        }
        if (i == 1 && j == 0) {
          return true;
        }
        if (i == 4 && j == 0) {
          return true;
        }
        if (i == 0 && j == 2) {
          return true;
        }
        if (i == 1 && j == 2) {
          return true;
        }
        if (i == 2 && j == 2) {
          return true;
        }
        if (i == 3 && j == 2) {
          return true;
        }
        if (i == 4 && j == 2) {
          return true;
        }
        if (i == 5 && j == 2) {
          return true;
        }
        break;
      case 503: // VW Jetta
        if (i == 0 && j == 0) {
          return true;
        }
        break;
      case 504: // VW Beetle
        if (i == 0 && j == 0) {
          return true;
        }
        if (i == 3 && j == 0) {
          return true;
        }
        if (i == 0 && j == 2) {
          return true;
        }
        if (i == 1 && j == 2) {
          return true;
        }
        if (i == 3 && j == 2) {
          return true;
        }
        break;
      case 505: // Lamborghini
        if (i == 2 && j == 0) {
          return true;
        }
        if (i == 3 && j == 0) {
          return true;
        }
        if (i == 0 && j == 2) {
          return true;
        }
        break;
      default:
        return false;
    }
    return false;
  }


  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    if (!this.hovered) {
      return;
    }
    int i = round(floor(mX - this.xi()));
    int j = round(floor(mY - this.yi()));
    if (this.ignoreSquare(i, j)) {
      this.hovered = false;
    }
  }


   public boolean car() {
    return this.type.equals("Car");
  }

   public int gasTankSize() {
    switch(this.ID) {
      case 501: // Honda CRV
      case 502: // Ford F150
      case 503: // VW Jetta
      case 504: // VW Beetle
      case 505: // Lamborghini
        return 150;
      default:
        return 0;
    }
  }


   public boolean targetable(Unit u) {
    if (this.targetableByUnit()) {
      return true;
    }
    else if (this.targetableByHeroOnly() && Hero.class.isInstance(u)) {
      return true;
    }
    return false;
  }

   public boolean targetableByUnit() {
    switch(this.ID) {
      case 101: // wooden table
      case 102: // desk
      case 103:
      case 104:
      case 105:
      case 106: // small wooden table
      case 107:
      case 108: // ping pong table
      case 111: // wooden chair
      case 112:
      case 113:
      case 114:
      case 115: // coordinator chair
      case 121: // couch
      case 122:
      case 123:
      case 124:
      case 125: // wooden bench
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131: // bed
      case 132:
      case 133:
      case 134:
      case 141: // wardrobe
      case 142:
      case 161: // water fountain
      case 162: // sink
      case 163: // shower stall
      case 164: // urinal
      case 165: // toilet
      case 185: // pickle jar
      case 211: // wire fence
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
      case 231: // barbed wire fence
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
      case 321: // window (open)
      case 322: // window (closed)
      case 323: // window (locked)
      case 331: // wooden door (open)
      case 332:
      case 333:
      case 334:
      case 335:
      case 336:
      case 337:
      case 338:
      case 339: // wooden door (closed)
      case 340:
      case 341:
      case 342:
      case 343: // wooden door (locked)
      case 344:
      case 345:
      case 346:
      case 351: // steel door (open)
      case 352:
      case 353:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
      case 359: // steel door (closed)
      case 360:
      case 361:
      case 362:
      case 363: // steel door (locked)
      case 364:
      case 365:
      case 366:
      case 401: // dandelion
      case 411: // gravel
      case 412:
      case 421: // tree
      case 422:
      case 423:
      case 424:
      case 425:
      case 426:
      case 441: // bush
      case 442:
      case 443:
      case 444: // large trees
      case 445:
      case 446:
      case 447:
      case 448:
      case 449:
        return true;
      default:
        return false;
    }
  }

   public boolean targetableByHeroOnly() {
    switch(this.ID) {
      case 11: // khalil
      case 12: // chuck quizmo
      case 21: // workbench
      case 22: // ender chest
      case 151: // sign
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
      case 171: // stove
      case 172: // vending machine
      case 173:
      case 174: // minifridge
      case 175: // refridgerator
      case 176: // washer
      case 177: // dryer
      case 178: // microwave
      case 180: // lamp
      case 181: // garbage can
      case 182: // recycle can
      case 183: // crate
      case 184: // cardboard box
      case 195: // light switch
      case 196:
      case 197:
      case 198:
      case 301: // movable brick wall
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 501: // cars
      case 502:
      case 503:
      case 504:
      case 505:
        return true;
      default:
        return false;
    }
  }


   public float interactionDistance() {
    switch(this.ID) {
      default:
        return Constants.feature_defaultInteractionDistance;
    }
  }


   public boolean onInteractionCooldown() {
    switch(this.ID) {
      case 151: // sign
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
      case 163: // shower stall
      case 164: // urinal
      case 165: // toilet
      case 185: // pickle jar
        if (this.number > 0) {
          return true;
        }
        break;
      default:
        return false;
    }
    return false;
  }


   public float interactionTime() {
    switch(this.ID) {
      case 101: // wooden table
      case 106: // small wooden table
      case 107:
      case 108: // ping pong table
      case 111: // wooden chair
      case 112:
      case 113:
      case 114:
      case 115: // coordinator chair
      case 121: // couch
      case 122:
      case 123:
      case 124:
      case 131: // bed
      case 132:
      case 133:
      case 134:
      case 141: // wardrobe
      case 142:
        return Constants.feature_furnitureInteractionTime;
      case 211: // wire fence
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
      case 231: // barbed wire fence
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
        return Constants.feature_wireFenceInteractionTime;
      case 301: // movable brick wall
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
        return Constants.feature_movableBrickWallInteractionTime;
      case 411: // gravel
      case 412:
        return Constants.feature_gravelInteractionTime;
      case 421: // tree
      case 422:
      case 423:
      case 424:
      case 425:
      case 426:
      case 444: // large trees
      case 445:
      case 446:
      case 447:
      case 448:
      case 449:
        return Constants.feature_treeInteractionTime;
      case 441: // bush
      case 442:
      case 443:
        return Constants.feature_bushInteractionTime;
      default:
        return 0;
    }
  }


   public ArrayList<Integer> drops() {
    ArrayList<Integer> id_list = new ArrayList<Integer>();
    switch(this.ID) {
      case 101: // wooden table
      case 102: // desk
      case 103:
      case 104:
      case 105:
      case 106: // small wooden table
      case 107:
      case 108: // ping pong table
      case 111: // wooden chair
      case 112:
      case 113:
      case 114:
      case 125: // wooden bench
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 115: // coordinator chair
      case 121: // couch
      case 122:
      case 123:
      case 124:
      case 131: // bed
      case 132:
      case 133:
      case 134:
      case 141: // wardrobe
      case 142:
        // wooden board, maybe nails / screws / wooden "piece" (small piece)
        break;
      case 185: // pickle jar
        id_list.add(2805);
        break;
      case 211: // wire fence
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
        id_list.add(2806);
        break;
      case 321: // window
      case 322:
      case 323:
        id_list.add(2805);
        id_list.add(2805);
        break;
      case 331: // wooden door
      case 332:
      case 333:
      case 334:
      case 335:
      case 336:
      case 337:
      case 338:
      case 339:
      case 340:
      case 341:
      case 342:
      case 343:
      case 344:
      case 345:
      case 346:
        // wooden board, maybe nails / screws / wooden "piece" (small piece)
        break;
      case 421: // tree
      case 422:
      case 423:
      case 424:
      case 426:
        id_list.add(2969);
        id_list.add(2969);
        break;
      case 425: // tree (large)
      case 444: // large trees
      case 445:
      case 446:
      case 447:
      case 449:
        id_list.add(2969);
        id_list.add(2969);
        id_list.add(2969);
        break;
      case 448: // large tree (large)
        id_list.add(2969);
        id_list.add(2969);
        id_list.add(2969);
        id_list.add(2969);
        break;
      default:
        break;
    }
    return id_list;
  }


   public float lightPercentageBlocked() {
    switch(this.ID) {
      case 172: // vending machine
      case 173: // vending machine
      case 175: // fridge
      case 201: // steel cross
      case 301: // movable brick wall
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 311: // pillar
      case 312: // pillar
      case 339: // wooden door (closed)
      case 340:
      case 341:
      case 342:
      case 343: // wooden door (locked)
      case 344:
      case 345:
      case 346:
      case 359: // steel door (closed)
      case 360:
      case 361:
      case 362:
      case 363: // steel door (locked)
      case 364:
      case 365:
      case 366:
        return 1;
      case 321: // window
      case 322:
      case 323:
        return 0.05f;
      case 421: // tree
      case 422:
      case 423:
      case 424:
      case 425:
      case 426:
      case 444:
      case 445:
      case 446:
      case 447:
      case 448:
      case 449:
        return 0.7f;
      default:
        return 0;
    }
  }


   public void destroy(AbstractGameMap map) {
    this.remove = true;
    for (int id : this.drops()) {
      map.addItem(new Item(id, this.x + 0.2f + random(0.6f + this.sizeX - 1),
        this.y + 0.2f + random(0.6f + this.sizeY - 1)));
    }
    if (this.inventory != null) {
      for (Item i : this.inventory.items()) {
        map.addItem(new Item(i, this.x + 0.2f + random(0.6f + this.sizeX - 1),
          this.y + 0.2f + random(0.6f + this.sizeY - 1)));
      }
    }
    // visual effects
    switch(this.ID) {
      case 12: // chuck quizmo
        map.addVisualEffect(4002, this.xCenter(), this.yCenter());
        break;
    }
  }


   public void interact(Unit u, AbstractGameMap map) {
    this.interact(u, map, false);
  }
   public void interact(Unit u, AbstractGameMap map, boolean use_item) {
    if (Hero.class.isInstance(u)) {
      if (use_item) {
        u.curr_action = UnitAction.HERO_INTERACTING_WITH_FEATURE_WITH_ITEM;
      }
      else {
        u.curr_action = UnitAction.HERO_INTERACTING_WITH_FEATURE;
      }
      return;
    }
    if (u.weapon() == null) {
      use_item = false;
    }
    Item new_i;
    // Non-hero interaction with feature
    switch(this.ID) {
      case 101: // wooden table
      case 102: // wooden desk
      case 103:
      case 104:
      case 105:
      case 106: // small wooden table
      case 107:
      case 108: // ping pong table
      case 111: // wooden chair
      case 112:
      case 113:
      case 114:
      case 115: // coordinator chair
      case 121: // couch
      case 122:
      case 123:
      case 124:
      case 125: // wooden bench
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
      case 131: // Bed
      case 132:
      case 141: // Wardrobe
      case 142:
        if (!u.holding(2977, 2979, 2980, 2981, 2983)) {
          break;
        }
        switch(u.weapon().ID) {
          case 2977: // Ax
            this.number -= 3;
            global.sounds.trigger_units("items/melee/ax",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 2979: // Saw
            this.number -= 1;
            global.sounds.trigger_units("items/saw_cut_wood",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 2980: // Drill
            this.number -= 1;
            global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 2981: // Roundsaw
            this.number -= 2;
            global.sounds.trigger_units("items/roundsaw_cut_wood",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 2983: // Chainsaw
            this.number -= 2;
            global.sounds.trigger_units("items/chainsaw_long",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
        }
        u.weapon().lowerDurability();
        if (this.number < 1) {
          this.destroy(map);
        }
        break;
      case 161: // Water Fountain
        global.sounds.trigger_environment("features/water_fountain",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 162: // Sink
        global.sounds.trigger_environment("features/sink",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 163: // Shower Stall
        this.number = Constants.feature_showerStallCooldown;
        global.sounds.trigger_environment("features/shower_stall",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 164: // urinal
        this.number = Constants.feature_urinalCooldown;
        global.sounds.trigger_environment("features/urinal",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 165: // toilet
        this.number = Constants.feature_toiletCooldown;
        global.sounds.trigger_environment("features/toilet",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 185: // pickle jar
        if (use_item && u.holding(2975)) {
          this.destroy(map);
          global.sounds.trigger_environment("items/glass_bottle_hit",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          break;
        }
        if (u.canPickup()) {
          this.number = Constants.feature_pickleJarCooldown;
          new_i = new Item(2106);
          u.pickup(new_i);
          new_i.pickupSound();
        }
        break;
      case 211: // wire fence
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
        if (use_item && u.holding(2978)) {
          this.destroy(map);
          u.weapon().lowerDurability();
          global.sounds.trigger_environment("items/wire_clipper",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          break;
        }
        else if (u.agility() >= 2) {
          u.setLocation(this.xCenter(), this.yCenter());
          global.sounds.trigger_units("features/climb_fence",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          if (randomChance(0.3f)) {
            u.addStatusEffect(StatusEffectCode.BLEEDING, 2000);
          }
        }
        break;
      case 231: // barbed wire fence
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
        if (u.agility() >= 3) {
          u.setLocation(this.xCenter(), this.yCenter());
          global.sounds.trigger_units("features/climb_fence",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          if (randomChance(0.8f)) {
            u.addStatusEffect(StatusEffectCode.BLEEDING, 2500);
          }
        }
        break;
      case 321: // window (open)
        if (use_item && u.holding(2976)) {
          this.destroy(map);
          u.weapon().lowerDurability();
          global.sounds.trigger_environment("items/window_break",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          break;
        }
        this.remove = true;
        map.addFeature(new Feature(322, this.x, this.y));
        global.sounds.trigger_environment("features/window_close",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 322: // window (closed)
        if (use_item && u.holding(2976)) {
          this.destroy(map);
          u.weapon().lowerDurability();
          global.sounds.trigger_environment("items/window_break",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
          break;
        }
        this.remove = true;
        map.addFeature(new Feature(321, this.x, this.y));
        global.sounds.trigger_environment("features/window_open",
          this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 323: // window (locked)
        if (!u.holding(2976)) {
          break;
        }
        this.destroy(map);
        u.weapon().lowerDurability();
        global.sounds.trigger_environment("items/window_break",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        break;
      case 331: // wooden door (open)
      case 332:
      case 333:
      case 334:
      case 335:
      case 336:
      case 337:
      case 338:
      case 339: // wooden door (closed)
      case 340:
      case 341:
      case 342:
      case 343: // wooden door (locked)
      case 344:
      case 345:
      case 346:
        if (use_item && u.holding(2977, 2979, 2983)) {
          this.destroy(map);
          u.weapon().lowerDurability();
          break;
        }
        switch(this.ID) {
          case 331: // door open (up)
            this.remove = true;
            map.addFeature(new Feature(339, this.x, this.y, false));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 332:
            this.remove = true;
            map.addFeature(new Feature(339, this.x, this.y, true));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 333: // door open (left)
            this.remove = true;
            map.addFeature(new Feature(340, this.x, this.y, false));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 334:
            this.remove = true;
            map.addFeature(new Feature(340, this.x, this.y, true));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 335: // door open (diagonal left)
            this.remove = true;
            map.addFeature(new Feature(341, this.x, this.y, false));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 336:
            this.remove = true;
            map.addFeature(new Feature(341, this.x, this.y, true));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 337: // door open (diagonal right)
            this.remove = true;
            map.addFeature(new Feature(342, this.x, this.y, false));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 338:
            this.remove = true;
            map.addFeature(new Feature(342, this.x, this.y, true));
            global.sounds.trigger_environment("features/wooden_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 339: // door closed (up)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(332, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(331, this.x, this.y));
            }
            global.sounds.trigger_environment("features/wooden_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 340: // door closed (left)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(334, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(333, this.x, this.y));
            }
            global.sounds.trigger_environment("features/wooden_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 341: // door closed (diagonal left)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(336, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(335, this.x, this.y));
            }
            global.sounds.trigger_environment("features/wooden_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 342: // door closed (diagonal right)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(338, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(337, this.x, this.y));
            }
            global.sounds.trigger_environment("features/wooden_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 343: // door locked (up)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(339, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/wooden_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 344: // door locked (left)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(340, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/wooden_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 345: // door locked (diagonal left)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(341, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/wooden_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 346: // door locked (diagonal right)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(342, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/wooden_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
        }
        break;
      case 351: // steel door (open)
      case 352:
      case 353:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
      case 359: // steel door (closed)
      case 360:
      case 361:
      case 362:
      case 363: // steel door (locked)
      case 364:
      case 365:
      case 366:
        switch(this.ID) {
          case 351: // door open (up)
            this.remove = true;
            map.addFeature(new Feature(359, this.x, this.y, false));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 352:
            this.remove = true;
            map.addFeature(new Feature(359, this.x, this.y, true));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 353: // door open (left)
            this.remove = true;
            map.addFeature(new Feature(360, this.x, this.y, false));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 354:
            this.remove = true;
            map.addFeature(new Feature(360, this.x, this.y, true));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 355: // door open (diagonal left)
            this.remove = true;
            map.addFeature(new Feature(361, this.x, this.y, false));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 356:
            this.remove = true;
            map.addFeature(new Feature(361, this.x, this.y, true));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 357: // door open (diagonal right)
            this.remove = true;
            map.addFeature(new Feature(362, this.x, this.y, false));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 358:
            this.remove = true;
            map.addFeature(new Feature(362, this.x, this.y, true));
            global.sounds.trigger_environment("features/steel_door_close",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 359: // door closed (up)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(352, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(351, this.x, this.y));
            }
            global.sounds.trigger_environment("features/steel_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 360: // door closed (left)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(354, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(353, this.x, this.y));
            }
            global.sounds.trigger_environment("features/steel_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 361: // door closed (diagonal left)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(356, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(355, this.x, this.y));
            }
            global.sounds.trigger_environment("features/steel_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 362: // door closed (diagonal right)
            this.remove = true;
            if (this.toggle) {
              map.addFeature(new Feature(358, this.x, this.y));
            }
            else {
              map.addFeature(new Feature(357, this.x, this.y));
            }
            global.sounds.trigger_environment("features/steel_door_open",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 363: // door locked (up)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(359, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/steel_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 364: // door locked (left)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(360, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/steel_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 365: // door locked (diagonal left)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(361, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/steel_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
          case 366: // door locked (diagonal right)
            if (u.weapon() == null || !u.weapon().unlocks(this.number)) {
              break;
            }
            this.remove = true;
            map.addFeature(new Feature(362, this.x, this.y, this.toggle));
            global.sounds.trigger_environment("features/steel_door_unlock",
              this.xCenter() - map.viewX, this.yCenter() - map.viewY);
            break;
        }
        break;
      case 401: // dandelion
        if (u.canPickup()) {
          this.remove = true;
          new_i = new Item(2961);
          u.pickup(new_i);
          new_i.pickupSound();
        }
        break;
      case 411: // gravel (pebbles)
        if (u.canPickup()) {
          new_i = new Item(2933);
          u.pickup(new_i);
          new_i.pickupSound();
          this.number--;
          if (this.number < 1) {
            this.remove = true;
            map.setTerrain(134, PApplet.parseInt(floor(this.x)), PApplet.parseInt(floor(this.y)));
          }
        }
        break;
      case 412: // gravel (rocks)
        if (u.canPickup()) {
          new_i = new Item(2931);
          u.pickup(new_i);
          new_i.pickupSound();
          this.number--;
          if (this.number < 1) {
            this.remove = true;
            map.addFeature(new Feature(411, this.x, this.y));
          }
        }
        break;
      case 421: // Tree (maple)
      case 422: // Tree (unknown)
      case 423: // Tree (cedar)
      case 424: // Tree (dead)
      case 425: // Tree (large)
      case 426: // Tree (pine)
      case 444: // large trees
      case 445:
      case 446:
      case 447:
      case 448:
      case 449:
        int branch_id = 0;
        switch(this.ID) {
          case 421:
          case 444:
            branch_id = 2965;
            break;
          case 422:
          case 445:
            branch_id = 2966;
            break;
          case 423:
          case 446:
            branch_id = 2967;
            break;
          case 424:
          case 447:
            branch_id = 2963;
            break;
          case 425:
          case 448:
            branch_id = 2965;
            break;
          case 426:
          case 449:
            branch_id = 2968;
            break;
        }
        if (!use_item || !u.holding(2977, 2979, 2981, 2983)) {
          if (this.toggle) {
            map.addItem(new Item(branch_id, u.frontX(), u.frontY()));
            if (randomChance(Constants.feature_treeChanceEndBranches)) {
              this.toggle = false;
            }
          }
        }
        else {
          switch(u.weapon().ID) {
            case 2977: // Ax
              this.number -= 2;
              global.sounds.trigger_units("items/melee/ax",
                this.xCenter() - map.viewX, this.yCenter() - map.viewY);
              break;
            case 2979: // Saw
              this.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood",
                this.xCenter() - map.viewX, this.yCenter() - map.viewY);
              break;
            case 2981: // Roundsaw
              this.number -= 2;
              global.sounds.trigger_units("items/roundsaw_cut_wood",
                this.xCenter() - map.viewX, this.yCenter() - map.viewY);
              break;
            case 2983: // Chainsaw
              this.number -= 4;
              global.sounds.trigger_units("items/chainsaw_long",
                this.xCenter() - map.viewX, this.yCenter() - map.viewY);
              break;
          }
          u.weapon().lowerDurability();
          if (randomChance(Constants.feature_treeDropChance)) {
            map.addItem(new Item(branch_id, u.frontX(), u.frontY()));
          }
          if (this.number < 1) {
            this.destroy(map);
          }
        }
        break;
      case 441: // Bush
      case 442:
      case 443:
        if (u.holding(2204, 2211)) {
          this.number--;
          if (randomChance(Constants.feature_bushDropChance)) {
            map.addItem(new Item(2964, this.x + 0.2f + random(0.6f), this.y + 0.2f + random(0.6f)));
          }
          u.weapon().lowerDurability();
          if (this.number < 1) {
            this.remove = true;
          }
          global.sounds.trigger_units("features/sword_bush",
            this.xCenter() - map.viewX, this.yCenter() - map.viewY);
        }
        break;
      default:
        global.errorMessage("ERROR: Unit " + u.display_name() + " trying to " +
          "interact with feature " + this.display_name() + " but no interaction logic found.");
        break;
    }
  }


   public boolean switchable() { // can be toggled with light switch
    switch(this.ID) {
      case 180: // lamp
      case 186: // outside light source
      case 187: // invisible light source
      case 188:
      case 189:
      case 190:
        return true;
      default:
        return false;
    }
  }


   public void update(int timeElapsed, AbstractGameMap map) {
    this.update(timeElapsed);
    switch(this.ID) {
      case 21: // workbench
        for (int i = 0; i < this.items.size(); i++) {
          if (this.items.get(i) == null || this.items.get(i).remove) {
            this.items.remove(i);
            i--;
          }
        }
        break;
      case 180: // lamp
        if (!toggle) {
          break;
        }
        try {
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y)).light_level = 9;
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y)).light_source = true;
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y + 1)).light_level = 9;
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y + 1)).light_source = true;
        } catch(NullPointerException e) {}
        break;
      case 186: // outside light source
        try {
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y + 1)).light_level = map.base_light_level;
          map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y + 1)).light_source = true;
        } catch(NullPointerException e) {}
        break;
      case 187: // invisible light source
      case 188:
      case 189:
      case 190:
        if (!toggle) {
          break;
        }
        try {
          for (int i = PApplet.parseInt(this.x); i < PApplet.parseInt(this.x + this.sizeX); i++) {
            for (int j = PApplet.parseInt(this.y); j < PApplet.parseInt(this.y + this.sizeY); j++) {
              map.mapSquare(i, j).light_level = 10;
              map.mapSquare(i, j).light_source = true;
            }
          }
        } catch(NullPointerException e) {}
        break;
      case 195: // light switch
      case 196:
      case 197:
      case 198:
        Feature light = map.getFeature(this.number);
        if (light == null || light.remove || !light.switchable()) {
          break;
        }
        if (this.toggle && !light.toggle) {
          light.toggle = true;
          light.refresh_map_image = true;
        }
        else if (!this.toggle && light.toggle) {
          light.toggle = false;
          light.refresh_map_image = true;
        }
        break;
      default:
        break;
    }
  }

   public void update(int timeElapsed) {
    switch(this.ID) {
      case 151: // sign
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
      case 163: // shower stall
      case 164: // urinal
      case 165: // toilet
      case 185: // pickle jar
        if (this.number < 0) {
          break;
        }
        this.number -= timeElapsed;
        break;
      default:
        break;
    }
  }


   public void createKhalilInventory() {
    if (this.ID != 11 || this.inventory != null) {
      return;
    }
    this.inventory = getKhalilInventory(this.number);
  }


   public String fileString() {
    String fileString = "\nnew: Feature: " + this.ID;
    fileString += this.objectFileString();
    fileString += "\nnumber: " + this.number;
    fileString += "\ntoggle: " + this.toggle;
    if (this.inventory != null && this.ID != 22) {
      fileString += this.inventory.internalFileString();
    }
    if (this.items != null) {
      for (Item i : this.items) {
        fileString += i.fileString() + ": item_array";
      }
    }
    switch(this.ID) {
      case 151: // Sign, green
      case 152:
      case 153:
      case 154:
      case 155: // Sign, gray
      case 156:
      case 157:
      case 158:
        fileString += "\ndescription: " + this.description;
        break;
      default:
        break;
    }
    fileString += "\nend: Feature\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    if (this.addObjectData(datakey, data)) {
      return;
    }
    switch(datakey) {
      case "number":
        this.number = toInt(data);
        break;
      case "toggle":
        this.toggle = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for feature data.");
        break;
    }
  }


   public boolean isFog() {
    switch(this.ID) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        return true;
      default:
        return false;
    }
  }
}
// default to if file does not exist create file
 public void mkFile(String path) {
  mkFile(path, false);
}
 public void mkFile(String path, boolean replace) {
  mkFile(Paths.get(sketchPath(path)), replace);
}
 public void mkFile(Path p, boolean replace) {
  if (!Files.exists(p)) {
    try {
      Files.createFile(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkFile(" + p + ")");
    }
  }
  else if (replace && !Files.isDirectory(p)) {
    deleteFile(p);
    try {
      Files.createFile(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkFile(" + p + ")");
    }
  }
}

// move file
 public void moveFile(String source_path, String target_path) {
  moveFile(Paths.get(sketchPath(source_path)), Paths.get(sketchPath(target_path)));
}
 public void moveFile(Path source, Path target) {
  try {
    Files.move(source, target);
  } catch(IOException e) {
    println("ERROR: IOException at moveFile(" + source + ", " + target + ")");
  }
}

// copy file
 public void copyFile(String source_path, String target_path) {
  copyFile(Paths.get(sketchPath(source_path)), Paths.get(sketchPath(target_path)));
}
 public void copyFile(Path source, Path target) {
  try {
    Files.copy(source, target);
  } catch(IOException e) {
    println("ERROR: IOException at copyFile(" + source + ", " + target + ")");
  }
}

// delete file
 public void deleteFile(String path) {
  deleteFile(Paths.get(sketchPath(path)));
}
 public void deleteFile(Path p) {
  try {
    Files.deleteIfExists(p);
  } catch(IOException e) {
    println("ERROR: IOException at deleteFile(" + p + ")");
  }
}

// list all entries in directory
 public ArrayList<Path> listEntries(String path) {
  return listEntries(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listEntries(Path p) {
  ArrayList<Path> entries = new ArrayList<Path>();
  try {
    if (Files.isDirectory(p)) {
      Files.list(p).forEach(entry -> entries.add(entry));
    }
    else {
      println("ERROR: Not a directory at listEntries(" + p + ")");
    }
  } catch(IOException e) {
    println("ERROR: IOException at listEntries(" + p + ")");
  }
  return entries;
}

// list all files in directory
 public ArrayList<Path> listFiles(String path) {
  return listFiles(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listFiles(Path p) {
  ArrayList<Path> files = listEntries(p);
  for (int i = 0; i < files.size(); i++) {
    if (Files.isDirectory(files.get(i))) {
      files.remove(i);
      i--;
    }
  }
  return files;
}

// list all folder in directory
 public ArrayList<Path> listFolders(String path) {
  return listFolders(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listFolders(Path p) {
  ArrayList<Path> folders = listEntries(p);
  for (int i = 0; i < folders.size(); i++) {
    if (!Files.isDirectory(folders.get(i))) {
      folders.remove(i);
      i--;
    }
  }
  return folders;
}

// default to if folder does not exist create folder
 public void mkdir(String path) {
  mkdir(path, false);
}
 public void mkdir(String path, boolean replace) {
  mkdir(path, replace, false);
}
 public void mkdir(String path, boolean replace, boolean replace_file) {
  mkdir(Paths.get(sketchPath(path)), replace, replace_file);
}
 public void mkdir(Path p, boolean replace, boolean replace_file) {
  if (!Files.exists(p)) {
    try {
      Files.createDirectory(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkdir(" + p + ")");
    }
  }
  else if (replace && Files.isDirectory(p)) {
    deleteFolder(p);
    try {
      Files.createDirectory(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkdir(" + p + ")");
    }
  }
  else if (replace_file && !Files.isDirectory(p)) {
    deleteFile(p);
    try {
      Files.createDirectory(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkdir(" + p + ")");
    }
  }
}

// move folder
 public void moveFolder(String source_path, String target_path) {
  moveFolder(Paths.get(sketchPath(source_path)), Paths.get(sketchPath(target_path)));
}
 public void moveFolder(Path source, Path target) {
  if (Files.isDirectory(source)) {
    mkdir(target, false, false);
    for (Path filePath : listFiles(source)) {
      moveFile(filePath, target.resolve(filePath.getFileName()));
    }
    for (Path folderPath : listFolders(source)) {
      moveFolder(folderPath, target.resolve(folderPath.getFileName()));
    }
  }
  else {
    moveFile(source, target);
  }
  deleteFolder(source);
}

// copy folder
 public void copyFolder(String source_path, String target_path) {
  copyFolder(Paths.get(sketchPath(source_path)), Paths.get(sketchPath(target_path)));
}
 public void copyFolder(Path source, Path target) {
  if (Files.isDirectory(source)) {
    mkdir(target, false, false);
    for (Path filePath : listFiles(source)) {
      copyFile(filePath, target.resolve(filePath.getFileName()));
    }
    for (Path folderPath : listFolders(source)) {
      copyFolder(folderPath, target.resolve(folderPath.getFileName()));
    }
  }
  else {
    copyFile(source, target);
  }
}

// recursively deletes folder
 public void deleteFolder(String path) {
  deleteFolder(Paths.get(sketchPath(path)));
}
 public void deleteFolder(Path p) {
  if (Files.isDirectory(p)) {
    for (Path filePath : listFiles(p)) {
      deleteFile(filePath);
    }
    for (Path folderPath : listFolders(p)) {
      deleteFolder(folderPath);
    }
    try {
      Files.delete(p);
    } catch(IOException e) {
      println("ERROR: IOException at deleteFolder(" + p + ")");
    }
  }
  else {
    deleteFile(p);
  }
}


// Entry exists
 public boolean entryExists(String path) {
  return entryExists(Paths.get(sketchPath(path)));
}
 public boolean entryExists(Path p) {
  return Files.exists(p);
}

// File exists
 public boolean fileExists(String path) {
  return fileExists(Paths.get(sketchPath(path)));
}
 public boolean fileExists(Path p) {
  return (Files.exists(p) && !Files.isDirectory(p));
}

// Folder exists
 public boolean folderExists(String path) {
  return folderExists(Paths.get(sketchPath(path)));
}
 public boolean folderExists(Path p) {
  return (Files.exists(p) && Files.isDirectory(p));
}
class GameMap extends AbstractGameMap {
  class TerrainDimgThread extends AbstractTerrainDimgThread {
    TerrainDimgThread() {
      super("TerrainDimgThread");
    }
     public void updateTerrainDisplay() {
      PImage new_terrain_display = GameMap.this.terrain_dimg.getImagePiece(
        round(this.startSquareX * this.terrain_resolution), round(this.startSquareY * this.terrain_resolution),
        round(this.visSquareX * this.terrain_resolution), round(this.visSquareY * this.terrain_resolution));
      new_terrain_display = resizeImage(new_terrain_display,
        round(this.xf_map - this.xi_map), round(this.yf_map - this.yi_map));
      GameMap.this.terrain_display = new_terrain_display;
    }
  }


  protected int mapWidth = 0;
  protected int mapHeight = 0;
  protected GameMapSquare[][] squares;

  protected DImg terrain_dimg;
  protected DImg fog_dimg;

  protected HashMap<Integer, Feature> features = new HashMap<Integer, Feature>();

  GameMap() {
    super();
  }
  GameMap(GameMapCode code, String folderPath) {
    super();
    this.code = code;
    this.mapName = GameMapCode.display_name(code);
    this.open(folderPath);
  }
  GameMap(String mapName, String folderPath) {
    super();
    this.mapName = mapName;
    this.open(folderPath);
  }
  GameMap(String mapName, int mapWidth, int mapHeight) {
    super();
    this.mapName = mapName;
    this.mapWidth = mapWidth;
    this.mapHeight = mapHeight;
    this.initializeSquares();
  }


   public int mapXI() {
    return 0;
  }
   public int mapYI() {
    return 0;
  }
   public int mapXF() {
    return this.mapWidth;
  }
   public int mapYF() {
    return this.mapHeight;
  }
   public int currMapXI() {
    return 0;
  }
   public int currMapYI() {
    return 0;
  }
   public int currMapXF() {
    return this.mapWidth;
  }
   public int currMapYF() {
    return this.mapHeight;
  }


   public GameMapSquare mapSquare(int i, int j) {
    try {
      return this.squares[i][j];
    } catch(ArrayIndexOutOfBoundsException e) {
      return null;
    }
  }

   public void initializeSquares() {
    this.squares = new GameMapSquare[this.mapWidth][this.mapHeight];
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j] = new GameMapSquare();
      }
    }
  }

   public void initializeBackgroundImage() {
    this.terrain_dimg = new DImg(this.mapWidth * this.terrain_resolution, this.mapHeight * this.terrain_resolution);
    this.terrain_dimg.setGrid(this.mapWidth, this.mapHeight);
    for (int i = 0; i < this.mapWidth; i++) {
      for (int j = 0; j < this.mapHeight; j++) {
        this.terrain_dimg.addImageGrid(this.mapSquare(i, j).terrainImage(), i, j);
      }
    }
    for (Feature f : this.features.values()) {
      if (f.displaysImage()) {
        this.terrain_dimg.addImageGrid(f.getImage(), PApplet.parseInt(floor(f.x)), PApplet.parseInt(floor(f.y)), f.sizeX, f.sizeY);
      }
    }
    this.fog_dimg = new DImg(this.mapWidth * Constants.map_fogResolution, this.mapHeight * Constants.map_fogResolution);
    this.fog_dimg.setGrid(this.mapWidth, this.mapHeight);
  }

   public void colorFogGrid(int c, int i, int j) {
    this.fog_dimg.colorGrid(c, i, j);
  }

   public void terrainImageGrid(PImage img, int x, int y, int w, int h) {
    if (this.terrain_dimg == null) {
      return;
    }
    this.terrain_dimg.addImageGrid(img, x, y, w, h);
  }

   public void colorTerrainGrid(int c, int x, int y, int w, int h) {
    if (this.terrain_dimg == null) {
      return;
    }
    this.terrain_dimg.colorGrid(c, x, y, w, h);
  }

   public void startTerrainDimgThread() {
    this.terrain_dimg_thread = new TerrainDimgThread();
    this.terrain_dimg_thread.start();
  }

   public PImage getFogImagePiece(int fog_xi, int fog_yi, int fog_w, int fog_h) {
    return this.fog_dimg.getImagePiece(fog_xi, fog_yi, fog_w, fog_h);
  }

   public void actuallyAddFeature(int code, Feature f) {
    this.features.put(code, f);
  }

   public void featureAddedMapSquareNotFound(IntegerCoordinate coordinate, Feature f) {
    global.errorMessage("ERROR: Couldn't find square with coordinates " +
      coordinate.x + ", " + coordinate.y + " where feature with code " + f.map_key + " was added.");
  }

   public void featureRemovedMapSquareNotFound(IntegerCoordinate coordinate, Feature f) {
    global.errorMessage("ERROR: Couldn't find square with coordinates " +
      coordinate.x + ", " + coordinate.y + " where feature with code " + f.map_key + " was removed.");
  }

   public Feature getFeature(int code) {
    return this.features.get(code);
  }

   public Collection<Feature> features() {
    return this.features.values();
  }

   public void updateFeatures(int time_elapsed) {
    Iterator feature_iterator = this.features.entrySet().iterator();
    while(feature_iterator.hasNext()) {
      Map.Entry<Integer, Feature> entry = (Map.Entry<Integer, Feature>)feature_iterator.next();
      updateFeature(entry.getValue(), feature_iterator, time_elapsed);
    }
  }

   public void updateFeaturesCheckRemovalOnly() {
    Iterator feature_iterator = this.features.entrySet().iterator();
    while(feature_iterator.hasNext()) {
      Map.Entry<Integer, Feature> entry = (Map.Entry<Integer, Feature>)feature_iterator.next();
      if (entry.getValue().remove) {
        this.removeFeature(entry.getKey());
        feature_iterator.remove();
      }
    }
  }


   public void saveTerrain(PrintWriter file) {
    file.println("dimensions: " + this.mapWidth + ", " + this.mapHeight);
    for (int i = this.mapXI(); i < this.mapXF(); i++) {
      for (int j = this.mapYI(); j < this.mapYF(); j++) {
        file.println("terrain: " + i + ", " + j + ": " + this.mapSquare(i, j).terrain_id +
          ", " + this.mapSquare(i, j).base_elevation + ", " + this.mapSquare(i, j).explored);
      }
    }
    // add feature data
    for (Map.Entry<Integer, Feature> entry : this.features.entrySet()) {
      file.println("nextFeatureKey: " + entry.getKey());
      file.println(entry.getValue().fileString());
    }
  }

   public void addImplementationSpecificData(String datakey, String data) {
    switch(datakey) {
      case "dimensions":
        String[] dimensions = split(data, ',');
        if (dimensions.length < 2) {
          global.errorMessage("ERROR: Map missing dimensions in data: " + data + ".");
          this.mapWidth = 1;
          this.mapHeight = 1;
        }
        else {
          this.mapWidth = toInt(trim(dimensions[0]));
          this.mapHeight = toInt(trim(dimensions[1]));
        }
        this.initializeSquares();
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for GameMap object.");
        break;
    }
  }
}
enum ReadFileObject {
  NONE("None"), MAP("Map"), FEATURE("Feature"), UNIT("Unit"), ITEM("Item"),
  PROJECTILE("Projectile"), LEVEL("Level"), LINKER("Linker"), TRIGGER("Trigger"),
  CONDITION("Condition"), EFFECT("Effect"), STATUS_EFFECT("StatusEffect"),
  ABILITY("Ability"), HERO("Hero"), INVENTORY("Inventory");

  private static final List<ReadFileObject> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String name;

  private ReadFileObject(String name) {
    this.name = name;
  }

  public static ReadFileObject objectType(String name) {
    for (ReadFileObject type : ReadFileObject.VALUES) {
      if (type == ReadFileObject.NONE) {
        continue;
      }
      if (type.name.equals(name)) {
        return type;
      }
    }
    return ReadFileObject.NONE;
  }
}



enum MapFogHandling {
  DEFAULT("Default"), NONE("None"), EXPLORED("Explored"), NOFOG("NoFog");

  private static final List<MapFogHandling> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String name;

  private MapFogHandling(String name) {
    this.name = name;
  }

  public static MapFogHandling fogHandling(String name) {
    for (MapFogHandling fogH : MapFogHandling.VALUES) {
      if (fogH.name.equals(name)) {
        return fogH;
      }
    }
    return MapFogHandling.NONE;
  }

  public boolean show_fog() {
    return MapFogHandling.show_fog(this);
  }
  public static boolean show_fog(MapFogHandling fogHandling) {
    switch(fogHandling) {
      case NONE:
      case NOFOG:
        return false;
      default:
        return true;
    }
  }
}



abstract class AbstractGameMap {
  class HeaderMessage {
    private String message;
    private int text_align;
    private float text_size;
    private boolean fading = true;
    private boolean showing = true;
    private int fade_time = Constants.map_headerMessageFadeTime;
    private int show_time = Constants.map_headerMessageShowTime;
    private int color_background = color(110, 90, 70, 150);
    private int color_text = color(255);
    private boolean clickable = true;
    private boolean centered = false;

    private float xi = 0;
    private float yi = 0;
    private float xf = 0;
    private float yf = 0;
    private float centerX = 0;
    private float centerY = 0;
    private int index = 0;

    private int alpha = 255;
    private boolean hovered = false;
    private boolean remove = false;

    HeaderMessage(String message) {
      this(message, CENTER, Constants.map_defaultHeaderMessageTextSize);
    }
    HeaderMessage(String message, int text_align) {
      this(message, text_align, Constants.map_defaultHeaderMessageTextSize);
    }
    HeaderMessage(String message, int text_align, float text_size) {
      this.message = message;
      this.text_align = text_align;
      this.text_size = text_size;
      this.evaluateSize();
    }

     public void setTextSize(float text_size) {
      this.text_size = text_size;
      this.evaluateSize();
    }

     public void evaluateSize() {
      textSize(this.text_size);
      float size_width = textWidth(this.message) + 4;
      float size_height = textAscent() + textDescent() + 2;
      switch(this.text_align) {
        case LEFT:
          this.xi = AbstractGameMap.this.xi + 5;
          this.yi = AbstractGameMap.this.yi + Constants.map_borderSize + 1;
          this.xf = this.xi + size_width;
          this.yf = this.yi + size_height;
          break;
        case RIGHT:
          this.xi = AbstractGameMap.this.xf - 5 - size_width;
          this.yi = AbstractGameMap.this.yi + Constants.map_borderSize + 1;
          this.xf = AbstractGameMap.this.xf - 5;
          this.yf = this.yi + size_height;
          break;
        case CENTER:
        default:
          this.xi = 0.5f * (width - size_width);
          this.yi = AbstractGameMap.this.yi + Constants.map_borderSize + 1;
          this.xf = 0.5f * (width + size_width);
          this.yf = this.yi + size_height;
          break;
      }
      this.centerX = this.xi + 0.5f * (this.xf - this.xi);
      this.centerY = this.yi + 0.5f * (this.yf - this.yi);
    }

     public void placeCenter() {
      this.placeCenter(34);
    }
     public void placeCenter(float text_size) {
      this.centered = true;
      this.text_size = text_size;
      textSize(this.text_size);
      float size_width = textWidth(this.message) + 4;
      float size_height = textAscent() + textDescent() + 2;
      this.xi = 0.5f * (width - size_width);
      this.yi = 0.5f * (height - size_height);
      this.xf = 0.5f * (width + size_width);
      this.yf = 0.5f * (height + size_height);
      this.centerX = this.xi + 0.5f * (this.xf - this.xi);
      this.centerY = this.yi + 0.5f * (this.yf - this.yi);
    }

     public void updateView(int timeElapsed, int index) {
      if (this.remove) {
        return;
      }
      this.index = index;
      if (this.fading) {
        this.fade_time -= timeElapsed;
        if (this.fade_time <= 0) {
          if (this.showing) {
            this.fading = false;
          }
          else {
            this.remove = true;
          }
        }
        if (this.showing) {
          this.alpha = PApplet.parseInt(round(255 * (Constants.map_headerMessageFadeTime - this.fade_time) / Constants.map_headerMessageFadeTime));
        }
        else {
          this.alpha = PApplet.parseInt(round(255 * this.fade_time / Constants.map_headerMessageFadeTime));
        }
      }
      else {
        this.alpha = 255;
        this.show_time -= timeElapsed;
        if (this.show_time <= 0) {
          this.fading = true;
          this.fade_time = Constants.map_headerMessageFadeTime;
          this.showing = false;
        }
      }
    }

     public void drawMessage() {
      if (this.remove) {
        return;
      }
      float translate_amount = this.index * (this.yf - this.yi + 4);
      translate(0, translate_amount);
      rectMode(CORNERS);
      fill(this.color_background, alpha);
      rect(this.xi, this.yi, this.xf, this.yf);
      textAlign(CENTER, BOTTOM);
      textSize(this.text_size);
      fill(this.color_text, alpha);
      text(this.message, this.centerX, this.yf - 2);
      translate(0, -translate_amount);
    }

     public void mouseMove(float mX, float mY) {
      if (mX > this.xi && mY > this.yi && mX < this.xf && mY < this.yf) {
        this.hovered = true;
      }
      else {
        this.hovered = false;
      }
    }

     public void mousePress() {
      if (this.hovered && this.clickable) {
        this.fading = false;
        this.showing = true;
        this.show_time = Constants.map_headerMessageShowTime;
      }
    }
  }



  class SelectedObjectTextbox extends TextBox {
    SelectedObjectTextbox() {
      super(Constants.map_selectedObjectPanelGap, 0.2f * height, Constants.
        map_selectedObjectPanelGap, 0.5f * height - 5);
      this.color_background = Constants.color_transparent;
      this.color_header = Constants.color_transparent;
      this.color_stroke = Constants.color_transparent;
      this.scrollbar.setButtonColors(color(170),
        adjust_color_brightness(global.color_panelBackground, 1.1f),
        adjust_color_brightness(global.color_panelBackground, 1.2f),
        adjust_color_brightness(global.color_panelBackground, 0.95f), Constants.color_black);
      this.scrollbar.button_upspace.setColors(Constants.color_transparent, Constants.color_transparent,
        Constants.color_transparent, Constants.color_black, Constants.color_black);
      this.scrollbar.button_downspace.setColors(Constants.color_transparent, Constants.color_transparent,
        Constants.color_transparent, Constants.color_black, Constants.color_black);
      this.scrollbar.button_up.raised_border = false;
      this.scrollbar.button_down.raised_border = false;
    }
  }



  abstract class ConfirmForm extends FormLNZ {
    protected boolean canceled = false;

    ConfirmForm(String title, String message) {
      super(0.5f * (width - Constants.mapEditor_formWidth_small), 0.5f * (height - Constants.mapEditor_formHeight_small),
        0.5f * (width + Constants.mapEditor_formWidth_small), 0.5f * (height + Constants.mapEditor_formHeight_small));
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);

      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      this.addField(new TextBoxFormField(message, 120));
      this.addField(submit);
      this.min_x = AbstractGameMap.this.xi;
      this.min_y = AbstractGameMap.this.yi;
      this.max_x = AbstractGameMap.this.xf;
      this.max_y = AbstractGameMap.this.yf;
    }

    @Override public 
    void cancel() {
      this.canceled = true;
    }
  }



  abstract class AbstractTerrainDimgThread extends Thread {
    protected float startSquareX = 0;
    protected float startSquareY = 0;
    protected float visSquareX = 0;
    protected float visSquareY = 0;
    protected float terrain_resolution = 0;
    protected float xi_map = 0;
    protected float yi_map = 0;
    protected float xf_map = 0;
    protected float yf_map = 0;
    protected float zoom = 0;
    AbstractTerrainDimgThread(String thread_name) {
      super(thread_name);
      this.setDaemon(true);
    }
    @Override public 
    void run() {
      this.startSquareX = AbstractGameMap.this.startSquareX;
      this.startSquareY = AbstractGameMap.this.startSquareY;
      this.visSquareX = AbstractGameMap.this.visSquareX;
      this.visSquareY = AbstractGameMap.this.visSquareY;
      this.terrain_resolution = AbstractGameMap.this.terrain_resolution;
      this.xi_map = AbstractGameMap.this.xi_map;
      this.yi_map = AbstractGameMap.this.yi_map;
      this.xf_map = AbstractGameMap.this.xf_map;
      this.yf_map = AbstractGameMap.this.yf_map;
      this.zoom = AbstractGameMap.this.zoom;
      this.updateTerrainDisplay();
      AbstractGameMap.this.startSquareX_old = this.startSquareX;
      AbstractGameMap.this.startSquareY_old = this.startSquareY;
      AbstractGameMap.this.visSquareX_old = this.visSquareX;
      AbstractGameMap.this.visSquareY_old = this.visSquareY;
      AbstractGameMap.this.xi_map_old = this.xi_map;
      AbstractGameMap.this.yi_map_old = this.yi_map;
      AbstractGameMap.this.xf_map_old = this.xf_map;
      AbstractGameMap.this.yf_map_old = this.yf_map;
      AbstractGameMap.this.xi_map_dif = 0;
      AbstractGameMap.this.yi_map_dif = 0;
      AbstractGameMap.this.xf_map_dif = 0;
      AbstractGameMap.this.yf_map_dif = 0;
      AbstractGameMap.this.zoom_old = this.zoom;
    }
     public abstract void updateTerrainDisplay();
  }


  class MouseMoveThread extends Thread {
    private float mX = 0;
    private float mY = 0;
    MouseMoveThread(float mX, float mY) {
      super("MouseMoveThread");
      this.setDaemon(true);
      this.mX = mX;
      this.mY = mY;
    }

    @Override public 
    void run() {
      if (this.mX < Constants.small_number) {
        AbstractGameMap.this.view_moving_left = true;
        if (!global.holding_right) {
          AbstractGameMap.this.view_moving_right = false;
        }
      }
      else if (this.mX > width - 1 - Constants.small_number) {
        AbstractGameMap.this.view_moving_right = true;
        if (!global.holding_left) {
          AbstractGameMap.this.view_moving_left = false;
        }
      }
      else {
        if (!global.holding_right) {
          AbstractGameMap.this.view_moving_right = false;
        }
        if (!global.holding_left) {
          AbstractGameMap.this.view_moving_left = false;
        }
      }
      if (this.mY < Constants.small_number) {
        AbstractGameMap.this.view_moving_up = true;
        if (!global.holding_down) {
          AbstractGameMap.this.view_moving_down = false;
        }
      }
      else if (this.mY > height - 1 - Constants.small_number) {
        AbstractGameMap.this.view_moving_down = true;
        if (!global.holding_up) {
          AbstractGameMap.this.view_moving_up = false;
        }
      }
      else {
        if (!global.holding_down) {
          AbstractGameMap.this.view_moving_down = false;
        }
        if (!global.holding_up) {
          AbstractGameMap.this.view_moving_up = false;
        }
      }
      AbstractGameMap.this.updateCursorPosition(this.mX, this.mY);
      if (AbstractGameMap.this.selected_object != null && AbstractGameMap.this.selected_object_textbox != null) {
        AbstractGameMap.this.selected_object_textbox.mouseMove(this.mX, this.mY);
      }
      if (AbstractGameMap.this.draw_fog) {
        AbstractGameMap.this.hovered_explored = false;
        AbstractGameMap.this.hovered_visible = false;
      }
      else {
        AbstractGameMap.this.hovered_explored = true;
        AbstractGameMap.this.hovered_visible = true;
      }
      boolean default_cursor = true;
      boolean viewing_inventory = false;
      if (AbstractGameMap.this.units.containsKey(0) && Hero.class.isInstance(AbstractGameMap.this.units.get(0))) {
        viewing_inventory = ((Hero)AbstractGameMap.this.units.get(0)).inventory.viewing;
      }
      if (mX > AbstractGameMap.this.xi_map && mY > AbstractGameMap.this.yi_map && mX < AbstractGameMap.
        this.xf_map && mY < AbstractGameMap.this.yf_map && !viewing_inventory) {
        AbstractGameMap.this.hovered = true;
        AbstractGameMap.this.hovered_area = true;
        AbstractGameMap.this.hovered_border = false;
        // update hovered for map objects
        AbstractGameMap.this.hovered_object = null;
        try {
          if (!AbstractGameMap.this.draw_fog || AbstractGameMap.this.mapSquare(
            PApplet.parseInt(AbstractGameMap.this.mX), PApplet.parseInt(AbstractGameMap.this.mY)).visible) {
            AbstractGameMap.this.hovered_explored = true;
            AbstractGameMap.this.hovered_visible = true;
          }
          else if (!AbstractGameMap.this.draw_fog || AbstractGameMap.this.mapSquare(
            PApplet.parseInt(AbstractGameMap.this.mX), PApplet.parseInt(AbstractGameMap.this.mY)).explored) {
            AbstractGameMap.this.hovered_explored = true;
          }
        } catch(NullPointerException e) {}
        for (Feature f : AbstractGameMap.this.features()) {
          f.mouseMove(AbstractGameMap.this.mX, AbstractGameMap.this.mY);
          if (f.hovered) {
            if (!AbstractGameMap.this.force_all_hoverable) {
              switch(f.ID) {
                case 186: // outside light source
                case 187: // invisible light source
                case 188:
                case 189:
                case 190:
                  f.hovered = false;
                  continue;
              }
            }
            if (!AbstractGameMap.this.hovered_explored) {
              f.hovered = false;
              continue;
            }
            AbstractGameMap.this.hovered_object = f;
            global.setCursor("icons/cursor_interact.png");
            default_cursor = false;
          }
        }
        for (Map.Entry<Integer, Unit> entry : AbstractGameMap.this.units.entrySet()) {
          Unit u = entry.getValue();
          u.mouseMove(AbstractGameMap.this.mX, AbstractGameMap.this.mY);
          if (u.hovered) {
            if (!AbstractGameMap.this.hovered_visible) {
              if (AbstractGameMap.this.units.containsKey(0)) {
                if (!AbstractGameMap.this.hovered_explored || AbstractGameMap.this.units.get(0).alliance != u.alliance) {
                  u.hovered = false;
                  continue;
                }
              }
              else {
                u.hovered = false;
                continue;
              }
            }
            AbstractGameMap.this.hovered_object = u;
            if (AbstractGameMap.this.units.containsKey(0) && u.alliance != AbstractGameMap.this.units.get(0).alliance) {
              global.setCursor("icons/cursor_attack.png");
              default_cursor = false;
            }
          }
        }
        for (Map.Entry<Integer, Item> entry : AbstractGameMap.this.items.entrySet()) {
          Item i = entry.getValue();
          i.mouseMove(AbstractGameMap.this.mX, AbstractGameMap.this.mY);
          if (i.hovered) {
            if (!AbstractGameMap.this.hovered_visible) {
              i.hovered = false;
              continue;
            }
            AbstractGameMap.this.hovered_object = i;
            if (AbstractGameMap.this.units.containsKey(0) && AbstractGameMap.this.units.get(0).tier() >= i.tier) {
              global.setCursor("icons/cursor_pickup.png");
              default_cursor = false;
            }
          }
        }
        // hovered for header message
        for (HeaderMessage message : AbstractGameMap.this.headerMessages) {
          message.mouseMove(mX, mY);
        }
      }
      else {
        AbstractGameMap.this.hovered = false;
        AbstractGameMap.this.hovered_object = null;
        AbstractGameMap.this.hovered_explored = false;
        AbstractGameMap.this.hovered_visible = false;
        if (mX > AbstractGameMap.this.xi && mY > AbstractGameMap.this.yi && mX < AbstractGameMap.this.xf && mY < AbstractGameMap.this.yf) {
          AbstractGameMap.this.hovered_area = true;
          if (mX < AbstractGameMap.this.xi + Constants.map_borderSize || mX > AbstractGameMap.this.xf - Constants.map_borderSize ||
            mY < AbstractGameMap.this.yi + Constants.map_borderSize || mY > AbstractGameMap.this.yf - Constants.map_borderSize) {
            AbstractGameMap.this.hovered_border = true;
          }
          else {
            AbstractGameMap.this.hovered_border = false;
          }
        }
        else {
          AbstractGameMap.this.hovered_area = false;
          AbstractGameMap.this.hovered_border = false;
        }
        // dehover map objects
        for (Feature f : AbstractGameMap.this.features()) {
          f.hovered = false;
        }
        for (Map.Entry<Integer, Unit> entry : AbstractGameMap.this.units.entrySet()) {
          entry.getValue().hovered = false;
        }
        for (Map.Entry<Integer, Item> entry : AbstractGameMap.this.items.entrySet()) {
          entry.getValue().hovered = false;
        }
      }
      // aiming for player
      if (AbstractGameMap.this.units.containsKey(0) && global.holding_ctrl && !viewing_inventory && AbstractGameMap.this.in_control) {
        switch(AbstractGameMap.this.units.get(0).curr_action) {
          case AIMING:
            AbstractGameMap.this.units.get(0).aim(AbstractGameMap.this.mX, AbstractGameMap.this.mY);
            break;
          case MOVING:
            AbstractGameMap.this.units.get(0).moveTo(AbstractGameMap.this.mX, AbstractGameMap.this.mY, AbstractGameMap.this);
            break;
          case NONE:
            AbstractGameMap.this.units.get(0).face(AbstractGameMap.this.mX, AbstractGameMap.this.mY);
            break;
        }
      }
      if (default_cursor) {
        global.defaultCursor("icons/cursor_interact.png", "icons/cursor_attack.png", "icons/cursor_pickup.png");
      }
      if (AbstractGameMap.this.restart_mouseMoveThread) {
        AbstractGameMap.this.startMouseMoveThread();
        AbstractGameMap.this.restart_mouseMoveThread = false;
      }
    }
  }



  protected GameMapCode code = GameMapCode.ERROR;
  protected String mapName = "";
  protected boolean nullify = false;
  protected int maxHeight = Constants.map_maxHeight;

  protected int terrain_resolution = Constants.map_terrainResolutionDefault;
  protected MapFogHandling fogHandling = MapFogHandling.DEFAULT;
  protected int fogColor = Constants.color_fog;
  protected boolean draw_fog = true;
  protected PImage terrain_display = createImage(0, 0, RGB);
  protected AbstractTerrainDimgThread terrain_dimg_thread;
  protected boolean update_terrain_display = false;
  protected boolean update_terrain_display_from_thread = false;
  protected PImage fog_display = createImage(0, 0, ARGB);

  protected float viewX = 0;
  protected float viewY = 0;
  protected float zoom = Constants.map_defaultZoom;
  protected float zoom_old = Constants.map_defaultZoom;
  protected boolean view_moving_left = false;
  protected boolean view_moving_right = false;
  protected boolean view_moving_up = false;
  protected boolean view_moving_down = false;

  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;
  protected int color_border = global.color_mapBackground;
  protected int color_background = global.color_mapBorder;
  protected int color_tint = Constants.color_transparent;
  protected boolean show_tint = false;

  protected float xi_map = 0;
  protected float yi_map = 0;
  protected float xf_map = 0;
  protected float yf_map = 0;
  protected float xi_map_old = 0;
  protected float yi_map_old = 0;
  protected float xf_map_old = 0;
  protected float yf_map_old = 0;
  protected float xi_map_dif = 0;
  protected float yi_map_dif = 0;
  protected float xf_map_dif = 0;
  protected float yf_map_dif = 0;

  protected float xi_fog = 0;
  protected float yi_fog = 0;
  protected float xf_fog = 0;
  protected float yf_fog = 0;

  protected float startSquareX = 0;
  protected float startSquareY = 0;
  protected float visSquareX = 0;
  protected float visSquareY = 0;
  protected float startSquareX_old = 0;
  protected float startSquareY_old = 0;
  protected float visSquareX_old = 0;
  protected float visSquareY_old = 0;

  protected int lastUpdateTime = millis();

  protected boolean hovered = false; // hover map
  protected boolean hovered_area = false; // hover GameMap-given area
  protected boolean hovered_border = false; // hover border
  protected boolean hovered_explored = false;
  protected boolean hovered_visible = false;
  protected boolean force_all_hoverable = false;

  protected float mX = 0;
  protected float mY = 0;
  protected float last_x = 0;
  protected float last_y = 0;
  protected MouseMoveThread mouse_move_thread = null;
  protected boolean restart_mouseMoveThread = false;
  protected MapObject hovered_object = null;
  protected MapObject selected_object = null;
  protected SelectedObjectTextbox selected_object_textbox = null;
  protected ArrayList<HeaderMessage> headerMessages = new ArrayList<HeaderMessage>();

  protected int nextFeatureKey = 1;
  protected HashMap<Integer, Unit> units = new HashMap<Integer, Unit>();
  protected int nextUnitKey = 1;
  protected int zombie_counter = 0;
  protected boolean in_control = true;
  protected HashMap<Integer, Item> items = new HashMap<Integer, Item>();
  protected int nextItemKey = 1;
  protected ArrayList<Projectile> projectiles = new ArrayList<Projectile>();
  protected ArrayList<VisualEffect> visualEffects = new ArrayList<VisualEffect>();

  protected float timer_refresh_fog = 0;
  protected float base_light_level = Constants.level_dayLightLevel;
  protected boolean outside_map = true;


  // put readfile/constructors into abstract as much as possible
  AbstractGameMap() {}


   public abstract int mapXI();
   public abstract int mapYI();
   public abstract int mapXF();
   public abstract int mapYF();
   public abstract int currMapXI();
   public abstract int currMapYI();
   public abstract int currMapXF();
   public abstract int currMapYF();
   public int currWidth() {
    return this.currMapXF() - this.currMapXI();
  }
   public int currHeight() {
    return this.currMapYF() - this.currMapYI();
  }

   public abstract GameMapSquare mapSquare(int i, int j); // return null if out of bounds
   public abstract void initializeSquares();
   public void initializeTerrain() {
    try {
      this.terrain_resolution = global.profile.options.terrain_resolution;
    } catch(Exception e) {}
    this.initializeBackgroundImage();
    this.setFogHandling(this.fogHandling);
  }
   public abstract void initializeBackgroundImage();

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    if (this.selected_object_textbox != null) {
      this.selected_object_textbox.setXLocation(Constants.map_selectedObjectPanelGap,
        xi - Constants.map_selectedObjectPanelGap);
    }
    this.refreshDisplayMapParameters();
  }

   public void setFogHandling(MapFogHandling fogHandling) {
    this.fogHandling = fogHandling;
    switch(fogHandling) {
      case DEFAULT:
        for (int i = this.currMapXI(); i < this.currMapXF(); i++) {
          for (int j = this.currMapYI(); j < this.currMapYF(); j++) {
            GameMapSquare square = this.mapSquare(i, j);
            if (square == null) {
              continue;
            }
            if (square.mapEdge()) {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
            else if (!square.explored) {
              this.colorFogGrid(Constants.color_black, i, j);
            }
            else if (!square.visible) {
              this.colorFogGrid(this.fogColor, i, j);
            }
            else {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
          }
        }
        break;
      case NONE:
        for (int i = this.currMapXI(); i < this.currMapXF(); i++) {
          for (int j = this.currMapYI(); j < this.currMapYF(); j++) {
            this.exploreTerrainAndVisible(i, j, false);
            this.colorFogGrid(Constants.color_transparent, i, j);
          }
        }
        break;
      case NOFOG:
        for (int i = this.currMapXI(); i < this.currMapXF(); i++) {
          for (int j = this.currMapYI(); j < this.currMapYF(); j++) {
            this.setTerrainVisible(true, i, j, false);
            GameMapSquare square = this.mapSquare(i, j);
            if (square == null) {
              continue;
            }
            if (square.mapEdge()) {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
            else if (!square.explored) {
              this.colorFogGrid(Constants.color_black, i, j);
            }
            else {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
          }
        }
        break;
      case EXPLORED:
        for (int i = this.currMapXI(); i < this.currMapXF(); i++) {
          for (int j = this.currMapYI(); j < this.currMapYF(); j++) {
            this.exploreTerrain(i, j, false);
            GameMapSquare square = this.mapSquare(i, j);
            if (square == null) {
              continue;
            }
            if (square.mapEdge()) {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
            else if (!square.visible) {
              this.colorFogGrid(this.fogColor, i, j);
            }
            else {
              this.colorFogGrid(Constants.color_transparent, i, j);
            }
          }
        }
        break;
      default:
        global.errorMessage("ERROR: Fog handling " + fogHandling.name + " not recognized.");
        break;
    }
    this.refreshFogImage();
  }
   public abstract void colorFogGrid(int c, int i, int j);
   public void terrainImageGrid(PImage img, int x, int y) {
    this.terrainImageGrid(img, x, y, 1, 1);
  }
   public abstract void terrainImageGrid(PImage img, int x, int y, int w, int h);
   public void colorTerrainGrid(int c, int x, int y) {
    this.colorTerrainGrid(c, x, y, 1, 1);
  }
   public abstract void colorTerrainGrid(int c, int x, int y, int w, int h);

   public void refreshDisplayMapParameters() {
    this.startSquareX = max(this.mapXI(), this.viewX - (0.5f * width - this.xi - Constants.map_borderSize) / this.zoom);
    this.startSquareY = max(this.mapYI(), this.viewY - (0.5f * height - this.yi - Constants.map_borderSize) / this.zoom);
    this.xi_map = 0.5f * width - (this.viewX - this.startSquareX) * this.zoom;
    this.yi_map = 0.5f * height - (this.viewY - this.startSquareY) * this.zoom;
    this.visSquareX = min(this.mapXF() - this.startSquareX, (this.xf - this.xi_map - Constants.map_borderSize) / this.zoom);
    this.visSquareY = min(this.mapYF() - this.startSquareY, (this.yf - this.yi_map - Constants.map_borderSize) / this.zoom);
    this.xf_map = this.xi_map + this.visSquareX * this.zoom;
    this.yf_map = this.yi_map + this.visSquareY * this.zoom;
    this.xi_map_dif = this.startSquareX - this.startSquareX_old;
    this.yi_map_dif = this.startSquareY - this.startSquareY_old;
    this.xf_map_dif = xi_map_dif + this.visSquareX - this.visSquareX_old;
    this.yf_map_dif = yi_map_dif + this.visSquareY - this.visSquareY_old;
    this.refreshDisplayImages();
  }

   public void refreshDisplayImages() {
    this.refreshTerrainImage();
    this.refreshFogImage();
  }

   public void refreshTerrainImage() {
    if (this.terrain_dimg_thread != null && this.terrain_dimg_thread.isAlive()) {
      this.update_terrain_display = true;
    }
    else {
      this.update_terrain_display = false;
      this.startTerrainDimgThread();
    }
  }
   public abstract void startTerrainDimgThread();

   public void refreshFogImage() {
    int fog_xi = round(floor(this.startSquareX_old * Constants.map_fogResolution));
    this.xi_fog = this.xi_map_old - this.zoom_old * (this.startSquareX_old - PApplet.parseFloat(fog_xi) / Constants.map_fogResolution);
    int fog_yi = round(floor(this.startSquareY_old * Constants.map_fogResolution));
    this.yi_fog = this.yi_map_old - this.zoom_old * (this.startSquareY_old - PApplet.parseFloat(fog_yi) / Constants.map_fogResolution);
    int fog_w = round(ceil(this.visSquareX_old * Constants.map_fogResolution));
    this.xf_fog = this.xi_fog + this.zoom_old * (PApplet.parseFloat(fog_w) / Constants.map_fogResolution);
    if (this.xf_fog + Constants.small_number < this.xf_map_old) {
      fog_w++;
      this.xf_fog += this.zoom_old / Constants.map_fogResolution;
    }
    int fog_h = round(ceil(this.visSquareY_old * Constants.map_fogResolution));
    this.yf_fog = this.yi_fog + this.zoom_old * (PApplet.parseFloat(fog_h) / Constants.map_fogResolution);
    if (this.yf_fog + Constants.small_number < this.yf_map_old) {
      fog_h++;
      this.yf_fog += this.zoom_old / Constants.map_fogResolution;
    }
    this.fog_display = this.getFogImagePiece(fog_xi, fog_yi, fog_w, fog_h);
  }
   public abstract PImage getFogImagePiece(int fog_xi, int fog_yi, int fog_w, int fog_h);

   public void setZoom(float zoom) {
    if (zoom > Constants.map_maxZoom) {
      zoom = Constants.map_maxZoom;
    }
    else if (zoom < Constants.map_minZoom) {
      zoom = Constants.map_minZoom;
    }
    this.zoom = zoom;
    this.refreshDisplayMapParameters();
  }
   public void changeZoom(float amount) {
    this.setZoom(this.zoom + amount);
  }

   public void setViewLocation(float viewX, float viewY) {
    this.setViewLocation(viewX, viewY, true);
  }
   public void setViewLocation(float viewX, float viewY, boolean refreshImage) {
    if (viewX < this.mapXI()) {
      viewX = this.mapXI();
    }
    else if (viewX > this.mapXF()) {
      viewX = this.mapXF();
    }
    if (viewY < this.mapYI()) {
      viewY = mapYI();
    }
    else if (viewY > this.mapYF()) {
      viewY = this.mapYF();
    }
    this.viewX = viewX;
    this.viewY = viewY;
    if (refreshImage) {
      this.refreshDisplayMapParameters();
      this.updateCursorPosition();
    }
  }
   public void moveView(float changeX, float changeY) {
    this.moveView(changeX, changeY, true);
  }
   public void moveView(float changeX, float changeY, boolean refreshImage) {
    this.setViewLocation(this.viewX + changeX, this.viewY + changeY, refreshImage);
  }

   public void setTerrain(int id, int x, int y) {
    this.setTerrain(id, x, y, true);
  }
   public void setTerrain(int id, int x, int y, boolean refreshImage) {
    try {
      this.mapSquare(x, y).setTerrain(id);
      this.terrainImageGrid(this.mapSquare(x, y).terrainImage(), x, y);
      if (refreshImage) {
        this.refreshDisplayImages();
      }
    }
    catch(NullPointerException e) {}
  }
   public void setTerrainBaseElevation(int h, int x, int y) {
    try {
      this.mapSquare(x, y).base_elevation = h;
    }
    catch(NullPointerException e) {}
  }
   public void exploreRectangle(Rectangle rect) {
    for (int i = PApplet.parseInt(rect.xi); i < PApplet.parseInt(rect.xf); i++) {
      for (int j = PApplet.parseInt(rect.yi); j < PApplet.parseInt(rect.yf); j++) {
        this.exploreTerrain(i, j, true);
      }
    }
  }
   public void exploreTerrain(int x, int y) {
    this.exploreTerrain(x, y, true);
  }
   public void exploreTerrain(int x, int y, boolean refreshFogImage) {
    try {
      if (this.mapSquare(x, y).explored) {
        return;
      }
      this.mapSquare(x, y).explored = true;
      if (refreshFogImage) {
        if (this.mapSquare(x, y).mapEdge()) {
          this.colorFogGrid(Constants.color_transparent, x, y);
        }
        else if (this.mapSquare(x, y).visible) {
          this.colorFogGrid(this.mapSquare(x, y).getColor(Constants.color_transparent), x, y);
        }
        else {
          this.colorFogGrid(this.mapSquare(x, y).getColor(this.fogColor), x, y);
        }
      }
    }
    catch(NullPointerException e) {}
  }
   public void exploreTerrainAndVisible(int x, int y) {
    this.exploreTerrainAndVisible(x, y, true);
  }
   public void exploreTerrainAndVisible(int x, int y, boolean refreshFogImage) {
    try {
      if (this.mapSquare(x, y).explored && this.mapSquare(x, y).visible) {
        return;
      }
      this.mapSquare(x, y).explored = true;
      this.mapSquare(x, y).visible = true;
      if (refreshFogImage) {
        if (this.mapSquare(x, y).mapEdge()) {
          this.colorFogGrid(Constants.color_transparent, x, y);
        }
        else {
          this.colorFogGrid(this.mapSquare(x, y).getColor(Constants.color_transparent), x, y);
        }
      }
    }
    catch(NullPointerException e) {}
  }
   public void setTerrainVisible(boolean visible, int x, int y) {
    this.setTerrainVisible(visible, x, y, true);
  }
   public void setTerrainVisible(boolean visible, int x, int y, boolean refreshFogImage) {
    try {
      if (this.mapSquare(x, y).visible == visible) {
        return;
      }
      this.mapSquare(x, y).visible = visible;
      if (refreshFogImage) {
        if (!this.mapSquare(x, y).explored) {
        }
        else if (this.mapSquare(x, y).mapEdge()) {
          this.colorFogGrid(Constants.color_transparent, x, y);
        }
        else if (this.mapSquare(x, y).visible) {
          this.colorFogGrid(this.mapSquare(x, y).getColor(Constants.color_transparent), x, y);
        }
        else {
          this.colorFogGrid(this.mapSquare(x, y).getColor(this.fogColor), x, y);
        }
      }
    }
    catch(NullPointerException e) {}
  }


  // add feature
   public void addFeature(int id, int x, int y) {
    this.addFeature(new Feature(id, x, y), true);
  }
   public void addFeature(Feature f) {
    this.addFeature(f, true);
  }
   public void addFeature(Feature f, boolean refresh_image) {
    this.addFeature(f, refresh_image, this.nextFeatureKey());
  }
   public synchronized int nextFeatureKey() {
    return this.nextFeatureKey++;
  }
   public void addFeature(Feature f, boolean refresh_image, int code) {
    if (!f.inMap(this.mapXI(), this.mapYI(), this.mapXF(), this.mapYF())) {
      return;
    }
    this.addFeatureToTerrain(f);
    if (f.displaysImage()) {
      this.terrainImageGrid(f.getImage(), round(floor(f.x)), round(floor(f.y)), f.sizeX, f.sizeY);
    }
    if (refresh_image) {
      this.refreshTerrainImage();
    }
    f.map_key = code;
    switch(f.ID) {
      case 195: // light switches
      case 196:
      case 197:
      case 198:
        if (f.number <= 0) {
          f.number = f.map_key - 1;
        }
        break;
      default:
        break;
    }
    this.actuallyAddFeature(code, f);
  }
   public abstract void actuallyAddFeature(int code, Feature f);
   public abstract void featureAddedMapSquareNotFound(IntegerCoordinate coordinate, Feature f);
   public abstract void featureRemovedMapSquareNotFound(IntegerCoordinate coordinate, Feature f);

  // remove feature
   public void removeFeature(int code) {
    Feature f = this.getFeature(code);
    if (f == null || f.remove) {
      return;
    }
    f.remove = true;
    if (!f.inMap(this.mapXI(), this.mapYI(), this.mapXF(), this.mapYF())) {
      return;
    }
    this.removeFeatureFromTerrain(f);
    if (!f.displaysImage()) {
      return;
    }
    this.removeFeatureImage(f);
    this.refreshTerrainImage();
  }
   public abstract Feature getFeature(int code);
   public abstract Collection<Feature> features();

   public void addFeatureToTerrain(Feature f) {
    if (f == null || f.remove) {
      return;
    }
    for (int i = round(f.x); i < round(f.x + f.sizeX); i++) {
      for (int j = round(f.y); j < round(f.y + f.sizeY); j++) {
        if (f.ignoreSquare(i - round(f.x), j - round(f.y))) {
          continue;
        }
        GameMapSquare square = this.mapSquare(i, j);
        if (square != null) {
          square.addedFeature(f);
        }
        else {
          this.featureAddedMapSquareNotFound(new IntegerCoordinate(i, j), f);
        }
      }
    }
  }

   public void removeFeatureFromTerrain(Feature f) {
    if (f == null || f.remove) {
      return;
    }
    for (int i = round(f.x); i < round(f.x + f.sizeX); i++) {
      for (int j = round(f.y); j < round(f.y + f.sizeY); j++) {
        if (f.ignoreSquare(i - round(f.x), j - round(f.y))) {
          continue;
        }
        GameMapSquare square = this.mapSquare(i, j);
        if (square != null) {
          square.removedFeature(f);
        }
        else {
          this.featureRemovedMapSquareNotFound(new IntegerCoordinate(i, j), f);
        }
      }
    }
  }

  // refresh feature image and terrain addition/removal (remove then add)
   public void refreshFeature(int code) {
    this.refreshFeature(this.getFeature(code));
  }
   public void refreshFeature(Feature f) {
    if (f == null || f.remove) {
      return;
    }
    f.refresh_map_image = false;
    if (!f.inMap(this.mapXI(), this.mapYI(), this.mapXF(), this.mapYF())) {
      return;
    }
    if (!f.displaysImage()) {
      return;
    }
    this.removeFeatureImage(f);
    this.terrainImageGrid(f.getImage(), round(floor(f.x)), round(floor(f.y)), f.sizeX, f.sizeY);
    this.refreshTerrainImage();
    this.removeFeatureFromTerrain(f);
    this.addFeatureToTerrain(f);
  }

   public void removeFeatureImage(Feature f) {
    this.colorTerrainGrid(Constants.color_transparent, round(f.x), round(f.y), f.sizeX, f.sizeY);
    for (int i = round(f.xi()); i < round(f.xf()); i++) {
      for (int j = round(f.yi()); j < round(f.yf()); j++) {
        this.terrainImageGrid(this.mapSquare(i, j).terrainImage(), i, j);
      }
    }
    for (Feature f2 : this.features()) {
      if (f2.map_key == f.map_key) {
        continue;
      }
      if (f2.x < f.x + f.sizeX && f2.y < f.y + f.sizeY && f2.x + f2.sizeX > f.x && f2.y + f2.sizeY > f.y) {
        DImg dimg = new DImg(f2.getImage());
        dimg.setGrid(f2.sizeX, f2.sizeY);
        int xi_overlap = round(max(f.x, f2.x));
        int yi_overlap = round(max(f.y, f2.y));
        int w_overlap = round(min(f.xf() - xi_overlap, f2.xf() - xi_overlap));
        int h_overlap = round(min(f.yf() - yi_overlap, f2.yf() - yi_overlap));
        PImage imagePiece = dimg.getImageGridPiece(xi_overlap - round(f2.x),
          yi_overlap - round(f2.y), w_overlap, h_overlap);
        this.terrainImageGrid(imagePiece, xi_overlap, yi_overlap, w_overlap, h_overlap);
      }
    }
  }

  // add unit
   public void addUnit(Unit u, float x, float y) {
    u.setLocation(x, y);
    this.addUnit(u);
  }
   public void addUnit(Unit u) {
    this.addUnit(u, this.nextUnitKey);
    this.nextUnitKey++;
  }
   public void addUnit(Unit u, int code) {
    this.units.put(code, u);
    u.map_key = code;
    if (u.x - u.size - Constants.small_number < this.mapXI()) {
      u.x = this.mapXI() + u.size + Constants.small_number;
    }
    else if (u.x + u.size + Constants.small_number > this.mapXF()) {
      u.x = this.mapXF() - u.size - Constants.small_number;
    }
    if (u.y - u.size - Constants.small_number < this.mapYI()) {
      u.y = this.mapYI() + u.size + Constants.small_number;
    }
    else if (u.y + u.size + Constants.small_number > this.mapYF()) {
      u.y = this.mapYF() - u.size - Constants.small_number;
    }
    u.curr_squares_on = u.getSquaresOn();
    u.resolveFloorHeight(this);
    if (u.type.equals("Zombie")) {
      this.zombie_counter++;
    }
  }
  // remove unit
   public void removeUnit(int code) {
    if (this.units.containsKey(code)) {
      this.units.get(code).remove = true;
    }
  }
  // add player unit
   public void addPlayer(Hero player) {
    player.ai_controlled = false;
    this.addUnit(player, 0);
    this.setViewLocation(player.x, player.y);
  }

  // add item
   public void addItem(Item i) {
    this.addItem(i, true);
  }
   public void addItemAsIs(Item i) {
    int disappear_timer = i.disappear_timer;
    this.addItem(i, i.disappearing);
    i.disappear_timer = disappear_timer;
  }
   public void addItemAsIs(Item i, int code) {
    int disappear_timer = i.disappear_timer;
    this.addItem(i, code, i.disappearing);
    i.disappear_timer = disappear_timer;
  }
   public void addItem(Item i, boolean auto_disappear) {
    this.addItem(i, this.nextItemKey, auto_disappear);
    this.nextItemKey++;
  }
   public void addItem(Item i, float x, float y) {
    this.addItem(i, x, y, true);
  }
   public void addItem(Item i, float x, float y, boolean auto_disappear) {
    i.setLocation(x, y);
    this.addItem(i, this.nextItemKey, auto_disappear);
    this.nextItemKey++;
  }
   public void addItem(Item i, int code) {
    this.addItem(i, code, true);
  }
   public void addItem(Item i, int code, boolean auto_disappear) {
    if (auto_disappear) {
      i.disappearing = true;
      i.disappear_timer = Constants.item_disappearTimer;
    }
    else {
      i.disappearing = false;
    }
    this.items.put(code, i);
    if (i.x - i.size - Constants.small_number < this.mapXI()) {
      i.x = this.mapXI() + i.size + Constants.small_number;
    }
    else if (i.x + i.size + Constants.small_number > this.mapXF()) {
      i.x = this.mapXF() - i.size - Constants.small_number;
    }
    if (i.y - i.size - Constants.small_number < this.mapYI()) {
      i.y = this.mapYI() + i.size + Constants.small_number;
    }
    else if (i.y + i.size + Constants.small_number > this.mapYF()) {
      i.y = this.mapYF() - i.size - Constants.small_number;
    }
    i.map_key = code;
  }
  // remove item
   public void removeItem(int code) {
    if (this.items.containsKey(code)) {
      this.items.get(code).remove = true;
    }
  }

  // add projectile
   public void addProjectile(Projectile p) {
    this.projectiles.add(p);
  }
  // remove projectile
   public void removeProjectile(int index) {
    if (index < 0 || index >= this.projectiles.size()) {
      return;
    }
    this.projectiles.remove(index);
  }

  // add visual effect
   public void addVisualEffect(int id, float v_x, float v_y) {
    VisualEffect v = new VisualEffect(id);
    v.setLocation(v_x, v_y);
    this.addVisualEffect(v);
  }
   public void addVisualEffect(VisualEffect v) {
    switch(v.ID) {
      case 4001:
        for (VisualEffect ve : this.visualEffects) {
          if (ve.ID == 4001) {
            ve.remove = true;
          }
        }
        break;
    }
    this.visualEffects.add(v);
  }
  // remove visual effect
   public void removeVisualEffect(int index) {
    if (index < 0 || index >= this.visualEffects.size()) {
      return;
    }
    this.visualEffects.remove(index);
  }

   public void addHeaderMessage(String message) {
    this.headerMessages.add(new HeaderMessage(message));
    if (this.headerMessages.size() > Constants.map_maxHeaderMessages) {
      this.headerMessages.remove(0);
    }
  }
   public void addHeaderMessage(String message, int message_id) {
    HeaderMessage header_message = new HeaderMessage(message);
    switch(message_id) {
      case 1: // center of screen
        header_message.placeCenter();
        header_message.clickable = false;
        break;
      case 2: // center of screen and longer
        header_message.placeCenter();
        header_message.show_time = 6000;
        header_message.clickable = false;
        break;
      case 3: // longer
        header_message.show_time = 5000;
        header_message.clickable = false;
        break;
      case 4: // center of screen and bigger
        header_message.placeCenter(40);
        header_message.clickable = false;
        break;
      case 5: // center of screen and bigger and longer
        header_message.placeCenter(40);
        header_message.show_time = 6000;
        header_message.clickable = false;
        break;
      default:
        break;
    }
    this.headerMessages.add(header_message);
    if (this.headerMessages.size() > Constants.map_maxHeaderMessages) {
      this.headerMessages.remove(0);
    }
  }


   public void displayNerdStats() {
    fill(255);
    textSize(14);
    textAlign(LEFT, TOP);
    float y_stats = this.yi + 31;
    float line_height = textAscent() + textDescent() + 2;
    text("Map Location: " + this.code.display_name(), this.xi + 1, y_stats);
    y_stats += line_height;
    text("FPS: " + PApplet.parseInt(global.lastFPS), this.xi + 1, y_stats);
    y_stats += line_height;
    Map<Thread, StackTraceElement[]> all_threads = Thread.getAllStackTraces();
    text("Active Threads: " + all_threads.size(), this.xi + 1, y_stats);
    y_stats += line_height;
    int gamemap_threads = 0;
    int unit_threads = 0;
    for (Thread thread : all_threads.keySet()) {
      String thread_name = thread.getName();
      if (thread_name.equals("TerrainDimgThread") || thread_name.equals("MouseMoveThread") ||
        thread_name.equals("LoadChunkThread") || thread_name.equals("FogDImgThread") ||
        thread_name.equals("HangingFeaturesThread")) {
        gamemap_threads++;
      }
      else if (thread_name.equals("PathFindingThread")) {
        unit_threads++;
      }
    }
    text("GameMap Threads: " + gamemap_threads, this.xi + 1, y_stats);
    y_stats += line_height;
    text("Unit Threads: " + unit_threads, this.xi + 1, y_stats);
    y_stats += line_height;
    text("Current View: " + this.viewX + ", " + this.viewY, this.xi + 1, y_stats);
    if (this.units.containsKey(0)) {
      y_stats += line_height;
      text("Location: (" + this.units.get(0).x + ", " + this.units.get(0).y +
        ", " + this.units.get(0).curr_height + ")", this.xi + 1, y_stats);
      y_stats += line_height;
      text("Facing: (" + this.units.get(0).facingX + ", " + this.units.get(0).facingY +
        ", " + this.units.get(0).facingA + ")", this.xi + 1, y_stats);
      y_stats += line_height;
      text("Height: (" + this.units.get(0).curr_height + ", " + this.units.get(0).floor_height +
        ", " + this.units.get(0).unit_height + ")", this.xi + 1, y_stats);
      try {
        GameMapSquare square = this.mapSquare(PApplet.parseInt(this.units.get(0).x), PApplet.parseInt(this.units.get(0).y));
        y_stats += line_height;
        text("Terrain: (" + square.terrainName() + ", " + PApplet.parseInt(10.0f * square.light_level)/10.0f + ")", this.xi + 1, y_stats);
      } catch(NullPointerException e) {}
    }
  }


   public void drawMap() {
    if (this.update_terrain_display) {
      this.update_terrain_display = false;
      this.refreshTerrainImage();
    }
    rectMode(CORNERS);
    noStroke();
    fill(this.color_border);
    rect(this.xi, this.yi, this.xf, this.yf);
    fill(this.color_background);
    rect(this.xi + Constants.map_borderSize, this.yi + Constants.map_borderSize,
      this.xf - Constants.map_borderSize, this.yf - Constants.map_borderSize);
    // hovered info
    if (this.hovered_object != null && this.hovered_object.remove) {
      this.hovered_object = null;
    }
    String nameDisplayed = null;
    int ellipseColor = color(255);
    float ellipseWeight = 0.8f;
    // display terrain
    imageMode(CORNERS);
    image(this.terrain_display, this.xi_map_old + this.xi_map_dif, this.yi_map_old +
      this.yi_map_dif, this.xf_map_old + this.xf_map_dif, this.yf_map_old + this.yf_map_dif);
    if (this.hovered && this.hovered_explored) {
      try {
        nameDisplayed = this.mapSquare(PApplet.parseInt(this.mX), PApplet.parseInt(this.mY)).terrainName();
      } catch(NullPointerException e) {}
    }
    imageMode(CORNER);
    for (int i = round(ceil(this.startSquareX_old)); i < round(floor(this.startSquareX_old + this.visSquareX_old)); i++) {
      for (int j = round(ceil(this.startSquareY_old)); j < round(floor(this.startSquareY_old + this.visSquareY_old)); j++) {
        try {
          if (this.mapSquare(i, j).terrain_id == 191) {
            image(this.mapSquare(i, j).terrainImage(), this.xi_map_old + (i - this.startSquareX_old) *
              this.zoom_old, this.yi_map_old + (j - this.startSquareY_old) * this.zoom_old, this.zoom_old, this.zoom_old);
          }
        } catch(NullPointerException e) {}
      }
    }
    // display units
    boolean display_player = false;
    imageMode(CENTER);
    Iterator unit_iterator = this.units.entrySet().iterator();
    while(unit_iterator.hasNext()) {
      Map.Entry<Integer, Unit> entry = (Map.Entry<Integer, Unit>)unit_iterator.next();
      Unit u = entry.getValue();
      if (!u.inView(this.startSquareX_old, this.startSquareY_old, this.startSquareX_old +
        this.visSquareX_old, this.startSquareY_old + this.visSquareY_old)) {
        continue;
      }
      if (u.map_key == 0) {
        display_player = true;
        continue;
      }
      if (this.draw_fog && !this.mapSquare(PApplet.parseInt(u.x), PApplet.parseInt(u.y)).visible) {
        if (!this.units.containsKey(0) || u.alliance != this.units.get(0).alliance) {
          continue;
        }
      }
      this.displayUnit(u);
    }
    if (display_player) {
      this.displayUnit(this.units.get(0), true);
    }
    // display items
    imageMode(CENTER);
    Iterator item_iterator = this.items.entrySet().iterator();
    while(item_iterator.hasNext()) {
      Map.Entry<Integer, Item> entry = (Map.Entry<Integer, Item>)item_iterator.next();
      Item i = entry.getValue();
      if (!i.inView(this.startSquareX_old, this.startSquareY_old, this.startSquareX_old +
        this.visSquareX_old, this.startSquareY_old + this.visSquareY_old)) {
        continue;
      }
      if (this.draw_fog && !this.mapSquare(PApplet.parseInt(i.x), PApplet.parseInt(i.y)).visible) {
        continue;
      }
      float translateX = this.xi_map_old + (i.x - this.startSquareX_old) * this.zoom_old;
      float translateY = this.yi_map_old + (i.y - this.startSquareY_old - Constants.item_bounceOffset *
        i.bounce.value / PApplet.parseFloat(Constants.item_bounceConstant)) * this.zoom_old;
      translate(translateX, translateY);
      image(i.getImage(), 0, 0, i.width() * this.zoom_old, i.height() * this.zoom_old);
      if (i.stack > 1) {
        fill(255);
        textSize(14);
        textAlign(RIGHT, BOTTOM);
        text(i.stack, i.size * this.zoom_old - 2, i.size * this.zoom_old - 2);
      }
      translate(-translateX, -translateY);
    }
    // display projectiles
    imageMode(CENTER);
    for (Projectile p : this.projectiles) {
      if (!p.inView(this.startSquareX_old, this.startSquareY_old, this.startSquareX_old +
        this.visSquareX_old, this.startSquareY_old + this.visSquareY_old)) {
        continue;
      }
      if (this.draw_fog && !this.mapSquare(PApplet.parseInt(p.x), PApplet.parseInt(p.y)).visible) {
        continue;
      }
      float translateX = this.xi_map_old + (p.x - this.startSquareX_old) * this.zoom_old;
      float translateY = this.yi_map_old + (p.y - this.startSquareY_old) * this.zoom_old;
      translate(translateX, translateY);
      rotate(p.facingA);
      image(p.getImage(), 0, 0, p.width() * this.zoom_old, p.height() * this.zoom_old);
      rotate(-p.facingA);
      translate(-translateX, -translateY);
    }
    // display visual effects
    imageMode(CENTER);
    for (VisualEffect v : this.visualEffects) {
      float translateX = this.xi_map_old + (v.x - this.startSquareX_old) * this.zoom_old;
      float translateY = this.yi_map_old + (v.y - this.startSquareY_old) * this.zoom_old;
      translate(translateX, translateY);
      v.display(this.zoom_old);
      translate(-translateX, -translateY);
    }
    // name displayed
    MapObject this_hovered_object = this.hovered_object;
    if (this_hovered_object != null) {
      nameDisplayed = this_hovered_object.display_name();
      float ellipseX = this.xi_map_old + this.zoom_old * (this_hovered_object.xCenter() - this.startSquareX_old);
      float ellipseY = this.yi_map_old + this.zoom_old * (this_hovered_object.yCenter() - this.startSquareY_old);
      float ellipseDiameterX = this.zoom_old * this_hovered_object.width();
      float ellipseDiameterY = this.zoom_old * this_hovered_object.height();
      ellipseMode(CENTER);
      noFill();
      stroke(ellipseColor);
      strokeWeight(ellipseWeight);
      ellipse(ellipseX, ellipseY, ellipseDiameterX, ellipseDiameterY);
    }
    if (nameDisplayed != null) {
      textSize(18);
      float name_width = textWidth(nameDisplayed) + 2;
      float name_height = textAscent() + textDescent() + 2;
      float name_xi = mouseX + 2;
      float name_yi = mouseY - name_height - global.configuration.cursor_size * 0.3f;
      if (mouseX > 0.5f * width) {
        name_xi -= name_width + 4;
      }
      fill(global.color_nameDisplayed_background);
      rectMode(CORNER);
      noStroke();
      rect(name_xi, name_yi, name_width, name_height);
      fill(global.color_nameDisplayed_text);
      textAlign(LEFT, TOP);
      text(nameDisplayed, name_xi + 1, name_yi + 1);
    }
    // display fog
    if (this.draw_fog) {
      imageMode(CORNERS);
      image(this.fog_display, this.xi_fog, this.yi_fog, this.xf_fog, this.yf_fog);
    }
    // map tint
    if (this.show_tint) {
      rectMode(CORNERS);
      fill(this.color_tint);
      noStroke();
      rect(this.xi, this.yi, this.xf, this.yf);
    }
    // header messages
    for (HeaderMessage message : this.headerMessages) {
      message.drawMessage();
    }
  }


   public void displayUnit(Unit u) {
    this.displayUnit(u, false);
  }
   public void displayUnit(Unit u, boolean player_unit) {
    if (u.invisible()) {
      return;
    }
    float translateX = this.xi_map_old + (u.x - this.startSquareX_old) * this.zoom_old;
    float translateY = this.yi_map_old + (u.y - this.startSquareY_old) * this.zoom_old;
    boolean removeCache = false;
    translate(translateX, translateY);
    float net_rotation = 0;
    boolean flip = false;
    if (abs(u.facingA) > HALF_PI) {
      flip = true;
      net_rotation = (PI - abs(u.facingA)) * u.facingA / abs(u.facingA) + u.facingAngleModifier();
    }
    else {
      net_rotation = u.facingA + u.facingAngleModifier();
    }
    if (flip) {
      scale(-1, 1);
    }
    rotate(net_rotation);
    float extra_translate_x = 0;
    float extra_translate_y = 0;
    if (u.diseased()) {
      tint(90, 250, 90);
      removeCache = true;
    }
    else if (u.sick()) {
      tint(150, 255, 150);
      removeCache = true;
    }
    if (u.frozen()) {
      tint(50, 180, 250);
      removeCache = true;
    }
    else if (u.chilled()) {
      tint(120, 220, 255);
      removeCache = true;
    }
    if (u.rageOfTheBenII()) {
      tint(255, 160, 160);
      removeCache = true;
      extra_translate_x = Constants.ability_110_shakeConstant - random(2 * Constants.ability_110_shakeConstant);
      extra_translate_y = Constants.ability_110_shakeConstant - random(2 * Constants.ability_110_shakeConstant);
    }
    else if (u.rageOfTheBen()) {
      tint(255, 80, 80);
      removeCache = true;
      extra_translate_x = Constants.ability_105_shakeConstant - random(2 * Constants.ability_105_shakeConstant);
      extra_translate_y = Constants.ability_105_shakeConstant - random(2 * Constants.ability_105_shakeConstant);
    }
    if (u.aposematicCamouflage() || u.aposematicCamouflageII()) {
      tint(255, 150);
      removeCache = true;
    }
    if (u.alkaloidSecretion()) {
      ellipseMode(CENTER);
      fill(128, 82, 48, 100);
      noStroke();
      ellipse(0, 0, 2 * Constants.ability_114_range * this.zoom_old, 2 * Constants.ability_114_range * this.zoom_old);
    }
    if (u.alkaloidSecretionII()) {
      ellipseMode(CENTER);
      fill(128, 82, 48, 100);
      noStroke();
      ellipse(0, 0, 2 * Constants.ability_119_range * this.zoom_old, 2 * Constants.ability_119_range * this.zoom_old);
    }
    translate(extra_translate_x, extra_translate_y);
    if (removeCache) {
      g.removeCache(u.getImage());
    }
    imageMode(CENTER);
    image(u.getImage(), 0, 0, u.width() * this.zoom_old, u.height() * this.zoom_old);
    if (player_unit && global.player_blinking) {
      ellipseMode(CENTER);
      noFill();
      stroke(255);
      strokeWeight(0.5f);
      ellipse(0, 0, u.width() * this.zoom_old, u.height() * this.zoom_old);
    }
    if (u.weapon() != null) {
      float translateItemX = 0.9f * (u.xRadius() + Constants.unit_weaponDisplayScaleFactor * Constants.item_defaultSize) * this.zoom_old;
      float translateItemY = 0.4f * (u.yRadius() + Constants.unit_weaponDisplayScaleFactor * Constants.item_defaultSize) * this.zoom_old;
      translate(translateItemX, translateItemY);
      float weapon_adjust_x = Constants.unit_weaponDisplayScaleFactor * u.weapon().width() * this.zoom_old;
      float weapon_adjust_y = Constants.unit_weaponDisplayScaleFactor * u.weapon().height() * this.zoom_old;
      image(u.weapon().getImage(), 0, 0, weapon_adjust_x, weapon_adjust_y);
      if (u.weapon().stack > 1) {
        fill(255);
        textSize(12);
        textAlign(RIGHT, BOTTOM);
        text(u.weapon().stack, 0.5f * weapon_adjust_x - 1, 0.5f * weapon_adjust_y - 1);
      }
      translate(-translateItemX, -translateItemY);
    }
    else if (player_unit) {
      float translateItemX = 0.9f * (u.xRadius() + Constants.unit_weaponDisplayScaleFactor * Constants.item_defaultSize) * this.zoom_old;
      float translateItemY = 0.4f * (u.yRadius() + Constants.unit_weaponDisplayScaleFactor * Constants.item_defaultSize) * this.zoom_old;
      translate(translateItemX, translateItemY);
      image(global.images.getImage("icons/hand.png"), 0, 0, Constants.unit_weaponDisplayScaleFactor *
        2 * Constants.item_defaultSize * this.zoom_old, Constants.unit_weaponDisplayScaleFactor *
        2 * Constants.item_defaultSize * this.zoom_old);
      translate(-translateItemX, -translateItemY);
    }
    if (u.charred()) {
      int flame_frame = PApplet.parseInt(floor(Constants.gif_fire_frames * ((u.random_number +
        millis()) % Constants.gif_fire_time) / Constants.gif_fire_time));
      PImage fire_img = global.images.getImage("gifs/fire/" + flame_frame + ".png");
      tint(255, 220);
      image(fire_img, 0, 0, u.width() * this.zoom_old, u.height() * this.zoom_old);
      g.removeCache(fire_img);
      noTint();
      g.removeCache(fire_img);
    }
    else if (u.burnt()) {
      int flame_frame = PApplet.parseInt(floor(Constants.gif_fire_frames * ((u.random_number +
        millis()) % Constants.gif_fire_time) / Constants.gif_fire_time));
      PImage fire_img = global.images.getImage("gifs/fire/" + flame_frame + ".png");
      tint(255, 160);
      image(fire_img, 0, 0, u.width() * this.zoom_old, u.height() * this.zoom_old);
      g.removeCache(fire_img);
      noTint();
      g.removeCache(fire_img);
    }
    if (u.drenched()) {
      int drenched_frame = PApplet.parseInt(floor(Constants.gif_drenched_frames * ((u.random_number +
        millis()) % Constants.gif_drenched_time) / Constants.gif_drenched_time));
      image(global.images.getImage("gifs/drenched/" + drenched_frame + ".png"), 0, 0, u.width() * this.zoom_old, u.height() * this.zoom_old);
    }
    if (removeCache) {
      g.removeCache(u.getImage());
      noTint();
      g.removeCache(u.getImage());
    }
    if (u.curr_action == UnitAction.CASTING) {
      try {
        Ability a = u.abilities.get(u.curr_action_id);
        float img_width = 0;
        float img_height = 0;
        switch(a.ID) {
          case 103: // Nelson Glare
            ellipseMode(RADIUS);
            fill(170, 200);
            noStroke();
            img_width = Constants.ability_103_range * (1 - a.timer_other / Constants.ability_103_castTime);
            arc(0, 0, img_width * this.zoom_old, img_width * this.zoom_old, -Constants.
              ability_103_coneAngle, Constants.ability_103_coneAngle, PIE);
            fill(100, 200);
            arc(0, 0, img_width * this.zoom_old, img_width * this.zoom_old, -0.3f *
              Constants.ability_103_coneAngle, 0.3f * Constants.ability_103_coneAngle, PIE);
            break;
          case 108: // Nelson Glare II
            ellipseMode(RADIUS);
            fill(170, 200);
            noStroke();
            img_width = Constants.ability_108_range * (1 - a.timer_other / Constants.ability_108_castTime);
            arc(0, 0, img_width * this.zoom_old, img_width * this.zoom_old, -Constants.
              ability_108_coneAngle, Constants.ability_108_coneAngle, PIE);
            fill(100, 200);
            arc(0, 0, img_width * this.zoom_old, img_width * this.zoom_old, -0.3f *
              Constants.ability_108_coneAngle, 0.3f * Constants.ability_108_coneAngle, PIE);
            break;
          case 112: // Tongue Lash
            img_width = Constants.ability_112_distance * (1 - a.timer_other / Constants.ability_112_castTime);
            img_height = u.size;
            image(global.images.getImage("abilities/tongue.png"), 0.5f * img_width * this.zoom_old,
              0, img_width * this.zoom_old, img_height * this.zoom_old);
            break;
          case 117: // Tongue Lash II
            img_width = Constants.ability_117_distance * (1 - a.timer_other / Constants.ability_112_castTime);
            img_height = u.size;
            image(global.images.getImage("abilities/tongue.png"), 0.5f * img_width * this.zoom_old,
              0, img_width * this.zoom_old, img_height * this.zoom_old);
            break;
          case 1001: // Blow Smoke
            img_width = Constants.ability_1001_range * (1 - a.timer_other / Constants.ability_1001_castTime);
            img_height = img_width * Constants.ability_1001_tanConeAngle;
            image(global.images.getImage("abilities/smoke.png"), 0.5f * img_width * this.zoom_old,
              0, img_width * this.zoom_old, img_height * this.zoom_old);
            break;
          case 1003: // Title IX Charge
            img_width = Constants.ability_1003_size_w;
            img_height = Constants.ability_1003_size_h;
            strokeWeight(2);
            stroke(0);
            noFill();
            tint(255, round(255 * (1 - a.timer_other / Constants.ability_1003_castTime)));
            rectMode(CENTER);
            rect(0.5f * img_width * this.zoom_old, 0, img_width * this.zoom_old, img_height * this.zoom_old);
            image(global.images.getImage("abilities/title_ix.png"), 0.5f * img_width * this.zoom_old,
              0, img_width * this.zoom_old, img_height * this.zoom_old);
            noTint();
            break;
          default:
            break;
        }
      } catch(Exception e) {}
    }
    translate(-extra_translate_x, -extra_translate_y);
    rotate(-net_rotation);
    if (flip) {
      scale(-1, 1);
    }
    // healthbar
    float healthbarWidth = Constants.unit_healthbarWidth * this.zoom_old;
    float healthbarHeight = Constants.unit_healthbarHeight * this.zoom_old;
    float manaBarHeight = 0;
    if (Hero.class.isInstance(u)) {
      manaBarHeight += Constants.hero_manabarHeight * this.zoom;
    }
    float totalHeight = healthbarHeight + manaBarHeight;
    float translateHealthBarX = -0.5f * healthbarWidth;
    float translateHealthBarY = -1.2f * u.size * this.zoom_old - totalHeight;
    textSize(totalHeight - 0.5f);
    translate(translateHealthBarX, translateHealthBarY);
    stroke(200);
    strokeWeight(0.8f);
    fill(0);
    rectMode(CORNER);
    rect(0, 0, healthbarWidth, totalHeight);
    rect(0, 0, totalHeight, totalHeight);
    fill(255);
    textSize(healthbarHeight - 1);
    textAlign(CENTER, TOP);
    text(u.level, 0.5f * totalHeight, 1 - textDescent());
    if (player_unit) {
      fill(50, 255, 50);
    }
    else if (u.alliance == Alliance.BEN) {
      fill(50, 50, 255);
    }
    else {
      fill(255, 50, 50);
    }
    noStroke();
    float health_ratio = u.curr_health / u.health();
    if (health_ratio >= 1) {
      rect(totalHeight, 0, healthbarWidth - totalHeight, healthbarHeight);
      fill(255);
      health_ratio = min(1, health_ratio - 1);
      rectMode(CORNERS);
      rect(healthbarWidth - health_ratio * (healthbarWidth - totalHeight), 0, healthbarWidth, healthbarHeight);
    }
    else {
      rect(totalHeight, 0, health_ratio * (healthbarWidth - totalHeight), healthbarHeight);
      if (u.timer_last_damage > 0) {
        fill(255, 220, 50, PApplet.parseInt(255 * u.timer_last_damage / Constants.unit_healthbarDamageAnimationTime));
        float damage_ratio = u.last_damage_amount / u.health();
        rect(totalHeight + health_ratio * (healthbarWidth - totalHeight),
          0, damage_ratio * (healthbarWidth - totalHeight), healthbarHeight);
      }
    }
    if (Hero.class.isInstance(u)) {
      rectMode(CORNER);
      fill(255, 255, 0);
      float mana_ratio = u.currMana() / u.mana();
      if (mana_ratio >= 1) {
        rect(totalHeight, healthbarHeight, healthbarWidth - totalHeight, manaBarHeight);
        fill(255);
        mana_ratio = min(1, mana_ratio - 1);
        rectMode(CORNERS);
        rect(healthbarWidth - mana_ratio * (healthbarWidth - totalHeight),
          healthbarHeight, healthbarWidth, totalHeight);
      }
      else {
        rect(totalHeight, healthbarHeight, mana_ratio * (healthbarWidth - totalHeight), manaBarHeight);
      }
    }
    textSize(healthbarHeight + 1);
    fill(255);
    textAlign(CENTER, BOTTOM);
    text(u.display_name(), 0.5f * healthbarWidth, - 1 - textDescent());
    translate(-translateHealthBarX, -translateHealthBarY);
    translate(-translateX, -translateY);
  }


   public void drawLeftPanel(int millis) {
    float currY = Constants.map_selectedObjectPanelGap;
    if (this.selected_object != null) {
      if (this.selected_object_textbox == null) {
        this.selected_object_textbox = new SelectedObjectTextbox();
        this.selected_object_textbox.setXLocation(Constants.map_selectedObjectPanelGap,
            xi - Constants.map_selectedObjectPanelGap);
      }
      fill(255);
      textSize(Constants.map_selectedObjectTitleTextSize);
      textAlign(CENTER, TOP);
      text(this.selected_object.display_name(), 0.5f * this.xi, currY);
      currY += textAscent() + textDescent() + Constants.map_selectedObjectPanelGap;
      float image_height = min(this.selected_object_textbox.yi - 2 * Constants.
        map_selectedObjectImageGap - currY, this.xi - 2 * Constants.map_selectedObjectPanelGap);
      float image_width = min(this.xi - 2 * Constants.map_selectedObjectPanelGap,
        image_height * this.selected_object.width() / this.selected_object.height());
      imageMode(CENTER);
      currY += 0.5f * image_height + Constants.map_selectedObjectImageGap;
      image(this.selected_object.getImage(), 0.5f * this.xi, currY, image_width, image_height);
      if (Item.class.isInstance(this.selected_object)) {
        Item i = (Item)this.selected_object;
        if (i.stack > 1) {
          fill(255);
          textAlign(RIGHT, BOTTOM);
          textSize(24);
          text(i.stack, 0.5f * (this.xi + image_width) - 2, currY + 0.5f * image_height - 2);
        }
        this.selected_object_textbox.setText(this.selected_object.selectedObjectTextboxText());
        this.selected_object_textbox.update(millis);
        // item tier image
        PImage tier_image = global.images.getImage("icons/tier_" + i.tier + ".png");
        float tier_image_width = (Constants.map_tierImageHeight * tier_image.width) / tier_image.height;
        imageMode(CORNER);
        image(tier_image, this.selected_object_textbox.xf - tier_image_width - 4,
          this.selected_object_textbox.yi + 4, tier_image_width, Constants.map_tierImageHeight);
      }
      else if (Unit.class.isInstance(this.selected_object) || Hero.class.isInstance(this.selected_object)) {
        Unit u = (Unit)this.selected_object;
        // weapon
        if (u.weapon() != null) {
          float weapon_image_width = image_width * Constants.unit_weaponDisplayScaleFactor * u.weapon().width() / u.width();
          float weapon_image_height = image_height * Constants.unit_weaponDisplayScaleFactor * u.weapon().height() / u.height();
          float weapon_image_x = 0.5f * this.xi + 0.45f * (image_width + weapon_image_width);
          float weapon_image_y = currY + 0.2f * (image_height + weapon_image_height);
          image(u.weapon().getImage(), weapon_image_x, weapon_image_y, weapon_image_width, weapon_image_height);
        }
        boolean lower_textbox = (u.statuses.size() > 0);
        if (lower_textbox) {
          this.selected_object_textbox.setYLocation(this.selected_object_textbox.yi +
            Constants.map_statusImageHeight + 4, this.selected_object_textbox.yf);
        }
        this.selected_object_textbox.setText(this.selected_object.selectedObjectTextboxText());
        this.selected_object_textbox.update(millis);
        // status effects
        float x_status = 3;
        float y_status = this.selected_object_textbox.yi - Constants.map_statusImageHeight - 2;
        StatusEffectCode status_effect_hovered = null;
        for (Map.Entry<StatusEffectCode, StatusEffect> entry : u.statuses.entrySet()) {
          imageMode(CORNER);
          rectMode(CORNER);
          ellipseMode(CENTER);
          fill(255, 150);
          stroke(0);
          strokeWeight(1);
          rect(x_status, y_status, Constants.map_statusImageHeight, Constants.map_statusImageHeight);
          image(global.images.getImage(entry.getKey().getImageString()), x_status,
            y_status, Constants.map_statusImageHeight, Constants.map_statusImageHeight);
          if (!entry.getValue().permanent) {
            fill(100, 100, 255, 140);
            noStroke();
            try {
              float angle = -HALF_PI + 2 * PI * entry.getValue().timer_gone / entry.getValue().timer_gone_start;
              arc(x_status + 0.5f * Constants.map_statusImageHeight, y_status +
                0.5f * Constants.map_statusImageHeight, Constants.map_statusImageHeight,
                Constants.map_statusImageHeight, -HALF_PI, angle, PIE);
            } catch(Exception e) {}
          }
          if (mouseX > x_status && mouseX < x_status + Constants.map_statusImageHeight &&
            mouseY > y_status && mouseY < y_status + Constants.map_statusImageHeight) {
            status_effect_hovered = entry.getKey();
          }
          x_status += Constants.map_statusImageHeight + 2;
        }
        if (status_effect_hovered != null) {
          noStroke();
          fill(global.color_nameDisplayed_background);
          textSize(14);
          float rect_height = textAscent() + textDescent() + 2;
          float rect_width = textWidth(status_effect_hovered.code_name()) + 2;
          rect(mouseX + 1, mouseY - rect_height - 1, rect_width, rect_height);
          fill(255);
          textAlign(LEFT, TOP);
          text(status_effect_hovered.code_name(), mouseX + 2, mouseY - rect_height - 1);
        }
        // unit tier image
        PImage tier_image = global.images.getImage("icons/tier_" + u.tier() + ".png");
        float tier_image_width = (Constants.map_tierImageHeight * tier_image.width) / tier_image.height;
        imageMode(CORNER);
        image(tier_image, this.selected_object_textbox.xf - tier_image_width - 4,
          this.selected_object_textbox.yi + 4, tier_image_width, Constants.map_tierImageHeight);
        // raise textbox
        if (lower_textbox) {
          this.selected_object_textbox.setYLocation(this.selected_object_textbox.yi -
            Constants.map_statusImageHeight - 4, this.selected_object_textbox.yf);
        }
      }
      else {
        this.selected_object_textbox.setText(this.selected_object.selectedObjectTextboxText());
        this.selected_object_textbox.update(millis);
      }
    }
    stroke(0);
    strokeWeight(1.5f);
    line(0, 0.5f * height, this.xi, 0.5f * height);
  }

   public boolean leftPanelElementsHovered() {
    if (this.selected_object != null && this.selected_object_textbox != null) {
      if (this.selected_object_textbox.hovered) {
        return true;
      }
    }
    return false;
  }


   public void updateView(int timeElapsed) {
    boolean refreshView = false;
    // lockscreen
    if ((global.profile.options.lock_screen || global.holding_space) && this.in_control && this.units.containsKey(0)) {
      this.setViewLocation(this.units.get(0).x, this.units.get(0).y);
      refreshView = true;
    }
    else {
      // moving view
      if (this.view_moving_left) {
        this.moveView(-timeElapsed * global.profile.options.map_viewMoveSpeedFactor, 0, false);
        refreshView = true;
      }
      if (this.view_moving_right) {
        this.moveView(timeElapsed * global.profile.options.map_viewMoveSpeedFactor, 0, false);
        refreshView = true;
      }
      if (this.view_moving_up) {
        this.moveView(0, -timeElapsed * global.profile.options.map_viewMoveSpeedFactor, false);
        refreshView = true;
      }
      if (this.view_moving_down) {
        this.moveView(0, timeElapsed * global.profile.options.map_viewMoveSpeedFactor, false);
        refreshView = true;
      }
    }
    this.timer_refresh_fog -= timeElapsed;
    if (this.timer_refresh_fog < 0) {
      this.timer_refresh_fog += global.profile.options.fog_update_time;
      this.refreshFog();
    }
    if (refreshView) {
      this.refreshDisplayMapParameters();
    }
    else {
      this.refreshFogImage();
    }
    // header messages
    int centered = 0;
    for (int i = 0; i < this.headerMessages.size(); i++) {
      int index = i - centered;
      if (this.headerMessages.get(i).centered) {
        index = centered;
        centered++;
      }
      this.headerMessages.get(i).updateView(timeElapsed, index);
      if (this.headerMessages.get(i).remove) {
        this.headerMessages.remove(i);
      }
    }
  }

   public void refreshFog() {
    for (int k = 0; k < Constants.map_lightUpdateIterations; k++) {
      for (int i = max(round(floor(this.startSquareX)) - 8, this.mapXI());
        i <= min(round(ceil(this.startSquareX + this.visSquareX)) + 8, this.mapXF()); i++) {
        for (int j = max(round(floor(this.startSquareY)) - 8, this.mapYI());
          j <= min(round(ceil(this.startSquareY + this.visSquareY)) + 8, this.mapYF()); j++) {
          try {
            if (k == 0) {
              this.mapSquare(i, j).original_light = this.mapSquare(i, j).light_level;
            }
            this.mapSquare(i, j).updateLightLevel(this, i, j);
            if (k == Constants.map_lightUpdateIterations - 1) {
              this.mapSquare(i, j).light_source = false;
              if (abs(this.mapSquare(i, j).light_level - this.mapSquare(i, j).original_light) < Constants.small_number) {
                continue;
              }
              if (this.mapSquare(i, j).mapEdge()) {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              else if (this.mapSquare(i, j).visible) {
                this.colorFogGrid(this.mapSquare(i, j).getColor(Constants.color_transparent), i, j);
              }
              else if (this.mapSquare(i, j).explored) {
                this.colorFogGrid(this.mapSquare(i, j).getColor(this.fogColor), i, j);
              }
              else {
                this.colorFogGrid(this.mapSquare(i, j).getColor(Constants.color_black), i, j);
              }
            }
          } catch(NullPointerException e) {}
        }
      }
    }
    if (this.units.containsKey(0)) {
      this.units.get(0).refreshPlayerSight(this);
    }
  }

   public void updateMap(int time_elapsed) {
    // Update features
    this.updateFeatures(time_elapsed);
    // Update units
    Iterator unit_iterator = this.units.entrySet().iterator();
    while(unit_iterator.hasNext()) {
      Map.Entry<Integer, Unit> entry = (Map.Entry<Integer, Unit>)unit_iterator.next();
      Unit u = entry.getValue();
      if (u.remove) {
        u.destroy(this);
        unit_iterator.remove();
        if (u.type.equals("Zombie")) {
          this.zombie_counter--;
        }
        continue;
      }
      u.update(time_elapsed, this);
      if (u.remove) {
        u.destroy(this);
        unit_iterator.remove();
        if (u.type.equals("Zombie")) {
          this.zombie_counter--;
        }
      }
    }
    this.updatePlayerUnit(time_elapsed);
    // Update items
    Iterator item_iterator = this.items.entrySet().iterator();
    while(item_iterator.hasNext()) {
      Map.Entry<Integer, Item> entry = (Map.Entry<Integer, Item>)item_iterator.next();
      Item i = entry.getValue();
      if (i.remove) {
        item_iterator.remove();
        continue;
      }
      i.update(time_elapsed);
      try {
        if (this.mapSquare(PApplet.parseInt(i.x), PApplet.parseInt(i.y)).terrain_id == 191) {
          i.remove = true;
        }
      } catch(NullPointerException e) {
      }
      if (i.remove) {
        item_iterator.remove();
      }
    }
    // Update projectiles
    for (int i = 0; i < this.projectiles.size(); i++) {
      if (this.projectiles.get(i).remove) {
        this.removeProjectile(i);
        i--;
        continue;
      }
      this.projectiles.get(i).update(time_elapsed, this);
      if (this.projectiles.get(i).remove) {
        this.removeProjectile(i);
        i--;
      }
    }
    // Update visual effects
    for (int i = 0; i < this.visualEffects.size(); i++) {
      if (this.visualEffects.get(i).remove) {
        this.removeVisualEffect(i);
        i--;
        continue;
      }
      this.visualEffects.get(i).update(time_elapsed);
      if (this.visualEffects.get(i).remove) {
        this.removeVisualEffect(i);
        i--;
      }
    }
  }
   public abstract void updateFeatures(int time_elapsed);
   public void updateFeature(Feature f, Iterator it, int time_elapsed) {
    if (f.remove) {
      this.removeFeature(f.map_key);
      it.remove();
      return;
    }
    f.update(time_elapsed, this);
    if (f.refresh_map_image) {
      this.refreshFeature(f.map_key);
    }
    if (f.remove) {
      this.removeFeature(f.map_key);
      it.remove();
    }
  }
   public abstract void updateFeaturesCheckRemovalOnly();

   public void updatePlayerUnit(int timeElapsed) {
    if (!this.units.containsKey(0)) {
      return;
    }
    if (!Hero.class.isInstance(this.units.get(0))) {
      return;
    }
    Hero player = (Hero)this.units.get(0);
    if (global.holding_shift) {
      player.addStatusEffect(StatusEffectCode.SNEAKING);
    }
    else {
      player.removeStatusEffect(StatusEffectCode.SNEAKING);
    }
  }

   public void updateMapCheckObjectRemovalOnly() {
    // Check features
    this.updateFeaturesCheckRemovalOnly();
    // Check units
    Iterator unit_iterator = this.units.entrySet().iterator();
    while(unit_iterator.hasNext()) {
      Map.Entry<Integer, Unit> entry = (Map.Entry<Integer, Unit>)unit_iterator.next();
      if (entry.getValue().remove) {
        entry.getValue().destroy(this);
        unit_iterator.remove();
        if (entry.getValue().type.equals("Zombie")) {
          this.zombie_counter--;
        }
      }
    }
    // Check items
    Iterator item_iterator = this.items.entrySet().iterator();
    while(item_iterator.hasNext()) {
      Map.Entry<Integer, Item> entry = (Map.Entry<Integer, Item>)item_iterator.next();
      if (entry.getValue().remove) {
        item_iterator.remove();
      }
    }
    // Check projectiles
    for (int i = 0; i < this.projectiles.size(); i++) {
      if (this.projectiles.get(i).remove) {
        this.removeProjectile(i);
        i--;
      }
    }
    // Check visual effects
    for (int i = 0; i < this.visualEffects.size(); i++) {
      if (this.visualEffects.get(i).remove) {
        this.removeVisualEffect(i);
        i--;
        continue;
      }
    }
  }

   public void splashDamage(float explode_x, float explode_y, float explode_range,
    float explode_maxPower, float explode_minPower, int source_key,
    DamageType damageType, Element element, float piercing, float penetration,
    boolean friendly_fire) {
    if (explode_range <= 0) {
      return;
    }
    Unit source = this.units.get(source_key);
    for (Map.Entry<Integer, Unit> entry : this.units.entrySet()) {
      Unit u = entry.getValue();
      if (source != null && !friendly_fire && source.alliance == u.alliance) {
        continue;
      }
      float distance = u.distanceFromPoint(explode_x, explode_y);
      float distance_ratio = 1 - distance / explode_range;
      if (distance_ratio <= 0) {
        continue;
      }
      float net_power = explode_minPower + distance_ratio * (explode_maxPower - explode_minPower);
      u.damage(source, u.calculateDamageFrom(net_power, damageType, element, piercing, penetration));
    }
  }

  // return max height from list of map squares
   public int maxHeightOfSquares(ArrayList<IntegerCoordinate> coordinates, boolean moving_onto) {
    int max_height = -100;
    for (IntegerCoordinate coordinate : coordinates) {
      try {
        int square_elevation = this.mapSquare(coordinate.x, coordinate.y).elevation(moving_onto);
        if (square_elevation > max_height) {
          max_height = square_elevation;
        }
      } catch(NullPointerException e) {}
    }
    return max_height;
  }

   public int heightOfSquare(IntegerCoordinate coordinate, boolean moving_onto) {
    return this.heightOfSquare(coordinate.x, coordinate.y, moving_onto);
  }
   public int heightOfSquare(int x, int y, boolean moving_onto) {
    int square_height = -100;
    try {
      square_height = this.mapSquare(x, y).elevation(moving_onto);
    } catch(NullPointerException e) {}
    return square_height;
  }

   public boolean containsMapSquare(IntegerCoordinate coordinate) {
    if (coordinate.x >= this.mapXI() && coordinate.x < this.mapXF() &&
      coordinate.y >= this.mapYI() && coordinate.y < this.mapYF()) {
      return true;
    }
    return false;
  }


   public void update(int millis) {
    int time_elapsed = millis - this.lastUpdateTime;
    this.updateMap(time_elapsed); // map and mapObject logic
    this.updateView(time_elapsed); // if moving or zooming, check refresh_fog
    this.drawMap(); // everything visual
    this.lastUpdateTime = millis;
  }

   public void mouseMove(float mX, float mY) {
    this.last_x = mX;
    this.last_y = mY;
    if (this.mouse_move_thread != null && this.mouse_move_thread.isAlive()) {
      this.restart_mouseMoveThread = true;
    }
    else {
      this.startMouseMoveThread();
    }
  }

   public void startMouseMoveThread() {
    this.mouse_move_thread = new MouseMoveThread(this.last_x, this.last_y);
    this.mouse_move_thread.start();
  }

   public void updateCursorPosition() {
    this.updateCursorPosition(this.last_x, this.last_y);
  }
   public void updateCursorPosition(float mouse_x, float mouse_y) {
    this.mX = this.startSquareX + (this.last_x - this.xi_map) / this.zoom;
    this.mY = this.startSquareY + (this.last_y - this.yi_map) / this.zoom;
  }

   public void selectHoveredObject() {
    if (this.hovered_area && !this.hovered_border) {
      this.selected_object = this.hovered_object;
    }
  }

   public void mousePress() {
    for (HeaderMessage message : this.headerMessages) {
      message.mousePress();
    }
    if (this.selected_object != null && this.selected_object_textbox != null) {
      this.selected_object_textbox.mousePress();
    }
    switch(mouseButton) {
      case LEFT:
        this.selectHoveredObject();
        break;
      case RIGHT:
        if (!this.hovered_area) {
          break;
        }
        boolean viewing_inventory = false;
        if (this.units.containsKey(0) && Hero.class.isInstance(this.units.get(0))) {
          viewing_inventory = ((Hero)this.units.get(0)).inventory.viewing;
        }
        if (this.units.containsKey(0) && this.in_control && !viewing_inventory) {
          Unit player = this.units.get(0);
          if (player.curr_action_unhaltable) {
            break;
          }
          if (player.weapon() != null && player.weapon().shootable() && global.holding_ctrl) {
            player.aim(this.mX, this.mY);
          }
          else if (this.hovered_object == null || !this.hovered_object.targetable(player)) {
            player.moveTo(this.mX, this.mY, this);
            this.addVisualEffect(4001, this.mX, this.mY);
          }
          else {
            player.target(this.hovered_object, this, global.holding_ctrl);
          }
        }
        break;
      case CENTER:
        break;
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.selected_object != null && this.selected_object_textbox != null) {
      this.selected_object_textbox.mouseRelease(mX, mY);
    }
  }

   public void scroll(int amount) {
    if (this.selected_object != null && this.selected_object_textbox != null) {
      this.selected_object_textbox.scroll(amount);
    }
    if (this.hovered_area && global.holding_ctrl) {
      this.changeZoom(Constants.map_scrollZoomFactor * amount);
    }
  }

   public void keyPress() {
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = true;
          break;
        case RIGHT:
          this.view_moving_right = true;
          break;
        case UP:
          this.view_moving_up = true;
          break;
        case DOWN:
          this.view_moving_down = true;
          break;
      }
    }
    else {
      switch(key) {
        case ' ':
          if (this.units.containsKey(0) && !global.holding_ctrl) {
            this.selected_object = this.units.get(0);
          }
          break;
        case 'q':
        case 'Q':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            this.units.get(0).dropWeapon(this);
          }
          break;
        case 'a':
        case 'A':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            if (this.units.get(0).abilities.size() < 2 || this.units.get(0).abilities.get(1) == null) {
              break;
            }
            else if (this.units.get(0).silenced()) {
              this.addHeaderMessage("You are silenced");
            }
            else {
              this.units.get(0).cast(1, this, this.hovered_object, true);
            }
          }
          break;
        case 's':
        case 'S':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            if (this.units.get(0).abilities.size() < 3 || this.units.get(0).abilities.get(2) == null) {
              break;
            }
            else if (this.units.get(0).silenced()) {
              this.addHeaderMessage("You are silenced");
            }
            else {
              this.units.get(0).cast(2, this, this.hovered_object, true);
            }
          }
          break;
        case 'd':
        case 'D':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            if (this.units.get(0).abilities.size() < 4 || this.units.get(0).abilities.get(3) == null) {
              break;
            }
            else if (this.units.get(0).silenced()) {
              this.addHeaderMessage("You are silenced");
            }
            else {
              this.units.get(0).cast(3, this, this.hovered_object, true);
            }
          }
          break;
        case 'f':
        case 'F':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            if (this.units.get(0).abilities.size() < 5 || this.units.get(0).abilities.get(4) == null) {
              break;
            }
            else if (this.units.get(0).silenced()) {
              this.addHeaderMessage("You are silenced");
            }
            else {
              this.units.get(0).cast(4, this, this.hovered_object, true);
            }
          }
          break;
        case 'v':
        case 'V':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            this.units.get(0).jump(this);
          }
          break;
        case 'y':
        case 'Y':
          if (this.units.containsKey(0) && !global.holding_ctrl && this.in_control) {
            this.units.get(0).stopAction();
          }
          break;
      }
    }
  }

   public void keyRelease() {
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = false;
          break;
        case RIGHT:
          this.view_moving_right = false;
          break;
        case UP:
          this.view_moving_up = false;
          break;
        case DOWN:
          this.view_moving_down = false;
          break;
      }
    }
    else {
      switch(key) {
      }
    }
  }

   public void loseFocus() {
  }

   public void gainFocus() {
  }


   public void save(String folder_path) {
    PrintWriter file;
    file = createWriter(folder_path + "/" + this.mapName + "." + this.fileType() + ".lnz");
    file.println("new: Map");
    file.println("code: " + this.code.file_name());
    file.println("mapName: " + this.mapName);
    file.println("maxHeight: " + this.maxHeight);
    file.println("outside_map: " + this.outside_map);
    file.println("color_tint: " + this.color_tint);
    file.println("show_tint: " + this.show_tint);
    this.saveTerrain(file);
    // add unit data
    for (Map.Entry<Integer, Unit> entry : this.units.entrySet()) {
      if (entry.getKey() == 0) {
        continue;
      }
      file.println("nextUnitKey: " + entry.getKey());
      file.println(entry.getValue().fileString());
    }
    // add item data
    for (Map.Entry<Integer, Item> entry : this.items.entrySet()) {
      file.println("nextItemKey: " + entry.getKey());
      file.println(entry.getValue().fileString());
    }
    file.println("end: Map");
    file.flush();
    file.close();
    global.profile.save(); // for ender chest
  }
   public String fileType() {
    return "map";
  }
   public abstract void saveTerrain(PrintWriter file);

   public void open(String folderPath) {
    this.open2Data(this.open1File(folderPath));
    this.initializeTerrain();
  }

   public String[] open1File(String folder_path) {
    String path = folder_path + "/" + this.mapName + "." + this.fileType() + ".lnz";
    String[] lines = loadStrings(path);
    if (lines == null) {
      global.errorMessage("ERROR: Reading map at path " + path + " but no file exists.");
      this.nullify = true;
    }
    return lines;
  }


   public void open2Data(String[] lines) {
    if (lines == null) {
      global.errorMessage("ERROR: Trying to open map data with null data.");
      this.nullify = true;
      return;
    }

    Stack<ReadFileObject> object_queue = new Stack<ReadFileObject>();

    int max_feature_key = 0;
    Feature curr_feature = null;
    int max_unit_key = 0;
    Unit curr_unit = null;
    int max_item_key = 0;
    Item curr_item = null;
    Item curr_item_internal = null; // for item inventories
    Projectile curr_projectile = null;
    StatusEffectCode curr_status_code = StatusEffectCode.ERROR;
    StatusEffect curr_status = null;
    Ability curr_ability = null;

    for (String line : lines) {
      if (line == null) {
        global.errorMessage("ERROR: Trying to open map data with null line.");
        this.nullify = true;
        continue;
      }
      String[] parameters = split(line, ':');
      if (parameters.length < 2) {
        continue;
      }

      String dataname = trim(parameters[0]);
      String data = trim(parameters[1]);
      for (int i = 2; i < parameters.length; i++) {
        data += ":" + parameters[i];
      }
      if (dataname.equals("new")) {
        ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
        switch(type) {
          case MAP:
            object_queue.push(type);
            break;
          case FEATURE:
            if (parameters.length < 3) {
              global.errorMessage("ERROR: Feature ID missing in Feature constructor.");
              break;
            }
            object_queue.push(type);
            curr_feature = new Feature(toInt(trim(parameters[2])));
            break;
          case UNIT:
            if (parameters.length < 3) {
              global.errorMessage("ERROR: Unit ID missing in Unit constructor.");
              break;
            }
            object_queue.push(type);
            curr_unit = new Unit(toInt(trim(parameters[2])));
            break;
          case ITEM:
            if (parameters.length < 3) {
              global.errorMessage("ERROR: Item ID missing in Item constructor.");
              break;
            }
            object_queue.push(type);
            if (curr_item == null) {
              curr_item = new Item(toInt(trim(parameters[2])));
            }
            else {
              if (curr_item_internal != null) {
                global.errorMessage("ERROR: Can't create an internal item inside an internal item.");
                break;
              }
              if (curr_item.inventory == null) {
                global.errorMessage("ERROR: Can't create an internal item " +
                  "inside an item with no inventory.");
                break;
              }
              curr_item_internal = new Item(toInt(trim(parameters[2])));
            }
            break;
          case PROJECTILE:
            if (parameters.length < 3) {
              global.errorMessage("ERROR: Projectile ID missing in Projectile constructor.");
              break;
            }
            object_queue.push(type);
            curr_projectile = new Projectile(toInt(trim(parameters[2])));
            break;
          case STATUS_EFFECT:
            object_queue.push(type);
            curr_status = new StatusEffect();
            break;
          case ABILITY:
            if (parameters.length < 3) {
              global.errorMessage("ERROR: Ability ID missing in Projectile constructor.");
              break;
            }
            object_queue.push(type);
            curr_ability = new Ability(toInt(trim(parameters[2])));
            break;
          default:
            global.errorMessage("ERROR: Can't add a " + type + " type to GameMap data.");
            break;
        }
      }
      else if (dataname.equals("end")) {
        ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
        if (object_queue.empty()) {
          global.errorMessage("ERROR: Tring to end a " + type.name + " object but not inside any object.");
        }
        else if (type.name.equals(object_queue.peek().name)) {
          switch(object_queue.pop()) {
            case MAP:
              return;
            case FEATURE:
              if (curr_feature == null) {
                global.errorMessage("ERROR: Trying to end a null feature.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end a feature not inside any other object.");
                break;
              }
              if (this.nextFeatureKey > max_feature_key) {
                max_feature_key = this.nextFeatureKey;
              }
              this.addFeature(curr_feature, false);
              curr_feature = null;
              break;
            case UNIT:
              if (curr_unit == null) {
                global.errorMessage("ERROR: Trying to end a null unit.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end a unit not inside any other object.");
                break;
              }
              if (this.nextUnitKey > max_unit_key) {
                max_unit_key = this.nextUnitKey;
              }
              this.addUnit(curr_unit);
              curr_unit = null;
              break;
            case ITEM:
              if (curr_item == null) {
                global.errorMessage("ERROR: Trying to end a null item.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end an item not inside any other object.");
                break;
              }
              switch(object_queue.peek()) {
                case MAP:
                  if (this.nextItemKey > max_item_key) {
                    max_item_key = this.nextItemKey;
                  }
                  this.addItemAsIs(curr_item);
                  break;
                case FEATURE:
                  if (parameters.length < 3) {
                    global.errorMessage("ERROR: Ending item in feature inventory " +
                      "but no slot information given.");
                    break;
                  }
                  if (curr_feature == null) {
                    global.errorMessage("ERROR: Trying to add item to null feature.");
                    break;
                  }
                  if (curr_feature.inventory == null) {
                    global.errorMessage("ERROR: Trying to add item to feature " +
                      "inventory but curr_feature has no inventory.");
                    break;
                  }
                  if (trim(parameters[1]).equals("item_array")) {
                    if (curr_feature.items == null) {
                      global.errorMessage("ERROR: Trying to add item to feature " +
                        "item array but curr_feature has no item array.");
                      break;
                    }
                    curr_feature.items.add(curr_item);
                    break;
                  }
                  if (!isInt(trim(parameters[2]))) {
                    global.errorMessage("ERROR: Ending item in feature inventory " +
                      "but no slot information given.");
                    break;
                  }
                  int slot_number = toInt(trim(parameters[2]));
                  if (slot_number < 0 || slot_number >= curr_feature.inventory.slots.size()) {
                    global.errorMessage("ERROR: Trying to add item to feature " +
                      "inventory but slot number " + slot_number + " out of range.");
                    break;
                  }
                  curr_feature.inventory.slots.get(slot_number).item = curr_item;
                  break;
                case UNIT:
                  if (parameters.length < 3) {
                    global.errorMessage("ERROR: GearSlot code missing in Item constructor.");
                    break;
                  }
                  GearSlot code = GearSlot.gearSlot(trim(parameters[2]));
                  if (curr_unit == null) {
                    global.errorMessage("ERROR: Trying to add gear to null unit.");
                    break;
                  }
                  curr_unit.gear.put(code, curr_item);
                  break;
                case ITEM:
                  if (curr_item_internal == null) {
                    global.errorMessage("ERROR: Trying to end a null internal item.");
                    break;
                  }
                  if (parameters.length < 3 || !isInt(trim(parameters[2]))) {
                    global.errorMessage("ERROR: Ending item in item inventory " +
                      "but no slot number given.");
                    break;
                  }
                  if (curr_item == null) {
                    global.errorMessage("ERROR: Trying to add item to null item.");
                    break;
                  }
                  if (curr_item.inventory == null) {
                    global.errorMessage("ERROR: Trying to add item to item " +
                      "inventory but curr_item has no inventory.");
                    break;
                  }
                  int item_slot_number = toInt(trim(parameters[2]));
                  if (item_slot_number < 0 || item_slot_number >= curr_item.inventory.slots.size()) {
                    global.errorMessage("ERROR: Trying to add item to feature " +
                      "inventory but slot number " + item_slot_number + " out of range.");
                    break;
                  }
                  curr_item.inventory.slots.get(item_slot_number).item = curr_item_internal;
                  break;
                default:
                  global.errorMessage("ERROR: Trying to end an item inside a " + object_queue.peek().name + ".");
                  break;
              }
              if (curr_item_internal == null) {
                curr_item = null;
              }
              else {
                curr_item_internal = null;
              }
              break;
            case PROJECTILE:
              if (curr_projectile == null) {
                global.errorMessage("ERROR: Trying to end a null projectile.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end a projectile not inside any other object.");
                break;
              }
              curr_projectile.refreshFacing();
              this.addProjectile(curr_projectile);
              curr_projectile = null;
              break;
            case STATUS_EFFECT:
              if (curr_status == null) {
                global.errorMessage("ERROR: Trying to end a null status effect.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end a status effect not inside any other object.");
                break;
              }
              if (object_queue.peek() != ReadFileObject.UNIT && object_queue.peek() != ReadFileObject.HERO) {
                global.errorMessage("ERROR: Trying to end a status effect inside a " + object_queue.peek().name + ".");
                break;
              }
              if (curr_unit == null) {
                global.errorMessage("ERROR: Trying to end a status effect inside a null unit.");
                break;
              }
              curr_unit.statuses.put(curr_status_code, curr_status);
              curr_status = null;
              break;
            case ABILITY:
              if (curr_ability == null) {
                global.errorMessage("ERROR: Trying to end a null ability.");
                break;
              }
              if (object_queue.empty()) {
                global.errorMessage("ERROR: Trying to end an ability not inside any other object.");
                break;
              }
              if (object_queue.peek() != ReadFileObject.UNIT && object_queue.peek() != ReadFileObject.HERO) {
                global.errorMessage("ERROR: Trying to end an ability inside a " + object_queue.peek().name + ".");
                break;
              }
              if (curr_unit == null) {
                global.errorMessage("ERROR: Trying to end an ability inside a null unit.");
                break;
              }
              curr_unit.abilities.add(curr_ability);
              curr_ability = null;
              break;
            default:
              global.errorMessage("ERROR: Trying to end a " + type.name + " which is not known.");
              break;
          }
        }
        else {
          global.errorMessage("ERROR: Tring to end a " + type.name + " object but current object is a " + object_queue.peek().name + ".");
        }
      }
      else {
        switch(object_queue.peek()) {
          case MAP:
            this.addData(dataname, data);
            break;
          case FEATURE:
            if (curr_feature == null) {
              global.errorMessage("ERROR: Trying to add feature data to a null feature.");
              break;
            }
            curr_feature.addData(dataname, data);
            break;
          case UNIT:
            if (curr_unit == null) {
              global.errorMessage("ERROR: Trying to add unit data to a null unit.");
              break;
            }
            if (dataname.equals("next_status_code")) {
              curr_status_code = StatusEffectCode.code(data);
            }
            else {
              curr_unit.addData(dataname, data);
            }
            break;
          case ITEM:
            if (curr_item == null) {
              global.errorMessage("ERROR: Trying to add item data to a null item.");
              break;
            }
            if (curr_item_internal != null) {
              curr_item_internal.addData(dataname, data);
            }
            else {
              curr_item.addData(dataname, data);
            }
            break;
          case PROJECTILE:
            if (curr_projectile == null) {
              global.errorMessage("ERROR: Trying to add projectile data to a null projectile.");
              break;
            }
            curr_projectile.addData(dataname, data);
            break;
          case STATUS_EFFECT:
            if (curr_status == null) {
              global.errorMessage("ERROR: Trying to add status effect data to a null status effect.");
              break;
            }
            curr_status.addData(dataname, data);
            break;
          case ABILITY:
            if (curr_ability == null) {
              global.errorMessage("ERROR: Trying to add ability data to a null ability.");
              break;
            }
            curr_status.addData(dataname, data);
            break;
          default:
            break;
        }
      }
    }

    // Refresh ability target units
    for (Map.Entry<Integer, Unit> entry : this.units.entrySet()) {
      for (Ability a : entry.getValue().abilities) {
        if (a == null) {
          continue;
        }
        if (this.units.containsKey(a.target_key)) {
          a.target_unit = this.units.get(a.target_key);
        }
      }
    }

    // Refresh hashmap keys
    this.nextFeatureKey = max_feature_key + 1;
    this.nextUnitKey = max_unit_key + 1;
    this.nextItemKey = max_item_key + 1;
  }


   public void addData(String datakey, String data) {
    switch(datakey) {
      case "code":
        this.code = GameMapCode.gameMapCode(data);
        break;
      case "mapName":
        this.mapName = data;
        break;
      case "fogHandling":
        this.fogHandling = MapFogHandling.fogHandling(data);
        break;
      case "color_tint":
        this.color_tint = toInt(data);
        break;
      case "show_tint":
        this.show_tint = toBoolean(data);
        break;
      case "outside_map":
        this.outside_map = toBoolean(data);
        break;
      case "maxHeight":
        this.maxHeight = toInt(data);
        break;
      case "terrain":
        String[] data_split = split(data, ':');
        if (data_split.length < 2) {
          global.errorMessage("ERROR: Terrain missing dimension in data: " + data + ".");
          break;
        }
        String[] terrain_dimensions = split(data_split[0], ',');
        if (terrain_dimensions.length < 2) {
          global.errorMessage("ERROR: Terrain dimensions missing dimension in data: " + data + ".");
          break;
        }
        int terrain_x = toInt(trim(terrain_dimensions[0]));
        int terrain_y = toInt(trim(terrain_dimensions[1]));
        String[] terrain_values = split(data_split[1], ',');
        if (terrain_values.length < 3) {
          global.errorMessage("ERROR: Terrain values missing dimension in data: " + data + ".");
          break;
        }
        int terrain_id = toInt(trim(terrain_values[0]));
        int terrain_height = toInt(trim(terrain_values[1]));
        this.setTerrain(terrain_id, terrain_x, terrain_y, false);
        this.setTerrainBaseElevation(terrain_height, terrain_x, terrain_y);
        if (toBoolean(trim(terrain_values[2]))) {
          this.exploreTerrain(terrain_x, terrain_y, false);
        }
        break;
      case "nextFeatureKey":
        this.nextFeatureKey  = toInt(data);
        break;
      case "nextUnitKey":
        this.nextUnitKey = toInt(data);
        break;
      case "nextItemKey":
        this.nextItemKey = toInt(data);
        break;
      default:
        this.addImplementationSpecificData(datakey, data);
        break;
    }
  }
   public abstract void addImplementationSpecificData(String datakey, String data);
}
class GameMapArea extends AbstractGameMap {
  class TerrainDimgThread extends AbstractTerrainDimgThread {
    TerrainDimgThread() {
      super("TerrainDimgThread");
    }
     public void updateTerrainDisplay() {
      DImg new_terrain_display = new DImg(round(this.xf_map - this.xi_map), round(this.yf_map - this.yi_map));
      if (this.visSquareX == 0 || this.visSquareY == 0) {
        return;
      }
      int xi_chunk = PApplet.parseInt(Math.floorDiv((long)this.startSquareX, (long)Constants.map_chunkWidth));
      int yi_chunk = PApplet.parseInt(Math.floorDiv((long)this.startSquareY, (long)Constants.map_chunkWidth));
      int xf_chunk = PApplet.parseInt(Math.floorDiv((long)(this.startSquareX + this.visSquareX), (long)Constants.map_chunkWidth));
      int yf_chunk = PApplet.parseInt(Math.floorDiv((long)(this.startSquareY + this.visSquareY), (long)Constants.map_chunkWidth));
      for (int i = xi_chunk; i <= xf_chunk; i++) {
        for (int j = yi_chunk; j <= yf_chunk; j++) {
          Chunk chunk = GameMapArea.this.chunk_reference.get(new IntegerCoordinate(i, j));
          if (chunk == null) {
            continue;
          }
          float img_x = 0;
          if (i * Constants.map_chunkWidth < this.startSquareX) {
            img_x = negMod(this.startSquareX, Constants.map_chunkWidth);
          }
          float img_y = 0;
          if (j * Constants.map_chunkWidth < this.startSquareY) {
            img_y = negMod(this.startSquareY, Constants.map_chunkWidth);
          }
          float img_w = Constants.map_chunkWidth - img_x;
          if ((i + 1) * Constants.map_chunkWidth > this.startSquareX + this.visSquareX) {
            img_w = negMod(this.startSquareX + this.visSquareX, Constants.map_chunkWidth) - img_x;
          }
          float img_h = Constants.map_chunkWidth - img_y;
          if ((j + 1) * Constants.map_chunkWidth > this.startSquareY + this.visSquareY) {
            img_h = negMod(this.startSquareY + this.visSquareY, Constants.map_chunkWidth) - img_y;
          }
          PImage chunk_terrain_image = chunk.terrain_dimg.getImagePiece(round(img_x * this.terrain_resolution),
            round(img_y * this.terrain_resolution), round(img_w * this.terrain_resolution), round(img_h * this.terrain_resolution));
          PImage chunk_fog_image = chunk.fog_dimg.getImagePiece(round(img_x * this.terrain_resolution),
            round(img_y * this.terrain_resolution), round(img_w * this.terrain_resolution), round(img_h * this.terrain_resolution));
          int resized_w = round((this.xf_map - this.xi_map) * img_w / this.visSquareX);
          int resized_h = round((this.yf_map - this.yi_map) * img_h / this.visSquareY);
          chunk_terrain_image = resizeImage(chunk_terrain_image, resized_w, resized_h);
          int resized_xi = round(max(0, i * Constants.map_chunkWidth - this.startSquareX) * new_terrain_display.img.width / this.visSquareX);
          int resized_yi = round(max(0, j * Constants.map_chunkWidth - this.startSquareY) * new_terrain_display.img.height / this.visSquareY);
          new_terrain_display.addImage(chunk_terrain_image, resized_xi, resized_yi, resized_w, resized_h);
        }
      }
      GameMapArea.this.terrain_display = new_terrain_display.img;
    }
  }


  class FogDImgThread extends Thread {
    private int fog_xi = 0;
    private int fog_yi = 0;
    private int fog_w = 0;
    private int fog_h = 0;
    private boolean replay = false;
    FogDImgThread(int fog_xi, int fog_yi, int fog_w, int fog_h) {
      super("FogDImgThread");
      this.setDaemon(true);
      this.fog_xi = fog_xi;
      this.fog_yi = fog_yi;
      this.fog_w = fog_w * Constants.map_fogResolution;
      this.fog_h = fog_h * Constants.map_fogResolution;
    }
    @Override public 
    void run() {
      while(true) {
        IntegerCoordinate current = GameMapArea.this.current_chunk.copy();
        for (int i = current.x - GameMapArea.this.chunk_view_radius; i <= current.x + GameMapArea.this.chunk_view_radius; i++) {
          for (int j = current.y - GameMapArea.this.chunk_view_radius; j <= current.y + GameMapArea.this.chunk_view_radius; j++) {
            Chunk chunk = GameMapArea.this.chunk_reference.get(new IntegerCoordinate(i, j));
            if (chunk == null) {
              continue;
            }
            GameMapArea.this.fog_dimg.addImageGrid(chunk.fog_dimg.img,
              i - current.x + GameMapArea.this.chunk_view_radius,
              j - current.y + GameMapArea.this.chunk_view_radius);
          }
        }
        this.fog_xi = this.fog_xi - (current.x - GameMapArea.this.chunk_view_radius) * Constants.map_chunkWidth * Constants.map_fogResolution;
        this.fog_yi = this.fog_yi - (current.y - GameMapArea.this.chunk_view_radius) * Constants.map_chunkWidth * Constants.map_fogResolution;
        GameMapArea.this.fog_display = GameMapArea.this.fog_dimg.getImagePiece(this.fog_xi, this.fog_yi, this.fog_w, this.fog_h);
        if (this.replay) {
          this.replay = false;
        }
        else {
          return;
        }
      }
    }
  }


  class HangingImage {
    private IntegerCoordinate chunk_coordinate;
    private PImage newImg;
    private int newImgX;
    private int newImgY;
    private int newImgW;
    private int newImgH;
    private int x;
    private int y;
    private int w;
    private int h;
    HangingImage(IntegerCoordinate chunk_coordinate, PImage newImg, int newImgX,
      int newImgY, int newImgW, int newImgH, int x, int y, int w, int h) {
      this.chunk_coordinate = chunk_coordinate;
      this.newImg = newImg;
      this.newImgX = newImgX;
      this.newImgY = newImgY;
      this.newImgW = newImgW;
      this.newImgH = newImgH;
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
     public boolean resolve() {
      Chunk chunk = GameMapArea.this.chunk_reference.get(this.chunk_coordinate);
      if (chunk == null) {
        return false;
      }
      chunk.terrain_dimg.addImageGrid(this.newImg, this.newImgX, this.newImgY,
        this.newImgW, this.newImgH, this.x, this.y, this.w, this.h);
      return true;
    }
  }


  class HangingFeaturesThread extends Thread {
    HangingFeaturesThread() {
      super("HangingFeaturesThread");
      this.setDaemon(true);
    }
    @Override public 
    void run() {
      while(true) {
        delay(200);
        if (GameMapArea.this == null || GameMapArea.this.nullify) {
          return;
        }
        GameMapArea.this.checkHangingFeatures();
        GameMapArea.this.checkHangingImages();
      }
    }
  }


  class Chunk {
    class LoadChunkThread extends Thread {
      LoadChunkThread() {
        super("LoadChunkThread");
        this.setDaemon(true);
      }

      @Override public 
      void run() {
        if (fileExists(Chunk.this.fileName())) {
          Chunk.this.load();
        }
        else {
          Chunk.this.generate();
        }
        Chunk.this.applyFogHandling();
      }
    }


    private GameMapSquare[][] squares;
    private ConcurrentHashMap<Integer, Feature> features = new ConcurrentHashMap<Integer, Feature>();
    private DImg terrain_dimg;
    private DImg fog_dimg;
    private IntegerCoordinate coordinate;
    private Biome biome = Biome.NONE;

    private LoadChunkThread thread;
    private boolean remove = false; // used to avoid concurrent modification error if trying to remove while generating chunk

    Chunk(IntegerCoordinate coordinate) {
      this.squares = new GameMapSquare[Constants.map_chunkWidth][Constants.map_chunkWidth];
      for (int i = 0; i < this.squares.length; i++) {
        for (int j = 0; j < this.squares[i].length; j++) {
          this.squares[i][j] = new GameMapSquare();
        }
      }
      this.coordinate = coordinate;
      Chunk.this.terrain_dimg = new DImg(Constants.map_chunkWidth * GameMapArea.this.terrain_resolution,
        Constants.map_chunkWidth * GameMapArea.this.terrain_resolution);
      Chunk.this.terrain_dimg.setGrid(Constants.map_chunkWidth, Constants.map_chunkWidth);
      Chunk.this.fog_dimg = new DImg(Constants.map_chunkWidth * Constants.map_fogResolution,
        Constants.map_chunkWidth * Constants.map_fogResolution);
      Chunk.this.fog_dimg.setGrid(Constants.map_chunkWidth, Constants.map_chunkWidth);
    }

     public void loadChunk() {
      this.thread = new LoadChunkThread();
      this.thread.start();
    }

     public String fileName() {
      return (GameMapArea.this.map_folder + "/" + this.coordinate.x + this.coordinate.y + ".chunk.lnz");
    }

     public int chunkXI() {
      return this.coordinate.x * Constants.map_chunkWidth;
    }
     public int chunkYI() {
      return this.coordinate.y * Constants.map_chunkWidth;
    }
     public int chunkXF() {
      return (this.coordinate.x + 1) * Constants.map_chunkWidth;
    }
     public int chunkYF() {
      return (this.coordinate.y + 1) * Constants.map_chunkWidth;
    }

     public void applyFogHandling() {
      for (int i = 0; i < this.squares.length; i++) {
        for (int j = 0; j < this.squares[i].length; j++) {
          GameMapSquare square = this.squares[i][j];
          if (square == null) {
            continue;
          }
          switch(GameMapArea.this.fogHandling) {
            case DEFAULT:
              if (square.mapEdge()) {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              else if (!square.explored) {
                this.colorFogGrid(Constants.color_black, i, j);
              }
              else if (!square.visible) {
                this.colorFogGrid(GameMapArea.this.fogColor, i, j);
              }
              else {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              break;
            case NONE:
              square.explored = true;
              square.visible = true;
              this.colorFogGrid(Constants.color_transparent, i, j);
              break;
            case NOFOG:
              square.visible = true;
              if (square.mapEdge()) {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              else if (!square.explored) {
                this.colorFogGrid(Constants.color_black, i, j);
              }
              else {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              break;
            case EXPLORED:
              square.explored = true;
              if (square.mapEdge()) {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              else if (!square.visible) {
                this.colorFogGrid(GameMapArea.this.fogColor, i, j);
              }
              else {
                this.colorFogGrid(Constants.color_transparent, i, j);
              }
              break;
          }
        }
      }
    }

     public void colorFogGrid(int c, int i, int j) {
      this.fog_dimg.colorGrid(c, i, j);
    }

     public void generate() {
      this.biome = GameMapArea.this.getBiome(this.coordinate);
      // Generate BiomeReturns from Perlin noise
      BiomeReturn[][] biome_return = new BiomeReturn[Constants.map_chunkWidth][Constants.map_chunkWidth];
      for (int i = 0; i < biome_return.length; i++) {
        for (int j = 0; j < biome_return[i].length; j++) {
          IntegerCoordinate square = new IntegerCoordinate(this.chunkXI() + i, this.chunkYI() + j);
          float noise_value = GameMapArea.this.perlinNoise(square, false);
          biome_return[i][j] = processPerlinNoise(this.biome, noise_value);
        }
      }
      // Base terrain from perlin noise and biome
      for (int i = 0; i < this.squares.length; i++) {
        for (int j = 0; j < this.squares[i].length; j++) {
          this.squares[i][j].setTerrain(biome_return[i][j].terrain_code);
          this.terrain_dimg.addImageGrid(this.squares[i][j].terrainImage(), i, j);
        }
      }
      // Base features from perlin noise and biome
      for (int i = 0; i < this.squares.length; i++) {
        for (int j = 0; j < this.squares[i].length; j++) {
          if (biome_return[i][j].spawn_feature) {
            GameMapArea.this.addFeature(biome_return[i][j].feature_id, this.chunkXI() + i, this.chunkYI() + j);
          }
        }
      }
      // terrain structures ??
      // add features ??
      this.save();
      GameMapArea.this.refreshTerrainImage();
    }

     public void load() {
      String[] lines = loadStrings(this.fileName());
      if (lines == null) {
        global.errorMessage("ERROR: Reading chunk at path " + this.fileName() + " but no file exists.");
        return;
      }

      Stack<ReadFileObject> object_queue = new Stack<ReadFileObject>();

      Feature curr_feature = null;
      int next_feature_key = 0;
      int max_item_key = 0;
      Item curr_item = null;
      Item curr_item_internal = null; // for item inventories

      for (String line : lines) {
        String[] line_split = split(line, ':');
        if (line_split.length < 2) {
          continue;
        }
        String datakey = trim(line_split[0]);
        String data = trim(line_split[1]);
        for (int i = 2; i < line_split.length; i++) {
          data += ":" + line_split[i];
        }
        if (datakey.equals("new")) {
          ReadFileObject type = ReadFileObject.objectType(trim(line_split[1]));
          switch(type) {
            case FEATURE:
              if (line_split.length < 3) {
                global.errorMessage("ERROR: Feature ID missing in Feature constructor.");
                break;
              }
              object_queue.push(type);
              curr_feature = new Feature(toInt(trim(line_split[2])));
              break;
            case ITEM:
              if (line_split.length < 3) {
                global.errorMessage("ERROR: Item ID missing in Item constructor.");
                break;
              }
              object_queue.push(type);
              if (curr_item == null) {
                curr_item = new Item(toInt(trim(line_split[2])));
              }
              else {
                if (curr_item_internal != null) {
                  global.errorMessage("ERROR: Can't create an internal item inside an internal item.");
                  break;
                }
                if (curr_item.inventory == null) {
                  global.errorMessage("ERROR: Can't create an internal item " +
                    "inside an item with no inventory.");
                  break;
                }
                curr_item_internal = new Item(toInt(trim(line_split[2])));
              }
              break;
            default:
              global.errorMessage("ERROR: Can't add a " + type + " type to Chunk data.");
              break;
          }
        }
        else if (datakey.equals("end")) {
          ReadFileObject type = ReadFileObject.objectType(trim(line_split[1]));
          if (object_queue.empty()) {
            global.errorMessage("ERROR: Tring to end a " + type.name + " object but not inside any object.");
          }
          else if (type.name.equals(object_queue.peek().name)) {
            switch(object_queue.pop()) {
              case FEATURE:
                if (curr_feature == null) {
                  global.errorMessage("ERROR: Trying to end a null feature.");
                  break;
                }
                GameMapArea.this.addFeature(curr_feature, false, next_feature_key);
                curr_feature = null;
                break;
              case ITEM:
                if (curr_item == null) {
                  global.errorMessage("ERROR: Trying to end a null item.");
                  break;
                }
                if (object_queue.empty()) {
                  global.errorMessage("ERROR: Trying to end an item not inside any other object.");
                  break;
                }
                switch(object_queue.peek()) {
                  case FEATURE:
                    if (line_split.length < 3) {
                      global.errorMessage("ERROR: Ending item in feature inventory " +
                        "but no slot information given.");
                      break;
                    }
                    if (curr_feature == null) {
                      global.errorMessage("ERROR: Trying to add item to null feature.");
                      break;
                    }
                    if (curr_feature.inventory == null) {
                      global.errorMessage("ERROR: Trying to add item to feature " +
                        "inventory but curr_feature has no inventory.");
                      break;
                    }
                    if (trim(line_split[1]).equals("item_array")) {
                      if (curr_feature.items == null) {
                        global.errorMessage("ERROR: Trying to add item to feature " +
                          "item array but curr_feature has no item array.");
                        break;
                      }
                      curr_feature.items.add(curr_item);
                      break;
                    }
                    if (!isInt(trim(line_split[2]))) {
                      global.errorMessage("ERROR: Ending item in feature inventory " +
                        "but no slot information given.");
                      break;
                    }
                    int slot_number = toInt(trim(line_split[2]));
                    if (slot_number < 0 || slot_number >= curr_feature.inventory.slots.size()) {
                      global.errorMessage("ERROR: Trying to add item to feature " +
                        "inventory but slot number " + slot_number + " out of range.");
                      break;
                    }
                    curr_feature.inventory.slots.get(slot_number).item = curr_item;
                    break;
                  case ITEM:
                    if (curr_item_internal == null) {
                      global.errorMessage("ERROR: Trying to end a null internal item.");
                      break;
                    }
                    if (line_split.length < 3 || !isInt(trim(line_split[2]))) {
                      global.errorMessage("ERROR: Ending item in item inventory " +
                        "but no slot number given.");
                      break;
                    }
                    if (curr_item == null) {
                      global.errorMessage("ERROR: Trying to add item to null item.");
                      break;
                    }
                    if (curr_item.inventory == null) {
                      global.errorMessage("ERROR: Trying to add item to item " +
                        "inventory but curr_item has no inventory.");
                      break;
                    }
                    int item_slot_number = toInt(trim(line_split[2]));
                    if (item_slot_number < 0 || item_slot_number >= curr_item.inventory.slots.size()) {
                      global.errorMessage("ERROR: Trying to add item to feature " +
                        "inventory but slot number " + item_slot_number + " out of range.");
                      break;
                    }
                    curr_item.inventory.slots.get(item_slot_number).item = curr_item_internal;
                    break;
                  default:
                    global.errorMessage("ERROR: Trying to end an item inside a " +
                      object_queue.peek().name + " in Chunk data.");
                    break;
                }
                if (curr_item_internal == null) {
                  curr_item = null;
                }
                else {
                  curr_item_internal = null;
                }
                break;
              default:
                global.errorMessage("ERROR: Trying to end a " + type.name + " which is not known.");
                break;
            }
          }
          else {
            global.errorMessage("ERROR: Tring to end a " + type.name + " object " +
              "but current object is a " + object_queue.peek().name + ".");
          }
        }
        else if (!object_queue.empty()) {
          switch(object_queue.peek()) {
            case FEATURE:
              if (curr_feature == null) {
                global.errorMessage("ERROR: Trying to add feature data to a null feature.");
                break;
              }
              curr_feature.addData(datakey, data);
              break;
            case ITEM:
              if (curr_item == null) {
                global.errorMessage("ERROR: Trying to add item data to a null item.");
                break;
              }
              if (curr_item_internal != null) {
                curr_item_internal.addData(datakey, data);
              }
              else {
                curr_item.addData(datakey, data);
              }
              break;
            default:
              break;
          }
        }
        else {
          switch(datakey) {
            case "biome":
              this.biome = Biome.biome(data);
              break;
            case "nextFeatureKey":
              next_feature_key = toInt(data);
              break;
            case "terrain":
              String[] data_split = split(data, ':');
              if (data_split.length < 2) {
                global.errorMessage("ERROR: Terrain missing dimension in data: " + data + ".");
                break;
              }
              String[] terrain_dimensions = split(data_split[0], ',');
              if (terrain_dimensions.length < 2) {
                global.errorMessage("ERROR: Terrain dimensions missing dimension in data: " + data + ".");
                break;
              }
              int terrain_x = toInt(trim(terrain_dimensions[0]));
              int terrain_y = toInt(trim(terrain_dimensions[1]));
              String[] terrain_values = split(data_split[1], ',');
              if (terrain_values.length < 3) {
                global.errorMessage("ERROR: Terrain values missing dimension in data: " + data + ".");
                break;
              }
              int terrain_id = toInt(trim(terrain_values[0]));
              int terrain_height = toInt(trim(terrain_values[1]));
              try {
                GameMapSquare square = this.squares[terrain_x][terrain_y];
                square.setTerrain(terrain_id);
                square.base_elevation = terrain_height;
                this.terrain_dimg.addImageGrid(square.terrainImage(), terrain_x, terrain_y);
                if (toBoolean(trim(terrain_values[2]))) {
                  square.explored = true;
                }
              }
              catch(ArrayIndexOutOfBoundsException e) {}
              break;
            default:
              global.errorMessage("ERROR: Datakey " + datakey + " not recognized.");
              break;
          }
        }
      }
      GameMapArea.this.refreshTerrainImage();
    }

     public void save() {
      PrintWriter file = createWriter(this.fileName());
      file.println("biome: " + this.biome.fileName());
      for (int i = 0; i < this.squares.length; i++) {
        for (int j = 0; j < this.squares[i].length; j++) {
          file.println("terrain: " + i + ", " + j + ": " + this.squares[i][j].terrain_id +
            ", " + this.squares[i][j].base_elevation + ", " + this.squares[i][j].explored);
        }
      }
      // save features
      for (Map.Entry<Integer, Feature> entry : this.features.entrySet()) {
        file.println("nextFeatureKey: " + entry.getKey());
        file.println(entry.getValue().fileString());
      }
      file.flush();
      file.close();
    }
  }


  protected AreaLocation area_location = AreaLocation.NONE;

  protected ConcurrentHashMap<IntegerCoordinate, Chunk> chunk_reference = new ConcurrentHashMap<IntegerCoordinate, Chunk>();
  protected IntegerCoordinate current_chunk = new IntegerCoordinate(0, 0);
  protected DImg fog_dimg;
  protected FogDImgThread fog_dimg_thread = null;

  protected String map_folder;
  protected int mapEdgeXi = 0;
  protected int mapEdgeYi = 0;
  protected int mapEdgeXf = 1;
  protected int mapEdgeYf = 1;
  protected IntegerCoordinate default_spawn_chunk = new IntegerCoordinate(0, 0);
  protected int chunk_view_radius = 1;
  protected int seed = 0;

  // prevents nullptr on perlinNoise() since noise/noiseDetail/noiseSeed not thread-safe (maybe??)
  protected boolean waiting_for_noise_initialization = true;

  // keeps track of features that are hanging over unloaded chunks when added / removed
  protected ConcurrentHashMap<IntegerCoordinate, ConcurrentHashMap<Integer, Feature>> hanging_features =
    new ConcurrentHashMap<IntegerCoordinate, ConcurrentHashMap<Integer, Feature>>();
  protected Queue<HangingImage> hanging_images = new ConcurrentLinkedQueue<HangingImage>();
  protected HangingFeaturesThread hanging_features_thread;


  GameMapArea(String mapName, String map_folder) {
    super();
    this.mapName = mapName;
    this.map_folder = map_folder;
  }

   public void initializeArea() {
    noiseSeed(this.seed);
    noiseDetail(Constants.map_noiseOctaves, 0.55f);
    this.waiting_for_noise_initialization = false;
    this.startTerrainDimgThread();
    this.hanging_features_thread = new HangingFeaturesThread();
    this.hanging_features_thread.start(); // runs continuously
  }


   public synchronized float perlinNoise(IntegerCoordinate coordinate, boolean chunk_noise) {
    if (coordinate == null) {
      return 0;
    }
    try {
      if (chunk_noise) {
        return noise(coordinate.x * Constants.map_chunkPerlinMultiplier + Constants.map_noiseOffsetX,
          coordinate.y * Constants.map_chunkPerlinMultiplier + Constants.map_noiseOffsetY);
      }
      else {
        return noise(coordinate.x * Constants.map_mapPerlinMultiplier + Constants.map_noiseOffsetX,
          coordinate.y * Constants.map_mapPerlinMultiplier + Constants.map_noiseOffsetY);
      }
    } catch(NullPointerException e) {
      return 0;
    }
  }

   public Biome getBiome(IntegerCoordinate coordinate) {
    float noise_value = this.perlinNoise(coordinate, true);
    return this.area_location.getBiome(noise_value);
  }


   public int mapXI() {
    return Constants.map_chunkWidth * this.mapEdgeXi;
  }
   public int mapYI() {
    return Constants.map_chunkWidth * this.mapEdgeYi;
  }
   public int mapXF() {
    return Constants.map_chunkWidth * this.mapEdgeXf;
  }
   public int mapYF() {
    return Constants.map_chunkWidth * this.mapEdgeYf;
  }
   public int currMapXI() {
    return Constants.map_chunkWidth * max(this.current_chunk.x - this.chunk_view_radius, this.mapEdgeXi);
  }
   public int currMapYI() {
    return Constants.map_chunkWidth * max(this.current_chunk.y - this.chunk_view_radius, this.mapEdgeYi);
  }
   public int currMapXF() {
    return Constants.map_chunkWidth * min(this.current_chunk.x + this.chunk_view_radius + 1, this.mapEdgeXf);
  }
   public int currMapYF() {
    return Constants.map_chunkWidth * min(this.current_chunk.y + this.chunk_view_radius + 1, this.mapEdgeYf);
  }


   public float defaultSpawnX() {
    return constrain(this.default_spawn_chunk.x * Constants.map_chunkWidth,
      this.mapXI(), this.mapXF()) + 0.5f * Constants.map_chunkWidth;
  }
   public float defaultSpawnY() {
    return constrain(this.default_spawn_chunk.y * Constants.map_chunkWidth,
    this.mapYI(), this.mapYF()) + 0.5f * Constants.map_chunkWidth;
  }
   public void viewDefaultChunk() {
    this.setViewLocation(this.defaultSpawnX(), this.defaultSpawnY());
  }


   public GameMapSquare mapSquare(int i, int j) {
    try {
      IntegerCoordinate coordinate = this.coordinateOf(i, j);
      Chunk chunk = this.chunk_reference.get(coordinate);
      if (chunk == null) {
        return null;
      }
      return chunk.squares[Math.floorMod(i, Constants.map_chunkWidth)][Math.floorMod(j, Constants.map_chunkWidth)];
    } catch(ArrayIndexOutOfBoundsException e) {
      return null;
    }
  }
   public IntegerCoordinate coordinateOf(int i, int j) {
    return new IntegerCoordinate(Math.floorDiv(i, Constants.map_chunkWidth),
      Math.floorDiv(j, Constants.map_chunkWidth));
  }

   public void initializeSquares() {}
   public void refreshChunks() {
    // remove unnecessary chunks from memory
    Iterator it = this.chunk_reference.entrySet().iterator();
    while(it.hasNext()) {
      Map.Entry<IntegerCoordinate, Chunk> entry = (Map.Entry<IntegerCoordinate, Chunk>)it.next();
      IntegerCoordinate coordinate = entry.getKey();
      if (entry.getValue().remove || coordinate.x > this.current_chunk.x + this.chunk_view_radius ||
        coordinate.x < this.current_chunk.x - this.chunk_view_radius ||
        coordinate.y > this.current_chunk.y + this.chunk_view_radius ||
        coordinate.y < this.current_chunk.y - this.chunk_view_radius) {
        entry.getValue().save();
        it.remove();
      }
    }
    // add needed new chunks
    this.current_chunk = new IntegerCoordinate(round(floor(this.viewX / Constants.map_chunkWidth)),
      round(floor(this.viewY / Constants.map_chunkWidth)));
    for (int i = this.current_chunk.x - this.chunk_view_radius; i <= this.current_chunk.x + this.chunk_view_radius; i++) {
      for (int j = this.current_chunk.y - this.chunk_view_radius; j <= this.current_chunk.y + this.chunk_view_radius; j++) {
        IntegerCoordinate coordinate = new IntegerCoordinate(i, j);
        if (!this.coordinateInMap(coordinate)) {
          continue;
        }
        if (this.chunk_reference.containsKey(coordinate)) {
          continue;
        }
        Chunk newChunk = new Chunk(coordinate);
        this.chunk_reference.put(coordinate, newChunk);
        newChunk.loadChunk();
      }
    }
  }
   public boolean coordinateInMap(IntegerCoordinate coordinate) {
    if (coordinate.x < this.mapEdgeXi || coordinate.x > this.mapEdgeXf ||
      coordinate.y < this.mapEdgeYi || coordinate.y > this.mapEdgeYf) {
      return false;
    }
    return true;
  }

   public void initializeBackgroundImage() {
    int chunk_view_width = (this.chunk_view_radius * 2 + 1);
    this.fog_dimg = new DImg(chunk_view_width * Constants.map_chunkWidth * Constants.map_fogResolution,
      chunk_view_width * Constants.map_chunkWidth * Constants.map_fogResolution);
    this.fog_dimg.setGrid(chunk_view_width, chunk_view_width);
  }

   public void colorFogGrid(int c, int i, int j) {
    Chunk chunk = this.chunk_reference.get(this.coordinateOf(i, j));
    if (chunk == null) {
      return;
    }
    chunk.fog_dimg.colorGrid(c, Math.floorMod(i, Constants.map_chunkWidth),
      Math.floorMod(j, Constants.map_chunkWidth));
  }

   public void terrainImageGrid(PImage img, int x, int y, int w, int h) {
    IntegerCoordinate coordinate = this.coordinateOf(x, y);
    Chunk chunk = this.chunk_reference.get(this.coordinateOf(x, y));
    if (chunk == null || w < 1 || h < 1) {
      // data corruption
      return;
    }
    int relative_x = Math.floorMod(x, Constants.map_chunkWidth);
    int relative_y = Math.floorMod(y, Constants.map_chunkWidth);
    chunk.terrain_dimg.addImageGrid(img, relative_x, relative_y, w, h);
    // now check for hanging
    boolean x_hanging = false;
    boolean y_hanging = false;
    if (relative_x + w > Constants.map_chunkWidth) {
      x_hanging = true;
    }
    if (relative_y + h > Constants.map_chunkWidth) {
      y_hanging = true;
    }
    if (x_hanging && y_hanging) {
      int remaining_width = relative_x + w - Constants.map_chunkWidth;
      int img_width = round(img.width * PApplet.parseFloat(remaining_width) / w);
      int remaining_height = relative_y + h - Constants.map_chunkWidth;
      int img_height = round(img.height * PApplet.parseFloat(remaining_height) / h);
      IntegerCoordinate x_edge = this.coordinateOf(x + w, y);
      Chunk x_chunk = this.chunk_reference.get(x_edge);
      if (x_chunk == null) {
      }
      else {
        x_chunk.terrain_dimg.addImageGrid(img, img.width - img_width, 0, img_width,
          img.height - img_height, 0, relative_y, remaining_width, Constants.map_chunkWidth - relative_y);
      }
      IntegerCoordinate y_edge = this.coordinateOf(x, y + h);
      Chunk y_chunk = this.chunk_reference.get(y_edge);
      if (y_chunk == null) {
      }
      else {
        y_chunk.terrain_dimg.addImageGrid(img, 0, img.height - img_height, img.width
          - img_width, img_height, relative_x, 0, Constants.map_chunkWidth - relative_x, remaining_height);
      }
      IntegerCoordinate xy_edge = this.coordinateOf(x + w, y + h);
      Chunk xy_chunk = this.chunk_reference.get(xy_edge);
      if (xy_chunk == null) {
      }
      else {
        xy_chunk.terrain_dimg.addImageGrid(img, img.width - img_width, img.height - img_height,
          img_width, img_height, 0, 0, remaining_width, remaining_height);
      }
    }
    else if (x_hanging) {
      IntegerCoordinate x_edge = this.coordinateOf(x + w, y);
      Chunk x_chunk = this.chunk_reference.get(x_edge);
      int remaining_width = relative_x + w - Constants.map_chunkWidth;
      int img_width = round(img.width * PApplet.parseFloat(remaining_width) / w);
      if (x_chunk == null) {
      }
      else {
        x_chunk.terrain_dimg.addImageGrid(img, img.width - img_width, 0, img_width,
          img.height, 0, relative_y, remaining_width, h);
      }
    }
    else if (y_hanging) {
      IntegerCoordinate y_edge = this.coordinateOf(x, y + h);
      Chunk y_chunk = this.chunk_reference.get(y_edge);
      int remaining_height = relative_y + h - Constants.map_chunkWidth;
      int img_height = round(img.height * PApplet.parseFloat(remaining_height) / h);
      if (y_chunk == null) {
      }
      else {
        y_chunk.terrain_dimg.addImageGrid(img, 0, img.height - img_height, img.width,
          img_height, relative_x, 0, w, remaining_height);
      }
    }
  }

   public void colorTerrainGrid(int c, int x, int y, int w, int h) {
    Chunk chunk = this.chunk_reference.get(this.coordinateOf(x, y));
    if (chunk == null) {
      return;
    }
    chunk.terrain_dimg.colorGrid(c, Math.floorMod(x, Constants.map_chunkWidth),
      Math.floorMod(y, Constants.map_chunkWidth));
  }

   public synchronized void startTerrainDimgThread() {
    if (this.waiting_for_noise_initialization) {
      return;
    }
    this.refreshChunks();
    this.terrain_dimg_thread = new TerrainDimgThread();
    this.terrain_dimg_thread.start();
  }

   public PImage getFogImagePiece(int fog_xi, int fog_yi, int fog_w, int fog_h) {
    // set fog display in terrain dimg thread
    if (this.fog_dimg_thread != null && this.fog_dimg_thread.isAlive()) {
      this.fog_dimg_thread.replay = true;
    }
    else {
      this.fog_dimg_thread = new FogDImgThread(fog_xi, fog_yi, fog_w, fog_h);
      this.fog_dimg_thread.start();
    }
    if (this.fog_dimg == null) {
      return global.images.getBlackPixel();
    }
    return this.fog_dimg.getImagePiece(fog_xi, fog_yi, fog_w, fog_h);
  }

   public void actuallyAddFeature(int code, Feature f) {
    IntegerCoordinate coordinate = this.coordinateOf(round(f.x), round(f.y));
    Chunk chunk = this.chunk_reference.get(coordinate);
    if (chunk == null) {
      global.log("WARNING: Can't find chunk with coordinates " + coordinate.x +
        ", " + coordinate.y + " to add feature to.");
      return;
    }
    chunk.features.put(code, f);
  }

   public void featureAddedMapSquareNotFound(IntegerCoordinate coordinate, Feature f) {
    // feature hanging over edge of unloaded chunk when added
    if (f == null || f.remove) {
      return;
    }
    if (!this.hanging_features.containsKey(coordinate)) {
      this.hanging_features.put(coordinate, new ConcurrentHashMap<Integer, Feature>());
    }
    this.hanging_features.get(coordinate).putIfAbsent(f.map_key, f);
  }

   public void featureRemovedMapSquareNotFound(IntegerCoordinate coordinate, Feature f) {
    // feature hanging over edge of unloaded chunk when removed
    if (f == null || f.remove) {
      return;
    }
    if (!this.hanging_features.containsKey(coordinate)) {
      return;
    }
    this.hanging_features.get(coordinate).remove(f.map_key);
    if (this.hanging_features.get(coordinate).isEmpty()) {
      this.hanging_features.remove(coordinate);
    }
  }

   public synchronized void checkHangingFeatures() {
    Iterator hanging_features_iterator = this.hanging_features.entrySet().iterator();
    while(hanging_features_iterator.hasNext()) {
      Map.Entry<IntegerCoordinate, ConcurrentHashMap<Integer, Feature>> entry =
        (Map.Entry<IntegerCoordinate, ConcurrentHashMap<Integer, Feature>>)hanging_features_iterator.next();
      GameMapSquare square = this.mapSquare(entry.getKey().x, entry.getKey().y);
      if (square == null) {
        continue;
      }
      Iterator coordinate_iterator = entry.getValue().entrySet().iterator();
      while(coordinate_iterator.hasNext()) {
        Map.Entry<Integer, Feature> feature_entry = (Map.Entry<Integer, Feature>)coordinate_iterator.next();
        if (feature_entry.getValue() == null || feature_entry.getValue().remove) {
          coordinate_iterator.remove();
          continue;
        }
        if (this.resolveHangingFeature(feature_entry.getValue(), entry.getKey())) {
          coordinate_iterator.remove();
        }
      }
      if (entry.getValue().isEmpty()) {
        hanging_features_iterator.remove();
      }
    }
  }

   public synchronized void checkHangingImages() {
    Iterator<HangingImage> hanging_image_iterator = this.hanging_images.iterator();
    while(hanging_image_iterator.hasNext()) {
      HangingImage hanging_image = hanging_image_iterator.next();
      if (hanging_image.resolve()) {
        hanging_image_iterator.remove();
      }
    }
  }

   public boolean featureHanging(Feature f) {
    if (f == null || f.remove) {
      return false;
    }
    IntegerCoordinate x_edge = this.coordinateOf(round(f.x + f.sizeX), round(f.y));
    IntegerCoordinate y_edge = this.coordinateOf(round(f.x), round(f.y + f.sizeY));
    IntegerCoordinate xy_edge = this.coordinateOf(round(f.x + f.sizeX), round(f.y + f.sizeY));
    Chunk x_chunk = this.chunk_reference.get(x_edge);
    Chunk y_chunk = this.chunk_reference.get(y_edge);
    Chunk xy_chunk = this.chunk_reference.get(xy_edge);
    return (x_chunk == null || y_chunk == null || xy_chunk == null);
  }

   public boolean resolveHangingFeature(Feature f, IntegerCoordinate coordinate) {
    if (f == null || f.remove) {
      return true;
    }
    GameMapSquare square = this.mapSquare(coordinate.x, coordinate.y);
    Chunk chunk = this.chunk_reference.get(this.coordinateOf(coordinate.x, coordinate.y));
    if (square == null || chunk == null) { // still hanging
      return false;
    }
    square.addedFeature(f);
    int x_chunk = Math.floorMod(coordinate.x, Constants.map_chunkWidth);
    int y_chunk = Math.floorMod(coordinate.y, Constants.map_chunkWidth);
    DImg dimg = new DImg(f.getImage());
    dimg.setGrid(f.sizeX, f.sizeY);
    PImage image_piece = dimg.getImageGridPiece(coordinate.x - round(f.x), coordinate.y - round(f.y));
    chunk.terrain_dimg.addImageGrid(image_piece, x_chunk, y_chunk);
    return true;
  }

   public Feature getFeature(int code) {
    for (Chunk chunk : this.chunk_reference.values()) {
      if (chunk.features.containsKey(code)) {
        return chunk.features.get(code);
      }
    }
    return null;
  }

   public Collection<Feature> features() { // remove this, make logic more specific
    ArrayList<Feature> feature_list = new ArrayList<Feature>();
    for (Chunk chunk : this.chunk_reference.values()) {
      feature_list.addAll(chunk.features.values());
    }
    return feature_list;
  }

   public void updateFeatures(int time_elapsed) {
    for (Chunk chunk : this.chunk_reference.values()) {
      Iterator feature_iterator = chunk.features.entrySet().iterator();
      while(feature_iterator.hasNext()) {
        Map.Entry<Integer, Feature> entry = (Map.Entry<Integer, Feature>)feature_iterator.next();
        updateFeature(entry.getValue(), feature_iterator, time_elapsed);
      }
    }
  }

   public void updateFeaturesCheckRemovalOnly() {
    for (Chunk chunk : this.chunk_reference.values()) {
      Iterator feature_iterator = chunk.features.entrySet().iterator();
      while(feature_iterator.hasNext()) {
        Map.Entry<Integer, Feature> entry = (Map.Entry<Integer, Feature>)feature_iterator.next();
        if (entry.getValue().remove) {
          this.removeFeature(entry.getKey());
          feature_iterator.remove();
        }
      }
    }
  }


  @Override public 
  void displayNerdStats() {
    fill(255);
    textSize(14);
    textAlign(LEFT, TOP);
    float y_stats = this.yi + 31;
    float line_height = textAscent() + textDescent() + 2;
    text("Map Location: " + this.code.display_name(), this.xi + 1, y_stats);
    y_stats += line_height;
    text("FPS: " + PApplet.parseInt(global.lastFPS), this.xi + 1, y_stats);
    y_stats += line_height;
    try {
      text("Area Location: " + this.area_location.displayName(), this.xi + 1, y_stats);
      y_stats += line_height;
      text("Biome: " + this.chunk_reference.get(this.current_chunk).biome.displayName(), this.xi + 1, y_stats);
      y_stats += line_height;
    } catch(NullPointerException e) {}
    Map<Thread, StackTraceElement[]> all_threads = Thread.getAllStackTraces();
    text("Active Threads: " + all_threads.size(), this.xi + 1, y_stats);
    y_stats += line_height;
    int gamemap_threads = 0;
    int unit_threads = 0;
    for (Thread thread : all_threads.keySet()) {
      String thread_name = thread.getName();
      if (thread_name.equals("TerrainDimgThread") || thread_name.equals("MouseMoveThread") ||
        thread_name.equals("LoadChunkThread") || thread_name.equals("FogDImgThread")) {
        gamemap_threads++;
      }
      else if (thread_name.equals("PathFindingThread")) {
        unit_threads++;
      }
    }
    text("GameMap Threads: " + gamemap_threads, this.xi + 1, y_stats);
    y_stats += line_height;
    text("Unit Threads: " + unit_threads, this.xi + 1, y_stats);
    y_stats += line_height;
    text("Current View: " + this.viewX + ", " + this.viewY, this.xi + 1, y_stats);
    if (this.units.containsKey(0)) {
      y_stats += line_height;
      text("Location: (" + this.units.get(0).x + ", " + this.units.get(0).y +
        ", " + this.units.get(0).curr_height + ")", this.xi + 1, y_stats);
      y_stats += line_height;
      text("Facing: (" + this.units.get(0).facingX + ", " + this.units.get(0).facingY +
        ", " + this.units.get(0).facingA + ")", this.xi + 1, y_stats);
      y_stats += line_height;
      text("Height: (" + this.units.get(0).curr_height + ", " + this.units.get(0).floor_height +
        ", " + this.units.get(0).unit_height + ")", this.xi + 1, y_stats);
      try {
        GameMapSquare square = this.mapSquare(PApplet.parseInt(this.units.get(0).x), PApplet.parseInt(this.units.get(0).y));
        y_stats += line_height;
        text("Terrain: (" + square.terrainName() + ", " + PApplet.parseInt(10.0f * square.light_level)/10.0f + ")", this.xi + 1, y_stats);
      } catch(NullPointerException e) {}
    }
  }


   public void saveTerrain(PrintWriter file) {
    file.println("area_location: " + this.area_location.fileName());
    file.println("mapEdgeXi: " + this.mapEdgeXi);
    file.println("mapEdgeYi: " + this.mapEdgeYi);
    file.println("mapEdgeXf: " + this.mapEdgeXf);
    file.println("mapEdgeYf: " + this.mapEdgeYf);
    file.println("seed: " + this.seed);
    file.println("nextFeatureKey: " + this.nextFeatureKey);
    file.println("default_spawn_chunk: " + this.default_spawn_chunk.x + ", " + this.default_spawn_chunk.y);
    Iterator it = this.chunk_reference.entrySet().iterator();
    while(it.hasNext()) {
      Map.Entry<IntegerCoordinate, Chunk> entry = (Map.Entry<IntegerCoordinate, Chunk>)it.next();
      entry.getValue().save();
    }
  }
  @Override public 
  String fileType() {
    return "area";
  }

   public void addImplementationSpecificData(String datakey, String data) {
    switch(datakey) {
      case "area_location":
        this.area_location = AreaLocation.areaLocation(data);
        break;
      case "mapEdgeXi":
        this.mapEdgeXi = toInt(data);
        break;
      case "mapEdgeYi":
        this.mapEdgeYi = toInt(data);
        break;
      case "mapEdgeXf":
        this.mapEdgeXf = toInt(data);
        break;
      case "mapEdgeYf":
        this.mapEdgeYf = toInt(data);
        break;
      case "default_spawn_chunk":
        String[] data_split = split(data, ',');
        if (data_split.length < 2) {
          global.errorMessage("ERROR: default_spawn_chunk data corrupted.");
          break;
        }
        this.default_spawn_chunk = new IntegerCoordinate(
          toInt(trim(data_split[0])), toInt(trim(data_split[1])));
        break;
      case "seed":
        this.seed = toInt(data);
        noiseSeed(this.seed);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for GameMap object.");
        break;
    }
  }
}
enum GameMapCode {
  ERROR, AREA_FERNWOOD, FRANCIS_FLOOR2, FRANCIS_FLOOR1, FRANCIS_GROUND,
  FRONTDOOR_FRONTDOOR, FRONTDOOR_AHIMDOOR, FRONTDOOR_CIRCLE, FRONTDOOR_ABANDONED,
    FRONTDOOR_CHAPEL, FRONTDOOR_CODA, FRONTDOOR_OUTSIDEFF, FRONTDOOR_INSIDEFF,
    FRONTDOOR_HILL, FRONTDOOR_LOT,
  FRANCIS_OUTSIDE_AHIM, FRANCIS_OUTSIDE_BROTHERS, FRANCIS_OUTSIDE_CHAPEL,
  FRANCIS_OUTSIDE_CUSTODIAL;

  private static final List<GameMapCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String display_name() {
    return GameMapCode.display_name(this);
  }
  public static String display_name(GameMapCode a) {
    switch(a) {
      case AREA_FERNWOOD:
        return "Fernwood Forest";
      case FRANCIS_FLOOR2:
        return "Francis Hall, 2nd floor";
      case FRANCIS_FLOOR1:
        return "Francis Hall, 1st floor";
      case FRANCIS_GROUND:
        return "Francis Hall, ground floor";
      case FRONTDOOR_FRONTDOOR:
        return "Outside Francis Hall, front door";
      case FRONTDOOR_AHIMDOOR:
        return "Outside Francis Hall, Ahim door";
      case FRONTDOOR_CIRCLE:
        return "Francisan Campus, the circle";
      case FRONTDOOR_ABANDONED:
        return "Francisan Campus, front hillside";
      case FRONTDOOR_HILL:
        return "Francisan Campus, front hillside";
      case FRONTDOOR_LOT:
        return "Franciscan Campus, lower parking lot";
      case FRONTDOOR_CHAPEL:
        return "Francisan Campus, outside Chapel";
      case FRONTDOOR_CODA:
        return "Francisan Campus, outside CODA";
      case FRONTDOOR_OUTSIDEFF:
        return "Francisan Campus, outside FFH";
      case FRONTDOOR_INSIDEFF:
        return "Finnegan Fieldhouse";

      case FRANCIS_OUTSIDE_AHIM:
        return "Outside Francis Hall, Ahim door";
      case FRANCIS_OUTSIDE_BROTHERS:
        return "Outside Francis Hall, Brother's door";
      case FRANCIS_OUTSIDE_CHAPEL:
        return "Outside Francis Hall, chapel door";
      case FRANCIS_OUTSIDE_CUSTODIAL:
        return "Outside Francis Hall, custodial door";
      default:
        return "-- Error --";
    }
  }

  public String file_name() {
    return GameMapCode.file_name(this);
  }
  public static String file_name(GameMapCode a) {
    switch(a) {
      case AREA_FERNWOOD:
        return "AREA_FERNWOOD";

      case FRANCIS_FLOOR2:
        return "FRANCIS_FLOOR2";
      case FRANCIS_FLOOR1:
        return "FRANCIS_FLOOR1";
      case FRANCIS_GROUND:
        return "FRANCIS_GROUND";

      case FRONTDOOR_FRONTDOOR:
        return "FRONTDOOR_FRONTDOOR";
      case FRONTDOOR_AHIMDOOR:
        return "FRONTDOOR_AHIMDOOR";
      case FRONTDOOR_CIRCLE:
        return "FRONTDOOR_CIRCLE";
      case FRONTDOOR_ABANDONED:
        return "FRONTDOOR_ABANDONED";
      case FRONTDOOR_HILL:
        return "FRONTDOOR_HILL";
      case FRONTDOOR_LOT:
        return "FRONTDOOR_LOT";
      case FRONTDOOR_CHAPEL:
        return "FRONTDOOR_CHAPEL";
      case FRONTDOOR_CODA:
        return "FRONTDOOR_CODA";
      case FRONTDOOR_OUTSIDEFF:
        return "FRONTDOOR_OUTSIDEFF";
      case FRONTDOOR_INSIDEFF:
        return "FRONTDOOR_INSIDEFF";

      case FRANCIS_OUTSIDE_AHIM:
        return "FRANCIS_OUTSIDE_AHIM";
      case FRANCIS_OUTSIDE_BROTHERS:
        return "FRANCIS_OUTSIDE_BROTHERS";
      case FRANCIS_OUTSIDE_CHAPEL:
        return "FRANCIS_OUTSIDE_CHAPEL";
      case FRANCIS_OUTSIDE_CUSTODIAL:
        return "FRANCIS_OUTSIDE_CUSTODIAL";
      default:
        return "ERROR";
    }
  }

  public static GameMapCode gameMapCode(String display_name) {
    for (GameMapCode code : GameMapCode.VALUES) {
      if (code == GameMapCode.ERROR) {
        continue;
      }
      if (GameMapCode.display_name(code).equals(display_name) ||
        GameMapCode.file_name(code).equals(display_name)) {
        return code;
      }
    }
    return GameMapCode.ERROR;
  }
}
class GameMapEditor extends GameMap {
  class ConfirmDeleteForm extends ConfirmForm {
    ConfirmDeleteForm() {
      super("Confirm Delete", "Are you sure you want to delete all the map " +
        "objects (features, units, items) in the rectangle?");
    }
    @Override public 
    void submit() {
      if (GameMapEditor.this.rectangle_dropping != null) {
        // Delete features
        for (Feature f : GameMapEditor.this.features.values()) {
          if (GameMapEditor.this.rectangle_dropping.contains(f)) {
            f.remove = true;
          }
        }
        // Delete units
        Iterator unit_iterator = GameMapEditor.this.units.entrySet().iterator();
        while(unit_iterator.hasNext()) {
          Map.Entry<Integer, Unit> entry = (Map.Entry<Integer, Unit>)unit_iterator.next();
          if (GameMapEditor.this.rectangle_dropping.contains(entry.getValue())) {
            entry.getValue().remove = true;
          }
        }
        // Delete items
        Iterator item_iterator = GameMapEditor.this.items.entrySet().iterator();
        while(item_iterator.hasNext()) {
          Map.Entry<Integer, Item> entry = (Map.Entry<Integer, Item>)item_iterator.next();
          if (GameMapEditor.this.rectangle_dropping.contains(entry.getValue())) {
            entry.getValue().remove = true;
          }
        }
      }
      GameMapEditor.this.rectangle_dropping = null;
      this.canceled = true;
    }
  }


  protected boolean dropping_terrain = false;
  protected boolean dragging_terrain = false;
  protected int terrain_id = 0;
  protected MapObject dropping_object;
  protected MapObject prev_dropping_object;
  protected boolean draw_grid = true;
  protected boolean rectangle_mode = false;
  protected Rectangle rectangle_dropping = null;
  protected boolean drawing_rectangle = false;
  protected boolean square_mode = false;
  protected ConfirmForm confirm_form;
  protected EditMapObjectForm map_object_form;

  GameMapEditor() {
    super();
    this.draw_fog = false;
    this.force_all_hoverable = true;
  }
  GameMapEditor(GameMapCode code, String folderPath) {
    super(code, folderPath);
    this.draw_fog = false;
    this.force_all_hoverable = true;
  }
  GameMapEditor(String mapName, String folderPath) {
    super(mapName, folderPath);
    this.draw_fog = false;
    this.force_all_hoverable = true;
  }
  GameMapEditor(String mapName, int mapWidth, int mapHeight) {
    super(mapName, mapWidth, mapHeight);
    this.draw_fog = false;
    this.force_all_hoverable = true;
  }


   public void dropTerrain(int id) {
    this.dropping_terrain = true;
    this.terrain_id = id;
  }


   public void update_super(int millis) {
    super.update(millis);
  }


  @Override public 
  void setZoom(float zoom) {
    if (zoom > 500) {
      zoom = 500;
    }
    else if (zoom < 15) {
      zoom = 15;
    }
    this.zoom = zoom;
    this.refreshDisplayMapParameters();
  }


  @Override public 
  void update(int millis) {
    if (this.confirm_form != null) {
      this.confirm_form.update(millis);
      if (this.confirm_form.canceled) {
        this.confirm_form = null;
      }
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.update(millis);
      if (this.map_object_form.canceled) {
        this.map_object_form = null;
      }
      return;
    }
    int timeElapsed = millis - this.lastUpdateTime;
    // check map object removals
    this.updateMapCheckObjectRemovalOnly();
    // update view
    this.updateView(timeElapsed);
    // draw map
    this.drawMap();
    // draw grid
    if (this.draw_grid) {
      stroke(255);
      strokeWeight(0.5f);
      textSize(10);
      textAlign(LEFT, TOP);
      rectMode(CORNER);
      for (int i = PApplet.parseInt(ceil(this.startSquareX)); i < PApplet.parseInt(floor(this.startSquareX + this.visSquareX)); i++) {
        for (int j = PApplet.parseInt(ceil(this.startSquareY)); j < PApplet.parseInt(floor(this.startSquareY + this.visSquareY)); j++) {
          float x = this.xi_map + this.zoom * (i - this.startSquareX);
          float y = this.yi_map + this.zoom * (j - this.startSquareY);
          fill(200, 0);
          rect(x, y, this.zoom, this.zoom);
          fill(255);
          text("(" + i + ", " + j + ")", x + 1, y + 1);
        }
      }
    }
    // draw rectangle dropping
    if (this.rectangle_mode && this.rectangle_dropping != null) {
      fill(170, 100);
      rectMode(CORNERS);
      noStroke();
      float rect_xi = max(this.startSquareX, this.rectangle_dropping.xi);
      float rect_yi = max(this.startSquareY, this.rectangle_dropping.yi);
      float rect_xf = min(this.startSquareX + this.visSquareX, this.rectangle_dropping.xf);
      float rect_yf = min(this.startSquareY + this.visSquareY, this.rectangle_dropping.yf);
      rect(this.xi_map + (rect_xi - this.startSquareX) * this.zoom,
        this.yi_map + (rect_yi - this.startSquareY) * this.zoom,
        this.xi_map + (rect_xf - this.startSquareX) * this.zoom,
        this.yi_map + (rect_yf - this.startSquareY) * this.zoom);
    }
    // draw object dropping
    if (this.hovered_area) {
      if (this.dropping_terrain) {
        imageMode(CENTER);
        image((new GameMapSquare(this.terrain_id)).terrainImage(), mouseX, mouseY, this.zoom, this.zoom);
      }
      else if (this.dropping_object == null) {
        imageMode(CORNER);
        image(global.images.getImage("items/eraser.png"), mouseX, mouseY, this.zoom, this.zoom);
      }
      else {
        if (Feature.class.isInstance(this.dropping_object)) {
          imageMode(CORNER);
          image(this.dropping_object.getImage(), mouseX - 0.5f * this.zoom, mouseY - 0.5f * this.zoom,
            this.zoom * this.dropping_object.width(), this.zoom * this.dropping_object.height());
        }
        else {
          imageMode(CENTER);
          image(this.dropping_object.getImage(), mouseX, mouseY, this.zoom *
            this.dropping_object.width(), this.zoom * this.dropping_object.height());
        }
      }
    }
    this.lastUpdateTime = millis;
  }

   public void mouseMove_super(float mX, float mY) {
    super.mouseMove(mX, mY);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    if (this.confirm_form != null) {
      this.confirm_form.mouseMove(mX, mY);
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.mouseMove(mX, mY);
      return;
    }
    super.mouseMove(mX, mY);
    if (this.drawing_rectangle) {
      if (this.square_mode) {
        this.rectangle_dropping.xf = ceil(this.mX);
        this.rectangle_dropping.yf = ceil(this.mY);
      }
      else {
        this.rectangle_dropping.xf = this.mX;
        this.rectangle_dropping.yf = this.mY;
      }
    }
    if (this.dragging_terrain) {
      this.setTerrain(this.terrain_id, PApplet.parseInt(floor(this.mX)), PApplet.parseInt(floor(this.mY)));
    }
  }

   public void mousePress_super() {
    super.mousePress();
  }

  @Override public 
  void mousePress() {
    for (HeaderMessage message : this.headerMessages) {
      message.mousePress();
    }
    if (this.confirm_form != null) {
      this.confirm_form.mousePress();
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.mousePress();
      return;
    }
    if (this.selected_object != null && this.selected_object_textbox != null) {
      this.selected_object_textbox.mousePress();
    }
    switch(mouseButton) {
      case LEFT:
        this.selectHoveredObject();
        break;
      case RIGHT:
        if (this.rectangle_mode) {
          if (this.square_mode) {
            this.rectangle_dropping = new Rectangle(this.mapName, floor(this.mX),
              floor(this.mY), floor(this.mX), floor(this.mY));
          }
          else {
            this.rectangle_dropping = new Rectangle(this.mapName, this.mX, this.mY, this.mX, this.mY);
          }
          this.drawing_rectangle = true;
          break;
        }
        if (this.dropping_terrain) {
          this.setTerrain(this.terrain_id, PApplet.parseInt(floor(this.mX)), PApplet.parseInt(floor(this.mY)));
          this.dragging_terrain = true;
        }
        else if (this.dropping_object == null) { // erase
          if (this.hovered_object != null) {
            this.hovered_object.remove = true;
          }
        }
        else {
          if (Feature.class.isInstance(this.dropping_object)) {
            this.dropping_object.setLocation(this.mX, this.mY);
            this.addFeature((Feature)this.dropping_object);
            this.dropping_object = new Feature(this.dropping_object.ID);
          }
          else if (Unit.class.isInstance(this.dropping_object)) {
            this.dropping_object.setLocation(this.mX, this.mY);
            this.addUnit((Unit)this.dropping_object);
            this.dropping_object = new Unit(this.dropping_object.ID);
          }
          else if (Item.class.isInstance(this.dropping_object)) {
            if (!global.holding_ctrl && Feature.class.isInstance(this.hovered_object)) {
              Feature hovered_object_feature = (Feature)this.hovered_object;
              if (hovered_object_feature.inventory != null) {
                hovered_object_feature.inventory.stashInDrawers(new Item(this.dropping_object.ID));
                break;
              }
            }
            else if (!global.holding_ctrl && Unit.class.isInstance(this.hovered_object)) {
              Unit hovered_object_unit = (Unit)this.hovered_object;
              if (hovered_object_unit.canPickup()) {
                hovered_object_unit.pickup(new Item(this.dropping_object.ID));
                break;
              }
            }
            this.dropping_object.setLocation(this.mX, this.mY);
            this.addItem((Item)this.dropping_object, false);
            this.dropping_object = new Item(this.dropping_object.ID);
          }
        }
        break;
      case CENTER:
        if (this.dropping_terrain) {
          this.dragging_terrain = false;
          this.dropping_terrain = false;
          this.dropping_object = null;
          this.prev_dropping_object = null;
        }
        else {
          if (this.dropping_object == null) {
            this.dropping_object = this.prev_dropping_object;
          }
          else {
            this.prev_dropping_object = this.dropping_object;
            this.dropping_object = null;
          }
        }
        break;
    }
  }

   public void mouseRelease_super(float mX, float mY) {
    super.mouseRelease(mX, mY);
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    if (this.confirm_form != null) {
      this.confirm_form.mouseRelease(mX, mY);
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.mouseRelease(mX, mY);
      return;
    }
    super.mouseRelease(mX, mY);
    switch(mouseButton) {
      case LEFT:
        break;
      case RIGHT:
        this.dragging_terrain = false;
        this.drawing_rectangle = false;
        if (this.rectangle_mode && this.rectangle_dropping != null) {
          if (this.dropping_terrain) {
            for (int i = PApplet.parseInt(floor(this.rectangle_dropping.xi)); i < PApplet.parseInt(ceil(this.rectangle_dropping.xf)); i++) {
              for (int j = PApplet.parseInt(floor(this.rectangle_dropping.yi)); j < PApplet.parseInt(ceil(this.rectangle_dropping.yf)); j++) {
                this.setTerrain(this.terrain_id, i, j);
              }
            }
            this.rectangle_dropping = null;
          }
          else if (this.dropping_object != null) {
            if (Feature.class.isInstance(this.dropping_object)) {
              for (int i = PApplet.parseInt(floor(this.rectangle_dropping.xi)); i < PApplet.parseInt(ceil(this.rectangle_dropping.xf)); i += this.dropping_object.width()) {
                for (int j = PApplet.parseInt(floor(this.rectangle_dropping.yi)); j < PApplet.parseInt(ceil(this.rectangle_dropping.yf)); j += this.dropping_object.height()) {
                  this.dropping_object.setLocation(i, j);
                  this.addFeature((Feature)this.dropping_object);
                  this.dropping_object = new Feature(this.dropping_object.ID);
                }
              }
            }
            else if (Unit.class.isInstance(this.dropping_object)) {
              // no support for unit rectangle adding
            }
            else if (Item.class.isInstance(this.dropping_object)) {
              // no support for item rectangle adding
            }
            this.rectangle_dropping = null;
          }
          else {
            this.confirm_form = new ConfirmDeleteForm();
          }
        }
        break;
      case CENTER:
        break;
    }
  }

   public void scroll_super(int amount) {
    super.scroll(amount);
  }

  @Override public 
  void scroll(int amount) {
    if (this.confirm_form != null) {
      this.confirm_form.scroll(amount);
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.scroll(amount);
      return;
    }
    super.scroll(amount);
  }

   public void keyPress_super() {
    super.keyPress();
  }

  @Override public 
  void keyPress() {
    if (this.confirm_form != null) {
      this.confirm_form.keyPress();
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.keyPress();
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = true;
          break;
        case RIGHT:
          this.view_moving_right = true;
          break;
        case UP:
          this.view_moving_up = true;
          break;
        case DOWN:
          this.view_moving_down = true;
          break;
      }
    }
    else {
      switch(key) {
        case 'p':
          this.terrain_dimg.img.save("data/maps/terrain.png");
          this.fog_dimg.img.save("data/maps/fog.png");
          this.terrain_display.save("data/maps/terrain_display.png");
          this.fog_display.save("data/maps/fog_display.png");
          break;
        case 'z':
          this.draw_grid = !this.draw_grid;
          if (this.draw_grid) {
            this.addHeaderMessage("Showing Grid");
          }
          else {
            this.addHeaderMessage("Hiding Grid");
          }
          break;
        case 'x':
          this.draw_fog = !this.draw_fog;
          if (this.draw_fog) {
            this.addHeaderMessage("Showing Fog");
          }
          else {
            this.addHeaderMessage("Hiding Fog");
          }
          break;
        case 'c':
          this.rectangle_mode = !this.rectangle_mode;
          this.drawing_rectangle = false;
          if (this.rectangle_mode) {
            this.addHeaderMessage("Rectangle Mode on");
          }
          else {
            this.addHeaderMessage("Rectangle Mode off");
          }
          break;
        case 'v':
          this.square_mode = !this.square_mode;
          if (this.square_mode) {
            this.addHeaderMessage("Square Mode on");
          }
          else {
            this.addHeaderMessage("Square Mode off");
          }
          break;
        case 'b':
          if (this.selected_object != null) {
            if (Feature.class.isInstance(this.selected_object)) {
              this.map_object_form = new EditFeatureForm((Feature)this.selected_object);
              global.defaultCursor();
            }
            else if (Unit.class.isInstance(this.selected_object)) {
              this.map_object_form = new EditUnitForm((Unit)this.selected_object);
              global.defaultCursor();
            }
            else if (Item.class.isInstance(this.selected_object)) {
              this.map_object_form = new EditItemForm((Item)this.selected_object);
              global.defaultCursor();
            }
          }
          break;
      }
    }
  }

   public void keyRelease_super() {
    super.keyRelease();
  }

  @Override public 
  void keyRelease() {
    if (this.confirm_form != null) {
      this.confirm_form.keyRelease();
      return;
    }
    else if (this.map_object_form != null) {
      this.map_object_form.keyRelease();
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = false;
          break;
        case RIGHT:
          this.view_moving_right = false;
          break;
        case UP:
          this.view_moving_up = false;
          break;
        case DOWN:
          this.view_moving_down = false;
          break;
      }
    }
    else {
      switch(key) {
      }
    }
  }
}



class GameMapLevelEditor extends GameMapEditor {
  GameMapLevelEditor(String mapName, String folderPath) {
    super(mapName, folderPath);
    this.rectangle_mode = true;
    this.square_mode = true;
  }

  @Override public 
  void update(int millis) {
    if (this.confirm_form != null) {
      this.confirm_form.update(millis);
      if (this.confirm_form.canceled) {
        this.confirm_form = null;
      }
      return;
    }
    int timeElapsed = millis - this.lastUpdateTime;
    // check map object removals
    this.updateMapCheckObjectRemovalOnly();
    // update view
    this.updateView(timeElapsed);
    // draw map
    this.drawMap();
    // draw grid
    if (this.draw_grid) {
      stroke(255);
      strokeWeight(0.5f);
      textSize(10);
      textAlign(LEFT, TOP);
      rectMode(CORNER);
      for (int i = PApplet.parseInt(ceil(this.startSquareX)); i < PApplet.parseInt(floor(this.startSquareX + this.visSquareX)); i++) {
        for (int j = PApplet.parseInt(ceil(this.startSquareY)); j < PApplet.parseInt(floor(this.startSquareY + this.visSquareY)); j++) {
          float x = this.xi_map + this.zoom * (i - this.startSquareX);
          float y = this.yi_map + this.zoom * (j - this.startSquareY);
          fill(200, 0);
          rect(x, y, this.zoom, this.zoom);
          fill(255);
          text("(" + i + ", " + j + ")", x + 1, y + 1);
        }
      }
    }
    // draw rectangle dropping
    if (this.rectangle_mode && this.rectangle_dropping != null) {
      fill(170, 100);
      rectMode(CORNERS);
      noStroke();
      float rect_xi = max(this.startSquareX, this.rectangle_dropping.xi);
      float rect_yi = max(this.startSquareY, this.rectangle_dropping.yi);
      float rect_xf = min(this.startSquareX + this.visSquareX, this.rectangle_dropping.xf);
      float rect_yf = min(this.startSquareY + this.visSquareY, this.rectangle_dropping.yf);
      rect(this.xi_map + (rect_xi - this.startSquareX) * this.zoom,
        this.yi_map + (rect_yi - this.startSquareY) * this.zoom,
        this.xi_map + (rect_xf - this.startSquareX) * this.zoom,
        this.yi_map + (rect_yf - this.startSquareY) * this.zoom);
    }
    this.lastUpdateTime = millis;
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    if (this.confirm_form != null) {
      this.confirm_form.mouseMove(mX, mY);
      return;
    }
    this.mouseMove_super(mX, mY);
    if (this.drawing_rectangle) {
      if (this.square_mode) {
        this.rectangle_dropping.xf = ceil(this.mX);
        this.rectangle_dropping.yf = ceil(this.mY);
      }
      else {
        this.rectangle_dropping.xf = this.mX;
        this.rectangle_dropping.yf = this.mY;
      }
    }
  }

  @Override public 
  void mousePress() {
    for (HeaderMessage message : this.headerMessages) {
      message.mousePress();
    }
    if (this.confirm_form != null) {
      this.confirm_form.mousePress();
      return;
    }
    if (this.selected_object != null && this.selected_object_textbox != null) {
      this.selected_object_textbox.mousePress();
    }
    switch(mouseButton) {
      case LEFT:
        this.selectHoveredObject();
        break;
      case RIGHT:
        if (this.rectangle_mode) {
          if (this.square_mode) {
            this.rectangle_dropping = new Rectangle(this.mapName, floor(this.mX),
              floor(this.mY), floor(this.mX), floor(this.mY));
          }
          else {
            this.rectangle_dropping = new Rectangle(this.mapName, this.mX, this.mY, this.mX, this.mY);
          }
          this.drawing_rectangle = true;
          break;
        }
        break;
      case CENTER:
        break;
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    if (this.confirm_form != null) {
      this.confirm_form.mouseRelease(mX, mY);
      return;
    }
    this.mouseRelease_super(mX, mY);
    switch(mouseButton) {
      case LEFT:
        break;
      case RIGHT:
        this.drawing_rectangle = false;
        break;
      case CENTER:
        break;
    }
  }

  @Override public 
  void scroll(int amount) {
    if (this.confirm_form != null) {
      this.confirm_form.scroll(amount);
      return;
    }
    this.scroll_super(amount);
  }

  @Override public 
  void keyPress() {
    if (this.confirm_form != null) {
      this.confirm_form.keyPress();
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = true;
          break;
        case RIGHT:
          this.view_moving_right = true;
          break;
        case UP:
          this.view_moving_up = true;
          break;
        case DOWN:
          this.view_moving_down = true;
          break;
      }
    }
    else {
      switch(key) {
        case 'z':
          this.draw_grid = !this.draw_grid;
          if (this.draw_grid) {
            this.addHeaderMessage("Showing Grid");
          }
          else {
            this.addHeaderMessage("Hiding Grid");
          }
          break;
        case 'x':
          this.draw_fog = !this.draw_fog;
          if (this.draw_fog) {
            this.addHeaderMessage("Showing Fog");
          }
          else {
            this.addHeaderMessage("Hiding Fog");
          }
          break;
        case 'c':
          this.rectangle_mode = !this.rectangle_mode;
          this.drawing_rectangle = false;
          if (this.rectangle_mode) {
            this.addHeaderMessage("Rectangle Mode on");
          }
          else {
            this.addHeaderMessage("Rectangle Mode off");
          }
          break;
        case 'v':
          this.square_mode = !this.square_mode;
          if (this.square_mode) {
            this.addHeaderMessage("Square Mode on");
          }
          else {
            this.addHeaderMessage("Square Mode off");
          }
          break;
      }
    }
  }

  @Override public 
  void keyRelease() {
    if (this.confirm_form != null) {
      this.confirm_form.keyRelease();
      return;
    }
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = false;
          break;
        case RIGHT:
          this.view_moving_right = false;
          break;
        case UP:
          this.view_moving_up = false;
          break;
        case DOWN:
          this.view_moving_down = false;
          break;
      }
    }
    else {
      switch(key) {
      }
    }
  }
}


class GameMapAreaEditor extends GameMapArea {
  protected boolean draw_grid = true;

  GameMapAreaEditor(String map_name, String map_folder) {
    super(map_name, map_folder);
    this.draw_fog = false;
  }

  @Override public 
  void setZoom(float zoom) {
    if (zoom > 500) {
      zoom = 500;
    }
    else if (zoom < 15) {
      zoom = 15;
    }
    this.zoom = zoom;
    this.refreshDisplayMapParameters();
  }

  @Override public 
  void update(int millis) {
    int time_elapsed = millis - this.lastUpdateTime;
    // check map object removals
    this.updateMapCheckObjectRemovalOnly();
    // update view
    this.updateView(time_elapsed);
    // draw map
    this.drawMap();
    // draw grid
    if (this.draw_grid) {
      stroke(255);
      strokeWeight(0.5f);
      textSize(10);
      textAlign(LEFT, TOP);
      rectMode(CORNER);
      for (int i = PApplet.parseInt(ceil(this.startSquareX)); i < PApplet.parseInt(floor(this.startSquareX + this.visSquareX)); i++) {
        for (int j = PApplet.parseInt(ceil(this.startSquareY)); j < PApplet.parseInt(floor(this.startSquareY + this.visSquareY)); j++) {
          float x = this.xi_map + this.zoom * (i - this.startSquareX);
          float y = this.yi_map + this.zoom * (j - this.startSquareY);
          fill(200, 0);
          rect(x, y, this.zoom, this.zoom);
          fill(255);
          text("(" + i + ", " + j + ")", x + 1, y + 1);
        }
      }
    }
    this.lastUpdateTime = millis;
  }

  @Override public 
  void keyPress() {
    if (key == CODED) {
      switch(keyCode) {
        case LEFT:
          this.view_moving_left = true;
          break;
        case RIGHT:
          this.view_moving_right = true;
          break;
        case UP:
          this.view_moving_up = true;
          break;
        case DOWN:
          this.view_moving_down = true;
          break;
      }
    }
    else {
      switch(key) {
        case 'p':
          this.fog_dimg.img.save("data/areas/fog.png");
          this.terrain_display.save("data/areas/terrain_display.png");
          this.fog_display.save("data/areas/fog_display.png");
          break;
        case 'z':
          this.draw_grid = !this.draw_grid;
          if (this.draw_grid) {
            this.addHeaderMessage("Showing Grid");
          }
          else {
            this.addHeaderMessage("Hiding Grid");
          }
          break;
        case 'x':
          this.draw_fog = !this.draw_fog;
          if (this.draw_fog) {
            this.addHeaderMessage("Showing Fog");
          }
          else {
            this.addHeaderMessage("Hiding Fog");
          }
          break;
      }
    }
  }
}
class GameMapSquare {
  private int base_elevation = 0;
  private int feature_elevation = 0;
  private int terrain_id = 0;
  private boolean explored = false;
  private boolean visible = false;
  private float light_level = 8; // [0, 10]
  private boolean light_source = false;
  private float original_light = 0;
  private float light_blocked_by_feature = 0;

  GameMapSquare() {
    this.setTerrain(1);
  }
  GameMapSquare(int terrain_id) {
    this.setTerrain(terrain_id);
  }

   public void addedFeature(Feature f) {
    this.feature_elevation += f.sizeZ;
    this.light_blocked_by_feature += f.lightPercentageBlocked();
  }

   public void removedFeature(Feature f) {
    this.feature_elevation -= f.sizeZ;
    this.light_blocked_by_feature -= f.lightPercentageBlocked();
  }

   public void updateLightLevel(AbstractGameMap map, int x, int y) {
    if (this.terrain_id == 191) { // lava
      this.light_source = true;
      this.light_level = 9.2f;
      return;
    }
    float light = this.light_level;
    if (!this.light_source) {
      light -= Constants.map_lightDecay;
    }
    if (map.outside_map && map.base_light_level > light) {
      light = map.base_light_level;
    }
    try {
      GameMapSquare square = map.mapSquare(x + 1, y);
      if (square.light_source || square.passesLight()) {
        float light_right = square.light_level - Constants.map_lightDecay;
        light_right *= 1 - square.light_blocked_by_feature;
        if (light_right > light) {
          light = light_right;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {}
    try {
      GameMapSquare square = map.mapSquare(x - 1, y);
      if (square.light_source || square.passesLight()) {
        float light_left = square.light_level - Constants.map_lightDecay;
        light_left *= 1 - square.light_blocked_by_feature;
        if (light_left > light) {
          light = light_left;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {}
    try {
      GameMapSquare square = map.mapSquare(x, y + 1);
      if (square.light_source || square.passesLight()) {
        float light_down = square.light_level - Constants.map_lightDecay;
        light_down *= 1 - square.light_blocked_by_feature;
        if (light_down > light) {
          light = light_down;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {}
    try {
      GameMapSquare square = map.mapSquare(x, y - 1);
      if (square.light_source || square.passesLight()) {
        float light_up = square.light_level - Constants.map_lightDecay;
        light_up *= 1 - square.light_blocked_by_feature;
        if (light_up > light) {
          light = light_up;
        }
      }
    } catch(ArrayIndexOutOfBoundsException e) {}
    if (light < 0) {
      light = 0;
    }
    this.light_level = light;
  }

   public int getColor(int fog_color) {
    float light_factor = 0.1f * this.light_level; // [0, 1]
    if (light_factor > 1) {
      light_factor = 1;
    }
    else if (light_factor < 0) {
      light_factor = 0;
    }
    float r = (fog_color >> 16 & 0xFF) * light_factor;
    float g = (fog_color >> 8 & 0xFF) * light_factor;
    float b = (fog_color & 0xFF) * light_factor;
    float a = alpha(fog_color) + (1 - light_factor) * (255 - alpha(fog_color));
    return ccolor(r, g, b, a);
  }

   public void setTerrain(int id) {
    this.terrain_id = id;
    if (id > 300) { // stairs
      this.base_elevation = 3;
    }
    else if (id > 200) { // walls
      this.base_elevation = 100;
    }
    else if (id > 100) { // floors
      this.base_elevation = 0;
    }
    else if (id == 2) { // walkable map edge
      this.base_elevation = 0;
    }
    else if (id == 1) { // map edge
      this.base_elevation = 100;
    }
    else {
      global.errorMessage("ERROR: Terrain ID " + id + " not found.");
    }
  }

   public boolean passesLight() {
    switch(this.terrain_id) {
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
      case 206:
      case 207:
      case 211:
      case 212:
      case 213:
        return false;
      default:
        if (this.light_blocked_by_feature < 1) {
          return true;
        }
        else {
          return false;
        }
    }
  }

   public boolean mapEdge() {
    switch(this.terrain_id) {
      case 1:
      case 2:
        return true;
      default:
        return false;
    }
  }

   public boolean isWall() {
    if (this.elevation(false) > Constants.map_maxHeight) {
      return true;
    }
    return false;
  }

   public int elevation(boolean moving_onto) {
    int net_elevation = this.base_elevation + this.feature_elevation;
    switch(this.terrain_id) {
      case 301:
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 308:
      case 309:
      case 310:
      case 311:
      case 312:
      case 313:
      case 314:
      case 315:
      case 316:
      case 317:
      case 318:
      case 319:
      case 320:
      case 321:
      case 322:
      case 323:
      case 324:
        if (moving_onto) {
          net_elevation -= 3;
        }
        break;
      default:
        break;
    }
    return net_elevation;
  }

   public String terrainName() {
    switch(this.terrain_id) {
      case 101: // floors
      case 102:
      case 103:
      case 104:
        return "Carpet";
      case 111:
      case 112:
      case 113:
        return "Wood Floor";
      case 121:
      case 122:
      case 123:
        return "Tile Floor";
      case 131:
        return "Concrete Floor";
      case 132:
      case 133:
        return "Sidewalk";
      case 134:
        return "Gravel";
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
        return "Sand";
      case 151:
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
        return "Grass";
      case 161:
      case 162:
      case 163:
        return "Dirt";
      case 171:
      case 172:
      case 173:
      case 174:
      case 175:
      case 176:
      case 177:
      case 178:
      case 179:
        return "Road";
      case 181:
      case 182:
      case 183:
      case 184:
      case 185:
        return "Water";
      case 191:
        return "Lava";
      case 201:
      case 202:
      case 203:
      case 204:
      case 205:
      case 206:
      case 207:
        return "Brick Wall";
      case 211:
      case 212:
      case 213:
        return "Wooden Wall";
      case 301:
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 308:
      case 309:
      case 310:
      case 311:
      case 312:
      case 313:
      case 314:
      case 315:
      case 316:
      case 317:
      case 318:
      case 319:
      case 320:
      case 321:
      case 322:
      case 323:
      case 324:
        return "Stairs";
      default:
        return null;
    }
  }

   public PImage terrainImage() {
    String imageName = "terrain/";
    switch(this.terrain_id) {
      case 1:
      case 2:
        imageName += "default.jpg";
        break;
      case 101:
        imageName += "carpet_light.jpg";
        break;
      case 102:
        imageName += "carpet_gray.jpg";
        break;
      case 103:
        imageName += "carpet_dark.jpg";
        break;
      case 104:
        imageName += "carpet_green.jpg";
        break;
      case 111:
        imageName += "woodFloor_light.jpg";
        break;
      case 112:
        imageName += "woodFloor_brown.jpg";
        break;
      case 113:
        imageName += "woodFloor_dark.jpg";
        break;
      case 121:
        imageName += "tile_red.jpg";
        break;
      case 122:
        imageName += "tile_green.jpg";
        break;
      case 123:
        imageName += "tile_gray.jpg";
        break;
      case 131:
        imageName += "concrete.jpg";
        break;
      case 132:
        imageName += "sidewalk1.jpg";
        break;
      case 133:
        imageName += "sidewalk2.jpg";
        break;
      case 134:
        imageName += "gravel1.jpg";
        break;
      case 141:
        imageName += "sand1.jpg";
        break;
      case 142:
        imageName += "sand2.jpg";
        break;
      case 143:
        imageName += "sand3.jpg";
        break;
      case 144:
        imageName += "sand3_left.jpg";
        break;
      case 145:
        imageName += "sand3_up.jpg";
        break;
      case 151:
        imageName += "grass1.jpg";
        break;
      case 152:
        imageName += "grass2.jpg";
        break;
      case 153:
        imageName += "grass3.jpg";
        break;
      case 154:
        imageName += "grass4.jpg";
        break;
      case 155:
        imageName += "grass2_line_left.jpg";
        break;
      case 156:
        imageName += "grass2_line_up.jpg";
        break;
      case 161:
        imageName += "dirt1.jpg";
        break;
      case 162:
        imageName += "dirt2.jpg";
        break;
      case 163:
        imageName += "dirt3.jpg";
        break;
      case 171:
        imageName += "road1.jpg";
        break;
      case 172:
        imageName += "road2.jpg";
        break;
      case 173:
        imageName += "road3.jpg";
        break;
      case 174:
        imageName += "road1_left.jpg";
        break;
      case 175:
        imageName += "road1_up.jpg";
        break;
      case 176:
        imageName += "road2_left.jpg";
        break;
      case 177:
        imageName += "road2_up.jpg";
        break;
      case 178:
        imageName += "road2_left_double.jpg";
        break;
      case 179:
        imageName += "road2_up_double.jpg";
        break;
      case 181:
        imageName += "water1.png";
        break;
      case 182:
        imageName += "water2.png";
        break;
      case 183:
        imageName += "water3.jpg";
        break;
      case 184:
        imageName += "water4.jpg";
        break;
      case 185:
        imageName += "water5.png";
        break;
      case 191:
        int lava_frame = PApplet.parseInt(floor(Constants.gif_lava_frames * (millis() %
          Constants.gif_lava_time) / Constants.gif_lava_time));
        imageName = "gifs/lava/" + lava_frame + ".png";
        break;
      case 201:
        imageName += "brickWall_blue.jpg";
        break;
      case 202:
        imageName += "brickWall_gray.jpg";
        break;
      case 203:
        imageName += "brickWall_green.jpg";
        break;
      case 204:
        imageName += "brickWall_pink.jpg";
        break;
      case 205:
        imageName += "brickWall_red.jpg";
        break;
      case 206:
        imageName += "brickWall_yellow.jpg";
        break;
      case 207:
        imageName += "brickWall_white.jpg";
        break;
      case 211:
        imageName += "woodWall_light.jpg";
        break;
      case 212:
        imageName += "woodWall_brown.jpg";
        break;
      case 213:
        imageName += "woodWall_dark.jpg";
        break;
      case 301:
        imageName += "stairs_gray_up.jpg";
        break;
      case 302:
        imageName += "stairs_gray_down.jpg";
        break;
      case 303:
        imageName += "stairs_gray_left.jpg";
        break;
      case 304:
        imageName += "stairs_gray_right.jpg";
        break;
      case 305:
        imageName += "stairs_green_up.jpg";
        break;
      case 306:
        imageName += "stairs_green_down.jpg";
        break;
      case 307:
        imageName += "stairs_green_left.jpg";
        break;
      case 308:
        imageName += "stairs_green_right.jpg";
        break;
      case 309:
        imageName += "stairs_red_up.jpg";
        break;
      case 310:
        imageName += "stairs_red_down.jpg";
        break;
      case 311:
        imageName += "stairs_red_left.jpg";
        break;
      case 312:
        imageName += "stairs_red_right.jpg";
        break;
      case 313:
        imageName += "stairs_white_up.jpg";
        break;
      case 314:
        imageName += "stairs_white_down.jpg";
        break;
      case 315:
        imageName += "stairs_white_left.jpg";
        break;
      case 316:
        imageName += "stairs_white_right.jpg";
        break;
      case 317:
        imageName += "stairway_green_up.png";
        break;
      case 318:
        imageName += "stairway_green_down.png";
        break;
      case 319:
        imageName += "stairway_green_left.png";
        break;
      case 320:
        imageName += "stairway_green_right.png";
        break;
      case 321:
        imageName += "stairway_red_up.png";
        break;
      case 322:
        imageName += "stairway_red_down.png";
        break;
      case 323:
        imageName += "stairway_red_left.png";
        break;
      case 324:
        imageName += "stairway_red_right.png";
        break;

      default:
        imageName += "default.jpg";
        break;
    }
    return global.images.getImage(imageName);
  }
}
enum ProgramState {
  INITIAL_INTERFACE, EXITING, ENTERING_MAINMENU, MAINMENU_INTERFACE,
  ENTERING_MAPEDITOR, MAPEDITOR_INTERFACE, ENTERING_TUTORIAL, TUTORIAL,
  ENTERING_PLAYING, PLAYING, ENTERING_MINIGAMES, MINIGAMES;
}


class Global {
  // Program
  private InterfaceLNZ menu;
  private Queue<NotificationLNZ> notification = new ArrayDeque<NotificationLNZ>();
  private ProgramState state = ProgramState.INITIAL_INTERFACE;
  private int timer_exiting = Constants.exit_delay;
  private Images images;
  private Sounds sounds;
  private Configuration configuration = new Configuration();
  private PImage cursor;
  private String last_cursor_string = "";
  private boolean holding_shift = false;
  private boolean holding_ctrl = false;
  private boolean holding_alt = false;
  private boolean holding_space = false;
  private boolean holding_left = false;
  private boolean holding_right = false;
  private boolean holding_up = false;
  private boolean holding_down = false;
  private boolean holding_rightclick = false;
  private Deque<String> error_messages = new ArrayDeque<String>();
  private PrintWriter log;
  private boolean focused_last_frame = true;
  private boolean viewing_ender_chest = false;
  private HashMap<Integer, CraftingRecipe> crafting_recipes = getAllCraftingRecipes();
  // FPS
  private int lastFrameTime = millis();
  private float lastFPS = Constants.maxFPS;
  private int frameCounter = frameCount;
  private int timer_FPS = Constants.frameUpdateTime;
  // Colors
  private int color_background = color(180);
  private int color_nameDisplayed_background = color(100, 180);
  private int color_nameDisplayed_text = color(255);
  private int color_panelBackground = color(160, 82, 45);
  private int color_loadingScreenBackground = color(222, 185, 140);
  private int color_mapBorder = color(20);
  private int color_mapBackground = color(20);
  private int color_inventoryBackground = color(210, 153, 108);
  private int color_perkTreeBaseColor = color(160, 120, 80);
  private int color_perkTreeLockedColor = color(150);
  private int color_perkTreeBrightColor = color(170, 160, 100);
  private int color_perkTreeDarkColor = color(150, 70, 50);
  // Profile
  private Profile profile;
  // Graphics
  protected boolean player_blinking = true;
  protected int player_blinks_left = 0;
  protected int player_blink_time = Constants.level_questBlinkTime;

  Global(LNZ thisInstance) {
    this.images = new Images();
    this.sounds = new Sounds(thisInstance);
    this.cursor = this.images.getImage("icons/cursor_default.png");
    if (!folderExists("data/logs")) {
      mkdir("data/logs");
    }
    this.log = createWriter(sketchPath("data/logs/curr_log.lnz"));
  }

   public int frame() {
    int elapsed = millis() - this.lastFrameTime;
    this.lastFrameTime = millis();
    return elapsed;
  }

   public void loseFocus() {
    this.holding_shift = false;
    this.holding_ctrl = false;
    this.holding_alt = false;
    this.holding_space = false;
    this.holding_left = false;
    this.holding_right = false;
    this.holding_up = false;
    this.holding_down = false;
    this.holding_rightclick = false;
    if (this.menu != null) {
      this.menu.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.menu != null) {
      this.menu.gainFocus();
    }
  }

   public void setCursor(String cursor_path) {
    this.cursor = this.images.getImage(cursor_path);
    this.last_cursor_string = cursor_path;
  }

  // The api calling default cursor has to provide the other cursors it can cause
   public void defaultCursor(String ... possible_cursors) {
    for (String s : possible_cursors) {
      if (s.equals(this.last_cursor_string)) {
        this.setCursor("icons/cursor_default.png");
      }
    }
  }
   public void defaultCursor() {
    this.setCursor("icons/cursor_default.png");
  }

   public void viewingEnderChest() {
    if (this.viewing_ender_chest) {
      global.errorMessage("ERROR: Already an ender chest open. Will cause concurrent modification errors.");
    }
    this.viewing_ender_chest = true;
  }

   public void notViewingEnderChest() {
    if (!this.viewing_ender_chest) {
      global.errorMessage("ERROR: Ender chest not open.");
    }
    this.viewing_ender_chest = false;
  }

   public synchronized void log(String message) {
    this.log.println(message);
    println("LNZ log: " + message);
  }

   public String lastErrorMessage() {
    if (this.error_messages.peek() == null) {
      return "None";
    }
    return this.error_messages.peek();
  }

   public synchronized void errorMessage(String message) {
    this.error_messages.push(message);
    this.log(message);
  }

   public void checkErrorMessge() {
    if (this.menu == null) {
      return;
    }
    if (this.error_messages.peek() == null) {
      return;
    }
    this.menu.throwError(this.error_messages.pop());
  }

   public void keyPressFX2D() {
    if (key == CODED) {
      switch(keyCode) {
        case ALT:
          this.holding_alt = true;
          break;
        case CONTROL:
          this.holding_ctrl = true;
          break;
        case SHIFT:
          this.holding_shift = true;
          break;
        case LEFT:
          this.holding_left = true;
          break;
        case RIGHT:
          this.holding_right = true;
          break;
        case UP:
          this.holding_up = true;
          break;
        case DOWN:
          this.holding_down = true;
          break;
      }
    }
    else {
      this.fixKeyFX2D();
      if (key == ' ') {
        this.holding_space = true;
      }
    }
  }
   public void keyReleaseFX2D() {
    if (key == CODED) {
      switch(keyCode) {
        case ALT:
          this.holding_alt = false;
          break;
        case CONTROL:
          this.holding_ctrl = false;
          break;
        case SHIFT:
          this.holding_shift = false;
          break;
        case LEFT:
          this.holding_left = false;
          break;
        case RIGHT:
          this.holding_right = false;
          break;
        case UP:
          this.holding_up = false;
          break;
        case DOWN:
          this.holding_down = false;
          break;
      }
    }
    else {
      this.fixKeyFX2D();
      if (key == ' ') {
        this.holding_space = false;
      }
    }
  }
   public void fixKeyFX2D() {
    if (!this.holding_shift) {
      if (key >= 'A' && key <= 'Z') {
        key += 32;
      }
      else {
        switch(key) {
          case 192:
            key = '`';
            break;
          case 222:
            key = '\'';
            break;
        }
      }
    }
    else {
      switch(key) {
        case '1':
          key = '!';
          break;
        case '2':
          key = '@';
          break;
        case '3':
          key = '#';
          break;
        case '4':
          key = '$';
          break;
        case '5':
          key = '%';
          break;
        case '6':
          key = '^';
          break;
        case '7':
          key = '&';
          break;
        case '8':
          key = '*';
          break;
        case '9':
          key = '(';
          break;
        case '0':
          key = ')';
          break;
        case '-':
          key = '_';
          break;
        case '=':
          key = '+';
          break;
        case '[':
          key = '{';
          break;
        case ']':
          key = '}';
          break;
        case '\\':
          key = '|';
          break;
        case ';':
          key = ':';
          break;
        case '\'':
          key = '\"';
          break;
        case ',':
          key = '<';
          break;
        case '.':
          key = '>';
          break;
        case '/':
          key = '?';
          break;
        case 192:
          key = '~';
          break;
        case 222:
          key = '\"';
          break;
      }
    }
  }

   public void exitDelay() {
    this.log("Exiting normally.");
    this.log.flush();
    this.log.close();
    if (!folderExists("data/logs/past")) {
      mkdir("data/logs/past");
    }
    copyFile("data/logs/curr_log.lnz", "data/logs/past/" + year() + this.monthString() +
      this.dayString() + "-" + this.hourString() + this.minuteString() + this.secondString() + ".lnz");
    this.state = ProgramState.EXITING;
  }

   public void exitImmediately() {
    this.exitDelay();
    exit();
  }

   public String monthString() {
    int month = month();
    if (month < 10) {
      return "0" + Integer.toString(month);
    }
    else {
      return Integer.toString(month);
    }
  }

   public String dayString() {
    int day = day();
    if (day < 10) {
      return "0" + Integer.toString(day);
    }
    else {
      return Integer.toString(day);
    }
  }

   public String hourString() {
    int hour = hour();
    if (hour < 10) {
      return "0" + Integer.toString(hour);
    }
    else {
      return Integer.toString(hour);
    }
  }

   public String minuteString() {
    int minute = minute();
    if (minute < 10) {
      return "0" + Integer.toString(minute);
    }
    else {
      return Integer.toString(minute);
    }
  }

   public String secondString() {
    int second = second();
    if (second < 10) {
      return "0" + Integer.toString(second);
    }
    else {
      return Integer.toString(second);
    }
  }
}


// global options (profile independent)
class Configuration {
  private String default_profile_name = "";
  private float cursor_size = Constants.default_cursor_size;

  Configuration() {
    this.loadConfiguration();
  }

   public void loadConfiguration() {
    String[] lines = loadStrings(sketchPath("data/configuration.lnz"));
    if (lines == null) {
      this.save(); // save defaults if no configuration exists
      return;
    }
    for (String line : lines) {
      String[] data = split(line, ':');
      if (data.length < 2) {
        continue;
      }
      switch(data[0]) {
        case "default_profile_name":
          this.default_profile_name = trim(data[1]);
          break;
        case "cursor_size":
          if (isFloat(trim(data[1]))) {
            this.cursor_size = toFloat(trim(data[1]));
          }
          break;
        default:
          break;
      }
    }
  }

   public void defaultConfiguration() {
    this.cursor_size = Constants.default_cursor_size;
  }

   public void save() {
    this.saveConfiguration();
  }
   public void saveConfiguration() {
    PrintWriter file = createWriter(sketchPath("data/configuration.lnz"));
    file.println("default_profile_name: " + this.default_profile_name);
    file.println("cursor_size: " + this.cursor_size);
    file.flush();
    file.close();
  }
}
enum HeroCode {
  ERROR, BEN, DAN, JF, SPINNY, MATTUS, PATRICK;

  private static final List<HeroCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String display_name() {
    return HeroCode.display_name(this);
  }
  static public String display_name(HeroCode code) {
    switch(code) {
      case BEN:
        return "Ben Nelson";
      case DAN:
        return "Daniel Gray";
      case JF:
        return "John-Francis";
      case SPINNY:
        return "Mark Spinny";
      case MATTUS:
        return "Mad Dog Mattus";
      case PATRICK:
        return "Patrick Rolwes";
      default:
        return "-- Error --";
    }
  }

  public Element element() {
    return HeroCode.element(this);
  }
  static public Element element(HeroCode code) {
    switch(code) {
      case BEN:
        return Element.GRAY;
      case DAN:
        return Element.BROWN;
      case JF:
        return Element.CYAN;
      case SPINNY:
        return Element.RED;
      case MATTUS:
        return Element.MAGENTA;
      case PATRICK:
        return Element.GRAY;
      default:
        return Element.GRAY;
    }
  }

  public String title() {
    return HeroCode.title(this);
  }
  static public String title(HeroCode code) {
    switch(code) {
      case BEN:
        return "The Rage of Wisconsin";
      case DAN:
        return "The Half-Frog of Hopedale";
      case JF:
        return "";
      case SPINNY:
        return "";
      case MATTUS:
        return "";
      case PATRICK:
        return "";
      default:
        return "-- Error --";
    }
  }

  public String description() {
    return HeroCode.description(this);
  }
  static public String description(HeroCode code) {
    switch(code) {
      case BEN:
        return "Ben description";
      case DAN:
        return "Dan description";
      case JF:
        return "";
      case SPINNY:
        return "";
      case MATTUS:
        return "";
      case PATRICK:
        return "";
      default:
        return "-- Error --";
    }
  }

  public String file_name() {
    return HeroCode.file_name(this);
  }
  static public String file_name(HeroCode code) {
    switch(code) {
      case BEN:
        return "BEN";
      case DAN:
        return "DAN";
      case JF:
        return "JF";
      case SPINNY:
        return "SPINNY";
      case MATTUS:
        return "MATTUS";
      case PATRICK:
        return "PATRICK";
      default:
        return "ERROR";
    }
  }

  public int unit_id() {
    return HeroCode.unit_id(this);
  }
  static public int unit_id(HeroCode code) {
    switch(code) {
      case BEN:
        return 1101;
      case DAN:
        return 1102;
      case JF:
        return 1103;
      case SPINNY:
        return 1104;
      case MATTUS:
        return 1105;
      case PATRICK:
        return 1106;
      default:
        return 1100;
    }
  }

  public String getImagePath() {
    return HeroCode.getImagePath(this);
  }
  public String getImagePath(boolean ben_has_eyes) {
    return HeroCode.getImagePath(this, ben_has_eyes);
  }
  static public String getImagePath(HeroCode code) {
    return HeroCode.getImagePath(code, true);
  }
  static public String getImagePath(HeroCode code, boolean ben_has_eyes) {
    String file_path = "units/";
    switch(code) {
      case BEN:
        if (ben_has_eyes) {
          file_path += "ben_circle.png";
        }
        else {
          file_path += "ben_circle_noeyes.png";
        }
        break;
      case DAN:
        file_path += "dan_circle.png";
        break;
      case JF:
        file_path += "jf_circle.png";
        break;
      case SPINNY:
        file_path += "spinny_circle.png";
        break;
      case MATTUS:
        file_path += "mattus_circle.png";
        break;
      case PATRICK:
        file_path += "patrick_circle.png";
        break;
      default:
        file_path += "default.png";
        break;
    }
    return file_path;
  }

  static public HeroCode heroCode(String display_name) {
    for (HeroCode code : HeroCode.VALUES) {
      if (code == HeroCode.ERROR) {
        continue;
      }
      if (HeroCode.display_name(code).equals(display_name) ||
        HeroCode.file_name(code).equals(display_name)) {
        return code;
      }
    }
    return ERROR;
  }

  static public HeroCode heroCodeFromId(int id) {
    switch(id) {
      case 1101:
        return HeroCode.BEN;
      case 1102:
        return HeroCode.DAN;
      case 1103:
        return HeroCode.JF;
      case 1104:
        return HeroCode.SPINNY;
      case 1105:
        return HeroCode.MATTUS;
      case 1106:
        return HeroCode.PATRICK;
      default:
        return HeroCode.ERROR;
    }
  }
}



enum LeftPanelMenuPage {
  NONE, PLAYER; // others in future as game becomes more complex
}



enum InventoryLocation {
  INVENTORY, GEAR, FEATURE, CRAFTING;
  private static final List<InventoryLocation> VALUES = Collections.unmodifiableList(Arrays.asList(values()));
}



enum HeroTreeCode {
  INVENTORYI, PASSIVEI, AI, SI, DI, FI, PASSIVEII, AII, SII, DII, FII,
  HEALTHI, ATTACKI, DEFENSEI, PIERCINGI, SPEEDI, SIGHTI, TENACITYI, AGILITYI, MAGICI,
    RESISTANCEI, PENETRATIONI, HEALTHII, ATTACKII, DEFENSEII, PIERCINGII, SPEEDII,
    SIGHTII, TENACITYII, AGILITYII, MAGICII, RESISTANCEII, PENETRATIONII, HEALTHIII,
  OFFHAND, BELTI, BELTII, INVENTORYII, INVENTORY_BARI, INVENTORY_BARII,
  CRAFTI, CRAFTII_ROW, CRAFTII_COL, CRAFTIII_ROW, CRAFTIII_COL,
  FOLLOWERI,
  ;
  private static final List<HeroTreeCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String file_name() {
    switch(this) {
      case INVENTORYI:
        return "Inventory";
      case PASSIVEI:
        return "Passive";
      case AI:
        return "A";
      case SI:
        return "S";
      case DI:
        return "D";
      case FI:
        return "F";
      case PASSIVEII:
        return "PassiveII";
      case AII:
        return "AII";
      case SII:
        return "SII";
      case DII:
        return "DII";
      case FII:
        return "FII";
      case HEALTHI:
        return "Health";
      case ATTACKI:
        return "Attack";
      case DEFENSEI:
        return "Defense";
      case PIERCINGI:
        return "Piercing";
      case SPEEDI:
        return "Speed";
      case SIGHTI:
        return "Sight";
      case TENACITYI:
        return "Tenacity";
      case AGILITYI:
        return "Agility";
      case MAGICI:
        return "Magic";
      case RESISTANCEI:
        return "Resistance";
      case PENETRATIONI:
        return "Penetration";
      case HEALTHII:
        return "HealthII";
      case ATTACKII:
        return "AttackII";
      case DEFENSEII:
        return "DefenseII";
      case PIERCINGII:
        return "PiercingII";
      case SPEEDII:
        return "SpeedII";
      case SIGHTII:
        return "SightII";
      case TENACITYII:
        return "TenacityII";
      case AGILITYII:
        return "AgilityII";
      case MAGICII:
        return "MagicII";
      case RESISTANCEII:
        return "ResistanceII";
      case PENETRATIONII:
        return "PenetrationII";
      case HEALTHIII:
        return "HealthIII";
      case OFFHAND:
        return "Offhand";
      case BELTI:
        return "Belt";
      case BELTII:
        return "BeltII";
      case INVENTORYII:
        return "InventoryII";
      case INVENTORY_BARI:
        return "InventoryBar";
      case INVENTORY_BARII:
        return "InventoryBarII";
      case CRAFTI:
        return "CraftI";
      case CRAFTII_ROW:
        return "CraftII_row";
      case CRAFTII_COL:
        return "CraftII_col";
      case CRAFTIII_ROW:
        return "CraftIII_row";
      case CRAFTIII_COL:
        return "CraftIII_col";
      case FOLLOWERI:
        return "Follower";
      default:
        return "--Error--";
    }
  }

  public static HeroTreeCode codeFromId(int id) {
    switch(id) {
      case 0:
        return HeroTreeCode.INVENTORYI;
      case 1:
        return HeroTreeCode.PASSIVEI;
      case 2:
        return HeroTreeCode.AI;
      case 3:
        return HeroTreeCode.SI;
      case 4:
        return HeroTreeCode.DI;
      case 5:
        return HeroTreeCode.FI;
      case 6:
        return HeroTreeCode.PASSIVEII;
      case 7:
        return HeroTreeCode.AII;
      case 8:
        return HeroTreeCode.SII;
      case 9:
        return HeroTreeCode.DII;
      case 10:
        return HeroTreeCode.FII;
      case 11:
        return HeroTreeCode.HEALTHI;
      case 12:
        return HeroTreeCode.ATTACKI;
      case 13:
        return HeroTreeCode.DEFENSEI;
      case 14:
        return HeroTreeCode.PIERCINGI;
      case 15:
        return HeroTreeCode.SPEEDI;
      case 16:
        return HeroTreeCode.SIGHTI;
      case 17:
        return HeroTreeCode.TENACITYI;
      case 18:
        return HeroTreeCode.AGILITYI;
      case 19:
        return HeroTreeCode.MAGICI;
      case 20:
        return HeroTreeCode.RESISTANCEI;
      case 21:
        return HeroTreeCode.PENETRATIONI;
      case 22:
        return HeroTreeCode.HEALTHII;
      case 23:
        return HeroTreeCode.ATTACKII;
      case 24:
        return HeroTreeCode.DEFENSEII;
      case 25:
        return HeroTreeCode.PIERCINGII;
      case 26:
        return HeroTreeCode.SPEEDII;
      case 27:
        return HeroTreeCode.SIGHTII;
      case 28:
        return HeroTreeCode.TENACITYII;
      case 29:
        return HeroTreeCode.AGILITYII;
      case 30:
        return HeroTreeCode.MAGICII;
      case 31:
        return HeroTreeCode.RESISTANCEII;
      case 32:
        return HeroTreeCode.PENETRATIONII;
      case 33:
        return HeroTreeCode.HEALTHIII;
      case 34:
        return HeroTreeCode.OFFHAND;
      case 35:
        return HeroTreeCode.BELTI;
      case 36:
        return HeroTreeCode.BELTII;
      case 37:
        return HeroTreeCode.INVENTORYII;
      case 38:
        return HeroTreeCode.INVENTORY_BARI;
      case 39:
        return HeroTreeCode.INVENTORY_BARII;
      case 40:
        return HeroTreeCode.FOLLOWERI;
      case 41:
        return HeroTreeCode.CRAFTI;
      case 42:
        return HeroTreeCode.CRAFTII_ROW;
      case 43:
        return HeroTreeCode.CRAFTII_COL;
      case 44:
        return HeroTreeCode.CRAFTIII_ROW;
      case 45:
        return HeroTreeCode.CRAFTIII_COL;
      default:
        return HeroTreeCode.INVENTORYI;
    }
  }

  public static HeroTreeCode code(String display_name) {
    for (HeroTreeCode code : HeroTreeCode.VALUES) {
      if (code.file_name().equals(display_name)) {
        return code;
      }
    }
    return null;
  }
}



class Hero extends Unit {

  class GearInventory extends Inventory {
    GearInventory() {
      super(4, 3, true);
    }

     public GearSlot indexToGearSlot(int index) {
      switch(index) {
        case 0:
          return GearSlot.HAND_THIRD;
        case 1:
          return GearSlot.HEAD;
        case 2:
          return GearSlot.HAND_FOURTH;
        case 3:
          return GearSlot.WEAPON;
        case 4:
          return GearSlot.CHEST;
        case 5:
          return GearSlot.OFFHAND;
        case 6:
          return GearSlot.BELT_RIGHT;
        case 7:
          return GearSlot.LEGS;
        case 8:
          return GearSlot.BELT_LEFT;
        case 9:
          return GearSlot.FEET_SECOND;
        case 10:
          return GearSlot.FEET;
        case 11:
          return GearSlot.FEET_THIRD;
        default:
          global.errorMessage("ERROR: Gear inventory index " + index + " out of range.");
          return GearSlot.ERROR;
      }
    }

     public Item getItem(int index) {
      return Hero.this.gear.get(this.indexToGearSlot(index));
    }

     public void setItem(int index, Item i) {
      Hero.this.gear.put(this.indexToGearSlot(index), i);
    }

    @Override public 
    Item placeAt(Item i, int index, boolean replace) {
      if (!i.equippable(this.indexToGearSlot(index))) {
        return i;
      }
      if (index < 0 || index >= this.slots.size()) {
        return i;
      }
      if (this.getItem(index) == null) {
        this.setItem(index, i);
        return null;
      }
      else if (this.getItem(index).ID == i.ID) {
        int stack_left = this.getItem(index).maxStack() - this.getItem(index).stack;
        if (i.stack > stack_left) {
          this.getItem(index).addStack(stack_left);
          i.removeStack(stack_left);
        }
        else {
          this.getItem(index).addStack(i.stack);
          return null;
        }
      }
      else if (replace) {
        Item replaced = new Item(this.getItem(index));
        this.setItem(index, i);
        return replaced;
      }
      return i;
    }

    @Override public 
    void update(int timeElapsed) {
      rectMode(CORNER);
      fill(this.color_background);
      noStroke();
      rect(0, 0, this.display_width, this.display_height);
      imageMode(CORNERS);
      for (Map.Entry<GearSlot, Item> entry : Hero.this.gear.entrySet()) {
        switch(entry.getKey()) {
          case WEAPON:
            this.updateSlot(timeElapsed, 3, entry.getValue());
            break;
          case HEAD:
            this.updateSlot(timeElapsed, 1, entry.getValue());
            break;
          case CHEST:
            this.updateSlot(timeElapsed, 4, entry.getValue());
            break;
          case LEGS:
            this.updateSlot(timeElapsed, 7, entry.getValue());
            break;
          case FEET:
            this.updateSlot(timeElapsed, 10, entry.getValue());
            break;
          case OFFHAND:
            this.updateSlot(timeElapsed, 5, entry.getValue());
            break;
          case BELT_LEFT:
            this.updateSlot(timeElapsed, 6, entry.getValue());
            break;
          case BELT_RIGHT:
            this.updateSlot(timeElapsed, 8, entry.getValue());
            break;
        }
      }
    }

     public void updateSlot(int timeElapsed, int index, Item i) {
      this.updateSlot(timeElapsed, index, i, true, 0, true);
    }
     public void updateSlot(int timeElapsed, int index, Item i, boolean translate_first, float temp_slot_width, boolean show_slot_hovered_message) {
      int x = index % this.max_cols;
      if (x < 0 || x >= this.max_cols) {
        return;
      }
      int y = index / this.max_cols;
      if (y < 0 || y >= this.max_rows) {
        return;
      }
      this.slots.get(index).item = i;
      if (translate_first) {
        translate(2 + x * this.button_size, 2 + y * this.button_size);
      }
      else {
        this.slots.get(index).setWidth(temp_slot_width);
        if (index == 3) { // hand white border
          this.slots.get(index).button.setStroke(color(255), 4);
        }
      }
      this.slots.get(index).update(timeElapsed, show_slot_hovered_message);
      if (this.slots.get(index).item == null) {
        String iconName = "icons/";
        switch(index) {
          case 0:
            iconName += "";
            break;
          case 1:
            iconName += "head.png";
            break;
          case 2:
            iconName += "";
            break;
          case 3:
            iconName += "hand_inverted.png";
            break;
          case 4:
            iconName += "chest.png";
            break;
          case 5:
            iconName += "hand.png";
            break;
          case 6:
            iconName += "belt_right.png";
            break;
          case 7:
            iconName += "legs.png";
            break;
          case 8:
            iconName += "belt_left.png";
            break;
          case 9:
            iconName += "";
            break;
          case 10:
            iconName += "feet.png";
            break;
          case 11:
            iconName += "";
            break;
          default:
            global.errorMessage("ERROR: Gear inventory index " + index + " out of range.");
            break;
        }
        image(global.images.getImage(iconName), 0, 0, this.slots.get(index).width(), this.slots.get(index).width());
      }
      if (translate_first) {
        translate(-2 - x * this.button_size, -2 - y * this.button_size);
      }
      else {
        this.slots.get(index).setWidth(this.button_size);
        if (index == 3) { // hand white border
          this.slots.get(index).button.setStroke(color(142, 75, 50), 3);
        }
      }
    }

    @Override public 
    void mouseMove(float mX, float mY) {
      if (mX + 5 < 0 || mY + 5 < 0 || mX - 5 > this.display_width || mY - 5 > this.display_height) {
        this.hovered = false;
      }
      else {
        this.hovered = true;
      }
      for (int x = 0; x < this.max_cols; x++) {
        for (int y = 0; y < this.max_rows; y++) {
          int i = y * this.max_cols + x;
          if (i >= this.slots.size()) {
            break;
          }
          if (!this.slotActive(i)) {
            continue;
          }
          this.slots.get(i).mouseMove(mX - 2 - x * this.button_size, mY - 2 - y * this.button_size);
        }
      }
    }

     public boolean slotActive(int index) {
      return Hero.this.gear.containsKey(this.indexToGearSlot(index));
    }
  }

  class CraftingInventory extends Inventory {
    class CraftButton extends RectangleButton {
      protected int craft_timer = 0;

      CraftButton() {
        super(0, 0, 0, 0);
        this.disabled = true;
        this.show_message = true;
        this.force_left_button = false;
        this.message = "Craft";
        this.use_time_elapsed = true;
        this.noStroke();
        this.setColors(color(170, 170), color(1, 0), color(200, 100), color(200,
          200), color(0));
      }

      @Override public 
      void update(int timeElapsed) {
        super.update(timeElapsed);
        if (this.clicked && mouseButton == RIGHT) {
          this.craft_timer -= timeElapsed;
          if (this.craft_timer < 0) {
            this.craft_timer = Constants.hero_multicraftTimer;
            this.release();
          }
        }
      }

       public void dehover() {}
       public void hover() {}
       public void click() {
        this.craft_timer = Constants.hero_multicraftTimer;
      }
       public void release() {
        if (!this.hovered) {
          return;
        }
        if (CraftingInventory.this.craftable_item == null) {
          return;
        }
        CraftingInventory.this.craft();
      }
    }


    class ToolsButton extends RectangleButton {
      class ToolsButtonTextBox extends TextBox {
        ToolsButtonTextBox() {
          super(0, 0, 0, 0);
          this.setTitleSize(19);
          this.setTextSize(17);
          this.color_background = global.color_nameDisplayed_background;
          this.color_header = global.color_nameDisplayed_background;
          this.color_stroke = color(1, 0);
          this.color_text = color(255);
          this.color_title = color(255);
          this.scrollbar.setButtonColors(color(170),
            adjust_color_brightness(global.color_nameDisplayed_background, 1.1f),
            adjust_color_brightness(global.color_nameDisplayed_background, 1.2f),
            adjust_color_brightness(global.color_nameDisplayed_background, 0.95f), color(0));
          this.scrollbar.button_upspace.setColors(color(1, 0), color(1, 0),
            color(1, 0), color(0), color(0));
          this.scrollbar.button_downspace.setColors(color(1, 0), color(1, 0),
            color(1, 0), color(0), color(0));
          this.useElapsedTime();
        }
      }

      protected ToolsButtonTextBox description = new ToolsButtonTextBox();

      ToolsButton() {
        super(0, 0, 0, 0);
        this.show_message = true;
        this.force_left_button = false;
        this.message = "Tools";
        this.use_time_elapsed = true;
        this.noStroke();
        this.setColors(color(170, 170), color(1, 0), color(200, 100), color(200, 200), color(0));
      }

       public void update(int timeElapsed) {
        super.update(timeElapsed);
        if (this.hovered && CraftingInventory.this.crafting_recipe != null) {
          String message_text = "Tools Needed:";
          for (ToolCode code : CraftingInventory.this.crafting_recipe.tools) {
            message_text += "\n - " + code.displayName();
          }
          message_text += "\n\nTools Have:";
          for (ToolCode code : CraftingInventory.this.currentTools()) {
            message_text += "\n - " + code.displayName();
          }
          textSize(this.description.text_size);
          float description_width = max(Constants.feature_workbenchMinimumToolsButtonWidth,
            textWidth(CraftingInventory.this.craftable_item.display_name()) + 2);
          this.description.setXLocation(this.xf - description_width, this.xf);
          float description_height = textAscent() + textDescent() + 6;
          this.description.setTitleText(CraftingInventory.this.craftable_item.display_name());
          this.description.setText(message_text);
          description_height += (2 + this.description.text_lines.size()) *
            (textAscent() + textDescent() + this.description.text_leading);
          this.description.setYLocation(this.yi - description_height, this.yi);
          this.description.update(timeElapsed);
        }
      }

       public void dehover() {}
       public void hover() {}
       public void click() {}
       public void release() {
        if (!this.hovered) {
          return;
        }
        // open crafting recipe form
      }
    }


    private int curr_crafting_hash_code = 0;
    private Item craftable_item = null;
    private CraftingRecipe crafting_recipe = null;
    private boolean craftable_item_hovered = false;
    private float last_mX = 0;
    private float last_mY = 0;
    private CraftButton craft = new CraftButton();
    private ToolsButton tools = new ToolsButton();

    CraftingInventory() {
      super(3, 6, true);
      this.deactivateSlots();
    }


     public ArrayList<ToolCode> currentTools() {
      return ToolCode.toolCodesFrom(this.currentToolItems().toArray(new Item[0]));
    }

     public ArrayList<Item> currentToolItems() {
      ArrayList<Item> tool_items = Hero.this.inventory.items();
      tool_items.add(Hero.this.weapon());
      tool_items.add(Hero.this.offhand());
      return tool_items;
    }


     public void craft() {
      if (this.craftable_item == null) {
        return;
      }
      if (this.slots.get(11).item != null && (this.slots.get(11).item.ID !=
        this.craftable_item.ID || this.slots.get(11).item.maxStack() - this.
        slots.get(11).item.stack < this.craftable_item.stack)) {
        return;
      }
      if (!this.crafting_recipe.hasTools(this.currentTools())) {
        return;
      }
      this.crafting_recipe.useTools(this.currentToolItems());
      this.slots.get(0).removeStack();
      this.slots.get(1).removeStack();
      this.slots.get(2).removeStack();
      this.slots.get(6).removeStack();
      this.slots.get(7).removeStack();
      this.slots.get(8).removeStack();
      this.slots.get(12).removeStack();
      this.slots.get(13).removeStack();
      this.slots.get(14).removeStack();
      if (this.slots.get(11).item == null) {
        this.slots.get(11).item = new Item(this.craftable_item);
      }
      else {
        this.slots.get(11).item.addStack(this.craftable_item.stack);
      }
      this.slots.get(11).deactivated = false;
      this.craftable_item = null;
    }


    @Override public 
    void setButtonSize(float button_size) {
      super.setButtonSize(button_size);
      this.craft.setLocation(2 + 3.5f * button_size, 2 + 2.1f * button_size,
        2 + 5 * button_size, 2 + 2.9f * button_size);
      this.craft.text_size = button_size * 0.35f;
      this.tools.setLocation(2 + 3.5f * button_size, 2 + 0.1f * button_size,
        2 + 5 * button_size, 2 + 0.9f * button_size);
      this.tools.text_size = button_size * 0.35f;
    }

    @Override public 
    void update(int timeElapsed) {
      if (this.slots.get(7).deactivated) {
        return;
      }
      if (!this.slots.get(11).deactivated && this.slots.get(11).item == null) {
        this.slots.get(11).deactivated = true;
        this.slots.get(11).button.hovered = false;
        this.slots.get(11).button.clicked = false;
      }
      super.update(timeElapsed);
      this.curr_crafting_hash_code = this.getCraftingHashCode();
      imageMode(CORNER);
      if (global.crafting_recipes.containsKey(this.curr_crafting_hash_code)) {
        this.crafting_recipe = global.crafting_recipes.get(this.curr_crafting_hash_code);
        this.craftable_item = new Item(this.crafting_recipe.output);
        this.craftable_item.stack = this.crafting_recipe.amount;
        this.craft.disabled = !this.crafting_recipe.hasTools(this.currentTools());
        if (this.craft.disabled) {
          image(global.images.getImage("icons/crafting_arrow_red.png"), 2 + 3.5f * this.button_size,
            2 + 1 * this.button_size, this.button_size, this.button_size);
        }
        else {
          image(global.images.getImage("icons/crafting_arrow_green.png"), 2 + 3.5f * this.button_size,
            2 + 1 * this.button_size, this.button_size, this.button_size);
        }
        image(this.craftable_item.getImage(), 2 + 5 * this.button_size,
          2 + 1 * this.button_size, this.button_size, this.button_size);
        if (this.craftable_item.stack > 1) {
          fill(255);
          textSize(14);
          textAlign(RIGHT, BOTTOM);
          text(this.craftable_item.stack, 6 * this.button_size, 2 * this.button_size);
        }
        if (this.craftable_item_hovered) {
          textSize(20);
          float rect_height = textAscent() + textDescent() + 2;
          float rect_width = textWidth(this.craftable_item.display_name()) + 2;
          rectMode(CORNER);
          fill(global.color_nameDisplayed_background);
          stroke(1, 0);
          strokeWeight(0.1f);
          rect(this.last_mX - rect_width - 1, this.last_mY - rect_height - 1, rect_width, rect_height);
          fill(255);
          textAlign(LEFT, TOP);
          text(this.craftable_item.display_name(), this.last_mX - rect_width - 1, this.last_mY - rect_height - 1);
        }
      }
      else {
        this.craftable_item = null;
        this.crafting_recipe = null;
        this.craft.disable();
        image(global.images.getImage("icons/crafting_arrow.png"), 2 + 3.5f * this.button_size,
          2 + 1 * this.button_size, this.button_size, this.button_size);
      }
      this.craft.update(timeElapsed);
      this.tools.update(timeElapsed);
    }

    @Override public 
    void mouseMove(float mX, float mY) {
      this.last_mX = mX;
      this.last_mY = mY;
      super.mouseMove(mX, mY);
      this.craft.mouseMove(mX, mY);
      this.tools.mouseMove(mX, mY);
      if (this.craftable_item == null) {
        this.craftable_item_hovered = false;
      }
      else {
        if (mX > 2 + 5 * this.button_size && mY > 2 + 1 * this.button_size &&
          mX < 2 + 6 * this.button_size && mY < 2 + 2 * this.button_size) {
          this.craftable_item_hovered = true;
        }
        else {
          this.craftable_item_hovered = false;
        }
      }
    }

    @Override public 
    void mouseRelease(float mX, float mY) {
      super.mouseRelease(mX, mY);
      this.craft.mouseRelease(mX, mY);
      this.tools.mouseRelease(mX, mY);
    }

    @Override public 
    int getCraftingHashCode() {
      int[][] item_grid = new int[3][3];
      if (this.slots.get(0).item != null) {
        item_grid[0][0] = this.slots.get(0).item.ID;
      }
      if (this.slots.get(1).item != null) {
        item_grid[0][1] = this.slots.get(1).item.ID;
      }
      if (this.slots.get(2).item != null) {
        item_grid[0][2] = this.slots.get(2).item.ID;
      }
      if (this.slots.get(6).item != null) {
        item_grid[1][0] = this.slots.get(6).item.ID;
      }
      if (this.slots.get(7).item != null) {
        item_grid[1][1] = this.slots.get(7).item.ID;
      }
      if (this.slots.get(8).item != null) {
        item_grid[1][2] = this.slots.get(8).item.ID;
      }
      if (this.slots.get(12).item != null) {
        item_grid[2][0] = this.slots.get(12).item.ID;
      }
      if (this.slots.get(13).item != null) {
        item_grid[2][1] = this.slots.get(13).item.ID;
      }
      if (this.slots.get(14).item != null) {
        item_grid[2][2] = this.slots.get(14).item.ID;
      }
      return Arrays.deepHashCode(reduceItemGrid(item_grid));
    }
  }

  class InventoryKey {
    private InventoryLocation location;
    private int index;
    InventoryKey(InventoryLocation location, int index) {
      this.location = location;
      this.index = index;
    }
  }

  class HeroInventory extends Inventory {
    protected Item item_holding = null;
    protected InventoryKey item_origin = null;
    protected Item item_dropping = null;
    protected ArrayList<Item> more_items_dropping = new ArrayList<Item>();

    protected GearInventory gear_inventory = new GearInventory();
    protected Inventory feature_inventory = null;
    protected CraftingInventory crafting_inventory = new CraftingInventory();

    protected float last_mX = 0;
    protected float last_mY = 0;
    protected boolean viewing = false;
    protected boolean any_hovered = false;
    protected int grab_mouse_button = LEFT;

    HeroInventory() {
      super(Constants.hero_inventoryMaxRows, Constants.hero_inventoryMaxCols, false);
      this.setSlots(Hero.this.inventoryStartSlots());
      this.setButtonSize(Constants.hero_defaultInventoryButtonSize);
    }


     public void dropItemHolding() {
      if (this.item_holding == null || this.item_holding.remove) {
        return;
      }
      if (this.item_origin == null || !this.any_hovered) {
        this.item_dropping = this.item_holding;
      }
      else {
        switch(this.item_origin.location) {
          case INVENTORY:
            this.item_dropping = this.placeAt(this.item_holding, this.item_origin.index);
            break;
          case GEAR:
            this.item_dropping = this.gear_inventory.placeAt(this.item_holding, this.item_origin.index);
            break;
          case FEATURE:
            if (this.feature_inventory == null) {
              this.item_dropping = this.item_holding;
            }
            else {
              this.item_dropping = this.feature_inventory.placeAt(this.item_holding, this.item_origin.index);
            }
            break;
          case CRAFTING:
            if (this.item_origin.index == 11) {
              this.item_dropping = this.stash(this.item_holding);
            }
            else {
              this.item_dropping = this.crafting_inventory.placeAt(this.item_holding, this.item_origin.index);
            }
            break;
        }
      }
      this.item_holding = null;
      this.item_origin = null;
    }


     public void clearCraftingInventory() {
      for (InventorySlot slot : this.crafting_inventory.slots) {
        if (slot.item == null || slot.item.remove) {
          continue;
        }
        Item i = this.stash(slot.item);
        slot.item = null;
        if (i == null || i.remove) {
          continue;
        }
        this.more_items_dropping.add(i);
      }
    }


     public InventoryKey itemLocation(int item_id) {
      InventoryKey location = null;
      for (InventoryLocation invLocation : InventoryLocation.VALUES) {
        location = this.itemLocation(item_id, invLocation);
        if (location != null) {
          break;
        }
      }
      return location;
    }
     public InventoryKey itemLocation(int item_id, InventoryLocation invLocation) {
      switch(invLocation) {
        case INVENTORY:
          for (int i = 0; i < this.slots.size(); i++) {
            if (this.slots.get(i).item != null && this.slots.get(i).item.ID == item_id) {
              return new InventoryKey(InventoryLocation.INVENTORY, i);
            }
          }
          break;
        case GEAR:
          for (int i = 0; i < this.gear_inventory.slots.size(); i++) {
            if (this.gear_inventory.slots.get(i).item != null
              && this.gear_inventory.slots.get(i).item.ID == item_id) {
              return new InventoryKey(InventoryLocation.GEAR, i);
            }
          }
          break;
        case FEATURE:
          if (this.feature_inventory == null) {
            break;
          }
          for (int i = 0; i < this.feature_inventory.slots.size(); i++) {
            if (this.feature_inventory.slots.get(i).item != null &&
              this.feature_inventory.slots.get(i).item.ID == item_id) {
              return new InventoryKey(InventoryLocation.FEATURE, i);
            }
          }
          break;
        case CRAFTING:
          for (int i = 0; i < this.crafting_inventory.slots.size(); i++) {
            if (this.crafting_inventory.slots.get(i).item != null &&
              this.crafting_inventory.slots.get(i).item.ID == item_id) {
              return new InventoryKey(InventoryLocation.CRAFTING, i);
            }
          }
          break;
      }
      return null;
    }


     public Item getItem(InventoryKey inventory_key) {
      if (inventory_key == null) {
        return null;
      }
      switch(inventory_key.location) {
        case INVENTORY:
          try {
            return this.slots.get(inventory_key.index).item;
          } catch(Exception e) {}
          break;
        case GEAR:
          try {
            return this.gear_inventory.slots.get(inventory_key.index).item;
          } catch(Exception e) {}
          break;
        case FEATURE:
          try {
            return this.feature_inventory.slots.get(inventory_key.index).item;
          } catch(Exception e) {}
          break;
        case CRAFTING:
          try {
            return this.crafting_inventory.slots.get(inventory_key.index).item;
          } catch(Exception e) {}
          break;
      }
      return null;
    }

     public void setItem(Item i, InventoryKey inventory_key) {
      if (i == null) {
        return;
      }
      if (inventory_key == null) {
        this.item_dropping = i;
        return;
      }
      switch(inventory_key.location) {
        case INVENTORY:
          try {
            this.slots.get(inventory_key.index).item = i;
            return;
          } catch(Exception e) {}
          break;
        case GEAR:
          try {
            this.gear_inventory.setItem(inventory_key.index, i);
            return;
          } catch(Exception e) {}
          break;
        case FEATURE:
          try {
            this.feature_inventory.slots.get(inventory_key.index).item = i;
            return;
          } catch(Exception e) {}
          break;
        case CRAFTING:
          try {
            this.crafting_inventory.slots.get(inventory_key.index).item = i;
          } catch(Exception e) {}
          break;
      }
      this.item_dropping = i;
    }


     public void featureInventory(Inventory feature_inventory) {
      if (feature_inventory == null) {
        return;
      }
      this.feature_inventory = feature_inventory;
      this.setButtonSize(this.button_size);
    }


    @Override public 
    void setButtonSize(float button_size) {
      super.setButtonSize(button_size);
      this.gear_inventory.setButtonSize(button_size);
      this.crafting_inventory.setButtonSize(button_size);
      if (this.feature_inventory != null) {
        this.feature_inventory.setButtonSize(button_size);
      }
    }


    @Override public 
    Item stash(Item i) {
      if (i == null || i.remove) {
        return null;
      }
      if (this.feature_inventory != null) {
        Item leftover = this.feature_inventory.stash(i);
        if (leftover == null || leftover.remove) {
          return null;
        }
        i = new Item(leftover);
      }
      for (int j = 0; j < this.gear_inventory.slots.size(); j++) {
        if (this.gear_inventory.indexToGearSlot(j) == GearSlot.WEAPON) {
          continue;
        }
        Item leftover = this.gear_inventory.placeAt(i, j, false);
        if (leftover == null || leftover.remove) {
          i.equipSound();
          return null;
        }
        i = new Item(leftover);
      }
      return super.stash(i);
    }


    @Override public 
    void update(int timeElapsed) {
      // main inventory
      super.update(timeElapsed);
      noFill();
      stroke(255);
      strokeWeight(2);
      rectMode(CORNER);
      if (Hero.this.inventory_bar.unlocked_inventory_bar2) {
        rect(2, 2, 9 * this.button_size, this.button_size);
      }
      else if (Hero.this.inventory_bar.unlocked_inventory_bar1) {
        rect(2, 2, 4 * this.button_size, this.button_size);
      }
      // gear
      float gearInventoryTranslateX = - this.gear_inventory.display_width - 2;
      float gearInventoryTranslateY = 0.5f * (this.display_height - this.gear_inventory.display_height);
      translate(gearInventoryTranslateX, gearInventoryTranslateY);
      this.gear_inventory.update(timeElapsed);
      translate(-gearInventoryTranslateX, -gearInventoryTranslateY);
      // crafting
      float craftingInventoryTranslateX = this.display_width + 2;
      float craftingInventoryTranslateY = 0.5f * (this.display_height - this.crafting_inventory.display_height);
      translate(craftingInventoryTranslateX, craftingInventoryTranslateY);
      this.crafting_inventory.update(timeElapsed);
      translate(-craftingInventoryTranslateX, -craftingInventoryTranslateY);
      // feature
      if (this.feature_inventory != null) {
        float featureInventoryTranslateX = 0.5f * (this.display_width - this.feature_inventory.display_width);
        float featureInventoryTranslateY = - this.feature_inventory.display_height - 2;
        translate(featureInventoryTranslateX, featureInventoryTranslateY);
        this.feature_inventory.update(timeElapsed);
        translate(-featureInventoryTranslateX, -featureInventoryTranslateY);
      }
      // item holding
      if (this.item_holding != null) {
        imageMode(CENTER);
        image(this.item_holding.getImage(), this.item_holding.x, this.item_holding.y,
          this.button_size, this.button_size);
        if (this.item_holding.stack > 1) {
          fill(255);
          textSize(14);
          textAlign(RIGHT, BOTTOM);
          text(this.item_holding.stack, this.item_holding.x + 0.5f * this.button_size -
            2, this.item_holding.y + 0.5f * this.button_size - 2);
        }
      }
    }

    @Override public 
    void mouseMove(float mX, float mY) {
      this.any_hovered = false;
      // item holding
      if (this.item_holding != null) {
        this.item_holding.x += mX - this.last_mX;
        this.item_holding.y += mY - this.last_mY;
      }
      this.last_mX = mX;
      this.last_mY = mY;
      // main inventory
      super.mouseMove(mX, mY);
      if (this.hovered) {
        this.any_hovered = true;
      }
      // gear
      float gearInventoryTranslateX = - this.gear_inventory.display_width - 2;
      float gearInventoryTranslateY = 0.5f * (this.display_height - this.gear_inventory.display_height);
      this.gear_inventory.mouseMove(mX - gearInventoryTranslateX, mY - gearInventoryTranslateY);
      if (this.gear_inventory.hovered) {
        this.any_hovered = true;
      }
      // crafting
      float craftingInventoryTranslateX = this.display_width + 2;
      float craftingInventoryTranslateY = 0.5f * (this.display_height - this.crafting_inventory.display_height);
      this.crafting_inventory.mouseMove(mX - craftingInventoryTranslateX, mY - craftingInventoryTranslateY);
      if (this.crafting_inventory.hovered) {
        this.any_hovered = true;
      }
      // feature
      if (this.feature_inventory != null) {
        float featureInventoryTranslateX = 0.5f * (this.display_width - this.feature_inventory.display_width);
        float featureInventoryTranslateY = - this.feature_inventory.display_height - 2;
        this.feature_inventory.mouseMove(mX - featureInventoryTranslateX, mY - featureInventoryTranslateY);
        if (this.feature_inventory.hovered) {
          this.any_hovered = true;
        }
      }
    }

    @Override public 
    void mousePress() {
      super.mousePress();
      if (this.feature_inventory != null) {
        this.feature_inventory.mousePress();
      }
      boolean found_clicked = false;
      Item source_item = null;
      float item_holding_x = 0;
      float item_holding_y = 0;
      // main inventory
      for (int x = 0; x < this.max_cols; x++) {
        for (int y = 0; y < this.max_rows; y++) {
          int i = y * this.max_cols + x;
          if (i >= this.slots.size()) {
            break;
          }
          this.slots.get(i).mousePress();
          if (this.slots.get(i).button.hovered) {
            source_item = this.slots.get(i).item;
            if (this.item_holding == null || this.item_holding.remove) {
              this.item_origin = new InventoryKey(InventoryLocation.INVENTORY, i);
              item_holding_x = 2 + (x + 0.5f) * this.button_size;
              item_holding_y = 2 + (y + 0.5f) * this.button_size;
              this.grab_mouse_button = mouseButton;
            }
            else {
              if (mouseButton != this.grab_mouse_button) {
                if (source_item == null || source_item.remove) {
                  this.slots.get(i).item = new Item(this.item_holding);
                  this.slots.get(i).item.stack = 1;
                  this.item_holding.removeStack();
                }
                else if (source_item.ID == this.item_holding.ID &&
                  source_item.maxStack() > source_item.stack) {
                  source_item.addStack();
                  this.item_holding.removeStack();
                }
              }
              return;
            }
            found_clicked = true;
            break;
          }
        }
      }
      // gear
      if (!found_clicked) {
        for (int x = 0; x < this.gear_inventory.max_cols; x++) {
          for (int y = 0; y < this.gear_inventory.max_rows; y++) {
            int i = y * this.gear_inventory.max_cols + x;
            if (i >= this.gear_inventory.slots.size()) {
              break;
            }
            if (!this.gear_inventory.slotActive(i)) {
              continue;
            }
            this.gear_inventory.slots.get(i).mousePress();
            if (this.gear_inventory.slots.get(i).button.hovered) {
              source_item = this.gear_inventory.getItem(i);
              if (this.item_holding == null || this.item_holding.remove) {
                this.item_origin = new InventoryKey(InventoryLocation.GEAR, i);
                item_holding_x = (x + 0.5f) * this.button_size - this.gear_inventory.display_width;
                item_holding_y = 0.5f * (this.display_height - this.gear_inventory.
                  display_height) + 2 + (y + 0.5f) * this.button_size;
                this.grab_mouse_button = mouseButton;
              }
              else {
                if (mouseButton != this.grab_mouse_button) {
                  if (source_item == null || source_item.remove) {
                    this.gear_inventory.slots.get(i).item = new Item(this.item_holding);
                    this.gear_inventory.slots.get(i).item.stack = 1;
                    this.item_holding.removeStack();
                  }
                  else if (source_item.ID == this.item_holding.ID &&
                    source_item.maxStack() > source_item.stack) {
                    source_item.addStack();
                    this.item_holding.removeStack();
                  }
                }
                return;
              }
              found_clicked = true;
              break;
            }
          }
          if (found_clicked) {
            break;
          }
        }
      }
      // crafting
      this.crafting_inventory.craft.mousePress();
      this.crafting_inventory.tools.mousePress();
      if (!found_clicked) {
        for (int x = 0; x < this.crafting_inventory.max_cols; x++) {
          for (int y = 0; y < this.crafting_inventory.max_rows; y++) {
            int i = y * this.crafting_inventory.max_cols + x;
            if (i >= this.crafting_inventory.slots.size()) {
              break;
            }
            this.crafting_inventory.slots.get(i).mousePress();
            if (this.crafting_inventory.slots.get(i).button.hovered) {
              source_item = this.crafting_inventory.slots.get(i).item;
              if (this.item_holding == null || this.item_holding.remove) {
                this.item_origin = new InventoryKey(InventoryLocation.CRAFTING, i);
                item_holding_x = this.display_width + 4 + (x + 0.5f) * this.button_size +
                  this.crafting_inventory.slots.get(i).button.xi;
                item_holding_y = 0.5f * (this.display_height - this.crafting_inventory.
                  display_height) + 2 + (y + 0.5f) * this.button_size + this.crafting_inventory.slots.get(i).button.yi;
                this.grab_mouse_button = mouseButton;
              }
              else {
                if (mouseButton != this.grab_mouse_button) {
                  if (source_item == null || source_item.remove) {
                    this.crafting_inventory.slots.get(i).item = new Item(this.item_holding);
                    this.crafting_inventory.slots.get(i).item.stack = 1;
                    this.item_holding.removeStack();
                  }
                  else if (source_item.ID == this.item_holding.ID &&
                    source_item.maxStack() > source_item.stack) {
                    source_item.addStack();
                    this.item_holding.removeStack();
                  }
                }
                return;
              }
              found_clicked = true;
              break;
            }
          }
          if (found_clicked) {
            break;
          }
        }
      }
      // feature
      if (!found_clicked) {
        if (this.feature_inventory != null) {
          for (int x = 0; x < this.feature_inventory.max_cols; x++) {
            for (int y = 0; y < this.feature_inventory.max_rows; y++) {
              int i = y * this.feature_inventory.max_cols + x;
              if (i >= this.feature_inventory.slots.size()) {
                break;
              }
              this.feature_inventory.slots.get(i).mousePress();
              if (this.feature_inventory.slots.get(i).button.hovered) {
                source_item = this.feature_inventory.slots.get(i).item;
                if (this.item_holding == null || this.item_holding.remove) {
                  this.item_origin = new InventoryKey(InventoryLocation.FEATURE, i);
                  item_holding_x = 0.5f * (this.display_width - this.
                    feature_inventory.display_width) + 2 + (x + 0.5f) * this.button_size +
                    this.feature_inventory.slots.get(i).button.xi;
                  item_holding_y = (y + 0.5f) * this.button_size - this.feature_inventory.
                    display_height + this.crafting_inventory.slots.get(i).button.yi;
                  this.grab_mouse_button = mouseButton;
                }
                else {
                  if (mouseButton != this.grab_mouse_button) {
                    if (source_item == null || source_item.remove) {
                      this.feature_inventory.slots.get(i).item = new Item(this.item_holding);
                      this.feature_inventory.slots.get(i).item.stack = 1;
                      this.item_holding.removeStack();
                    }
                    else if (source_item.ID == this.item_holding.ID &&
                      source_item.maxStack() > source_item.stack) {
                      source_item.addStack();
                      this.item_holding.removeStack();
                    }
                  }
                  return;
                }
                found_clicked = true;
                break;
              }
            }
            if (found_clicked) {
              break;
            }
          }
        }
      }
      if (found_clicked) {
        switch(mouseButton) {
          case LEFT:
            if (source_item == null) {
              break;
            }
            this.item_holding = new Item(source_item);
            source_item.remove = true;
            break;
          case RIGHT:
            if (source_item == null) {
              break;
            }
            this.item_holding = new Item(source_item);
            if (this.item_holding != null && !this.item_holding.remove) {
              this.item_holding.stack = 1;
            }
            source_item.removeStack(1);
            break;
          case CENTER:
            if (source_item == null) {
              break;
            }
            int stack_to_transfer = PApplet.parseInt(ceil(0.5f * source_item.stack));
            this.item_holding = new Item(source_item);
            if (this.item_holding != null && !this.item_holding.remove) {
              this.item_holding.stack = stack_to_transfer;
            }
            source_item.removeStack(stack_to_transfer);
            break;
        }
        if (this.item_holding != null) {
          if (global.holding_shift) {
            switch(this.item_origin.location) {
              case INVENTORY:
                if (this.feature_inventory == null) {
                  this.item_holding = this.gear_inventory.placeAt(this.item_holding, 3, false);
                }
                else {
                  this.item_holding = this.feature_inventory.stash(this.item_holding);
                }
                break;
              case GEAR:
                this.item_holding = this.stash(this.item_holding);
                break;
              case FEATURE:
                this.item_holding = super.stash(this.item_holding);
                if (this.item_holding != null && !this.item_holding.remove) {
                  this.item_holding = this.gear_inventory.placeAt(this.item_holding, 3, false);
                }
                break;
              case CRAFTING:
                this.item_holding = this.stash(this.item_holding);
                break;
            }
          }
          if (this.item_holding != null) {
            this.item_holding.x = item_holding_x;
            this.item_holding.y = item_holding_y;
          }
        }
      }
    }

    @Override public 
    void mouseRelease(float mX, float mY) {
      // process latest hovered information
      super.mouseRelease(mX, mY);
      float gearInventoryTranslateX = - this.gear_inventory.display_width - 2;
      float gearInventoryTranslateY = 0.5f * (this.display_height - this.gear_inventory.display_height);
      this.gear_inventory.mouseRelease(mX - gearInventoryTranslateX, mY - gearInventoryTranslateY);
      float craftingInventoryTranslateX = this.display_width + 2;
      float craftingInventoryTranslateY = 0.5f * (this.display_height - this.crafting_inventory.display_height);
      this.crafting_inventory.mouseRelease(mX - craftingInventoryTranslateX, mY - craftingInventoryTranslateY);
      if (this.feature_inventory != null) {
        float featureInventoryTranslateX = 0.5f * (this.display_width - this.feature_inventory.display_width);
        float featureInventoryTranslateY = - this.feature_inventory.display_height - 2;
        this.feature_inventory.mouseRelease(mX - featureInventoryTranslateX, mY - featureInventoryTranslateY);
      }
      // process item holding
      if (this.item_holding == null || this.item_holding.remove || mouseButton != this.grab_mouse_button) {
        return;
      }
      // main inventory
      boolean found_hovered = false;
      for (int i = 0; i < this.slots.size(); i++) {
        if (this.slots.get(i).button.hovered) {
          this.item_holding = this.placeAt(this.item_holding, i, true);
          found_hovered = true;
          this.dropItemHolding();
          break;
        }
      }
      // gear
      if (found_hovered) {
        return;
      }
      for (int i = 0; i < this.gear_inventory.slots.size(); i++) {
        if (!this.gear_inventory.slotActive(i)) {
          continue;
        }
        if (this.gear_inventory.slots.get(i).button.hovered) {
          this.item_holding = this.gear_inventory.placeAt(this.item_holding, i, true);
          found_hovered = true;
          this.dropItemHolding();
          break;
        }
      }
      // crafting
      if (found_hovered) {
        return;
      }
      for (int i = 0; i < this.crafting_inventory.slots.size(); i++) {
        if (this.crafting_inventory.slots.get(i).button.hovered) {
          this.item_holding = this.crafting_inventory.placeAt(this.item_holding, i, true);
          found_hovered = true;
          this.dropItemHolding();
          break;
        }
      }
      // feature
      if (found_hovered) {
        return;
      }
      if (this.feature_inventory != null) {
        for (int i = 0; i < this.feature_inventory.slots.size(); i++) {
          if (this.feature_inventory.slots.get(i).button.hovered) {
            this.item_holding = this.feature_inventory.placeAt(this.item_holding, i, true);
            found_hovered = true;
            this.dropItemHolding();
            break;
          }
        }
      }
      if (!found_hovered) {
        this.dropItemHolding();
      }
    }
  }


  class InventoryBar {
    class StatusEffectTextBox extends TextBox {
      private boolean display = false;
      StatusEffectTextBox() {
        super(0, 0, 0, 0);
        this.setTitleSize(15);
        this.setTextSize(13);
        this.color_background = global.color_nameDisplayed_background;
        this.color_header = global.color_nameDisplayed_background;
        this.color_stroke = color(1, 0);
        this.color_text = color(255);
        this.color_title = color(255);
        this.scrollbar.setButtonColors(color(170),
          adjust_color_brightness(global.color_nameDisplayed_background, 1.1f),
          adjust_color_brightness(global.color_nameDisplayed_background, 1.2f),
          adjust_color_brightness(global.color_nameDisplayed_background, 0.95f), color(0));
        this.scrollbar.button_upspace.setColors(color(1, 0), color(1, 0),
          color(1, 0), color(0), color(0));
        this.scrollbar.button_downspace.setColors(color(1, 0), color(1, 0),
          color(1, 0), color(0), color(0));
        this.useElapsedTime();
      }
    }

    class AbilityButton extends RectangleButton {
      class AbilityTextBox extends TextBox {
        private boolean display = false;
        AbilityTextBox(float xi, float yi, float xf, float yf) {
          super(xi, yi, xf, yf);
          this.setTitleSize(18);
          this.setTextSize(15);
          this.color_background = global.color_nameDisplayed_background;
          this.color_header = global.color_nameDisplayed_background;
          this.color_stroke = color(1, 0);
          this.color_text = color(255);
          this.color_title = color(255);
          this.scrollbar.setButtonColors(color(170),
            adjust_color_brightness(global.color_nameDisplayed_background, 1.1f),
            adjust_color_brightness(global.color_nameDisplayed_background, 1.2f),
            adjust_color_brightness(global.color_nameDisplayed_background, 0.95f), color(0));
          this.scrollbar.button_upspace.setColors(color(1, 0), color(1, 0),
            color(1, 0), color(0), color(0));
          this.scrollbar.button_downspace.setColors(color(1, 0), color(1, 0),
            color(1, 0), color(0), color(0));
          this.useElapsedTime();
        }
      }

      Ability a = null;
      AbilityTextBox description;

      AbilityButton(float xi, float yi, float xf, float yf, Ability a, String letter) {
        super(xi, yi, xf, yf);
        this.message = letter;
        this.roundness = 10;
        this.setColors(color(0), color(0), color(0), color(0), color(0));
        this.setStroke(InventoryBar.this.color_ability_border, 2);
        this.use_time_elapsed = true;
        this.description = new AbilityTextBox(xi, yi, xi, yi);
        this.setAbility(a);
      }

       public void setAbility(Ability a) {
        this.a = a;
        if (a == null) {
          this.description.setTitleText("");
          this.description.setText("");
          this.description.setXLocation(this.xi, this.xi);
          this.description.setYLocation(this.yi, this.yi);
        }
        else {
          textSize(18);
          float description_width = max(Constants.hero_abilityDescriptionMinWidth, 4 + textWidth(a.displayName()));
          this.description.setXLocation(this.xi - 0.5f * description_width, this.xf + 0.5f * description_width);
          float description_height = textAscent() + textDescent() + 6;
          textSize(15);
          this.description.setTitleText(a.displayName());
          this.description.setText(a.description());
          description_height += (2 + this.description.text_lines.size()) * (textAscent() + textDescent() + this.description.text_leading);
          this.description.setYLocation(this.yi - description_height, this.yi);
        }
      }

      @Override public 
      void update(int timeElapsed) {
        super.update(timeElapsed);
        if (this.description.display) {
          this.description.update(timeElapsed);
        }
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        if (this.a != null) {
          imageMode(CORNERS);
          ellipseMode(CENTER);
          image(this.a.getImage(), this.xi, this.yi, this.xf, this.yf);
          if (InventoryBar.this.hero().silenced()) {
            image(global.images.getImage("statuses/silenced.png"), this.xi, this.yi, this.xf, this.yf);
          }
          if (this.a.timer_cooldown > 0) {
            fill(100, 100, 255, 140);
            noStroke();
            try {
              float angle = -HALF_PI + 2 * PI * this.a.timer_cooldown / this.a.timer_cooldown();
              arc(this.xCenter(), this.yCenter(), this.button_width(),
                this.button_height(), -HALF_PI, angle, PIE);
            } catch(Exception e) {}
            fill(255);
            textSize(24);
            textAlign(CENTER, CENTER);
            text(PApplet.parseInt(ceil(0.001f * this.a.timer_cooldown)), this.xCenter(), this.yCenter());
          }
          if (this.a.checkMana()) {
            fill(255);
            textSize(18);
            textAlign(LEFT, BOTTOM);
            text(PApplet.parseInt(ceil(this.a.manaCost())), this.xi + 2, this.yf - 1);
          }
          fill(255);
          textSize(18);
          textAlign(LEFT, TOP);
          text(this.message, this.xi + 2, this.yi + 1);
        }
      }

       public void hover() {
        if (this.a != null) {
          this.description.display = true;
          // show cast indicators
        }
      }
       public void dehover() {
        this.description.display = false;
      }
       public void click() {
        InventoryBar.this.tryCast(this.message);
      }
       public void release() {}
    }


    private float xi_border = 0;
    private float yi = 0;
    private float xf_border = 0;
    private float yf = 0;
    private float xi_bar = 0;
    private float xf_bar = 0;
    private float xi_picture = 0;
    private float yi_picture = 0;
    private float xf_picture = 0;
    private float yf_picture = 0;
    private float radius_picture = 0;
    private float ability_width = 0;
    private float slot_width = 0;
    private float status_width = 0;
    private float yi_status = 0;
    private float yi_slot = 0;

    private float last_mX = 0;
    private float last_mY = 0;
    private StatusEffectCode code_hovered = null;
    private StatusEffectTextBox code_description = new StatusEffectTextBox();
    private ArrayList<AbilityButton> ability_buttons = new ArrayList<AbilityButton>();
    private boolean portrait_hovered = false;
    private boolean portrait_clicked = false;
    private boolean hovered = false;

    protected int color_background = color(210, 153, 108);
    protected int color_ability_border = color(120, 70, 40);

    protected int equipped_index = 0;
    protected float equipped_text_size = 15;
    protected boolean unlocked_inventory_bar1 = false;
    protected boolean unlocked_inventory_bar2 = false;


    InventoryBar() {
      if (global.profile == null) {
        this.setHeight(Constants.hero_defaultInventoryBarHeight);
      }
      else {
        this.setHeight(global.profile.options.inventory_bar_size);
      }
    }


     public Hero hero() {
      return Hero.this;
    }


     public void setHeight(float new_height) {
      this.yf = height - Constants.hero_inventoryBarGap;
      this.yi = this.yf - new_height;
      textSize(this.equipped_text_size);
      float new_height_buttons = new_height - textAscent() - textDescent() - 2;
      this.yi_slot = this.yi + textAscent() + textDescent() + 2;
      this.xf_bar = 0.5f * (width + 3.333f * new_height_buttons) + 2;
      this.xi_bar = 0.5f * (width - 3.333f * new_height_buttons) - 2;
      this.xf_border = this.xi_bar - Constants.hero_inventoryBarGap;
      this.xi_border = this.xf_border - new_height;
      float border_thickness = 0.04166667f * new_height;
      this.xi_picture = this.xi_border + border_thickness;
      this.yi_picture = this.yi + border_thickness;
      this.xf_picture = this.xf_border - border_thickness;
      this.yf_picture = this.yf - border_thickness;
      this.radius_picture = 0.5f * (this.xf_picture - this.xi_picture);
      this.ability_width = 0.2f * (this.xf_bar - this.xi_bar - 4) - 4;
      this.slot_width = 0.1f * (this.xf_bar - this.xi_bar - 4) - 2;
      this.status_width = 0.08f * (this.xf_bar - this.xi_bar);
      this.yi_status = this.yi - 2 - this.status_width;
      float xi = this.xi_bar + 4;
      float yi = this.yf - this.ability_width - 4;
      this.ability_buttons.clear();
      for (int i = 0; i < Constants.hero_abilityNumber; i++, xi += this.ability_width + 4) {
        String letter = "";
        switch(i) {
          case 0:
            letter = "P";
            break;
          case 1:
            letter = "A";
            break;
          case 2:
            letter = "S";
            break;
          case 3:
            letter = "D";
            break;
          case 4:
            letter = "F";
            break;
        }
        Ability a = null;
        try {
          a = Hero.this.abilities.get(i);
        } catch(Exception e) {}
        this.ability_buttons.add(new AbilityButton(xi, yi, xi + this.ability_width,
          yi + this.ability_width, a, letter));
      }
    }

     public void tryCast(String letter) {
      switch(letter) {
        case "A":
          Hero.this.bufferCast(1);
          break;
        case "S":
          Hero.this.bufferCast(2);
          break;
        case "D":
          Hero.this.bufferCast(3);
          break;
        case "F":
          Hero.this.bufferCast(4);
          break;
      }
    }

     public PImage getBorderImage() {
      String imageName = "icons/border";
      switch(Hero.this.code) {
        case BEN:
          imageName += "_gray.png";
          break;
        case DAN:
          imageName += "_brown.png";
          break;
        default:
          imageName += "_template.png";
          break;
      }
      return global.images.getImage(imageName);
    }

     public PImage getHeroImage() {
      String imageName = "units/";
      switch(Hero.this.code) {
        case BEN:
          if (global.profile.ben_has_eyes) {
            imageName += "ben_circle.png";
          }
          else {
            imageName += "ben_circle_noeyes.png";
          }
          break;
        case DAN:
          imageName += "dan_circle.png";
          break;
        default:
          imageName += "default.png";
          break;
      }
      return global.images.getImage(imageName);
    }


     public void setEquippedIndex(int new_index) {
      int max_equipped_index = 0;
      if (this.unlocked_inventory_bar2) {
        max_equipped_index = 9;
      }
      else if (this.unlocked_inventory_bar1) {
        max_equipped_index = 4;
      }
      else {
        return;
      }
      if (new_index < 0 || new_index > max_equipped_index) {
        return;
      }
      int last_index = this.equipped_index;
      this.equipped_index = new_index;
      if (new_index == last_index) {
        return;
      }
      Item curr_item = new Item(Hero.this.weapon());
      if (curr_item.remove) {
        curr_item = null;
      }
      if (new_index > last_index) {
        for (int i = last_index; i < new_index; i++) {
          Item next_item = new Item(Hero.this.inventory.slots.get(i).item);
          Hero.this.inventory.slots.get(i).item = curr_item;
          curr_item = next_item;
        }
        Hero.this.pickup(curr_item);
      }
      else {
        for (int i = last_index-1; i >= new_index; i--) {
          Item next_item = new Item(Hero.this.inventory.slots.get(i).item);
          Hero.this.inventory.slots.get(i).item = curr_item;
          curr_item = next_item;
        }
        Hero.this.pickup(curr_item);
      }
    }


     public void update(int timeElapsed) {
      if (global.profile.options.inventory_bar_hidden) {
        return;
      }
      rectMode(CORNERS);
      noStroke();
      fill(this.color_background);
      rect(this.xi_bar, this.yi, this.xf_bar, this.yf, 12);
      imageMode(CORNERS);
      image(this.getBorderImage(), this.xi_border, this.yi, this.xf_border, this.yf);
      if (this.portrait_clicked) {
        tint(150);
      }
      image(this.getHeroImage(), this.xi_picture, this.yi_picture, this.xf_picture, this.yf_picture);
      if (this.portrait_clicked) {
        g.removeCache(this.getHeroImage());
        noTint();
      }
      float xi = this.xi_bar;
      this.code_hovered = null;
      for (Map.Entry<StatusEffectCode, StatusEffect> entry : Hero.this.statuses.entrySet()) {
        imageMode(CORNER);
        rectMode(CORNER);
        ellipseMode(CENTER);
        fill(255, 150);
        stroke(0);
        strokeWeight(1);
        rect(xi, this.yi_status, this.status_width, this.status_width);
        image(global.images.getImage(entry.getKey().getImageString()), xi, this.yi_status, this.status_width, this.status_width);
        if (!entry.getValue().permanent) {
          fill(100, 100, 255, 140);
          noStroke();
          try {
            float angle = -HALF_PI + 2 * PI * entry.getValue().timer_gone / entry.getValue().timer_gone_start;
            arc(xi + 0.5f * this.status_width, this.yi_status + 0.5f * this.status_width,
              this.status_width, this.status_width, -HALF_PI, angle, PIE);
          } catch(Exception e) {}
        }
        if (this.last_mX > xi && this.last_mX < xi + this.status_width &&
          this.last_mY > this.yi_status && this.last_mY < this.yi_status + this.status_width) {
          if (!this.code_description.display) {
            noStroke();
            fill(global.color_nameDisplayed_background);
            textSize(14);
            rectMode(CORNER);
            float rect_height = textAscent() + textDescent() + 2;
            float rect_width = textWidth(entry.getKey().code_name()) + 2;
            rect(this.last_mX - rect_width - 1, this.last_mY - rect_height - 1, rect_width, rect_height);
            fill(255);
            textAlign(LEFT, TOP);
            text(entry.getKey().code_name(), this.last_mX - rect_width - 1, this.last_mY - rect_height - 1);
          }
          this.code_hovered = entry.getKey();
        }
        xi += this.status_width + 2;
      }
      textAlign(LEFT, TOP);
      textSize(this.equipped_text_size);
      fill(0);
      if (Hero.this.weapon() == null) {
        text("-- no weapon --", this.xi_bar + 1, this.yi + 1);
      }
      else {
        text(Hero.this.weapon().display_name(), this.xi_bar + 1, this.yi + 1);
      }
      translate(this.xi_bar + 3, this.yi_slot);
      float translate_x = this.equipped_index * (this.slot_width + 2);
      translate(translate_x, 0);
      Hero.this.inventory.gear_inventory.updateSlot(timeElapsed, 3, Hero.this.weapon(), false, this.slot_width, !Hero.this.inventory.viewing);
      translate(-translate_x, 0);
      int inventory_slots_to_show = 0;
      if (this.unlocked_inventory_bar2) {
        inventory_slots_to_show = 9;
      }
      else if (this.unlocked_inventory_bar1) {
        inventory_slots_to_show = 4;
      }
      for (int i = 0; i < inventory_slots_to_show; i++) {
        int translate_index = i;
        if (translate_index >= this.equipped_index) {
          translate_index++;
        }
        translate_x = translate_index * (this.slot_width + 2);
        translate(translate_x, 0);
        Hero.this.inventory.slots.get(i).setWidth(this.slot_width);
        Hero.this.inventory.slots.get(i).update(timeElapsed, !Hero.this.inventory.viewing);
        Hero.this.inventory.slots.get(i).setWidth(Hero.this.inventory.button_size);
        translate(-translate_x, 0);
      }
      translate(-this.xi_bar - 3, -this.yi_slot);
      for (AbilityButton ability : this.ability_buttons) {
        ability.update(timeElapsed);
      }
      if (this.code_description.display) {
        this.code_description.update(timeElapsed);
      }
    }

     public void mouseMove(float mX, float mY) {
      this.hovered = false;
      if (global.profile.options.inventory_bar_hidden) {
        return;
      }
      this.last_mX = mX;
      this.last_mY = mY;
      for (AbilityButton ability : this.ability_buttons) {
        ability.mouseMove(mX, mY);
      }
      if (this.code_description.display) {
        this.code_description.mouseMove(mX, mY);
      }
      if (this.code_hovered != null || this.code_description.hovered) {
        this.hovered = true;
      }
      if ((this.code_hovered == null || !this.code_hovered.code_name().equals(
        this.code_description.text_title)) && !this.code_description.hovered) {
        this.code_description.display = false;
      }
      float portrait_distance_x = mX - this.xi_picture - this.radius_picture;
      float portrait_distance_y = mY - this.yi_picture - this.radius_picture;
      if (sqrt(portrait_distance_x * portrait_distance_x + portrait_distance_y * portrait_distance_y) < this.radius_picture) {
        this.portrait_hovered = true;
        this.hovered = true;
      }
      else {
        this.portrait_hovered = false;
      }
      if (!this.hovered) {
        if (mX > this.xi_bar && mY > this.yi && mX < this.xf_bar && mY < this.yf) {
          this.hovered = true;
        }
      }
      if (!Hero.this.inventory.viewing) {
        mX -= this.xi_bar + 3;
        mY -= this.yi_slot;
        float translate_x = this.equipped_index * (this.slot_width + 2);
        Hero.this.inventory.gear_inventory.slots.get(3).setWidth(this.slot_width);
        Hero.this.inventory.gear_inventory.slots.get(3).mouseMove(mX - translate_x, mY);
        Hero.this.inventory.gear_inventory.slots.get(3).setWidth(Hero.this.inventory.gear_inventory.button_size);
        int inventory_slots_to_show = 0;
        if (this.unlocked_inventory_bar2) {
          inventory_slots_to_show = 9;
        }
        else if (this.unlocked_inventory_bar1) {
          inventory_slots_to_show = 4;
        }
        for (int i = 0; i < inventory_slots_to_show; i++) {
          int translate_index = i;
          if (translate_index >= this.equipped_index) {
            translate_index++;
          }
          translate_x = translate_index * (this.slot_width + 2);
          Hero.this.inventory.slots.get(i).setWidth(this.slot_width);
          Hero.this.inventory.slots.get(i).mouseMove(mX - translate_x, mY);
          Hero.this.inventory.slots.get(i).setWidth(Hero.this.inventory.button_size);
        }
      }
    }

     public void mousePress() {
      if (global.profile.options.inventory_bar_hidden) {
        return;
      }
      for (AbilityButton ability : this.ability_buttons) {
        ability.mousePress();
      }
      if (this.code_description.display) {
        this.code_description.mousePress();
      }
      if (this.code_hovered == null && !this.code_description.hovered) {
        this.code_description.display = false;
      }
      else if (code_hovered != null) {
        this.code_description.display = true;
        this.code_description.setLocation(this.last_mX - Constants.hero_statusDescription_width,
          this.last_mY - Constants.hero_statusDescription_height, this.last_mX, this.last_mY);
        this.code_description.setTitleText(this.code_hovered.code_name());
        this.code_description.setText(this.code_hovered.description());
      }
      if (this.portrait_hovered) {
        this.portrait_clicked = true;
      }
      if (!Hero.this.inventory.viewing) {
        boolean use_item = false;
        if (this.unlocked_inventory_bar2 && global.holding_ctrl) {
          use_item = true;
        }
        if (Hero.this.inventory.gear_inventory.slots.get(3).button.hovered) {
          Hero.this.inventory.gear_inventory.slots.get(3).button.hovered = false;
          if (use_item) {
            Hero.this.useItem(null);
          }
        }
        int inventory_slots_to_show = 0;
        if (this.unlocked_inventory_bar2) {
          inventory_slots_to_show = 9;
        }
        else if (this.unlocked_inventory_bar1) {
          inventory_slots_to_show = 4;
        }
        for (int i = 0; i < inventory_slots_to_show; i++) {
          int translate_index = i;
          if (translate_index >= this.equipped_index) {
            translate_index++;
          }
          if (Hero.this.inventory.slots.get(i).button.hovered) {
            Hero.this.inventory.slots.get(i).button.hovered = false;
            if (use_item) {
              Hero.this.useItem(null, new InventoryKey(InventoryLocation.INVENTORY, i));
            }
            else {
              this.setEquippedIndex(translate_index);
            }
          }
        }
      }
    }

     public void mouseRelease(float mX, float mY) {
      if (global.profile.options.inventory_bar_hidden) {
        return;
      }
      for (AbilityButton ability : this.ability_buttons) {
        ability.mouseRelease(mX, mY);
      }
      if (this.code_description.display) {
        this.code_description.mouseRelease(mX, mY);
      }
      if (this.portrait_hovered && this.portrait_clicked) {
        Hero.this.openLeftPanelMenu(LeftPanelMenuPage.PLAYER);
      }
      this.portrait_clicked = false;
    }

     public void scroll(int amount) {
      if (global.profile.options.inventory_bar_hidden) {
        return;
      }
      if (this.code_description.display) {
        this.code_description.scroll(amount);
        return;
      }
      if (!Hero.this.inventory.viewing && !global.holding_ctrl) {
        int max_equipped_index = 0;
        if (this.unlocked_inventory_bar2) {
          max_equipped_index = 9;
        }
        else if (this.unlocked_inventory_bar1) {
          max_equipped_index = 4;
        }
        else {
          return;
        }
        int new_equipped_index = this.equipped_index + amount;
        while (new_equipped_index > max_equipped_index) {
          new_equipped_index -= max_equipped_index + 1;
        }
        while (new_equipped_index < 0) {
          new_equipped_index += max_equipped_index + 1;
        }
        this.setEquippedIndex(new_equipped_index);
      }
    }
  }


  abstract class LeftPanelMenu {
    LeftPanelMenu() {
    }
     public Hero hero() {
      return Hero.this;
    }
     public abstract void deposited(float money);
     public abstract void drawPanel(int timeElapsed, float panel_width);
     public abstract void mouseMove(float mX, float mY);
     public abstract void mousePress();
     public abstract void mouseRelease(float mX, float mY);
  }


  class PlayerLeftPanelMenu extends LeftPanelMenu {
    abstract class LeftPanelButton extends RectangleButton {
      protected float hover_timer = Constants.hero_leftPanelButtonHoverTimer;
      protected boolean show_hover_message = false;
      protected String hover_message = "";
      protected float hover_message_text_size = 15;
      protected float hover_message_offset = 0;

      LeftPanelButton(float xi, float yi, float xf, float yf) {
        super(xi, yi, xf, yf);
        textSize(15);
        this.hover_message_offset = 0.5f * (textAscent() + textDescent()) + 2;
      }

      @Override public 
      void update(int millis) {
        int time_elapsed = millis - this.lastUpdateTime;
        super.update(millis);
        if (this.show_hover_message) {
          fill(global.color_nameDisplayed_background);
          stroke(1, 0);
          rectMode(CENTER);
          textSize(this.hover_message_text_size);
          float xCenter = mouseX + 0.5f * textWidth(this.hover_message + 2);
          float yCenter = mouseY - this.hover_message_offset;
          rect(xCenter, yCenter, textWidth(this.hover_message + 2), textAscent() + textDescent());
          textAlign(CENTER, CENTER);
          fill(255);
          text(this.hover_message, xCenter, yCenter);
          stroke(0);
        }
        else if (this.hovered) {
          this.hover_timer -= time_elapsed;
          if (this.hover_timer < 0) {
            this.show_hover_message = true;
          }
        }
      }

       public void hover() {
        this.updateHoverMessage();
      }
       public void dehover() {
        this.hover_timer = Constants.hero_leftPanelButtonHoverTimer;
        this.show_hover_message = false;
      }
       public void click() {
        this.updateHoverMessage();
        this.show_hover_message = true;
      }
       public void release() {
        this.updateHoverMessage();
      }

       public abstract void updateHoverMessage();
    }


    class MoneyButton extends LeftPanelButton {
      protected int blinks = 0;
      protected float blink_timer = 300;
      protected boolean blinking = false;

      MoneyButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(100, 100), color(1, 0), color(1, 0), color(1, 0), color(0));
        this.text_size = 18;
        this.show_message = true;
        this.roundness = 2;
        this.noStroke();
      }

      @Override public 
      void update(int millis) {
        int time_elapsed = millis - this.lastUpdateTime;
        if (this.blinks > 0) {
          this.blink_timer -= time_elapsed;
          if (this.blink_timer < 0) {
            this.blink_timer += 300;
            this.blinking = !this.blinking;
            if (this.blinking) {
              this.blinks--;
            }
          }
          if (this.blinking) {
            this.color_text = color(1, 0);
          }
          else {
            this.color_text = color(255, 255, 0);
          }
        }
        else {
          this.color_text = color(0);
        }
        super.update(millis);
      }

      @Override public 
      void writeText() {
        if (this.show_message) {
          fill(this.color_text);
          textAlign(LEFT, CENTER);
          textSize(this.text_size);
          if (this.adjust_for_text_descent) {
            text(this.message, this.xi + 2, this.yCenter() - textDescent());
          }
          else {
            text(this.message, this.xi + 2, this.yCenter());
          }
        }
      }

       public void updateHoverMessage() {
        this.hover_message = "$" + round(PlayerLeftPanelMenu.this.hero().money * 100.0f) / 100.0f + " deposited";
      }
    }


    class LevelTokensButton extends LeftPanelButton {
      LevelTokensButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(170), color(1, 0), color(150, 100), color(150, 200), color(0));
        this.text_size = 18;
        this.show_message = true;
        this.roundness = 2;
        this.noStroke();
      }

      @Override public 
      void writeText() {
        if (this.show_message) {
          fill(this.color_text);
          textAlign(LEFT, CENTER);
          textSize(this.text_size);
          if (this.adjust_for_text_descent) {
            text(this.message, this.xi + 2, this.yCenter() - textDescent());
          }
          else {
            text(this.message, this.xi + 2, this.yCenter());
          }
        }
      }

      @Override public 
      void release() {
        if (!this.hovered) {
          return;
        }
        if (PlayerLeftPanelMenu.this.hero().heroTree.curr_viewing) {
          PlayerLeftPanelMenu.this.hero().heroTree.curr_viewing = false;
        }
        else {
          PlayerLeftPanelMenu.this.hero().heroTree.curr_viewing = true;
          PlayerLeftPanelMenu.this.hero().heroTree.set_screen_location = true;
        }
        super.release();
      }

       public void updateHoverMessage() {
        if (PlayerLeftPanelMenu.this.hero().heroTree.curr_viewing) {
          this.hover_message = "Close Level Tree";
        }
        else {
          this.hover_message = "Open Level Tree";
        }
      }
    }


    class LevelButton extends LeftPanelButton {
      LevelButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(100, 100), color(1, 0), color(1, 0), color(1, 0), color(0));
        this.text_size = 18;
        this.show_message = true;
        this.noStroke();
      }

       public void updateHoverMessage() {
        this.hover_message = "Tier: " + PlayerLeftPanelMenu.this.hero().tier();
      }
    }


    class ExperienceButton extends LeftPanelButton {
      ExperienceButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(1, 0));
        this.setStroke(color(0), 1.5f);
        this.roundness = 0;
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        rectMode(CORNER);
        float xp_ratio = PlayerLeftPanelMenu.this.hero().experience /
          PlayerLeftPanelMenu.this.hero().experience_next_level;
        fill(0);
        rect(this.xi, this.yi, xp_ratio * this.button_width(), Constants.hero_leftPanelBarHeight);
      }

       public void updateHoverMessage() {
        this.hover_message = "Experience: " + PlayerLeftPanelMenu.this.hero().experience +
          "/" + PlayerLeftPanelMenu.this.hero().experience_next_level;
      }
    }


    class HealthButton extends LeftPanelButton {
      protected float bar_xi = 0;
      protected float bar_yi = 0;
      protected float bar_yf = 0;

      HealthButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(1, 0));
        this.noStroke();
        this.roundness = 0;
        this.bar_xi = 4 + 2 * Constants.hero_leftPanelBarHeight;
        this.bar_yi = yi + 0.25f * (yf - yi);
        this.bar_yf = yi + 0.75f * (yf - yi);
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        imageMode(CORNERS);
        image(global.images.getImage("icons/health.png"), this.xi, this.yi,
          this.bar_xi - 2, this.yf);
        rectMode(CORNERS);
        fill(0);
        noStroke();
        rect(this.bar_xi, this.bar_yi, this.xf, this.bar_yf);
        rectMode(CORNER);
        float health_ratio = min(1.0f, PlayerLeftPanelMenu.this.hero().curr_health
          / PlayerLeftPanelMenu.this.hero().health());
        fill(0, 255, 0);
        rect(this.bar_xi, this.bar_yi, health_ratio * (this.xf - this.bar_xi),
          Constants.hero_leftPanelBarHeight);
      }

       public void updateHoverMessage() {
        this.hover_message = "Health: " + PApplet.parseInt(round(PlayerLeftPanelMenu.this.
          hero().curr_health * 10.0f)) / 10.0f + "/" + PApplet.parseInt(round(PlayerLeftPanelMenu.
          this.hero().health() * 10.0f)) / 10.0f;
      }
    }


    class ManaButton extends LeftPanelButton {
      protected float bar_xi = 0;
      protected float bar_yi = 0;
      protected float bar_yf = 0;

      ManaButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(1, 0));
        this.noStroke();
        this.roundness = 0;
        this.bar_xi = 4 + 2 * Constants.hero_leftPanelBarHeight;
        this.bar_yi = yi + 0.25f * (yf - yi);
        this.bar_yf = yi + 0.75f * (yf - yi);
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        imageMode(CORNERS);
        image(global.images.getImage("icons/mana_" + PlayerLeftPanelMenu.
          this.hero().manaFileName() + ".png"), this.xi, this.yi, this.bar_xi - 2, this.yf);
        rectMode(CORNERS);
        fill(0);
        noStroke();
        rect(this.bar_xi, this.bar_yi, this.xf, this.bar_yf);
        rectMode(CORNER);
        float mana_ratio = min(1, PlayerLeftPanelMenu.this.hero().currMana() /
          PlayerLeftPanelMenu.this.hero().mana());
        fill(255, 255, 0);
        rect(this.bar_xi, this.bar_yi, mana_ratio * (this.xf - this.bar_xi),
          Constants.hero_leftPanelBarHeight);
      }

       public void updateHoverMessage() {
        this.hover_message = PlayerLeftPanelMenu.this.hero().manaDisplayName() +
          ": " + PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().currMana())) + "/" +
          PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().mana()));
      }
    }


    class HungerButton extends LeftPanelButton {
      protected float bar_xi = 0;
      protected float bar_yi = 0;
      protected float bar_yf = 0;

      HungerButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(1, 0));
        this.noStroke();
        this.roundness = 0;
        this.bar_xi = 4 + 2 * Constants.hero_leftPanelBarHeight;
        this.bar_yi = yi + 0.25f * (yf - yi);
        this.bar_yf = yi + 0.75f * (yf - yi);
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        imageMode(CORNERS);
        image(global.images.getImage("icons/hunger.png"), this.xi, this.yi,
          this.bar_xi - 2, this.yf);
        rectMode(CORNERS);
        fill(0);
        noStroke();
        rect(this.bar_xi, this.bar_yi, this.xf, this.bar_yf);
        rectMode(CORNER);
        float hunger_ratio = PlayerLeftPanelMenu.this.hero().hunger / PApplet.parseFloat(Constants.hero_maxHunger);
        fill(140, 70, 20);
        rect(this.bar_xi, this.bar_yi, hunger_ratio * (this.xf - this.bar_xi), Constants.hero_leftPanelBarHeight);
      }

       public void updateHoverMessage() {
        this.hover_message = "Hunger: " + PApplet.parseInt(100 * PlayerLeftPanelMenu.this.hero().hunger /
          PApplet.parseFloat(Constants.hero_maxHunger)) + "%";
      }
    }


    class ThirstButton extends LeftPanelButton {
      protected float bar_xi = 0;
      protected float bar_yi = 0;
      protected float bar_yf = 0;

      ThirstButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(1, 0));
        this.noStroke();
        this.roundness = 0;
        this.bar_xi = 4 + 2 * Constants.hero_leftPanelBarHeight;
        this.bar_yi = yi + 0.25f * (yf - yi);
        this.bar_yf = yi + 0.75f * (yf - yi);
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        imageMode(CORNERS);
        image(global.images.getImage("icons/thirst.png"), this.xi, this.yi,
          this.bar_xi - 2, this.yf);
        rectMode(CORNERS);
        fill(0);
        noStroke();
        rect(this.bar_xi, this.bar_yi, this.xf, this.bar_yf);
        rectMode(CORNER);
        float thirst_ratio = PlayerLeftPanelMenu.this.hero().thirst / PApplet.parseFloat(Constants.hero_maxThirst);
        fill(0, 0, 255);
        rect(this.bar_xi, this.bar_yi, thirst_ratio * (this.xf - this.bar_xi), Constants.hero_leftPanelBarHeight);
      }

       public void updateHoverMessage() {
        this.hover_message = "Thirst: " + PApplet.parseInt(100 * PlayerLeftPanelMenu.this.hero().thirst /
          PApplet.parseFloat(Constants.hero_maxThirst)) + "%";
      }
    }


    abstract class StatButton extends LeftPanelButton {
      protected float icon_xf = 0;
      protected String icon_name = "";

      StatButton(float yi, float yf) {
        super(0, yi, 0, yf);
        this.show_message = true;
        this.updateMessage();
        this.setColors(color(1, 0), color(1, 0), color(1, 0), color(1, 0), color(0));
        this.noStroke();
        this.roundness = 0;
        this.icon_xf = yf - yi;
        this.text_size = 17;
      }

      @Override public 
      void setXLocation(float xi, float xf) {
        super.setXLocation(xi, xf);
        this.icon_xf = this.xi + this.yf - this.yi;
      }

      @Override public 
      void writeText() {
        if (this.show_message) {
          fill(this.color_text);
          textAlign(LEFT, CENTER);
          textSize(this.text_size);
          if (this.adjust_for_text_descent) {
            text(this.message, this.icon_xf + 6, this.yCenter() - textDescent());
          }
          else {
            text(this.message, this.icon_xf + 6, this.yCenter());
          }
        }
      }

      @Override public 
      void drawButton() {
        this.updateMessage();
        super.drawButton();
        imageMode(CORNERS);
        image(global.images.getImage("icons/" + this.icon_name + ".png"),
          this.xi, this.yi, this.icon_xf, this.yf);
      }

       public abstract void updateMessage();
    }


    class AttackButton extends StatButton {
      AttackButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_attack";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().attack())));
      }

       public void updateHoverMessage() {
        this.hover_message = "Attack: " + PlayerLeftPanelMenu.this.hero().attack();
      }
    }


    class MagicButton extends StatButton {
      MagicButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_magic";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().magic())));
      }

       public void updateHoverMessage() {
        this.hover_message = "Magic: " + PlayerLeftPanelMenu.this.hero().magic();
      }
    }


    class DefenseButton extends StatButton {
      DefenseButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_defense";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().defense())));
      }

       public void updateHoverMessage() {
        this.hover_message = "Defense: " + PlayerLeftPanelMenu.this.hero().defense();
      }
    }


    class ResistanceButton extends StatButton {
      ResistanceButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_resistance";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().resistance())));
      }

       public void updateHoverMessage() {
        this.hover_message = "Resistance: " + PlayerLeftPanelMenu.this.hero().resistance();
      }
    }


    class PiercingButton extends StatButton {
      PiercingButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_piercing";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(100.0f * PlayerLeftPanelMenu.this.hero().piercing()))) + "%";
      }

       public void updateHoverMessage() {
        this.hover_message = "Piercing: " + PApplet.parseInt(round(1000.0f * PlayerLeftPanelMenu.this.hero().piercing())) / 10.0f + "%";
      }
    }


    class PenetrationButton extends StatButton {
      PenetrationButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_penetration";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(100.0f * PlayerLeftPanelMenu.this.hero().penetration()))) + "%";
      }

       public void updateHoverMessage() {
        this.hover_message = "Penetration: " + PApplet.parseInt(round(1000.0f * PlayerLeftPanelMenu.this.hero().penetration())) / 10.0f + "%";
      }
    }


    class RangeButton extends StatButton {
      RangeButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_range";
      }

       public void updateMessage() {
        this.message = Float.toString(PApplet.parseInt(round(10 * PlayerLeftPanelMenu.this.hero().attackRange())) / 10.0f);
      }

       public void updateHoverMessage() {
        this.hover_message = "Attack Range: " + PlayerLeftPanelMenu.this.hero().attackRange() + " m";
      }
    }


    class SpeedButton extends StatButton {
      SpeedButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_speed";
      }

       public void updateMessage() {
        this.message = Float.toString(PApplet.parseInt(round(10 * PlayerLeftPanelMenu.this.hero().speed())) / 10.0f);
      }

       public void updateHoverMessage() {
        this.hover_message = "Speed: " + PlayerLeftPanelMenu.this.hero().speed() + " m/s";
      }
    }


    class TenacityButton extends StatButton {
      TenacityButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_tenacity";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(100 * PlayerLeftPanelMenu.this.hero().tenacity()))) + "%";
      }

       public void updateHoverMessage() {
        this.hover_message = "Tenacity: " + PApplet.parseInt(round(1000.0f * PlayerLeftPanelMenu.this.hero().tenacity())) / 10.0f + "%";
      }
    }


    class AgilityButton extends StatButton {
      AgilityButton(float yi, float yf) {
        super(yi, yf);
        this.icon_name = "stat_agility";
      }

       public void updateMessage() {
        this.message = Integer.toString(PApplet.parseInt(round(PlayerLeftPanelMenu.this.hero().agility())));
      }

       public void updateHoverMessage() {
        this.hover_message = "Agility: " + PlayerLeftPanelMenu.this.hero().agility();
      }
    }


    protected float yi;
    protected float image_yi;
    protected float image_size;
    protected MoneyButton money;
    protected LevelTokensButton level_tokens;
    protected LevelButton level;
    protected ExperienceButton experience;
    protected HealthButton health;
    protected ManaButton mana;
    protected HungerButton hunger;
    protected ThirstButton thirst;
    protected AttackButton attack;
    protected MagicButton magic;
    protected DefenseButton defense;
    protected ResistanceButton resistance;
    protected PiercingButton piercing;
    protected PenetrationButton penetration;
    protected RangeButton range;
    protected SpeedButton speed;
    protected TenacityButton tenacity;
    protected AgilityButton agility;

    PlayerLeftPanelMenu() {
      this.yi = 0.5f * height + Constants.map_selectedObjectPanelGap;
      textSize(Constants.map_selectedObjectTitleTextSize);
      float currY = this.yi + textAscent() + textDescent() + Constants.map_selectedObjectPanelGap;
      this.image_yi = currY;
      this.image_size = 0.1f * height;
      textSize(18);
      float button_text_height = textAscent() + textDescent() + Constants.map_selectedObjectPanelGap;
      this.money = new MoneyButton(currY + this.image_size - 2 * button_text_height - Constants.map_selectedObjectPanelGap,
        currY + this.image_size - button_text_height - Constants.map_selectedObjectPanelGap);
      this.level_tokens = new LevelTokensButton(currY + this.image_size - button_text_height,
        currY + this.image_size - Constants.map_selectedObjectPanelGap);
      currY += image_size + Constants.map_selectedObjectPanelGap;
      this.level = new LevelButton(currY, currY + textAscent() + textDescent() + Constants.map_selectedObjectPanelGap);
      currY += textAscent() + textDescent() + Constants.map_selectedObjectPanelGap + 2;
      this.experience = new ExperienceButton(currY, currY + Constants.hero_leftPanelBarHeight);
      currY += 2 * Constants.hero_leftPanelBarHeight + Constants.map_selectedObjectPanelGap;
      this.health = new HealthButton(currY, currY + 2 * Constants.hero_leftPanelBarHeight);
      currY += 2 * Constants.hero_leftPanelBarHeight + Constants.map_selectedObjectPanelGap;
      this.mana = new ManaButton(currY, currY + 2 * Constants.hero_leftPanelBarHeight);
      currY += 2 * Constants.hero_leftPanelBarHeight + Constants.map_selectedObjectPanelGap;
      this.hunger = new HungerButton(currY, currY + 2 * Constants.hero_leftPanelBarHeight);
      currY += 2 * Constants.hero_leftPanelBarHeight + Constants.map_selectedObjectPanelGap;
      this.thirst = new ThirstButton(currY, currY + 2 * Constants.hero_leftPanelBarHeight);
      currY += 2 * Constants.hero_leftPanelBarHeight + 4 * Constants.map_selectedObjectPanelGap;
      // Stats
      float stat_button_height = max(0, 0.2f * (height - currY - 6 * Constants.map_selectedObjectPanelGap));
      this.attack = new AttackButton(currY, currY + stat_button_height);
      this.magic = new MagicButton(currY, currY + stat_button_height);
      currY += stat_button_height + Constants.map_selectedObjectPanelGap;
      this.defense = new DefenseButton(currY, currY + stat_button_height);
      this.resistance = new ResistanceButton(currY, currY + stat_button_height);
      currY += stat_button_height + Constants.map_selectedObjectPanelGap;
      this.piercing = new PiercingButton(currY, currY + stat_button_height);
      this.penetration = new PenetrationButton(currY, currY + stat_button_height);
      currY += stat_button_height + Constants.map_selectedObjectPanelGap;
      this.range = new RangeButton(currY, currY + stat_button_height);
      this.speed = new SpeedButton(currY, currY + stat_button_height);
      currY += stat_button_height + Constants.map_selectedObjectPanelGap;
      this.tenacity = new TenacityButton(currY, currY + stat_button_height);
      this.agility = new AgilityButton(currY, currY + stat_button_height);
      currY += stat_button_height + Constants.map_selectedObjectPanelGap;
    }

     public void deposited(float money) {
      this.money.blinks = max(this.money.blinks, min(PApplet.parseInt(ceil(money * 0.4f)), 5));
      this.money.blink_timer = 300;
      this.money.blinking = false;
    }

     public void drawPanel(int millis, float panel_width) {
      float half_panel_width = 0.5f * panel_width;
      // name
      fill(255);
      textSize(Constants.map_selectedObjectTitleTextSize);
      textAlign(CENTER, TOP);
      text(Hero.this.display_name(), half_panel_width, this.yi);
      // picture
      imageMode(CORNER);
      image(Hero.this.getImage(), 1, this.image_yi, this.image_size, this.image_size);
      // money
      this.money.message = "Money: $" + round(100.0f * Hero.this.money) / 100.0f;
      this.money.setXLocation(half_panel_width + 2, panel_width - 2);
      this.money.update(millis);
      // level tokens
      this.level_tokens.message = "Tokens: " + Hero.this.level_tokens;
      this.level_tokens.setXLocation(half_panel_width + 2, panel_width - 2);
      this.level_tokens.update(millis);
      // level
      this.level.message = "Level " + Hero.this.level;
      this.level.setXLocation(2, panel_width - 2);
      this.level.update(millis);
      // experience
      this.experience.setXLocation(2, panel_width - 2);
      this.experience.update(millis);
      // health
      this.health.setXLocation(2, panel_width - 2);
      this.health.update(millis);
      // mana
      this.mana.setXLocation(2, panel_width - 2);
      this.mana.update(millis);
      // hunger
      this.hunger.setXLocation(2, panel_width - 2);
      this.hunger.update(millis);
      // thirst
      this.thirst.setXLocation(2, panel_width - 2);
      this.thirst.update(millis);
      // stats
      this.magic.setXLocation(half_panel_width + 2, panel_width - 2);
      this.magic.update(millis);
      this.attack.setXLocation(2, half_panel_width);
      this.attack.update(millis);
      this.resistance.setXLocation(half_panel_width + 2, panel_width - 2);
      this.resistance.update(millis);
      this.defense.setXLocation(2, 0.5f * panel_width);
      this.defense.update(millis);
      this.penetration.setXLocation(half_panel_width + 2, panel_width - 2);
      this.penetration.update(millis);
      this.piercing.setXLocation(2, 0.5f * panel_width);
      this.piercing.update(millis);
      this.speed.setXLocation(half_panel_width + 2, panel_width - 2);
      this.speed.update(millis);
      this.range.setXLocation(2, 0.5f * panel_width);
      this.range.update(millis);
      this.agility.setXLocation(half_panel_width + 2, panel_width - 2);
      this.agility.update(millis);
      this.tenacity.setXLocation(2, 0.5f * panel_width);
      this.tenacity.update(millis);
    }

     public void mouseMove(float mX, float mY) {
      this.money.mouseMove(mX, mY);
      this.level_tokens.mouseMove(mX, mY);
      this.level.mouseMove(mX, mY);
      this.experience.mouseMove(mX, mY);
      this.health.mouseMove(mX, mY);
      this.mana.mouseMove(mX, mY);
      this.hunger.mouseMove(mX, mY);
      this.thirst.mouseMove(mX, mY);
      this.attack.mouseMove(mX, mY);
      this.magic.mouseMove(mX, mY);
      this.defense.mouseMove(mX, mY);
      this.resistance.mouseMove(mX, mY);
      this.piercing.mouseMove(mX, mY);
      this.penetration.mouseMove(mX, mY);
      this.speed.mouseMove(mX, mY);
      this.range.mouseMove(mX, mY);
      this.tenacity.mouseMove(mX, mY);
      this.agility.mouseMove(mX, mY);
    }

     public void mousePress() {
      this.money.mousePress();
      this.level_tokens.mousePress();
      this.level.mousePress();
      this.experience.mousePress();
      this.health.mousePress();
      this.mana.mousePress();
      this.hunger.mousePress();
      this.thirst.mousePress();
      this.attack.mousePress();
      this.magic.mousePress();
      this.defense.mousePress();
      this.resistance.mousePress();
      this.piercing.mousePress();
      this.penetration.mousePress();
      this.speed.mousePress();
      this.range.mousePress();
      this.tenacity.mousePress();
      this.agility.mousePress();
    }

     public void mouseRelease(float mX, float mY) {
      this.money.mouseRelease(mX, mY);
      this.level_tokens.mouseRelease(mX, mY);
      this.level.mouseRelease(mX, mY);
      this.experience.mouseRelease(mX, mY);
      this.health.mouseRelease(mX, mY);
      this.mana.mouseRelease(mX, mY);
      this.hunger.mouseRelease(mX, mY);
      this.thirst.mouseRelease(mX, mY);
      this.attack.mouseRelease(mX, mY);
      this.magic.mouseRelease(mX, mY);
      this.defense.mouseRelease(mX, mY);
      this.resistance.mouseRelease(mX, mY);
      this.piercing.mouseRelease(mX, mY);
      this.penetration.mouseRelease(mX, mY);
      this.speed.mouseRelease(mX, mY);
      this.range.mouseRelease(mX, mY);
      this.tenacity.mouseRelease(mX, mY);
      this.agility.mouseRelease(mX, mY);
    }
  }


  class XpLeftPanelMenu extends LeftPanelMenu {
    XpLeftPanelMenu() {
    }

     public void deposited(float money) {}

     public void drawPanel(int timeElapsed, float panel_width) {
    }

     public void mouseMove(float mX, float mY) {
    }

     public void mousePress() {
    }

     public void mouseRelease(float mX, float mY) {
    }
  }



  class HeroTree {
    class HeroTreeButton extends RippleCircleButton {
      protected HeroTreeCode code;
      protected ArrayList<HeroTreeCode> dependencies = new ArrayList<HeroTreeCode>();
      protected boolean in_view = false;
      protected boolean visible = false;
      protected boolean unlocked = false;

      HeroTreeButton(HeroTreeCode code, float xc, float yc, float r) {
        super(xc, yc, r);
        this.code = code;
        Element e = HeroTree.this.hero().element;
        this.setColors(elementalColorLocked(e), elementalColorLocked(e), elementalColorLocked(e),
          elementalColorDark(e), elementalColorText(e));
        this.setStroke(elementalColorDark(e), 6);
        this.message = HeroTree.this.shortMessage(code);
        this.use_time_elapsed = true;
        this.text_size = 16;
        this.setDependencies();
        this.refreshColor();
      }

       public void setDependencies() {
        switch(this.code) {
          case INVENTORYI:
            break;
          case PASSIVEI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case AI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case SI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case DI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case FI:
            this.dependencies.add(HeroTreeCode.PASSIVEI);
            this.dependencies.add(HeroTreeCode.AI);
            this.dependencies.add(HeroTreeCode.SI);
            this.dependencies.add(HeroTreeCode.DI);
            break;
          case PASSIVEII:
            this.dependencies.add(HeroTreeCode.FI);
            break;
          case AII:
            this.dependencies.add(HeroTreeCode.FI);
            break;
          case SII:
            this.dependencies.add(HeroTreeCode.FI);
            break;
          case DII:
            this.dependencies.add(HeroTreeCode.FI);
            break;
          case FII:
            this.dependencies.add(HeroTreeCode.PASSIVEII);
            this.dependencies.add(HeroTreeCode.AII);
            this.dependencies.add(HeroTreeCode.SII);
            this.dependencies.add(HeroTreeCode.DII);
            break;
          case HEALTHI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case ATTACKI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case DEFENSEI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case PIERCINGI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case SPEEDI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case SIGHTI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case TENACITYI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case AGILITYI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case MAGICI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case RESISTANCEI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case PENETRATIONI:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case HEALTHII:
            this.dependencies.add(HeroTreeCode.HEALTHI);
            break;
          case ATTACKII:
            this.dependencies.add(HeroTreeCode.ATTACKI);
            break;
          case DEFENSEII:
            this.dependencies.add(HeroTreeCode.DEFENSEI);
            break;
          case PIERCINGII:
            this.dependencies.add(HeroTreeCode.PIERCINGI);
            break;
          case SPEEDII:
            this.dependencies.add(HeroTreeCode.SPEEDI);
            break;
          case SIGHTII:
            this.dependencies.add(HeroTreeCode.SIGHTI);
            break;
          case TENACITYII:
            this.dependencies.add(HeroTreeCode.TENACITYI);
            break;
          case AGILITYII:
            this.dependencies.add(HeroTreeCode.AGILITYI);
            break;
          case MAGICII:
            this.dependencies.add(HeroTreeCode.MAGICI);
            break;
          case RESISTANCEII:
            this.dependencies.add(HeroTreeCode.RESISTANCEI);
            break;
          case PENETRATIONII:
            this.dependencies.add(HeroTreeCode.PENETRATIONI);
            break;
          case HEALTHIII:
            this.dependencies.add(HeroTreeCode.HEALTHII);
            break;
          case OFFHAND:
            this.dependencies.add(HeroTreeCode.INVENTORYII);
            break;
          case BELTI:
            this.dependencies.add(HeroTreeCode.INVENTORYII);
            break;
          case BELTII:
            this.dependencies.add(HeroTreeCode.BELTI);
            break;
          case INVENTORYII:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case INVENTORY_BARI:
            this.dependencies.add(HeroTreeCode.INVENTORYII);
            break;
          case INVENTORY_BARII:
            this.dependencies.add(HeroTreeCode.INVENTORY_BARI);
            break;
          case CRAFTI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          case CRAFTII_ROW:
            this.dependencies.add(HeroTreeCode.CRAFTI);
            break;
          case CRAFTII_COL:
            this.dependencies.add(HeroTreeCode.CRAFTI);
            break;
          case CRAFTIII_ROW:
            this.dependencies.add(HeroTreeCode.CRAFTII_ROW);
            break;
          case CRAFTIII_COL:
            this.dependencies.add(HeroTreeCode.CRAFTII_COL);
            break;
          case FOLLOWERI:
            this.dependencies.add(HeroTreeCode.INVENTORYI);
            break;
          default:
            global.errorMessage("ERROR: HeroTreeCode " + this.code + " not recognized.");
            break;
        }
      }

       public void visible() {
        this.visible = true;
        this.show_message = true;
        Element e = HeroTree.this.hero().element;
        this.setColors(elementalColorLocked(e), elementalColorDark(e), elementalColor(e),
          elementalColorLight(e), elementalColorText(e));
        this.setStroke(elementalColorLight(e), 9);
        this.refreshColor();
      }

       public void unlock() {
        this.unlocked = true;
        Element e = HeroTree.this.hero().element;
        this.setColors(elementalColorLocked(e), elementalColorLight(e), elementalColorLight(e),
          elementalColorLight(e), elementalColorText(e));
        this.setStroke(elementalColorLight(e), 12);
        this.refreshColor();
      }

      @Override public 
      int fillColor() {
        if (this.disabled) {
          return this.color_disabled;
        }
        else if (this.clicked && this.visible) {
          return this.color_click;
        }
        else if (this.hovered) {
          return this.color_hover;
        }
        else {
          return this.color_default;
        }
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        fill(1, 0);
        stroke(this.color_stroke);
        strokeWeight(this.stroke_weight);
        ellipseMode(CORNERS);
        ellipse(this.xi, this.yi, this.xf, this.yf);
      }

      @Override public 
      void hover() {
        super.hover();
        if (this.unlocked) {
          this.message = "Unlocked";
        }
        else {
          this.message = HeroTree.this.longMessage(code);
        }
      }

      @Override public 
      void dehover() {
        super.hover();
        this.message = HeroTree.this.shortMessage(code);
      }

      @Override public 
      void click() {
        if (this.unlocked || this.visible) {
          super.click();
        }
      }

      @Override public 
      void release() {
        super.release();
        if (this.hovered) {
          if (this.unlocked || this.visible) {
            HeroTree.this.showDetails(this.code);
          }
        }
      }
    }


    class NodeDetailsForm extends Form {
      protected boolean canceled = false;
      protected HeroTreeButton button;
      protected float shadow_distance = 10;
      protected PImage img;

      NodeDetailsForm(HeroTreeButton button) {
        super(0.5f * (width - Constants.hero_treeForm_width), 0.5f * (height - Constants.hero_treeForm_height),
          0.5f * (width + Constants.hero_treeForm_width), 0.5f * (height + Constants.hero_treeForm_height));
        this.img = getCurrImage();
        this.cancelButton();
        this.draggable = false;
        this.button = button;
        this.setTitleText(HeroTree.this.upgradeName(button.code));
        this.setTitleSize(20);
        this.setFieldCushion(0);
        Element e = HeroTree.this.hero().element;
        this.color_background = elementalColorLocked(e);
        this.color_header = elementalColorLight(e);
        this.color_stroke = elementalColorDark(e);
        this.color_title = elementalColorText(e);

        this.addField(new SpacerFormField(20));
        TextBoxFormField textbox = new TextBoxFormField(HeroTree.this.upgradeDescription(button.code), 200);
        textbox.textbox.scrollbar.setButtonColors(elementalColorLocked(e), elementalColor(e),
          elementalColorLight(e), elementalColorDark(e), elementalColorText(e));
        textbox.textbox.useElapsedTime();
        this.addField(textbox);
        this.addField(new SpacerFormField(20));
        boolean has_enough = HeroTree.this.hero().level_tokens >= HeroTree.this.upgradeCost(button.code);
        SubmitCancelFormField buttons = new SubmitCancelFormField(HeroTree.this.hero().
          level_tokens + "/" + HeroTree.this.upgradeCost(button.code), "Cancel");
        buttons.button1.setColors(elementalColorLocked(e), elementalColor(e),
          elementalColorLight(e), elementalColorDark(e), elementalColorText(e));
        buttons.button2.setColors(elementalColorLocked(e), elementalColor(e),
          elementalColorLight(e), elementalColorDark(e), elementalColorText(e));
        if (has_enough && button.visible && !button.unlocked) {
        }
        else {
          buttons.button1.disabled = true;
          if (button.unlocked) {
            buttons.button1.message = "Unlocked";
          }
        }
        this.addField(buttons);
      }

      @Override public 
      void update(int millis) {
        rectMode(CORNERS);
        fill(0);
        imageMode(CORNER);
        image(this.img, 0, 0);
        fill(0, 150);
        stroke(0, 1);
        translate(shadow_distance, shadow_distance);
        rect(this.xi, this.yi, this.xf, this.yf);
        translate(-shadow_distance, -shadow_distance);
        super.update(millis);
      }

       public void cancel() {
        this.canceled = true;
      }

       public void submit() {
        HeroTree.this.unlockNode(this.button.code);
        this.canceled = true;
      }

       public void buttonPress(int index) {}
    }


    class BackButton extends RectangleButton {
      BackButton() {
        super(0, 0, 0, 0);
        this.setColors(color(170), color(1, 0), color(40, 120), color(20, 150), color(255));
        this.noStroke();
        this.show_message = true;
        this.message = "Back";
        this.use_time_elapsed = true;
        this.text_size = 18;
        this.adjust_for_text_descent = true;
      }

       public void hover() {}
       public void dehover() {}
       public void click() {}
       public void release() {
        if (this.hovered) {
          HeroTree.this.curr_viewing = false;
        }
      }
    }


    protected float xi = 0;
    protected float yi = 0;
    protected float xf = 0;
    protected float yf = 0;
    protected float xCenter = 0.5f * width;
    protected float yCenter = 0.5f * height;

    protected float tree_xi = 0;
    protected float tree_yi = 0;
    protected float tree_xf = 0;
    protected float tree_yf = 0;
    protected float translateX = 0;
    protected float translateY = 0;

    protected float viewX = 0;
    protected float viewY = 0;
    protected float zoom = 1.0f;
    protected float inverse_zoom = 1.0f;
    protected boolean curr_viewing = false;
    protected boolean set_screen_location = false;

    protected boolean dragging = false;
    protected float last_mX = mouseX;
    protected float last_mY = mouseY;
    protected boolean hovered = false;

    protected float lowestX = 0;
    protected float lowestY = 0;
    protected float highestX = 0;
    protected float highestY = 0;

    protected int color_background = color(50);
    protected int color_connectorStroke_locked = elementalColorDark(Hero.this.element);
    protected int color_connectorStroke_visible = elementalColor(Hero.this.element);
    protected int color_connectorStroke_unlocked = elementalColorLight(Hero.this.element);
    protected int color_connectorFill_locked = elementalColorLocked(Hero.this.element);
    protected int color_connectorFill_visible = elementalColorDark(Hero.this.element);
    protected int color_connectorFill_unlocked = elementalColor(Hero.this.element);

    protected HashMap<HeroTreeCode, HeroTreeButton> nodes = new HashMap<HeroTreeCode, HeroTreeButton>();
    protected NodeDetailsForm node_details = null;
    protected BackButton back_button = new BackButton();


    HeroTree() {
      this.initializeNodes();
      this.updateDependencies();
      this.setView(0, 0);
    }


     public void showDetails(HeroTreeCode code) {
      if (!this.nodes.containsKey(code)) {
        return;
      }
      this.node_details = new NodeDetailsForm(this.nodes.get(code));
    }

     public void unlockNode(HeroTreeCode code) {
      this.unlockNode(code, false, true);
    }
     public void unlockNode(HeroTreeCode code, boolean force_unlock, boolean first_time) {
      if (!this.nodes.containsKey(code)) {
        return;
      }
      if (this.nodes.get(code).unlocked || (!this.nodes.get(code).visible && !force_unlock)) {
        return;
      }
      if (!force_unlock && Hero.this.level_tokens < this.upgradeCost(code)) {
        return;
      }
      if (!force_unlock) {
        Hero.this.level_tokens -= this.upgradeCost(code);
      }
      this.nodes.get(code).unlock();
      this.updateDependencies();
      Hero.this.upgrade(code);
      if (first_time) {
        global.sounds.trigger_player("player/unlock_node");
        switch(code) {
          case HEALTHI:
            Hero.this.curr_health += Constants.upgrade_healthI;
            break;
          case HEALTHII:
            Hero.this.curr_health += Constants.upgrade_healthII;
            break;
          case HEALTHIII:
            Hero.this.curr_health += Constants.upgrade_healthIII;
            break;
        }
      }
    }

     public ArrayList<HeroTreeCode> unlockedCodes() {
      ArrayList<HeroTreeCode> codes = new ArrayList<HeroTreeCode>();
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().unlocked) {
          codes.add(entry.getKey());
        }
      }
      return codes;
    }

     public void updateDependencies() {
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().visible) {
          continue;
        }
        boolean visible = true;
        for (HeroTreeCode code : entry.getValue().dependencies) {
          if (!this.nodes.get(code).unlocked) {
            visible = false;
            break;
          }
        }
        if (visible) {
          entry.getValue().visible();
        }
      }
    }


     public void setLocation(float xi, float yi, float xf, float yf) {
      this.xi = xi;
      this.yi = yi;
      this.xf = xf;
      this.yf = yf;
      this.setView(this.viewX, this.viewY);
      this.back_button.setLocation(xf - 120, yf - 70, xf - 30, yf - 30);
    }

     public void moveView(float moveX, float moveY) {
      this.setView(this.viewX + moveX, this.viewY + moveY);
    }
     public void setView(float viewX, float viewY) {
      if (viewX < this.lowestX) {
        viewX = this.lowestX;
      }
      else if (viewX > this.highestX) {
        viewX = this.highestX;
      }
      if (viewY < this.lowestY) {
        viewY = this.lowestY;
      }
      else if (viewY > this.highestY) {
        viewY = this.highestY;
      }
      this.viewX = viewX;
      this.viewY = viewY;
      this.tree_xi = viewX - this.inverse_zoom * (this.xCenter - this.xi);
      this.tree_yi = viewY - this.inverse_zoom * (this.yCenter - this.yi);
      this.tree_xf = viewX - this.inverse_zoom * (this.xCenter - this.xf);
      this.tree_yf = viewY - this.inverse_zoom * (this.yCenter - this.yf);
      this.translateX = this.xCenter - this.zoom * viewX;
      this.translateY = this.yCenter - this.zoom * viewY;
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().xi > this.tree_xi && entry.getValue().yi > this.tree_yi &&
          entry.getValue().xf < this.tree_xf && entry.getValue().yf < this.tree_yf) {
          entry.getValue().in_view = true;
        }
        else {
          entry.getValue().in_view = false;
        }
      }
    }


     public void update(int timeElapsed) {
      if (this.node_details != null) {
        this.node_details.update(timeElapsed);
        if (this.node_details.canceled) {
          this.node_details = null;
        }
        return;
      }
      rectMode(CORNERS);
      fill(this.color_background);
      noStroke();
      rect(this.xi, this.yi, this.xf, this.yf);
      translate(this.translateX, this.translateY);
      scale(this.zoom, this.zoom);
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        rectMode(CORNERS);
        translate(entry.getValue().xCenter(), entry.getValue().yCenter());
        for (HeroTreeCode dependency : entry.getValue().dependencies) {
          HeroTreeButton dependent = this.nodes.get(dependency);
          if (!entry.getValue().in_view && !dependent.in_view) {
            continue;
          }
          strokeWeight(2);
          float connector_width = 6;
          if (entry.getValue().unlocked) {
            fill(this.color_connectorFill_unlocked);
            stroke(this.color_connectorStroke_unlocked);
            strokeWeight(4);
            connector_width = 10;
          }
          else if (entry.getValue().visible || dependent.unlocked) {
            fill(this.color_connectorFill_visible);
            stroke(this.color_connectorStroke_visible);
            strokeWeight(3);
            connector_width = 8;
          }
          else {
            fill(this.color_connectorFill_locked);
            stroke(this.color_connectorStroke_locked);
          }
          float xDif = dependent.xCenter() - entry.getValue().xCenter();
          float yDif = dependent.yCenter() - entry.getValue().yCenter();
          float rotation = (float)Math.atan2(yDif, xDif);
          float distance = sqrt(xDif * xDif + yDif * yDif);
          rotate(rotation);
          rect(0, -connector_width, distance, connector_width);
          rotate(-rotation);
        }
        translate(-entry.getValue().xCenter(), -entry.getValue().yCenter());
      }
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().update(timeElapsed);
        }
      }
      scale(this.inverse_zoom, this.inverse_zoom);
      translate(-this.translateX, -this.translateY);
      this.back_button.update(timeElapsed);
      fill(255);
      textAlign(CENTER, TOP);
      textSize(30);
      text("Hero Tree", this.xCenter, this.yi + 5);
      text("Level Tokens: " + Hero.this.level_tokens, this.xCenter, textAscent() + textDescent() + 10);
    }

     public void mouseMove(float mX, float mY) {
      if (this.node_details != null) {
        this.node_details.mouseMove(mX, mY);
        return;
      }
      this.back_button.mouseMove(mX, mY);
      if (this.dragging) {
        this.moveView(this.inverse_zoom * (this.last_mX - mX), this.inverse_zoom * (this.last_mY - mY));
      }
      this.last_mX = mX;
      this.last_mY = mY;
      if (mX > this.xi && mY > this.yi && mX < this.xf && mY < this.yf) {
        this.hovered = true;
      }
      else {
        this.hovered = false;
      }
      mX -= this.translateX;
      mY -= this.translateY;
      mX *= this.inverse_zoom;
      mY *= this.inverse_zoom;
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mouseMove(mX, mY);
        }
      }
    }

     public void mousePress() {
      if (this.node_details != null) {
        this.node_details.mousePress();
        return;
      }
      this.back_button.mousePress();
      boolean button_hovered = false;
      if (this.back_button.hovered) {
        button_hovered = true;
      }
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mousePress();
          if (entry.getValue().hovered) {
            button_hovered = true;
          }
        }
      }
      if (!button_hovered && mouseButton == LEFT && this.hovered) {
        this.dragging = true;
      }
    }

     public void mouseRelease(float mX, float mY) {
      if (this.node_details != null) {
        this.node_details.mouseRelease(mX, mY);
        return;
      }
      this.back_button.mouseRelease(mX, mY);
      if (mouseButton == LEFT) {
        this.dragging = false;
      }
      mX -= this.translateX;
      mY -= this.translateY;
      for (Map.Entry<HeroTreeCode, HeroTreeButton> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mouseRelease(mX, mY);
        }
      }
    }

     public void scroll(int amount) {
      if (this.node_details != null) {
        this.node_details.scroll(amount);
        return;
      }
      this.zoom -= amount * 0.01f;
      if (this.zoom < 0.5f) {
        this.zoom = 0.5f;
      }
      if (this.zoom > 1.5f) {
        this.zoom = 1.5f;
      }
      this.inverse_zoom = 1 / this.zoom;
      this.setView(this.viewX, this.viewY);
    }

     public void keyPress() {
      if (this.node_details != null) {
        this.node_details.keyPress();
        return;
      }
      if (key == ESC) {
        this.curr_viewing = false;
      }
    }

     public void keyRelease() {
      if (this.node_details != null) {
        this.node_details.keyRelease();
        return;
      }
    }


     public void initializeNodes() {
      for (HeroTreeCode code : HeroTreeCode.VALUES) {
        float xc = 0;
        float yc = 0;
        float r = Constants.hero_treeButtonDefaultRadius;
        switch(code) {
          case INVENTORYI:
            r = Constants.hero_treeButtonCenterRadius;
            break;
          case PASSIVEI:
            xc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = -3.45f * Constants.hero_treeButtonDefaultRadius;
            break;
          case AI:
            xc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = -1.15f * Constants.hero_treeButtonDefaultRadius;
            break;
          case SI:
            xc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 1.15f * Constants.hero_treeButtonDefaultRadius;
            break;
          case DI:
            xc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 3.45f * Constants.hero_treeButtonDefaultRadius;
            break;
          case FI:
            xc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 0;
            break;
          case PASSIVEII:
            xc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = -3.45f * Constants.hero_treeButtonDefaultRadius;
            break;
          case AII:
            xc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = -1.15f * Constants.hero_treeButtonDefaultRadius;
            break;
          case SII:
            xc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 1.15f * Constants.hero_treeButtonDefaultRadius;
            break;
          case DII:
            xc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 3.45f * Constants.hero_treeButtonDefaultRadius;
            break;
          case FII:
            xc = 15 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            yc = 0;
            break;
          case HEALTHI:
            xc = 0;
            yc = -3 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case ATTACKI:
            xc = 2.3f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case DEFENSEI:
            xc = 4.6f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case PIERCINGI:
            xc = 6.9f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case SPEEDI:
            xc = 9.2f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case SIGHTI:
            xc = 11.5f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case TENACITYI:
            xc = 13.8f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case AGILITYI:
            xc = 16.1f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case MAGICI:
            xc = -2.3f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case RESISTANCEI:
            xc = -4.6f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case PENETRATIONI:
            xc = -6.9f * Constants.hero_treeButtonDefaultRadius;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case HEALTHII:
            xc = 0;
            yc = -8 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case ATTACKII:
            xc = 2.3f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case DEFENSEII:
            xc = 4.6f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case PIERCINGII:
            xc = 6.9f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case SPEEDII:
            xc = 9.2f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case SIGHTII:
            xc = 11.5f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case TENACITYII:
            xc = 13.8f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case AGILITYII:
            xc = 16.1f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case MAGICII:
            xc = -2.3f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case RESISTANCEII:
            xc = -4.6f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case PENETRATIONII:
            xc = -6.9f * Constants.hero_treeButtonDefaultRadius;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case HEALTHIII:
            xc = 0;
            yc = -13 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            break;
          case OFFHAND:
            xc = 1.15f * Constants.hero_treeButtonDefaultRadius;
            yc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case BELTI:
            xc = 3.45f * Constants.hero_treeButtonDefaultRadius;
            yc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case BELTII:
            xc = 3.45f * Constants.hero_treeButtonDefaultRadius;
            yc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case INVENTORYII:
            xc = 0;
            yc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case INVENTORY_BARI:
            xc = -1.15f * Constants.hero_treeButtonDefaultRadius;
            yc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case INVENTORY_BARII:
            xc = -1.15f * Constants.hero_treeButtonDefaultRadius;
            yc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case CRAFTI:
            xc = -3 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            yc = 3 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case CRAFTII_ROW:
            xc = -3.45f * Constants.hero_treeButtonDefaultRadius;
            yc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case CRAFTII_COL:
            xc = -5.75f * Constants.hero_treeButtonDefaultRadius;
            yc = 7 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case CRAFTIII_ROW:
            xc = -3.45f * Constants.hero_treeButtonDefaultRadius;
            yc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case CRAFTIII_COL:
            xc = -5.75f * Constants.hero_treeButtonDefaultRadius;
            yc = 11 * Constants.hero_treeButtonDefaultRadius + Constants.hero_treeButtonCenterRadius;
            break;
          case FOLLOWERI:
            xc = -3 * Constants.hero_treeButtonDefaultRadius - Constants.hero_treeButtonCenterRadius;
            yc = 0;
            break;
          default:
            global.errorMessage("ERROR: No place to put " + code + " in HeroTree.");
            break;
        }
        this.nodes.put(code, new HeroTreeButton(code, xc, yc, r));
        if (xc - r < this.lowestX) {
          this.lowestX = xc - r;
        }
        else if (xc + r > this.highestX) {
          this.highestX = xc + r;
        }
        if (yc - r < this.lowestY) {
          this.lowestY = yc - r;
        }
        else if (yc + r > this.highestY) {
          this.highestY = yc + r;
        }
      }
    }

     public Hero hero() {
      return Hero.this;
    }

     public String upgradeName(HeroTreeCode code) {
      switch(code) {
        case INVENTORYI:
          return "Unlock Inventory";
        case PASSIVEI:
          return (new Ability(Hero.this.abilityId(0))).displayName();
        case AI:
          return (new Ability(Hero.this.abilityId(1))).displayName();
        case SI:
          return (new Ability(Hero.this.abilityId(2))).displayName();
        case DI:
          return (new Ability(Hero.this.abilityId(3))).displayName();
        case FI:
          return (new Ability(Hero.this.abilityId(4))).displayName();
        case PASSIVEII:
          return (new Ability(Hero.this.upgradedAbilityId(0))).displayName();
        case AII:
          return (new Ability(Hero.this.upgradedAbilityId(1))).displayName();
        case SII:
          return (new Ability(Hero.this.upgradedAbilityId(2))).displayName();
        case DII:
          return (new Ability(Hero.this.upgradedAbilityId(3))).displayName();
        case FII:
          return (new Ability(Hero.this.upgradedAbilityId(4))).displayName();
        case HEALTHI:
          return "Increase Health";
        case ATTACKI:
          return "Increase Attack";
        case DEFENSEI:
          return "Increase Defense";
        case PIERCINGI:
          return "Increase Piercing";
        case SPEEDI:
          return "Increase Speed";
        case SIGHTI:
          return "Increase Sight";
        case TENACITYI:
          return "Increase Tenacity";
        case AGILITYI:
          return "Increase Agility";
        case MAGICI:
          return "Increase Magic";
        case RESISTANCEI:
          return "Increase Resistance";
        case PENETRATIONI:
          return "Increase Penetration";
        case HEALTHII:
          return "Increase Health II";
        case ATTACKII:
          return "Increase Attack II";
        case DEFENSEII:
          return "Increase Defense II";
        case PIERCINGII:
          return "Increase Piercing II";
        case SPEEDII:
          return "Increase Speed II";
        case SIGHTII:
          return "Increase Sight II";
        case TENACITYII:
          return "Increase Tenacity II";
        case AGILITYII:
          return "Increase Agility II";
        case MAGICII:
          return "Increase Magic II";
        case RESISTANCEII:
          return "Increase Resistance II";
        case PENETRATIONII:
          return "Increase Penetration II";
        case HEALTHIII:
          return "Increase Health III";
        case OFFHAND:
          return "Offhand Gear Slot";
        case BELTI:
          return "Belt Gear Slot";
        case BELTII:
          return "Belt Gear Slot II";
        case INVENTORYII:
          return "Inventory Slots";
        case INVENTORY_BARI:
          return "Inventory Bar";
        case INVENTORY_BARII:
          return "Inventory Bar II";
        case CRAFTI:
          return "Unlock Self-Crafting";
        case CRAFTII_ROW:
          return "Unlock Self-Crafting Second Row";
        case CRAFTII_COL:
          return "Unlock Self-Crafting Second Column";
        case CRAFTIII_ROW:
          return "Unlock Self-Crafting Third Row";
        case CRAFTIII_COL:
          return "Unlock Self-Crafting Third Column";
        case FOLLOWERI:
          return "Unlock Follower";
        default:
          return "-- Error --";
      }
    }

     public String shortMessage(HeroTreeCode code) {
      switch(code) {
        case INVENTORYI:
          return "Inventory";
        case PASSIVEI:
          return "Passive";
        case AI:
          return "A";
        case SI:
          return "S";
        case DI:
          return "D";
        case FI:
          return "F";
        case PASSIVEII:
          return "Passive II";
        case AII:
          return "A II";
        case SII:
          return "S II";
        case DII:
          return "D II";
        case FII:
          return "F II";
        case HEALTHI:
          return "Health";
        case ATTACKI:
          return "Attack";
        case DEFENSEI:
          return "Defense";
        case PIERCINGI:
          return "Piercing";
        case SPEEDI:
          return "Speed";
        case SIGHTI:
          return "Sight";
        case TENACITYI:
          return "Tenacity";
        case AGILITYI:
          return "Agility";
        case MAGICI:
          return "Magic";
        case RESISTANCEI:
          return "Resistance";
        case PENETRATIONI:
          return "Penetration";
        case HEALTHII:
          return "Health II";
        case ATTACKII:
          return "Attack II";
        case DEFENSEII:
          return "Defense II";
        case PIERCINGII:
          return "Piercing II";
        case SPEEDII:
          return "Speed II";
        case SIGHTII:
          return "Sight II";
        case TENACITYII:
          return "Tenacity II";
        case AGILITYII:
          return "Agility II";
        case MAGICII:
          return "Magic II";
        case RESISTANCEII:
          return "Resistance II";
        case PENETRATIONII:
          return "Penetration II";
        case HEALTHIII:
          return "Health III";
        case OFFHAND:
          return "Offhand";
        case BELTI:
          return "Belt";
        case BELTII:
          return "Belt II";
        case INVENTORYII:
          return "Inventory II";
        case INVENTORY_BARI:
          return "Inventory Bar";
        case INVENTORY_BARII:
          return "Inventory Bar II";
        case CRAFTI:
          return "Self-Crafting";
        case CRAFTII_ROW:
          return "2nd Row";
        case CRAFTII_COL:
          return "2nd Column";
        case CRAFTIII_ROW:
          return "3rd Row";
        case CRAFTIII_COL:
          return "3rd Column";
        case FOLLOWERI:
          return "Follower";
        default:
          return "-- Error --";
      }
    }

     public String longMessage(HeroTreeCode code) {
      switch(code) {
        case INVENTORYI:
          return "Unlock\nInventory";
        case PASSIVEI:
          return "Unlock\nPassive\nAbility";
        case AI:
          return "Unlock\nA\nAbility";
        case SI:
          return "Unlock\nS\nAbility";
        case DI:
          return "Unlock\nD\nAbility";
        case FI:
          return "Unlock\nF\nAbility";
        case PASSIVEII:
          return "Upgrade\nPassive\nAbility";
        case AII:
          return "Upgrade\nA\nAbility";
        case SII:
          return "Upgrade\nS\nAbility";
        case DII:
          return "Upgrade\nD\nAbility";
        case FII:
          return "Upgrade\nF\nAbility";
        case HEALTHI:
          return "Increase\nHealth";
        case ATTACKI:
          return "Increase\nAttack";
        case DEFENSEI:
          return "Increase\nDefense";
        case PIERCINGI:
          return "Increase\nPiercing";
        case SPEEDI:
          return "Increase\nSpeed";
        case SIGHTI:
          return "Increase\nSight";
        case TENACITYI:
          return "Increase\nTenacity";
        case AGILITYI:
          return "Increase\nAgility";
        case MAGICI:
          return "Increase\nMagic";
        case RESISTANCEI:
          return "Increase\nResistance";
        case PENETRATIONI:
          return "Increase\nPenetration";
        case HEALTHII:
          return "Increase\nHealth";
        case ATTACKII:
          return "Increase\nAttack";
        case DEFENSEII:
          return "Increase\nDefense";
        case PIERCINGII:
          return "Increase\nPiercing";
        case SPEEDII:
          return "Increase\nSpeed";
        case SIGHTII:
          return "Increase\nSight";
        case TENACITYII:
          return "Increase\nTenacity";
        case AGILITYII:
          return "Increase\nAgility";
        case MAGICII:
          return "Increase\nMagic";
        case RESISTANCEII:
          return "Increase\nResistance";
        case PENETRATIONII:
          return "Increase\nPenetration";
        case HEALTHIII:
          return "Increase\nHealth";
        case OFFHAND:
          return "Unlock\nOffhand\nGear Slot";
        case BELTI:
          return "Unlock\nBelt\nGear Slot";
        case BELTII:
          return "Unlock\nBelt II\nGear Slot";
        case INVENTORYII:
          return "More\nInventory\nSlots";
        case INVENTORY_BARI:
          return "Unlock\nInventory Bar";
        case INVENTORY_BARII:
          return "Upgrade\nInventory Bar";
        case CRAFTI:
          return "Unlock\nSelf-Crafting";
        case CRAFTII_ROW:
          return "Unlock\n2nd Row\nSelf-Crafting";
        case CRAFTII_COL:
          return "Unlock\n2nd Column\nSelf-Crafting";
        case CRAFTIII_ROW:
          return "Unlock\n3rd Row\nSelf-Crafting";
        case CRAFTIII_COL:
          return "Unlock\n3rd Column\nSelf-Crafting";
        case FOLLOWERI:
          return "Unlock\nFollower";
        default:
          return "-- Error --";
      }
    }

     public String upgradeDescription(HeroTreeCode code) {
      switch(code) {
        case INVENTORYI:
          return "Unlock your inventory and increase your available slots by " +
            Constants.upgrade_inventoryI + ".";
        case PASSIVEI:
          return (new Ability(Hero.this.abilityId(0))).description();
        case AI:
          return (new Ability(Hero.this.abilityId(1))).description();
        case SI:
          return (new Ability(Hero.this.abilityId(2))).description();
        case DI:
          return (new Ability(Hero.this.abilityId(3))).description();
        case FI:
          return (new Ability(Hero.this.abilityId(4))).description();
        case PASSIVEII:
          return (new Ability(Hero.this.upgradedAbilityId(0))).description();
        case AII:
          return (new Ability(Hero.this.upgradedAbilityId(1))).description();
        case SII:
          return (new Ability(Hero.this.upgradedAbilityId(2))).description();
        case DII:
          return (new Ability(Hero.this.upgradedAbilityId(3))).description();
        case FII:
          return (new Ability(Hero.this.upgradedAbilityId(4))).description();
        case HEALTHI:
          return "Increase your base health by " + Constants.upgrade_healthI + ".";
        case ATTACKI:
          return "Increase your base attack by " + Constants.upgrade_attackI + ".";
        case DEFENSEI:
          return "Increase your base defense by " + Constants.upgrade_defenseI + ".";
        case PIERCINGI:
          return "Increase your base piercing by " + (100.0f * Constants.upgrade_piercingI) + "%.";
        case SPEEDI:
          return "Increase your base speed by " + Constants.upgrade_speedI + ".";
        case SIGHTI:
          return "Increase your base sight by " + Constants.upgrade_sightI + ".";
        case TENACITYI:
          return "Increase your base tenacity by " + (100.0f * Constants.upgrade_tenacityI) + "%.";
        case AGILITYI:
          return "Increase your base agility by " + Constants.upgrade_agilityI + ".";
        case MAGICI:
          return "Increase your base magic by " + Constants.upgrade_magicI + ".";
        case RESISTANCEI:
          return "Increase your base resistance by " + Constants.upgrade_resistanceI + ".";
        case PENETRATIONI:
          return "Increase your base penetration by " + (100.0f * Constants.upgrade_penetrationI) + "%.";
        case HEALTHII:
          return "Increase your base health by " + Constants.upgrade_healthII + ".";
        case ATTACKII:
          return "Increase your base attack by " + Constants.upgrade_attackII + ".";
        case DEFENSEII:
          return "Increase your base defense by " + Constants.upgrade_defenseII + ".";
        case PIERCINGII:
          return "Increase your base piercing by " + (100.0f * Constants.upgrade_piercingII) + "%.";
        case SPEEDII:
          return "Increase your base speed by " + Constants.upgrade_speedII + ".";
        case SIGHTII:
          return "Increase your base sight by " + Constants.upgrade_sightII + ".";
        case TENACITYII:
          return "Increase your base tenacity by " + (100.0f * Constants.upgrade_tenacityII) + "%.";
        case AGILITYII:
          return "Increase your base agility by " + Constants.upgrade_agilityII + ".";
        case MAGICII:
          return "Increase your base magic by " + Constants.upgrade_magicII + ".";
        case RESISTANCEII:
          return "Increase your base resistance by " + Constants.upgrade_resistanceII + ".";
        case PENETRATIONII:
          return "Increase your base penetration by " + (100.0f * Constants.upgrade_penetrationII) + "%.";
        case HEALTHIII:
          return "Increase your base health by " + Constants.upgrade_healthIII + ".";
        case OFFHAND:
          return "Unlock the Offhand gear slot, allowing you to wield offhand items.";
        case BELTI:
          return "Unlock the first Belt gear slot, allowing you to wield belt items.";
        case BELTII:
          return "Unlock the second Belt gear slot, allowing you to wield two belt items.";
        case INVENTORYII:
          return "Increase your available inventory slots by " + Constants.upgrade_inventoryII + ".";
        case INVENTORY_BARI:
          return "Unlock the inventory bar, which allows you to view and quickly " +
            "switch between active items using the number keys or by scrolling.";
        case INVENTORY_BARII:
          return "Upgrade the inventory bar, doubling its capacity and allowing " +
            "direct use of items in it without first switching to them.";
        case CRAFTI:
          return "Unlock the ability to craft items directly in your inventory.\n" +
            "This upgrade will unlock a 1x1 grid to craft items.\nNote to use " +
            "a tool in self-crafting you must have it in your inventory or hand.";
        case CRAFTII_ROW:
          return "Unlock the second row in your self-crafting grid.\nIf you " +
            "have already unlocked the second column this will give you a full " +
            "2x2 grid, but if you have not you will have a 2x1 grid.";
        case CRAFTII_COL:
          return "Unlock the second column in your self-crafting grid.\nIf you " +
            "have already unlocked the second row this will give you a full " +
            "2x2 grid, but if you have not you will have a 1x2 grid.";
        case CRAFTIII_ROW:
          return "Unlock the third row in your self-crafting grid.";
        case CRAFTIII_COL:
          return "Unlock the third column in your self-crafting grid.";
        case FOLLOWERI:
          return "Unlock your follower (will be released in future update).";
        default:
          return "-- Error --";
      }
    }

     public int upgradeCost(HeroTreeCode code) {
      switch(code) {
        case INVENTORYI:
          return 1;
        case PASSIVEI:
          return 5;
        case AI:
          return 7;
        case SI:
          return 7;
        case DI:
          return 7;
        case FI:
          return 20;
        case PASSIVEII:
          return 100;
        case AII:
          return 100;
        case SII:
          return 100;
        case DII:
          return 100;
        case FII:
          return 300;
        case HEALTHI:
          return 2;
        case ATTACKI:
          return 3;
        case DEFENSEI:
          return 3;
        case PIERCINGI:
          return 3;
        case SPEEDI:
          return 3;
        case SIGHTI:
          return 3;
        case TENACITYI:
          return 3;
        case AGILITYI:
          return 3;
        case MAGICI:
          return 7;
        case RESISTANCEI:
          return 7;
        case PENETRATIONI:
          return 7;
        case HEALTHII:
          return 15;
        case ATTACKII:
          return 30;
        case DEFENSEII:
          return 30;
        case PIERCINGII:
          return 30;
        case SPEEDII:
          return 30;
        case SIGHTII:
          return 30;
        case TENACITYII:
          return 30;
        case AGILITYII:
          return 30;
        case MAGICII:
          return 35;
        case RESISTANCEII:
          return 35;
        case PENETRATIONII:
          return 35;
        case HEALTHIII:
          return 70;
        case OFFHAND:
          return 150;
        case BELTI:
          return 50;
        case BELTII:
          return 150;
        case INVENTORYII:
          return 12;
        case INVENTORY_BARI:
          return 40;
        case INVENTORY_BARII:
          return 75;
        case CRAFTI:
          return 5;
        case CRAFTII_ROW:
          return 20;
        case CRAFTII_COL:
          return 20;
        case CRAFTIII_ROW:
          return 85;
        case CRAFTIII_COL:
          return 85;
        case FOLLOWERI:
          return 25000;
        default:
          return 0;
      }
    }
  }



  protected HeroCode code;
  protected Location location = Location.ERROR;

  protected int level_tokens = 0;
  protected float experience = 0;
  protected int experience_next_level = 1;
  protected float money = 0;
  protected float curr_mana = 0;
  protected int hunger = 100;
  protected int thirst = 100;
  protected int hunger_timer = Constants.hero_hungerTimer;
  protected int thirst_timer = Constants.hero_thirstTimer;

  protected LeftPanelMenu left_panel_menu = new PlayerLeftPanelMenu();
  protected HeroInventory inventory = new HeroInventory();
  protected boolean can_view_inventory = false;
  protected InventoryBar inventory_bar = new InventoryBar();
  protected HeroTree heroTree = new HeroTree();

  protected Queue<String> messages = new LinkedList<String>();
  protected boolean in_control = true;

  Hero(int ID) {
    super(ID);
    this.code = HeroCode.heroCodeFromId(ID);
    this.addAbilities();
  }
  Hero(HeroCode code) {
    super(HeroCode.unit_id(code));
    this.code = code;
    this.addAbilities();
  }


   public boolean isUpgraded(HeroTreeCode code) {
    return this.heroTree.nodes.get(code).unlocked;
  }

   public void upgrade(HeroTreeCode code) {
    switch(code) {
      case INVENTORYI:
        this.can_view_inventory = true;
        this.inventory.addSlots(Constants.upgrade_inventoryI);
        break;
      case PASSIVEI:
        this.activateAbility(0);
        break;
      case AI:
        this.activateAbility(1);
        break;
      case SI:
        this.activateAbility(2);
        break;
      case DI:
        this.activateAbility(3);
        break;
      case FI:
        this.activateAbility(4);
        break;
      case PASSIVEII:
        this.upgradeAbility(0);
        break;
      case AII:
        this.upgradeAbility(1);
        break;
      case SII:
        this.upgradeAbility(2);
        break;
      case DII:
        this.upgradeAbility(3);
        break;
      case FII:
        this.upgradeAbility(4);
        break;
      case HEALTHI:
        this.base_health += Constants.upgrade_healthI;
        break;
      case ATTACKI:
        this.base_attack += Constants.upgrade_attackI;
        break;
      case DEFENSEI:
        this.base_defense += Constants.upgrade_defenseI;
        break;
      case PIERCINGI:
        this.base_piercing += Constants.upgrade_piercingI;
        break;
      case SPEEDI:
        this.base_speed += Constants.upgrade_speedI;
        break;
      case SIGHTI:
        this.base_sight += Constants.upgrade_sightI;
        break;
      case TENACITYI:
        this.base_tenacity += Constants.upgrade_tenacityI;
        break;
      case AGILITYI:
        this.base_agility += Constants.upgrade_agilityI;
        break;
      case MAGICI:
        this.base_magic += Constants.upgrade_magicI;
        break;
      case RESISTANCEI:
        this.base_resistance += Constants.upgrade_resistanceI;
        break;
      case PENETRATIONI:
        this.base_penetration += Constants.upgrade_penetrationI;
        break;
      case HEALTHII:
        this.base_health += Constants.upgrade_healthII;
        break;
      case ATTACKII:
        this.base_attack += Constants.upgrade_attackII;
        break;
      case DEFENSEII:
        this.base_defense += Constants.upgrade_defenseII;
        break;
      case PIERCINGII:
        this.base_piercing += Constants.upgrade_piercingII;
        break;
      case SPEEDII:
        this.base_speed += Constants.upgrade_speedII;
        break;
      case SIGHTII:
        this.base_sight += Constants.upgrade_sightII;
        break;
      case TENACITYII:
        this.base_tenacity += Constants.upgrade_tenacityII;
        break;
      case AGILITYII:
        this.base_agility += Constants.upgrade_agilityII;
        break;
      case MAGICII:
        this.base_magic += Constants.upgrade_magicII;
        break;
      case RESISTANCEII:
        this.base_resistance += Constants.upgrade_resistanceII;
        break;
      case PENETRATIONII:
        this.base_penetration += Constants.upgrade_penetrationII;
        break;
      case HEALTHIII:
        this.base_health += Constants.upgrade_healthIII;
        break;
      case OFFHAND:
        this.gearSlots("Offhand");
        break;
      case BELTI:
        this.gearSlots("Belt (left)");
        break;
      case BELTII:
        this.gearSlots("Belt (right)");
        break;
      case INVENTORYII:
        this.inventory.addSlots(Constants.upgrade_inventoryII);
        break;
      case INVENTORY_BARI:
        this.inventory.addSlots(Constants.upgrade_inventory_bar_slots);
        this.inventory_bar.unlocked_inventory_bar1 = true;
        break;
      case INVENTORY_BARII:
        this.inventory.addSlots(Constants.upgrade_inventory_bar_slots);
        this.inventory_bar.unlocked_inventory_bar2 = true;
        break;
      case CRAFTI:
        this.inventory.crafting_inventory.slots.get(7).deactivated = false;
        break;
      case CRAFTII_ROW:
        this.inventory.crafting_inventory.slots.get(13).deactivated = false;
        if (this.isUpgraded(HeroTreeCode.CRAFTII_COL)) {
          this.inventory.crafting_inventory.slots.get(14).deactivated = false;
        }
        if (this.isUpgraded(HeroTreeCode.CRAFTIII_COL)) {
          this.inventory.crafting_inventory.slots.get(12).deactivated = false;
        }
        break;
      case CRAFTII_COL:
        this.inventory.crafting_inventory.slots.get(8).deactivated = false;
        if (this.isUpgraded(HeroTreeCode.CRAFTII_ROW)) {
          this.inventory.crafting_inventory.slots.get(14).deactivated = false;
        }
        if (this.isUpgraded(HeroTreeCode.CRAFTIII_ROW)) {
          this.inventory.crafting_inventory.slots.get(2).deactivated = false;
        }
        break;
      case CRAFTIII_ROW:
        this.inventory.crafting_inventory.slots.get(1).deactivated = false;
        if (this.isUpgraded(HeroTreeCode.CRAFTII_COL)) {
          this.inventory.crafting_inventory.slots.get(2).deactivated = false;
        }
        if (this.isUpgraded(HeroTreeCode.CRAFTIII_COL)) {
          this.inventory.crafting_inventory.slots.get(0).deactivated = false;
        }
        break;
      case CRAFTIII_COL:
        this.inventory.crafting_inventory.slots.get(6).deactivated = false;
        if (this.isUpgraded(HeroTreeCode.CRAFTII_ROW)) {
          this.inventory.crafting_inventory.slots.get(12).deactivated = false;
        }
        if (this.isUpgraded(HeroTreeCode.CRAFTIII_ROW)) {
          this.inventory.crafting_inventory.slots.get(0).deactivated = false;
        }
        break;
      case FOLLOWERI:
        // follower
        break;
      default:
        global.errorMessage("ERROR: Trying to upgrade but code " + code + " not found.");
        break;
    }
  }


   public void openLeftPanelMenu(LeftPanelMenuPage menu) {
    switch(menu) {
      case PLAYER:
        this.left_panel_menu = new PlayerLeftPanelMenu();
        break;
      default:
        this.left_panel_menu = null;
        break;
    }
  }


   public void addAbilities() {
    this.addAbilities(false);
  }
   public void addAbilities(boolean powerful_version) {
    for (int i = 0; i < Constants.hero_abilityNumber; i++) {
      this.abilities.add(null);
    }
  }

   public int abilityId(int index) {
    return 2 * Constants.hero_abilityNumber * (this.ID - 1101) + index + 101;
  }
   public int upgradedAbilityId(int index) {
    return 2 * Constants.hero_abilityNumber * (this.ID - 1101) + index + 101 + 5;
  }

   public void activateAbility(int index) {
    if (index < 0 || index >= this.abilities.size()) {
      global.log("WARNING: Trying to activate ability index " + index + " but it doesn't exist.");
      return;
    }
    this.abilities.set(index, new Ability(this.abilityId(index)));
    this.inventory_bar.ability_buttons.get(index).setAbility(this.abilities.get(index));
  }

   public void upgradeAbility(int index) {
    if (index < 0 || index >= this.abilities.size()) {
      global.log("WARNING: Trying to upgrade ability index " + index + " but it doesn't exist.");
      return;
    }
    Ability a = this.abilities.get(index);
    if (a == null) {
      global.log("WARNING: Trying to upgrade a null ability.");
      return;
    }
    if (a.ID % 10 > 5) {
      global.log("WARNING: Trying to upgrade a tier II ability.");
      return;
    }
    a = new Ability(this.upgradedAbilityId(index));
  }


   public void refreshExperienceNextLevel() {
    if (this.level == Constants.hero_maxLevel) {
      this.experience_next_level = 0;
      return;
    }
    this.experience_next_level = PApplet.parseInt(ceil(pow(
      this.level * Constants.hero_experienceNextLevel_level *
      (1 + (this.tier() - 1) * Constants.hero_experienceNextLevel_tier),
    Constants.hero_experienceNextLevel_power) + 1));
  }


   public String manaDisplayName() {
    switch(this.code) {
      case BEN:
        return "% Rage";
      case DAN:
        return "Frog Energy";
      default:
        return "Error";
    }
  }

   public String manaFileName() {
    switch(this.code) {
      case BEN:
        return "rage";
      case DAN:
        return "frog";
      default:
        return "error";
    }
  }


  @Override public 
  float currMana() {
    return this.curr_mana;
  }

  @Override public 
  float mana() {
    float mana = 0;
    switch(this.code) {
      case BEN:
        return 100;
      case DAN:
        mana = 80;
        break;
      default:
        break;
    }
    return mana;
  }


   public int inventoryStartSlots() {
    return Constants.hero_inventoryDefaultStartSlots;
  }


   public void addExperience(float amount) {
    if (this.level == Constants.hero_maxLevel) {
      return;
    }
    this.experience += amount;
    while(this.experience > this.experience_next_level) {
      this.experience -= this.experience_next_level;
      this.levelup();
      if (this.level == Constants.hero_maxLevel) {
        break;
      }
    }
  }

   public void levelup() {
    this.setLevel(this.level + 1);
    this.refreshExperienceNextLevel();
    this.level_tokens += this.level;
    global.sounds.trigger_player("player/levelup");
  }

  @Override public 
  void setLevel(int level) {
    super.setLevel(level);
    this.base_health = 4 + 0.5f * Constants.hero_scaling_health * level * (level + 1.0f);
    this.base_attack = 1 + 0.5f * Constants.hero_scaling_attack * level * (level + 1.0f);
    this.base_magic = 0.5f * Constants.hero_scaling_magic * level * (level + 1.0f);
    this.base_defense = 0.5f * Constants.hero_scaling_defense * level * (level + 1.0f);
    this.base_resistance = 0.5f * Constants.hero_scaling_resistance * level * (level + 1.0f);
    this.base_piercing = 0.5f * Constants.hero_scaling_piercing * level * (level + 1.0f);
    this.base_penetration = 0.5f * Constants.hero_scaling_penetration * level * (level + 1.0f);
    switch(this.ID) {
      case 1102: // Dan Gray
        this.base_magic += 2.5f;
        break;
      default:
        break;
    }
  }


  @Override public 
  void killed(Unit u) {
    super.killed(u);
    this.addExperience(PApplet.parseInt(ceil(1 + pow(u.level, Constants.hero_killExponent))));
  }


   public boolean seesTime() {
    return true;
  }

   public void startUseItemTimer() {
    if (this.weapon() == null) {
      return;
    }
    if (this.curr_action == UnitAction.MOVING || this.curr_action == UnitAction.MOVING_AND_USING_ITEM) {
      this.curr_action = UnitAction.MOVING_AND_USING_ITEM;
    }
    else {
      this.curr_action = UnitAction.USING_ITEM;
    }
    this.timer_actionTime = this.weapon().useTime();
    switch(this.weapon().ID) {
      case 2101: // crumb
      case 2102: // unknown food
      case 2103: // unknown food
      case 2104: // unknown food
      case 2105: // unknown food
      case 2106: // pickle
      case 2107: // ketchup
      case 2108: // chicken wing
      case 2109: // steak
      case 2110: // poptart
      case 2111: // donut
      case 2112: // chocolate
      case 2113: // chips
      case 2114: // cheese
      case 2115: // peanuts
      case 2116: // raw chicken
      case 2117: // cooked chicken
      case 2118: // chicken egg
      case 2119: // rotten flesh
      case 2120: // apple
      case 2121: // banana
      case 2122: // pear
      case 2123: // bread
      case 2125: // hot pocket
      case 2142: // golden apple
        global.sounds.trigger_player("player/eat");
        break;
      case 2124: // hot pocket package
        global.sounds.trigger_player("player/open_package");
        break;
      case 2131: // water cup
      case 2132: // coke
      case 2133: // wine
      case 2134: // beer
      case 2141: // holy water
      case 2924: // Glass Bottle
      case 2925: // Water Bottle
      case 2926: // Canteen
      case 2927: // Water Jug
        global.sounds.trigger_player("player/drink");
        break;
      case 2301: // Slingshot
        global.sounds.trigger_player("items/slingshot_reload");
        break;
      case 2311: // Recurve Bow
        global.sounds.trigger_player("items/recurve_bow_reload");
        break;
      case 2312: // M1911
        global.sounds.trigger_player("items/m1911_reload");
        break;
      case 2321: // War Machine
        global.sounds.trigger_player("items/war_machine_reload");
        break;
      case 2322: // Five-Seven
      case 2343:
        global.sounds.trigger_player("items/five_seven_reload");
        break;
      case 2323: // Type25
      case 2344:
        global.sounds.trigger_player("items/type25_reload");
        break;
      case 2331: // Mustang and Sally
        global.sounds.trigger_player("items/mustang_and_sally_reload");
        break;
      case 2332: // FAL
      case 2352:
        global.sounds.trigger_player("items/FAL_reload");
        break;
      case 2333: // Python
      case 2354:
        global.sounds.trigger_player("items/python_reload");
      case 2341: // RPG
      case 2362:
        global.sounds.trigger_player("items/RPG_reload");
        break;
      case 2342: // Dystopic Demolisher
        global.sounds.trigger_player("items/dystopic_demolisher_reload");
        break;
      case 2345: // Executioner
      case 2364:
        global.sounds.trigger_player("items/executioner_reload");
        break;
      case 2351: // Galil
      case 2373:
        global.sounds.trigger_player("items/galil_reload");
        break;
      case 2353: // Ballistic Knife
      case 2374:
        global.sounds.trigger_player("items/ballistic_knife_reload");
        break;
      case 2355: // MTAR
      case 2375:
        global.sounds.trigger_player("items/MTAR_reload");
        break;
      case 2361: // RPD
      case 2381: // Relativistic Punishment Device
        global.sounds.trigger_player("items/RPD_reload");
        break;
      case 2363: // DSR-50
      case 2382:
        global.sounds.trigger_player("items/DSR50_reload");
        break;
      case 2371: // HAMR
      case 2391:
        global.sounds.trigger_player("items/HAMR_reload");
        break;
      case 2372: // Ray Gun
      case 2392: // Porter's X2 Ray Gun
        global.sounds.trigger_player("items/ray_gun_reload");
        break;
      case 2921: // Backpack
      case 2922: // Ben's Backpack
      case 2923: // Purse
        global.sounds.trigger_player("player/armor_cloth");
        break;
      default:
        break;
    }
  }

  @Override public 
  void useItem(AbstractGameMap map) {
    this.useItem(map, new InventoryKey(InventoryLocation.GEAR, 3));
  }
   public void useItem(AbstractGameMap map, InventoryKey location) {
    Item i = this.inventory.getItem(location);
    if (i == null || !i.usable() || i.remove) {
      return;
    }
    if (i.consumable()) {
      this.heal(i.curr_health);
      this.increaseHunger(i.hunger);
      this.increaseThirst(i.thirst);
      this.money += i.money;
      switch(i.ID) {
        case 2116: // raw chicken
          if (randomChance(0.6f)) {
            this.addStatusEffect(StatusEffectCode.SICK, 10000);
          }
          break;
        case 2118: // chicken egg
          if (randomChance(0.3f)) {
            this.addStatusEffect(StatusEffectCode.SICK, 8000);
          }
          break;
        case 2119: // rotten flesh
          this.addStatusEffect(StatusEffectCode.SICK, 12000);
          break;
        case 2133: // wine
        case 2134: // beer
          this.addStatusEffect(StatusEffectCode.RELAXED, 9000);
          this.addStatusEffect(StatusEffectCode.WOOZY, 9000);
          break;
      }
      i.consumed();
      return;
    }
    if (i.openable()) {
      switch(i.ID) {
        case 2124: // hot pocket package
          i = new Item(2125);
          i.stack = 5;
          this.inventory.setItem(i, location);
          break;
        default:
          global.errorMessage("ERROR: Item ID " + i.ID + " not a recognized package.");
          break;
      }
      return;
    }
    if (i.reloadable()) {
      while(i.maximumAmmo() - i.availableAmmo() > 0) {
        ArrayList<Integer> possible_ammo = i.possibleAmmo();
        boolean noAmmo = true;
        for (int id : possible_ammo) {
          InventoryKey ammoLocation = this.inventory.itemLocation(id, InventoryLocation.INVENTORY);
          if (ammoLocation != null) {
            Item ammo = this.inventory.slots.get(ammoLocation.index).item;
            int ammoLoaded = min(i.maximumAmmo() - i.availableAmmo(), ammo.stack);
            ammo.removeStack(ammoLoaded);
            i.ammo += ammoLoaded;
            noAmmo = false;
            break;
          }
        }
        if (noAmmo) {
          break;
        }
      }
      return;
    }
    if (i.money()) {
      this.money += i.money;
      i.remove = true;
      global.sounds.trigger_player("player/money");
      this.left_panel_menu.deposited(i.money);
      return;
    }
    if (i.utility()) {
      switch(i.ID) {
        case 2904: // small key ring
        case 2905: // large key ring
          this.inventory.featureInventory(i.inventory);
          this.inventory.viewing = true;
          global.sounds.trigger_environment("items/keychain" + randomInt(1, 3),
            i.xCenter() - map.viewX, i.yCenter() - map.viewY);
          break;
        case 2921: // backpack
          this.inventory.addSlots(2);
          i.remove = true;
          break;
        case 2922: // Ben's backpack
          this.inventory.addSlots(4);
          i.remove = true;
          break;
        case 2923: // purse
          this.inventory.addSlots(1);
          i.remove = true;
          break;
        case 2924: // water bottles
        case 2925:
        case 2926:
        case 2927:
          int thirst_quenched = min(Constants.hero_maxThirst - this.thirst, i.ammo);
          i.ammo -= thirst_quenched;
          this.increaseThirst(thirst_quenched);
          break;
        case 2929: // gas can
          break;
      }
      return;
    }
    global.log("WARNING: Trying to use item " + i.display_name() + " but no logic exists to use it.");
  }


  @Override public 
  void destroy(AbstractGameMap map) {
    super.destroy(map);
    this.inventory.clear();
  }

  @Override public 
  ArrayList<Item> drops() {
    ArrayList<Item> drops = super.drops();
    for (Item i : this.inventory.items()) {
      drops.add(i);
    }
    return drops;
  }


   public void drawLeftPanel(int timeElapsed, float panel_width) {
    if (this.left_panel_menu != null) {
      this.left_panel_menu.drawPanel(timeElapsed, panel_width);
    }
  }


   public void hungerTick() {
    this.decreaseHunger(1);
    this.hunger_timer = Constants.hero_hungerTimer;
  }

   public void thirstTick() {
    this.decreaseThirst(1);
    this.thirst_timer = Constants.hero_thirstTimer;
  }

   public void increaseHunger(int amount) {
    this.changeHunger(amount);
  }

   public void decreaseHunger(int amount) {
    this.changeHunger(-amount);
  }

   public void changeHunger(int amount) {
    this.setHunger(this.hunger + amount);
  }

   public void setHunger(int amount) {
    this.hunger = amount;
    if (this.hunger > 100) {
      this.hunger = 100;
    }
    else if (this.hunger < 0) {
      this.hunger = 0;
    }
  }

   public void increaseThirst(int amount) {
    this.changeThirst(amount);
  }

   public void decreaseThirst(int amount) {
    this.changeThirst(-amount);
  }

   public void changeThirst(int amount) {
    this.setThirst(this.thirst + amount);
  }

   public void setThirst(int amount) {
    this.thirst = amount;
    if (this.thirst > 100) {
      this.thirst = 100;
    }
    else if (this.thirst < 0) {
      this.thirst = 0;
    }
  }

  @Override public 
  void increaseMana(int amount) {
    this.changeMana(amount);
  }

  @Override public 
  void decreaseMana(int amount) {
    this.changeMana(-amount);
  }

   public void changeMana(float amount) {
    this.setMana(this.curr_mana + amount);
  }

   public void setMana(float amount) {
    this.curr_mana = amount;
    if (this.curr_mana < 0) {
      this.curr_mana = 0;
    }
    else if (this.curr_mana > this.mana()) {
      this.curr_mana = this.mana();
    }
  }


   public void update_hero(int timeElapsed) {
    this.hunger_timer -= timeElapsed;
    if (this.hunger_timer < 0) {
      this.hungerTick();
    }
    this.thirst_timer -= timeElapsed;
    if (this.thirst_timer < 0) {
      this.thirstTick();
    }
    this.inventory_bar.update(timeElapsed);
    if (this.inventory.viewing) {
      float inventoryTranslateX = 0.5f * (width - this.inventory.display_width);
      float inventoryTranslateY = 0.5f * (height - this.inventory.display_height);
      translate(inventoryTranslateX, inventoryTranslateY);
      this.inventory.update(timeElapsed);
      translate(-inventoryTranslateX, -inventoryTranslateY);
    }
    if (this.hunger < Constants.hero_hungerThreshhold) {
      this.refreshStatusEffect(StatusEffectCode.HUNGRY, 3000);
    }
    if (this.thirst < Constants.hero_thirstThreshhold) {
      this.refreshStatusEffect(StatusEffectCode.THIRSTY, 3000);
    }
  }

   public void mouseMove_hero(float mX, float mY) {
    this.inventory_bar.mouseMove(mX, mY);
    if (this.inventory.viewing) {
      float inventoryTranslateX = 0.5f * (width - this.inventory.display_width);
      float inventoryTranslateY = 0.5f * (height - this.inventory.display_height);
      this.inventory.mouseMove(mX - inventoryTranslateX, mY - inventoryTranslateY);
    }
    if (this.left_panel_menu != null) {
      this.left_panel_menu.mouseMove(mX, mY);
    }
  }

   public void mousePress_hero() {
    this.inventory_bar.mousePress();
    if (this.inventory.viewing) {
      this.inventory.mousePress();
    }
    if (this.left_panel_menu != null) {
      this.left_panel_menu.mousePress();
    }
  }

   public void mouseRelease_hero(float mX, float mY) {
    this.inventory_bar.mouseRelease(mX, mY);
    if (this.inventory.viewing) {
      float inventoryTranslateX = 0.5f * (width - this.inventory.display_width);
      float inventoryTranslateY = 0.5f * (height - this.inventory.display_height);
      this.inventory.mouseRelease(mX - inventoryTranslateX, mY - inventoryTranslateY);
    }
    if (this.left_panel_menu != null) {
      this.left_panel_menu.mouseRelease(mX, mY);
    }
  }

   public void scroll_hero(int amount) {
    this.inventory_bar.scroll(amount);
  }

   public void keyPress_hero() {
    if (key == CODED) {
      switch(keyCode) {
        default:
          break;
      }
    }
    else {
      switch(key) {
        case '1':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(0);
          break;
        case '2':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(1);
          break;
        case '3':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(2);
          break;
        case '4':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(3);
          break;
        case '5':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(4);
          break;
        case '6':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(5);
          break;
        case '7':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(6);
          break;
        case '8':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(7);
          break;
        case '9':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(8);
          break;
        case '0':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory_bar.setEquippedIndex(9);
          break;
        case 'w':
        case 'W':
          if (global.holding_ctrl) {
            break;
          }
          if (this.weapon() != null) {
            this.gear.put(GearSlot.WEAPON, this.inventory.stash(this.weapon()));
          }
          break;
        case 'e':
        case 'E':
          if (global.holding_ctrl) {
            break;
          }
          this.inventory.viewing = !this.inventory.viewing;
          if (!this.inventory.viewing) {
            if (EnderChestInventory.class.isInstance(this.inventory.feature_inventory)) {
              global.notViewingEnderChest();
            }
            this.inventory.feature_inventory = null;
            this.inventory.dropItemHolding();
            this.inventory.clearCraftingInventory();
          }
          break;
        case 'r':
        case 'R':
          if (global.holding_ctrl || !this.in_control) {
            break;
          }
          if (this.weapon() != null && this.weapon().usable()) {
            if (this.weapon().reloadable()) {
              ArrayList<Integer> possible_ammo = this.weapon().possibleAmmo();
              boolean noAmmo = true;
              for (int id : possible_ammo) {
                if (this.inventory.itemLocation(id, InventoryLocation.INVENTORY) != null) {
                  noAmmo = false;
                  break;
                }
              }
              if (noAmmo) {
                this.messages.add("Out of ammo");
                break;
              }
            }
            this.startUseItemTimer();
          }
          break;
        default:
          break;
      }
    }
  }

   public void keyRelease_hero() {
    if (key == CODED) {
      switch(keyCode) {
        default:
          break;
      }
    }
    else {
      switch(key) {
        default:
          break;
      }
    }
  }


  @Override public 
  String fileString() {
    String fileString = "\nnew: Hero: " + this.ID;
    fileString += super.fileString(false);
    for (Ability a : this.abilities) {
      if (a == null) {
        fileString += "\naddNullAbility:";
      }
      else {
        fileString += a.fileString();
      }
    }
    fileString += "\nlevel_location: " + this.location.file_name();
    fileString += "\nlevel_tokens: " + this.level_tokens;
    fileString += "\nexperience: " + this.experience;
    fileString += "\nexperience_next_level: " + this.experience_next_level;
    fileString += "\nmoney: " + this.money;
    fileString += "\ncurr_mana: " + this.curr_mana;
    fileString += "\nhunger: " + this.hunger;
    fileString += "\nthirst: " + this.thirst;
    fileString += "\nhunger_timer: " + this.hunger_timer;
    fileString += "\nthirst_timer: " + this.thirst_timer;
    fileString += this.inventory.fileString();
    for (HeroTreeCode code : this.heroTree.unlockedCodes()) {
      fileString += "\nperk: " + code.file_name();
    }
    fileString += "\nend: Hero\n";
    return fileString;
  }


  @Override public 
  void addData(String datakey, String data) {
    switch(datakey) {
      case "level_location":
        this.location = Location.location(data);
        break;
      case "perk":
        HeroTreeCode tree_code = HeroTreeCode.code(data);
        if (tree_code != null) {
          this.heroTree.unlockNode(tree_code, true, false);
        }
        break;
      case "level_tokens":
        this.level_tokens = toInt(data);
        break;
      case "experience":
        this.experience = toFloat(data);
        break;
      case "experience_next_level":
        this.experience_next_level = toInt(data);
        break;
      case "money":
        this.money = toFloat(data);
        break;
      case "curr_mana":
        this.curr_mana = toFloat(data);
        break;
      case "hunger":
        this.hunger = toInt(data);
        break;
      case "thirst":
        this.thirst = toInt(data);
        break;
      case "hunger_timer":
        this.hunger_timer = toInt(data);
        break;
      case "thirst_timer":
        this.thirst_timer = toInt(data);
        break;
      default:
        super.addData(datakey, data);
        break;
    }
  }
}


 public Hero readHeroFile(String filePath) {
  Hero hero = null;
  String[] lines = loadStrings(filePath);
  if (lines == null) {
    global.errorMessage("ERROR: Reading hero at path " + filePath + " but no hero file exists.");
    return null;
  }
  Stack<ReadFileObject> object_queue = new Stack<ReadFileObject>();
  StatusEffectCode curr_status_code = StatusEffectCode.ERROR;
  StatusEffect curr_status = null;
  Ability curr_ability = null;
  Item curr_item = null;
  boolean ended_hero = false;
  for (String line : lines) {
    String[] parameters = split(line, ':');
    if (parameters.length < 2) {
      continue;
    }
    String dataname = trim(parameters[0]);
    String data = trim(parameters[1]);
    for (int i = 2; i < parameters.length; i++) {
      data += ":" + parameters[i];
    }
    if (dataname.equals("new")) {
      ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
      switch(type) {
        case HERO:
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Unit ID missing in Hero constructor.");
            break;
          }
          object_queue.push(type);
          hero = new Hero(toInt(trim(parameters[2])));
          hero.abilities.clear();
          break;
        case INVENTORY:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to start an inventory in a null hero.");
          }
          object_queue.push(type);
          break;
        case ITEM:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to start an item in a null hero.");
          }
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Item ID missing in Item constructor.");
            break;
          }
          object_queue.push(type);
          curr_item = new Item(toInt(trim(parameters[2])));
          break;
        case STATUS_EFFECT:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to start a status effect in a null hero.");
          }
          object_queue.push(type);
          curr_status = new StatusEffect();
          break;
        case ABILITY:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to start an ability in a null hero.");
          }
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Ability ID missing in Projectile constructor.");
            break;
          }
          object_queue.push(type);
          curr_ability = new Ability(toInt(trim(parameters[2])));
          break;
        default:
          global.errorMessage("ERROR: Can't add a " + type + " type to Heroes data.");
          break;
      }
    }
    else if (dataname.equals("end")) {
      ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
      if (object_queue.empty()) {
        global.errorMessage("ERROR: Tring to end a " + type.name + " object but not inside any object.");
      }
      else if (type.name.equals(object_queue.peek().name)) {
        switch(object_queue.pop()) {
          case HERO:
            if (hero == null) {
              global.errorMessage("ERROR: Trying to end a null hero.");
              break;
            }
            if (!object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end a hero but inside another object.");
              break;
            }
            if (hero.code == HeroCode.ERROR) {
              global.errorMessage("ERROR: Trying to end hero with errored code.");
              break;
            }
            ended_hero = true;
            break;
          case INVENTORY:
            if (hero == null) {
              global.errorMessage("ERROR: Trying to end an inventory in a null hero.");
              break;
            }
            break;
          case ITEM:
            if (curr_item == null) {
              global.errorMessage("ERROR: Trying to end a null item.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end an item not inside any other object.");
              break;
            }
            switch(object_queue.peek()) {
              case HERO:
                if (parameters.length < 3) {
                  global.errorMessage("ERROR: GearSlot code missing in Item constructor.");
                  break;
                }
                GearSlot code = GearSlot.gearSlot(trim(parameters[2]));
                if (hero == null) {
                  global.errorMessage("ERROR: Trying to add gear to null hero.");
                  break;
                }
                hero.gear.put(code, curr_item);
                break;
              case INVENTORY:
                if (parameters.length < 3) {
                  global.errorMessage("ERROR: No positional information for inventory item.");
                  break;
                }
                int index = toInt(trim(parameters[2]));
                if (hero == null) {
                  global.errorMessage("ERROR: Trying to add inventory item to null hero.");
                  break;
                }
                Item i = hero.inventory.placeAt(curr_item, index, true);
                if (i != null) {
                  global.errorMessage("ERROR: Item already exists at position " + index + ".");
                  break;
                }
                break;
              default:
                global.errorMessage("ERROR: Trying to end an item inside a " + object_queue.peek().name + ".");
                break;
            }
            curr_item = null;
            break;
          case STATUS_EFFECT:
            if (curr_status == null) {
              global.errorMessage("ERROR: Trying to end a null status effect.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end a status effect not inside any other object.");
              break;
            }
            if (object_queue.peek() != ReadFileObject.HERO) {
              global.errorMessage("ERROR: Trying to end a status effect not inside a hero.");
              break;
            }
            if (hero == null) {
              global.errorMessage("ERROR: Trying to end a status effect inside a null hero.");
              break;
            }
            hero.statuses.put(curr_status_code, curr_status);
            curr_status = null;
            break;
          case ABILITY:
            if (curr_ability == null) {
              global.errorMessage("ERROR: Trying to end a null ability.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end an ability not inside any other object.");
              break;
            }
            if (object_queue.peek() != ReadFileObject.HERO) {
              global.errorMessage("ERROR: Trying to end an ability inside a " + object_queue.peek().name + ".");
              break;
            }
            if (hero == null) {
              global.errorMessage("ERROR: Trying to end an ability inside a null hero.");
              break;
            }
            hero.abilities.add(curr_ability);
            curr_ability = null;
            break;
        }
      }
      else {
        global.errorMessage("ERROR: Tring to end a " + type.name + " object but current object is a " + object_queue.peek().name + ".");
      }
    }
    else {
      switch(object_queue.peek()) {
        case HERO:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to add hero data to a null hero.");
            break;
          }
          if (dataname.equals("next_status_code")) {
            curr_status_code = StatusEffectCode.code(data);
          }
          else {
            hero.addData(dataname, data);
          }
          break;
        case INVENTORY:
          if (hero == null) {
            global.errorMessage("ERROR: Trying to add hero inventory data to a null hero.");
            break;
          }
          hero.inventory.addData(dataname, data);
          break;
        case ITEM:
          if (curr_item == null) {
            global.errorMessage("ERROR: Trying to add item data to a null item.");
            break;
          }
          curr_item.addData(dataname, data);
          break;
        case STATUS_EFFECT:
          if (curr_status == null) {
            global.errorMessage("ERROR: Trying to add status effect data to a null status effect.");
            break;
          }
          curr_status.addData(dataname, data);
          break;
        case ABILITY:
          if (curr_ability == null) {
            global.errorMessage("ERROR: Trying to add ability data to a null ability.");
            break;
          }
          curr_status.addData(dataname, data);
          break;
        default:
          break;
      }
    }
  }
  if (!ended_hero) {
    global.errorMessage("ERROR: Hero data never ended.");
    return null;
  }
  return hero;
}
class Images {
  private HashMap<String, PImage> imgs = new HashMap<String, PImage>();
  private String basePath = sketchPath("data/images/");
  private boolean loaded_map_gifs = false;

  Images() {}

   public PImage getImage(String filePath) {
    if (this.imgs.containsKey(filePath)) {
      return this.imgs.get(filePath);
    }
    else {
      this.loadImageFile(filePath);
      return this.imgs.get(filePath);
    }
  }

   public PGraphics getImageAsGraphic(String filePath) {
    PImage img = this.getImage(filePath);
    PGraphics graphic = createGraphics(img.width, img.height);
    graphic.beginDraw();
    graphic.image(img, 0, 0);
    graphic.endDraw();
    return graphic;
  }

   public void loadImageFiles(String ... filePaths) {
    for (String filePath : filePaths) {
      this.loadImageFile(filePath);
    }
  }
   public void loadImageFile(String filePath) {
    PImage img = loadImage(this.basePath + filePath);
    if (img == null) {
      global.log("Images: Missing image " + filePath + ".");
      this.imgs.put(filePath, this.getBlackPixel());
    }
    else {
      this.imgs.put(filePath, img);
    }
  }

   public void loadMapGifs() {
    if (this.loaded_map_gifs) {
      return;
    }
    this.loaded_map_gifs = true;
    // move gif
    for (int i = 0; i <= Constants.gif_move_frames; i++) {
      this.loadImageFile("gifs/move/" + i + ".png");
    }
    // ability gifs
    for (int i = 0; i <= Constants.gif_poof_frames; i++) {
      this.loadImageFile("gifs/poof/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_amphibiousLeap_frames; i++) {
      this.loadImageFile("gifs/amphibious_leap/" + i + ".png");
    }
    // explosion gifs
    for (int i = 0; i <= Constants.gif_explosionBig_frames; i++) {
      this.loadImageFile("gifs/explosion_big/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_explosionCrackel_frames; i++) {
      this.loadImageFile("gifs/explosion_crackel/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_explosionFire_frames; i++) {
      this.loadImageFile("gifs/explosion_fire/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_explosionGreen_frames; i++) {
      this.loadImageFile("gifs/explosion_green/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_explosionNormal_frames; i++) {
      this.loadImageFile("gifs/explosion_normal/" + i + ".png");
    }
    // map gifs
    for (int i = 0; i <= Constants.gif_fire_frames; i++) {
      this.loadImageFile("gifs/fire/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_lava_frames; i++) {
      this.loadImageFile("gifs/lava/" + i + ".png");
    }
    for (int i = 0; i <= Constants.gif_drenched_frames; i++) {
      this.loadImageFile("gifs/drenched/" + i + ".png");
    }
    // other images
    for (int i = 1; i <= 11; i++) {
      this.loadImageFile("icons/tier_" + i + ".png");
    }
  }

   public void loadMinigameImages(MinigameName name) {
    switch(name) {
      case CHESS:
        String p = "minigames/chess/";
        this.loadImageFiles(p + "black_bishop.png", p + "black_king.png",
        p + "black_knight.png", p + "black_pawn.png", p + "black_queen.png",
        p + "black_rook.png", p + "white_bishop.png", p + "white_king.png",
        p + "white_knight.png", p + "white_pawn.png", p + "white_queen.png",
        p + "white_rook.png");
        break;
      default:
        break;
    }
  }

   public PImage getBlackPixel() {
    PImage img = new PImage(1, 1, RGB);
    img.loadPixels();
    img.pixels[0] = color(0);
    img.updatePixels();
    return img;
  }

   public PImage getTransparentPixel() {
    PImage img = new PImage(1, 1, ARGB);
    img.loadPixels();
    img.pixels[0] = color(255, 0);
    img.updatePixels();
    return img;
  }

   public PImage getRandomPixel() {
    PImage img = new PImage(1, 1, ARGB);
    img.loadPixels();
    img.pixels[0] = color(round(random(255)), round(random(255)), round(random(255)));
    img.updatePixels();
    return img;
  }

   public PImage getColoredPixel(int c) {
    PImage img = new PImage(1, 1, ARGB);
    img.loadPixels();
    img.pixels[0] = c;
    img.updatePixels();
    return img;
  }
}



 public PImage getCurrImage() {
  PImage img = createImage(width, height, ARGB);
  img.loadPixels();
  loadPixels();
  for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
      int index = i + j * width;
      img.pixels[index] = pixels[index];
    }
  }
  img.updatePixels();
  return img;
}

 public PImage getCurrImage(int xi, int yi, int xf, int yf) {
  PImage img = createImage(xf - xi, yf - yi, ARGB);
  img.loadPixels();
  loadPixels();
  for (int i = xi; i <= xf; i++) {
    for (int j = yi; j <= yf; j++) {
      int index = i + j * width;
      if (index < 0 || index >= pixels.length) {
        continue;
      }
      int img_index = (i - xi) + (j - yi) * img.width;
      if (img_index >= img.pixels.length) {
        continue;
      }
      img.pixels[img_index] = pixels[index];
    }
  }
  img.updatePixels();
  return img;
}
class InitialInterface extends InterfaceLNZ {

  abstract class InitialInterfaceButton extends RectangleButton {
    InitialInterfaceButton(float yi, float yf) {
      super(Constants.initialInterface_size - Constants.initialInterface_buttonWidth -
        Constants.initialInterface_buttonGap, yi, Constants.initialInterface_size -
        Constants.initialInterface_buttonGap, yf);
      this.setColors(color(0, 100, 30, 200), color(0, 129, 50, 150),
        color(0, 129, 50, 190), color(0, 129, 50, 230), color(255));
      this.noStroke();
      this.show_message = true;
      this.text_size = 15;
    }

     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn1");
      InitialInterface.this.logo.release();
    }
     public void dehover() {
      this.clicked = false;
    }
     public void click() {
      InitialInterface.this.logo.release();
    }
     public void release() {
      this.stayDehovered();
      InitialInterface.this.logo.release();
      InitialInterface.this.logo.release();
    }
  }

  class InitialInterfaceButton1 extends InitialInterfaceButton {
    InitialInterfaceButton1(float buttonHeight) {
      super(Constants.initialInterface_buttonGap,
        Constants.initialInterface_buttonGap + buttonHeight);
      this.message = "Launch";
    }

    @Override public 
    void release() {
      super.release();
      global.sounds.trigger_interface("interfaces/buttonClick4");
      global.state = ProgramState.ENTERING_MAINMENU;
      background(global.color_background);
      surface.setSize(displayWidth, displayHeight);
      surface.setLocation(0, 0);
    }
  }

  class InitialInterfaceButton2 extends InitialInterfaceButton {
    InitialInterfaceButton2(float buttonHeight) {
      super(2 * Constants.initialInterface_buttonGap + buttonHeight,
        2 * Constants.initialInterface_buttonGap + 2 * buttonHeight);
      this.message = "Uninstall";
    }

    @Override public 
    void release() {
      super.release();
      global.sounds.trigger_interface("interfaces/buttonClick3");
      InitialInterface.this.form = new InitialInterfaceForm("Uninstall Game", "Just delete it ya dip");
    }
  }

  class InitialInterfaceButton3 extends InitialInterfaceButton {
    InitialInterfaceButton3(float buttonHeight) {
      super(3 * Constants.initialInterface_buttonGap + 2 * buttonHeight,
        3 * Constants.initialInterface_buttonGap + 3 * buttonHeight);
      this.message = "Reset\nGame";
    }

    @Override public 
    void release() {
      super.release();
      global.sounds.trigger_interface("interfaces/buttonClick3");
      InitialInterface.this.form = new InitialInterfaceForm("Reset Game", "Why would you want to reinstall a test version?");
    }
  }

  class InitialInterfaceButton4 extends InitialInterfaceButton {
    InitialInterfaceButton4(float buttonHeight) {
      super(4 * Constants.initialInterface_buttonGap + 3 * buttonHeight,
        4 * Constants.initialInterface_buttonGap + 4 * buttonHeight);
      this.message = "Version\nHistory";
    }

    @Override public 
    void release() {
      super.release();
      global.sounds.trigger_interface("interfaces/buttonClick3");
      InitialInterface.this.form = new InitialInterfaceForm("Version History", Constants.version_history);
    }
  }

  class InitialInterfaceButton5 extends InitialInterfaceButton {
    InitialInterfaceButton5(float buttonHeight) {
      super(5 * Constants.initialInterface_buttonGap + 4 * buttonHeight,
        5 * Constants.initialInterface_buttonGap + 5 * buttonHeight);
      this.message = "Exit";
    }

    @Override public 
    void release() {
      super.release();
      global.sounds.trigger_interface("interfaces/buttonClick3");
      global.exitDelay();
    }
  }

  class LogoImageButton extends ImageButton {
    LogoImageButton() {
      super(global.images.getImage("logo.png"), 0, 0, 400, 400);
    }

     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
      this.color_tint = color(255, 200, 200);
    }
     public void release() {
      this.color_tint = color(255);
    }
  }

  class InitialInterfaceForm extends FormLNZ {
    InitialInterfaceForm(String title, String message) {
      super(0.5f * Constants.initialInterface_size - 120, 0.5f * Constants.initialInterface_size - 120,
        0.5f * Constants.initialInterface_size + 120, 0.5f * Constants.initialInterface_size + 120);
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));

      SubmitFormField submit = new SubmitFormField("  Ok  ");
      submit.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      TextBoxFormField textbox = new TextBoxFormField(message, 120);
      textbox.textbox.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));
      this.addField(textbox);
      this.addField(submit);
    }
     public void submit() {
      this.canceled = true;
    }
  }

  private InitialInterfaceButton[] buttons = new InitialInterfaceButton[5];
  private LogoImageButton logo = new LogoImageButton();

  InitialInterface() {
    super();
    float buttonHeight = (Constants.initialInterface_size - (this.buttons.length + 1) *
      Constants.initialInterface_buttonGap) / this.buttons.length;
    this.buttons[0] = new InitialInterfaceButton1(buttonHeight);
    this.buttons[1] = new InitialInterfaceButton2(buttonHeight);
    this.buttons[2] = new InitialInterfaceButton3(buttonHeight);
    this.buttons[3] = new InitialInterfaceButton4(buttonHeight);
    this.buttons[4] = new InitialInterfaceButton5(buttonHeight);
  }

   public void saveAndExitToMainMenu() {}

   public Hero getCurrentHeroIfExists() {
    return null;
  }

   public void update(int millis) {
    this.logo.update(millis);
    for (InitialInterfaceButton button : this.buttons) {
      button.update(millis);
    }
  }

   public void showNerdStats() {
    this.showDefaultNerdStats();
  }

   public void mouseMove(float mX, float mY) {
    this.logo.mouseMove(mX, mY);
    for (InitialInterfaceButton button : this.buttons) {
      button.mouseMove(mX, mY);
    }
  }

   public void mousePress() {
    this.logo.mousePress();
    for (InitialInterfaceButton button : this.buttons) {
      button.mousePress();
    }
  }

   public void mouseRelease(float mX, float mY) {
    this.logo.mouseRelease(mX, mY);
    for (InitialInterfaceButton button : this.buttons) {
      button.mouseRelease(mX, mY);
    }
  }

   public void scroll(int amount) {}
   public void keyPress() {}
   public void openEscForm() {}
   public void keyRelease() {}
   public void loseFocus() {}
   public void gainFocus() {}
   public void restartTimers() {}
}
abstract class FormLNZ extends Form {
  protected boolean canceled = false;
  protected float shadow_distance = 10;
  protected PImage img;
  protected int color_shadow = color(0, 150);
  protected boolean need_to_reset_cursor = true;

  FormLNZ(float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
    this.img = getCurrImage();
    this.cancelButton();
    this.draggable = true;
  }

  @Override public 
  void update(int millis) {
    if (this.need_to_reset_cursor) {
      global.defaultCursor();
    }
    rectMode(CORNERS);
    fill(0);
    imageMode(CORNER);
    image(this.img, 0, 0);
    fill(color_shadow);
    stroke(0, 1);
    translate(shadow_distance, shadow_distance);
    rect(this.xi, this.yi, this.xf, this.yf);
    translate(-shadow_distance, -shadow_distance);
    super.update(millis);
  }

   public void cancel() {
    this.canceled = true;
  }

   public void buttonPress(int i) {}

   public void keyPress() {
    super.keyPress();
    if (key == ESC) {
      this.cancel();
    }
  }
}



abstract class InterfaceLNZ {

  abstract class ConfirmForm extends FormLNZ {
    ConfirmForm(String title, String message) {
      this(title, message, Constants.mapEditor_formWidth_small, Constants.mapEditor_formHeight_small);
    }
    ConfirmForm(String title, String message, boolean mediumForm) {
      this(title, message, Constants.mapEditor_formWidth, Constants.mapEditor_formHeight);
    }
    ConfirmForm(String title, String message, float formWidth, float formHeight) {
      super(0.5f * (width - formWidth), 0.5f * (height - formHeight),
        0.5f * (width + formWidth), 0.5f * (height + formHeight));
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);

      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      this.addField(new TextBoxFormField(message, formHeight - 130));
      this.addField(submit);
    }
  }


  class EscForm extends FormLNZ {
    class EscButtonFormField extends ButtonFormField {
      EscButtonFormField(String message) {
        super(message);
        this.button.setColors(color(170, 200), color(1, 0), color(40, 150), color(20, 180), color(255));
        this.button.raised_border = false;
        this.button.raised_body = false;
        this.button.noStroke();
        this.button.text_size = 20;
        this.extend_width = true;
      }
    }

    EscForm() {
      super(0.5f * (width - Constants.escFormWidth), 0.5f * (height - Constants.escFormHeight),
        0.5f * (width + Constants.escFormWidth), 0.5f * (height + Constants.escFormHeight));
      this.cancel = null;
      this.scrollbar_width_multiplier = 0;
      this.draggable = false;
      this.color_shadow = color(1, 0);
      this.setFieldCushion(20);
      this.setTitleText("Paused");
      this.setTitleSize(22);
      this.color_background = color(60, 120);
      this.color_header = color(1, 0);
      this.color_stroke = color(1, 0);
      this.color_title = color(255);

      this.addField(new SpacerFormField(0));
      this.addField(new EscButtonFormField("Continue"));
      this.addField(new EscButtonFormField("Options"));
      this.addField(new EscButtonFormField("Heroes"));
      this.addField(new EscButtonFormField("Achievements"));
      this.addField(new EscButtonFormField("Perk Tree"));
      this.addField(new EscButtonFormField("Save and Exit to Main Menu"));
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      stroke(255);
      strokeWeight(2);
      line(this.xi, this.yi, this.xf, this.yi);
      line(this.xi, this.yStart, this.xf, this.yStart);
      line(this.xi, this.yf, this.xf, this.yf);
      line(this.xi, this.yi, this.xi, this.yf);
      line(this.xf, this.yi, this.xf, this.yf);
    }

     public void submit() {}

    @Override public 
    void buttonPress(int i) {
      switch(i) {
        case 1:
          this.cancel();
          break;
        case 2:
          InterfaceLNZ.this.return_to_esc_menu = true;
          InterfaceLNZ.this.esc_menu_img = this.img;
          InterfaceLNZ.this.optionsForm();
          break;
        case 3:
          InterfaceLNZ.this.return_to_esc_menu = true;
          InterfaceLNZ.this.esc_menu_img = this.img;
          InterfaceLNZ.this.heroesForm();
          break;
        case 4:
          InterfaceLNZ.this.return_to_esc_menu = true;
          InterfaceLNZ.this.esc_menu_img = this.img;
          InterfaceLNZ.this.achievementsForm();
          break;
        case 5:
          InterfaceLNZ.this.openPlayerTree();
          break;
        case 6:
          InterfaceLNZ.this.saveAndExitToMainMenu();
          break;
        default:
          break;
      }
    }
  }


  class HeroesForm extends FormLNZ {
    class HeroesFormField extends FormField {
      class HeroButton extends IconInverseButton {
        protected HeroCode code;
        protected Hero hero = null;
        HeroButton(float xi, float yi, float xf, float yf, HeroCode code) {
          super(xi, yi, xf, yf, global.images.getImage(code.getImagePath(global.profile.ben_has_eyes)));
          this.roundness = 4;
          this.adjust_for_text_descent = true;
          this.code = code;
          Element e = code.element();
          this.background_color = color(170, 170);
          this.setColors(elementalColorLocked(e), elementalColorDark(e), elementalColor(e),
            elementalColorLight(e), elementalColorText(e));
          this.show_message = true;
          this.message = code.display_name();
          this.text_size = 24;
          this.rippleTimer = 450;
          this.setStroke(color(0), 1);
          if (global.profile.heroes.containsKey(this.code)) {
            this.hero = global.profile.heroes.get(this.code);
            if (global.profile.curr_hero == this.code) {
              this.setStroke(color(255), 6);
            }
          }
        }
         public void hover() {
          super.hover();
          this.message = this.code.display_name() + "\n" + this.code.title() +
            "\nLocation: " + this.hero.location.display_name();
          this.text_size = 16;
        }
         public void dehover() {
          super.dehover();
          this.message = this.code.display_name();
          this.text_size = 24;
        }
         public void release() {
          super.release();
          if (this.hovered || this.button_focused) {
            HeroesFormField.this.last_code_clicked = this.code;
            HeroesFormField.this.clicked = true;
          }
        }
      }

      protected HeroButton[] heroes = new HeroButton[2];
      protected HeroCode last_code_clicked = HeroCode.ERROR;
      protected boolean clicked = false;

      HeroesFormField(int index) {
        super("");
        switch(index) {
          case 0:
            this.heroes[0] = new HeroButton(0, 0, 0, 100, HeroCode.BEN);
            this.heroes[1] = new HeroButton(0, 0, 0, 100, HeroCode.DAN);
            break;
        }
        this.enable();
      }

       public void disable() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.disabled = true;
        }
      }
       public void enable() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.disabled = !global.profile.heroes.containsKey(button.code);
        }
      }

       public boolean focusable() {
        for (int i = 0; i < this.heroes.length; i++) {
          if (this.heroes[this.heroes.length - 1 - i] == null) {
            continue;
          }
          if (this.heroes[this.heroes.length - 1 - i].button_focused) {
            return false;
          }
          return true;
        }
        return false;
      }
       public void focus() {
        boolean refocused = false;
        for (int i = 0; i < this.heroes.length; i++) {
          if (this.heroes[i] == null) {
            continue;
          }
          if (this.heroes[i].button_focused) {
            this.heroes[i].button_focused = false;
            if (i == this.heroes.length - 1) {
              this.heroes[0].button_focused = true;
            }
            else {
              this.heroes[i + 1].button_focused = true;
            }
            refocused = true;
            break;
          }
        }
        if (!refocused) {
          this.heroes[0].button_focused = true;
        }
      }
       public void defocus() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.button_focused = false;
        }
      }
       public boolean focused() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          if (button.button_focused) {
            return true;
          }
        }
        return false;
      }

       public void updateWidthDependencies() {
        float button_width = (this.field_width - 4) / this.heroes.length - (this.heroes.length - 1) * 10;
        for (int i = 0; i < this.heroes.length; i++) {
          if (this.heroes[i] == null) {
            continue;
          }
          this.heroes[i].setXLocation(2 + i * (button_width + 10), 2 + i * (button_width + 10) + button_width);
        }
      }

       public float getHeight() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          return button.button_height();
        }
        return 0;
      }

       public String getValue() {
        return this.last_code_clicked.file_name();
      }
       public void setValue(String value) {
        this.message = value;
      }

       public FormFieldSubmit update(int millis) {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.update(millis);
        }
        if (this.clicked) {
          this.clicked = false;
          return FormFieldSubmit.BUTTON;
        }
        return FormFieldSubmit.NONE;
      }

       public void mouseMove(float mX, float mY) {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.mouseMove(mX, mY);
        }
      }

       public void mousePress() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.mousePress();
        }
      }

       public void mouseRelease(float mX, float mY) {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.mouseRelease(mX, mY);
        }
      }

       public void scroll(int amount) {}
       public void keyPress() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.keyPress();
        }
      }
       public void keyRelease() {
        for (HeroButton button : this.heroes) {
          if (button == null) {
            continue;
          }
          button.keyRelease();
        }
      }
       public void submit() {}
    }

    HeroesForm() {
      super(0.5f * (width - Constants.profile_heroesFormWidth), 0.5f * (height - Constants.profile_heroesFormHeight),
        0.5f * (width + Constants.profile_heroesFormWidth), 0.5f * (height + Constants.profile_heroesFormHeight));
      this.setTitleText("Heroes");
      this.setTitleSize(22);
      this.color_shadow = color(0, 180);
      this.color_background = color(60);
      this.color_header = color(90);
      this.color_stroke = color(0);
      this.color_title = color(255);
      this.setFieldCushion(15);

      this.addField(new SpacerFormField(0));
      this.addField(new HeroesFormField(0));
    }

     public void submit() {}

     public void buttonPress(int i) {
      HeroCode code_clicked = HeroCode.ERROR;
      try {
        code_clicked = ((HeroesFormField)this.fields.get(i)).last_code_clicked;
      } catch(Exception e) {}
      if (code_clicked != HeroCode.ERROR) {
        InterfaceLNZ.this.openHeroForm(code_clicked);
      }
    }

     public void keyPress() {
      super.keyPress();
      if (key == 'h' && global.holding_ctrl) {
        this.cancel();
      }
    }
  }


  class HeroForm extends FormLNZ {
    protected Hero hero;
    protected boolean switch_hero = true;
    HeroForm(Hero hero) {
      super(0.5f * (width - Constants.profile_heroFormWidth), 0.5f * (height - Constants.profile_heroFormHeight),
        0.5f * (width + Constants.profile_heroFormWidth), 0.5f * (height + Constants.profile_heroFormHeight));
      this.hero = hero;
      this.setTitleText(hero.code.display_name());
      this.setTitleSize(22);
      Element e = hero.element;
      this.color_background = elementalColorLight(e);
      this.color_header = elementalColor(e);
      this.color_stroke = elementalColorDark(e);
      this.color_title = elementalColorText(e);
      this.setFieldCushion(15);

      MessageFormField message1 = new MessageFormField("Location: " + hero.location.display_name());
      message1.text_color = elementalColorText(hero.element);
      MessageFormField message2 = new MessageFormField(hero.code.title());
      message2.text_color = elementalColorText(hero.element);
      TextBoxFormField textbox = new TextBoxFormField(hero.code.description(), 100);
      textbox.textbox.color_text = elementalColorText(hero.element);

      this.addField(new SpacerFormField(80));
      this.addField(message1);
      if (PlayingInterface.class.isInstance(InterfaceLNZ.this)) {
        SubmitFormField submit = null;
        if (global.profile.curr_hero == hero.code) {
          submit = new SubmitFormField("Continue Playing");
          this.switch_hero = false;
        }
        else {
          submit = new SubmitFormField("Play Hero");
        }
        submit.button.text_size = 18;
        submit.button.setColors(elementalColorLocked(hero.element), elementalColor(
          hero.element), elementalColorLight(hero.element), elementalColorDark(
          hero.element), elementalColorText(hero.element));
        this.addField(submit);
      }
      this.addField(new SpacerFormField(10));
      this.addField(message2);
      this.addField(textbox);
      this.addField(new SpacerFormField(10));
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      imageMode(CENTER);
      image(global.images.getImage(this.hero.code.getImagePath(global.profile.ben_has_eyes)), this.xCenter(), this.yStart + 40, 75, 75);
    }

     public void submit() {
      if (this.switch_hero && PlayingInterface.class.isInstance(InterfaceLNZ.this)) {
        ((PlayingInterface)InterfaceLNZ.this).switchHero(this.hero);
      }
      this.canceled = true;
      InterfaceLNZ.this.return_to_heroes_menu = false;
    }

     public void buttonPress(int i) {}
  }


  class ErrorForm extends FormLNZ {
    ErrorForm(String errorMessage) {
      super(0.5f * (width - Constants.errorForm_width), 0.5f * (height - Constants.errorForm_height),
        0.5f * (width + Constants.errorForm_width), 0.5f * (height + Constants.errorForm_height));
      this.setTitleText("Error Detected");
      this.setTitleSize(20);
      this.setFieldCushion(0);
      this.color_background = color(250, 150, 150);
      this.color_header = color(180, 50, 50);
      this.addField(new SpacerFormField(20));
      this.addField(new MessageFormField("Error detected on this frame."));
      this.addField(new SpacerFormField(10));
      this.addField(new TextBoxFormField("Error message:\n" + errorMessage, 100));
      this.addField(new SpacerFormField(20));
      this.addField(new MessageFormField("Check the data/error folder for logs and image."));
      this.addField(new SpacerFormField(20));
      this.addField(new CheckboxFormField("Send error report  "));
      this.addField(new SpacerFormField(20));
      SubmitCancelFormField buttons = new SubmitCancelFormField("Continue\n(may crash)", "Exit");
      textSize(buttons.button1.text_size);
      buttons.button1.setColors(color(180), color(240, 160, 160),
        color(190, 110, 110), color(140, 70, 70), color(0));
      buttons.button2.setColors(color(180), color(240, 160, 160),
        color(190, 110, 110), color(140, 70, 70), color(0));
      buttons.setButtonHeight(2 * (textAscent() + textDescent() + 2));
      this.addField(buttons);
      this.img.save("data/logs/screenshot.jpg");
    }

     public void submit() {
      if (this.fields.get(7).getValue().equals(Boolean.toString(true))) {
        this.sendEmail();
      }
      this.canceled = true;
    }

    @Override public 
    void cancel() {
      if (this.fields.get(7).getValue().equals(Boolean.toString(true))) {
        this.sendEmail();
      }
      global.exitDelay();
    }

     public void sendEmail() {
      global.log("Send email (not configured).");
    }

     public void addErrorMessage(String message) {
      this.fields.get(3).setValue(this.fields.get(3).getValue() + "\n\nError Message:\n" + message);
    }
  }


  class OptionsForm extends FormLNZ {
    OptionsForm() {
      super(Constants.optionsForm_widthOffset, Constants.optionsForm_heightOffset,
        width - Constants.optionsForm_widthOffset, height - Constants.optionsForm_heightOffset);
      this.setTitleText("Options");
      this.setTitleSize(20);
      this.setFieldCushion(5);
      this.color_background = color(250, 250, 180);
      this.color_header = color(180, 180, 50);
      if (global.profile == null) {
        this.canceled = true;
        return;
      }
      SliderFormField volume_master = new SliderFormField("Master Volume: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_master.threshhold = Constants.optionsForm_threshhold_master;
      volume_master.addCheckbox("mute: ");
      volume_master.addLabel("%", true);
      SliderFormField volume_music = new SliderFormField("Music: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_music.threshhold = Constants.optionsForm_threshhold_other;
      volume_music.addCheckbox("mute: ");
      volume_music.addLabel("%", true);
      SliderFormField volume_interface = new SliderFormField("Interface: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_interface.threshhold = Constants.optionsForm_threshhold_other;
      volume_interface.addCheckbox("mute: ");
      volume_interface.addLabel("%", true);
      SliderFormField volume_environment = new SliderFormField("Environment: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_environment.threshhold = Constants.optionsForm_threshhold_other;
      volume_environment.addCheckbox("mute: ");
      volume_environment.addLabel("%", true);
      SliderFormField volume_units = new SliderFormField("Units: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_units.threshhold = Constants.optionsForm_threshhold_other;
      volume_units.addCheckbox("mute: ");
      volume_units.addLabel("%", true);
      SliderFormField volume_player = new SliderFormField("Player: ",
        Constants.options_volumeMin, Constants.options_volumeMax);
      volume_player.threshhold = Constants.optionsForm_threshhold_other;
      volume_player.addCheckbox("mute: ");
      volume_player.addLabel("%", true);
      SliderFormField map_move_speed = new SliderFormField("Camera Speed: ",
        Constants.map_minCameraSpeed, Constants.map_maxCameraSpeed);
      map_move_speed.threshhold = Constants.optionsForm_threshhold_other;
      SliderFormField inventory_bar_size = new SliderFormField("Inventory Bar Size: ", 80, 180);
      inventory_bar_size.threshhold = Constants.optionsForm_threshhold_other;
      inventory_bar_size.addCheckbox("hide: ");
      SliderFormField map_resolution = new SliderFormField("Terrain Resolution: ", 10, 110, 20);
      map_resolution.threshhold = Constants.optionsForm_threshhold_other;
      map_resolution.addLabel(" pixels", true, false);
      SliderFormField fog_update_time = new SliderFormField("Fog Update Time: ",
        Constants.map_timer_refresh_fog_min, Constants.map_timer_refresh_fog_max, 50);
      fog_update_time.threshhold = Constants.optionsForm_threshhold_other;
      fog_update_time.addLabel(" ms", true, true);
      CheckboxFormField lock_screen = new CheckboxFormField("Lock Screen:  ");
      SubmitFormField apply = new ButtonFormField("Apply");
      apply.button.setColors(color(220), color(240, 240, 190),
        color(190, 190, 140), color(140, 140, 90), color(0));
      SubmitFormField submit = new SubmitFormField("Save Options");
      submit.button.setColors(color(220), color(240, 240, 190),
        color(190, 190, 140), color(140, 140, 90), color(0));
      SubmitFormField defaults = new ButtonFormField("Defaults");
      defaults.button.setColors(color(220), color(240, 240, 190),
        color(190, 190, 140), color(140, 140, 90), color(0));
      SubmitFormField cancel = new SubmitFormField("Cancel", false);
      cancel.button.setColors(color(220), color(240, 240, 190),
        color(190, 190, 140), color(140, 140, 90), color(0));

      this.addField(new SpacerFormField(15));
      this.addField(new MessageFormField("Volume", CENTER));
      this.addField(volume_master);
      this.addField(volume_music);
      this.addField(volume_interface);
      this.addField(volume_environment);
      this.addField(volume_units);
      this.addField(volume_player);
      this.addField(new SpacerFormField(10));
      this.addField(new MessageFormField("Display", CENTER));
      this.addField(map_move_speed);
      this.addField(inventory_bar_size);
      this.addField(map_resolution);
      this.addField(fog_update_time);
      this.addField(lock_screen);
      this.addField(new SpacerFormField(10));
      this.addField(apply);
      this.addField(new SpacerFormField(10));
      this.addField(submit);
      this.addField(new SpacerFormField(10));
      this.addField(defaults);
      this.addField(new SpacerFormField(10));
      this.addField(cancel);

      this.setFormFieldValues();
    }

     public void setFormFieldValues() {
      this.fields.get(2).setValue(global.profile.options.volume_master);
      if (global.profile.options.volume_master_muted) {
        this.fields.get(2).disable();
      }
      else {
        this.fields.get(2).enable();
      }

      this.fields.get(3).setValue(global.profile.options.volume_music);
      if (global.profile.options.volume_music_muted) {
        this.fields.get(3).disable();
      }
      else {
        this.fields.get(3).enable();
      }

      this.fields.get(4).setValue(global.profile.options.volume_interface);
      if (global.profile.options.volume_interface_muted) {
        this.fields.get(4).disable();
      }
      else {
        this.fields.get(4).enable();
      }

      this.fields.get(5).setValue(global.profile.options.volume_environment);
      if (global.profile.options.volume_environment_muted) {
        this.fields.get(5).disable();
      }
      else {
        this.fields.get(5).enable();
      }

      this.fields.get(6).setValue(global.profile.options.volume_units);
      if (global.profile.options.volume_units_muted) {
        this.fields.get(6).disable();
      }
      else {
        this.fields.get(6).enable();
      }

      this.fields.get(7).setValue(global.profile.options.volume_player);
      if (global.profile.options.volume_player_muted) {
        this.fields.get(7).disable();
      }
      else {
        this.fields.get(7).enable();
      }

      this.fields.get(10).setValue(global.profile.options.map_viewMoveSpeedFactor);

      this.fields.get(11).setValue(global.profile.options.inventory_bar_size);
      if (global.profile.options.inventory_bar_hidden) {
        this.fields.get(11).disable();
      }
      else {
        this.fields.get(11).enable();
      }

      this.fields.get(12).setValue(global.profile.options.terrain_resolution);

      this.fields.get(13).setValue(global.profile.options.fog_update_time);

      this.fields.get(14).setValue(global.profile.options.lock_screen);
    }

     public void submit() {
      this.apply();
      global.profile.save();
      this.canceled = true;
    }

     public void apply() {
      String vol_master = this.fields.get(2).getValue();
      if (vol_master.contains("disabled")) {
        global.profile.options.volume_master_muted = true;
      }
      else {
        global.profile.options.volume_master_muted = false;
      }
      global.profile.options.volume_master = toFloat(split(vol_master, ':')[0]);

      String vol_music = this.fields.get(3).getValue();
      if (vol_music.contains("disabled")) {
        global.profile.options.volume_music_muted = true;
      }
      else {
        global.profile.options.volume_music_muted = false;
      }
      global.profile.options.volume_music = toFloat(split(vol_music, ':')[0]);

      String vol_interface = this.fields.get(4).getValue();
      if (vol_interface.contains("disabled")) {
        global.profile.options.volume_interface_muted = true;
      }
      else {
        global.profile.options.volume_interface_muted = false;
      }
      global.profile.options.volume_interface = toFloat(split(vol_interface, ':')[0]);

      String vol_environment = this.fields.get(5).getValue();
      if (vol_environment.contains("disabled")) {
        global.profile.options.volume_environment_muted = true;
      }
      else {
        global.profile.options.volume_environment_muted = false;
      }
      global.profile.options.volume_environment = toFloat(split(vol_environment, ':')[0]);

      String vol_units = this.fields.get(6).getValue();
      if (vol_units.contains("disabled")) {
        global.profile.options.volume_units_muted = true;
      }
      else {
        global.profile.options.volume_units_muted = false;
      }
      global.profile.options.volume_units = toFloat(split(vol_units, ':')[0]);

      String vol_player = this.fields.get(7).getValue();
      if (vol_player.contains("disabled")) {
        global.profile.options.volume_player_muted = true;
      }
      else {
        global.profile.options.volume_player_muted = false;
      }
      global.profile.options.volume_player = toFloat(split(vol_player, ':')[0]);

      String camera_speed = this.fields.get(10).getValue();
      global.profile.options.map_viewMoveSpeedFactor = toFloat(split(camera_speed, ':')[0]);

      String hud_size = this.fields.get(11).getValue();
      if (hud_size.contains("disabled")) {
        global.profile.options.inventory_bar_hidden = true;
      }
      else {
        global.profile.options.inventory_bar_hidden = false;
      }
      global.profile.options.inventory_bar_size = toFloat(split(hud_size, ':')[0]);

      String terrain_resolution = this.fields.get(12).getValue();
      global.profile.options.terrain_resolution = round(toFloat(split(terrain_resolution, ':')[0]));

      String fog_update_time = this.fields.get(13).getValue();
      global.profile.options.fog_update_time = toFloat(split(fog_update_time, ':')[0]);

      String lock_screen = this.fields.get(14).getValue();
      global.profile.options.lock_screen = toBoolean(lock_screen);

      global.profile.options.change();
    }

     public void buttonPress(int index) {
      switch(index) {
        case 16: // apply
          this.apply();
          break;
        case 20: // defaults
          global.profile.options.defaults();
          this.setFormFieldValues();
          break;
        default:
          break;
      }
    }

     public void keyPress() {
      super.keyPress();
      if (key == 'o' && global.holding_ctrl) {
        this.cancel();
      }
    }
  }


  class AchievementsForm extends FormLNZ {
    class OpenPerkTreeButton extends RippleRectangleButton {
      OpenPerkTreeButton(float xi, float yi, float xf, float yf) {
        super(xi, yi, xf, yf);
        this.roundness = 4;
        this.show_message = true;
        this.noStroke();
        this.message = "Open Perk Tree";
        this.setColors(color(170, 170), color(1, 0), color(1, 0), color(150, 150), color(0));
        this.rippleTime = 700;
        this.text_size = 22;
      }
      @Override public 
      void drawButton() {
        super.drawButton();
        if (this.hovered) {
          noFill();
          stroke(150, 40, 40);
          strokeWeight(1);
          rectMode(CORNERS);
          rect(this.xi, this.yi, this.xf, this.yf, this.roundness);
        }
      }
      @Override public 
      void hover() {
        super.hover();
        this.color_text = color(150, 40, 40);
      }
      @Override public 
      void dehover() {
        super.dehover();
        this.color_text = color(0);
      }
      @Override public 
      void release() {
        super.release();
        if (this.hovered || this.button_focused) {
          AchievementsForm.this.submit();
        }
      }
    }

    AchievementsForm() {
      super(Constants.achievementsForm_widthOffset, Constants.achievementsForm_heightOffset,
        width - Constants.achievementsForm_widthOffset, height - Constants.achievementsForm_heightOffset);
      this.setTitleText("Achievements");
      this.setTitleSize(20);
      //this.color_background = color(180, 250, 250);
      this.color_background = color(150, 220, 220);
      this.color_header = color(50, 180, 180);
      if (global.profile == null) {
        this.canceled = true;
        return;
      }
      this.addField(new SpacerFormField(10));
      this.addField(new MessageFormField("Achievement Tokens: " + global.profile.achievement_tokens + " 〶"));
      SubmitFormField perk_tree = new SubmitFormField("");
      perk_tree.button = new OpenPerkTreeButton(0, 0, 0, 30);
      perk_tree.align_left = true;
      textSize(perk_tree.button.text_size);
      perk_tree.setButtonHeight((textAscent() + textDescent() + 4) * 1.2f);
      this.addField(perk_tree);
      this.addField(new SpacerFormField(30));
      ArrayList<MessageFormField> achievements_complete = new ArrayList<MessageFormField>();
      ArrayList<MessageFormField> achievements_incomplete = new ArrayList<MessageFormField>();
      for (AchievementCode code : AchievementCode.VALUES) {
        if (global.profile.achievements.get(code).equals(Boolean.TRUE)) {
          achievements_complete.add(new MessageFormField(code.display_name()));
        }
        else {
          achievements_incomplete.add(new MessageFormField(code.display_name()));
        }
      }
      for (MessageFormField field : achievements_complete) {
        field.text_color = color(0);
        this.addField(field);
      }
      for (MessageFormField field : achievements_incomplete) {
        field.text_color = color(170, 150);
        this.addField(field);
      }
    }

     public void submit() {
      InterfaceLNZ.this.openPlayerTree();
    }

     public void keyPress() {
      super.keyPress();
      if (key == 'a' && global.holding_ctrl) {
        this.cancel();
      }
    }
  }


  protected FormLNZ form = null;
  protected boolean return_to_esc_menu = false;
  protected boolean return_to_heroes_menu = false;
  protected PImage esc_menu_img = null;
  protected PImage heroes_menu_img = null;
  protected boolean showing_nerd_stats = false;

  InterfaceLNZ() {
  }

   public boolean escFormOpened() {
    if (this.form == null) {
      return false;
    }
    if (EscForm.class.isInstance(this.form)) {
      return true;
    }
    return false;
  }

   public void throwError(String message) {
    if (this.form != null && ErrorForm.class.isInstance(this.form)) {
      ((ErrorForm)this.form).addErrorMessage(message);
    }
    else {
      this.form = new ErrorForm(message);
    }
  }

   public void achievementsForm() {
    this.form = new AchievementsForm();
  }

   public void heroesForm() {
    this.form = new HeroesForm();
  }

   public void openHeroForm(HeroCode code) {
    if (!global.profile.heroes.containsKey(code)) {
      return;
    }
    this.return_to_heroes_menu = true;
    this.heroes_menu_img = this.form.img;
    this.form = new HeroForm(global.profile.heroes.get(code));
  }

   public void optionsForm() {
    this.form = new OptionsForm();
  }

   public void openPlayerTree() {
    if (global.profile != null && !global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.curr_viewing = true;
      global.profile.player_tree.setLocation(0, 0, width, height);
      global.profile.player_tree.setView(0, 0);
    }
  }

   public void LNZ_update(int millis) {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.setCursor("icons/cursor_white.png");
      global.profile.player_tree.update(millis);
    }
    else if (this.form == null) {
      global.defaultCursor("icons/cursor_white.png");
      this.update(millis);
    }
    else {
      global.defaultCursor("icons/cursor_white.png");
      this.form.update(millis);
      if (this.form.canceled) {
        this.form = null;
        if (this.return_to_heroes_menu) {
          this.return_to_heroes_menu = false;
          this.form = new HeroesForm();
          this.form.img = this.heroes_menu_img;
          this.heroes_menu_img = null;
        }
        else if (this.return_to_esc_menu) {
          this.return_to_esc_menu = false;
          this.form = new EscForm();
          this.form.img = this.esc_menu_img;
          this.esc_menu_img = null;
        }
        else {
          this.restartTimers();
        }
      }
    }
    if (this.showing_nerd_stats) {
      this.showNerdStats();
    }
  }

   public void LNZ_mouseMove(float mX, float mY) {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.mouseMove(mX, mY);
    }
    else if (this.form == null) {
      this.mouseMove(mX, mY);
    }
    else {
      this.form.mouseMove(mX, mY);
    }
  }

   public void LNZ_mousePress() {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.mousePress();
    }
    else if (this.form == null) {
      this.mousePress();
    }
    else {
      this.form.mousePress();
    }
  }

   public void LNZ_mouseRelease(float mX, float mY) {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.mouseRelease(mX, mY);
    }
    else if (this.form == null) {
      this.mouseRelease(mX, mY);
    }
    else {
      this.form.mouseRelease(mX, mY);
    }
  }

   public void LNZ_scroll(int amount) {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.scroll(amount);
    }
    else if (this.form == null) {
      this.scroll(amount);
    }
    else {
      this.form.scroll(amount);
    }
  }

   public void LNZ_keyPress() {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.keyPress();
    }
    else if (this.form == null) {
      this.keyPress();
      switch(key) {
        case ESC:
          this.openEscForm();
          break;
        case 'a':
        case 'A':
          if (this.form == null && global.holding_ctrl && global.profile != null) {
            this.form = new AchievementsForm();
          }
          break;
        case 'o':
        case 'O':
          if (this.form == null && global.holding_ctrl && global.profile != null) {
            this.form = new OptionsForm();
          }
          break;
        case 'h':
        case 'H':
          if (this.form == null && global.holding_ctrl && global.profile != null) {
            this.form = new HeroesForm();
          }
          break;
        case 'p':
        case 'P':
          if (global.holding_ctrl && global.profile != null) {
            this.openPlayerTree();
          }
          break;
        case 's':
        case 'S':
          if (global.holding_ctrl) {
            this.showing_nerd_stats = !this.showing_nerd_stats;
          }
          break;
      }
    }
    else {
      this.form.keyPress();
    }
  }

   public void LNZ_keyRelease() {
    if (global.profile != null && global.profile.player_tree.curr_viewing) {
      global.profile.player_tree.keyRelease();
    }
    else if (this.form == null) {
      this.keyRelease();
    }
    else {
      this.form.keyRelease();
    }
  }


   public abstract Hero getCurrentHeroIfExists();
   public abstract void saveAndExitToMainMenu();
   public abstract void loseFocus();
   public abstract void gainFocus();
   public abstract void restartTimers();
   public abstract void update(int millis);
   public abstract void showNerdStats();
   public void showDefaultNerdStats() {
    this.showDefaultNerdStats(color(0));
  }
   public void showDefaultNerdStats(int c) {
    fill(c);
    textSize(14);
    textAlign(LEFT, TOP);
    float y_stats = 1;
    float line_height = textAscent() + textDescent() + 2;
    text("FPS: " + PApplet.parseInt(global.lastFPS), 1, y_stats);
    y_stats += line_height;
    text("Active Threads: " + Thread.getAllStackTraces().size(), 1, y_stats);
    println("");
  }
   public abstract void mouseMove(float mX, float mY);
   public abstract void mousePress();
   public abstract void mouseRelease(float mX, float mY);
   public abstract void scroll(int amount);
   public abstract void keyPress();
   public abstract void openEscForm();
   public abstract void keyRelease();
}
class Inventory {

  class InventorySlot {

    class InventoryButton extends RectangleButton {
      InventoryButton() {
        this(0);
      }
      InventoryButton(float button_size) {
        super(0, 0, 0, 0);
        this.setColors(color(0, 120), color(1, 0), color(220, 70), color(220, 140), color(0));
        this.setStroke(color(142, 75, 50), 3);
        this.setSize(button_size);
        this.roundness = 0;
        this.use_time_elapsed = true;
        this.force_left_button = false;
      }

       public void setSize(float size) {
        this.setLocation(0, 0, size, size);
      }

       public void hover() {}
       public void dehover() {}
       public void click() {
        if (InventorySlot.this.item == null) {
          this.clicked = false;
        }
      }
       public void release() {}
    }


    protected InventoryButton button = new InventoryButton();
    protected Item item = null;
    protected boolean deactivated = false;
    protected float last_mX = 0;
    protected float last_mY = 0;

    InventorySlot() {
      this(0);
    }
    InventorySlot(float button_size) {
      this.button = new InventoryButton(button_size);
    }

     public void removeStack() {
      if (this.item != null) {
        this.item.removeStack();
      }
    }

     public float width() {
      return this.button.button_width();
    }
     public void setWidth(float new_width) {
      this.button.xf = new_width;
      this.button.yf = new_width;
    }

     public void update(int timeElapsed) {
      this.update(timeElapsed, true);
    }
     public void update(int timeElapsed, boolean show_slot_hovered_message) {
      if (this.deactivated) {
        return;
      }
      if (this.item != null) {
        image(this.item.getImage(), this.button.xi, this.button.yi, this.button.xf, this.button.yf);
        if (this.item.stack > 1) {
          fill(255);
          textSize(14);
          textAlign(RIGHT, BOTTOM);
          text(this.item.stack, this.button.xf - 2, this.button.yf - 2);
        }
      }
      this.button.update(timeElapsed);
      if (this.item != null && this.item.remove) {
        this.item = null;
      }
      if (this.button.hovered && this.item != null && show_slot_hovered_message) {
        textSize(20);
        float rect_height = textAscent() + textDescent() + 2;
        float rect_width = textWidth(this.item.display_name()) + 2;
        rectMode(CORNER);
        fill(global.color_nameDisplayed_background);
        stroke(1, 0);
        strokeWeight(0.1f);
        rect(this.last_mX - rect_width - 1, this.last_mY - rect_height - 1, rect_width, rect_height);
        fill(255);
        textAlign(LEFT, TOP);
        text(this.item.display_name(), this.last_mX - rect_width - 1, this.last_mY - rect_height - 1);
      }
    }

     public void mouseMove(float mX, float mY) {
      this.last_mX = mX;
      this.last_mY = mY;
      if (this.deactivated) {
        return;
      }
      this.button.mouseMove(mX, mY);
    }

     public void mousePress() {
      if (this.deactivated) {
        return;
      }
      this.button.mousePress();
    }

     public void mouseRelease(float mX, float mY) {
      if (this.deactivated) {
        return;
      }
      this.button.mouseRelease(mX, mY);
    }
  }


  protected int max_rows = 0;
  protected int max_cols = 0;
  protected ArrayList<InventorySlot> slots = new ArrayList<InventorySlot>();
  protected float button_size = 0;

  protected int color_background = global.color_inventoryBackground;

  protected float display_width = 0;
  protected float display_height = 0;

  protected boolean hovered = false;

  Inventory(int rows, int cols) {
    this(rows, cols, true);
  }
  Inventory(int rows, int cols, boolean fillup) {
    this.max_rows = rows;
    this.max_cols = cols;
    if (fillup) {
      this.fillMaxCapacity();
    }
  }

   public void clear() {
    for (InventorySlot slot : this.slots) {
      slot.item = null;
    }
  }

   public int maxCapacity() {
    return this.max_rows * this.max_cols;
  }

   public void addSlot() {
    if (this.slots.size() < this.maxCapacity()) {
      this.slots.add(new InventorySlot(this.button_size));
    }
  }

   public void addSlots(int amount) {
    int slotsLeft = this.maxCapacity() - this.slots.size();
    for (int i = 0; i < min(amount, slotsLeft); i++) {
      this.slots.add(new InventorySlot(this.button_size));
    }
  }

   public void setSlots(int amount) {
    if (amount < 0) {
      return;
    }
    if (amount > this.maxCapacity()) {
      amount = this.maxCapacity();
    }
    if (amount < this.slots.size()) {
      // remove slots
      global.errorMessage("ERROR: Can't reduce slots in inventory yet.");
    }
    else {
      this.addSlots(amount - this.slots.size());
    }
  }

   public void deactivateSlots() {
    for (InventorySlot slot : this.slots) {
      slot.deactivated = true;
    }
  }

   public void activateSlots() {
    for (InventorySlot slot : this.slots) {
      slot.deactivated = false;
    }
  }

   public void fillMaxCapacity() {
    int currSize = this.slots.size();
    int maxSize = this.maxCapacity();
    for (int i = currSize; i < maxSize; i++) {
      this.slots.add(new InventorySlot(this.button_size));
    }
  }

   public void setButtonSize(float button_size) {
    this.button_size = button_size;
    for (InventorySlot slot : this.slots) {
      slot.button.setSize(button_size);
    }
    this.refreshDisplayParameters();
  }

   public void refreshDisplayParameters() {
    this.display_width = this.button_size * this.max_cols + 4;
    this.display_height = this.button_size * this.max_rows + 4;
  }


  // stashes in open drawers for specialized inventories
   public void stashInDrawers(Item i) {
    this.stash(i);
  }

   public void stash(Item i, int ... slots) {
    for (int slot : slots) {
      if (i == null) {
        break;
      }
      i = this.placeAt(i, slot, false, true);
    }
  }

   public Item stash(Item i) {
    if (i == null || i.remove) {
      return null;
    }
    for (InventorySlot slot : this.slots) {
      if (slot.deactivated) {
        continue;
      }
      if (slot.item != null && slot.item.ID == i.ID) {
        int stack_left = slot.item.maxStack() - slot.item.stack;
        if (stack_left < 1) {
          continue;
        }
        if (i.stack > stack_left) {
          slot.item.addStack(stack_left);
          i.removeStack(stack_left);
        }
        else {
          slot.item.addStack(i.stack);
          return null;
        }
      }
    }
    for (InventorySlot slot : this.slots) {
      if (slot.deactivated) {
        continue;
      }
      if (slot.item == null) {
        slot.item = new Item(i);
        if (slot.item.remove) {
          slot.item = null;
        }
        return null;
      }
    }
    return i;
  }

   public Item placeAt(Item i, int index) {
    return this.placeAt(i, index, false);
  }
   public Item placeAt(Item i, int index, boolean replace) {
    return this.placeAt(i, index, replace, false);
  }
   public Item placeAt(Item i, int index, boolean replace, boolean ignore_deactivate) {
    if (index < 0 || index >= this.slots.size()) {
      return i;
    }
    if (!ignore_deactivate && this.slots.get(index).deactivated) {
      return i;
    }
    if (i == null || i.remove) {
      return null;
    }
    if (this.slots.get(index).item == null) {
      this.slots.get(index).item = new Item(i);
      if (this.slots.get(index).item.remove) {
        this.slots.get(index).item = null;
      }
      return null;
    }
    else if (this.slots.get(index).item.ID == i.ID) {
      int stack_left = this.slots.get(index).item.maxStack() - this.slots.get(index).item.stack;
      if (i.stack > stack_left) {
        this.slots.get(index).item.addStack(stack_left);
        i.removeStack(stack_left);
      }
      else {
        this.slots.get(index).item.addStack(i.stack);
        return null;
      }
    }
    else if (replace) {
      Item replaced = new Item(this.slots.get(index).item);
      if (replaced.remove) {
        replaced = null;
      }
      this.slots.get(index).item = new Item(i);
      if (this.slots.get(index).item.remove) {
        this.slots.get(index).item = null;
      }
      return replaced;
    }
    return i;
  }

   public ArrayList<Item> items() {
    ArrayList<Item> items = new ArrayList<Item>();
    for (InventorySlot slot : this.slots) {
      if (slot.item != null) {
        items.add(slot.item);
      }
    }
    return items;
  }


  // default 0 means default inventories can't craft anything
   public int getCraftingHashCode() {
    return 0;
  }


   public void drawBackground() {
    rectMode(CORNER);
    fill(this.color_background);
    noStroke();
    rect(0, 0, this.display_width, this.display_height);
  }

   public void update(int timeElapsed) {
    this.update(timeElapsed, true);
  }
   public void update(int timeElapsed, boolean draw_background) {
    if (draw_background) {
      this.drawBackground();
    }
    imageMode(CORNERS);
    for (int x = 0; x < this.max_cols; x++) {
      for (int y = 0; y < this.max_rows; y++) {
        int i = y * this.max_cols + x;
        if (i >= this.slots.size()) {
          break;
        }
        translate(2 + x * this.button_size, 2 + y * this.button_size);
        this.slots.get(i).update(timeElapsed);
        translate(-2 - x * this.button_size, -2 - y * this.button_size);
      }
    }
  }

   public void mouseMove(float mX, float mY) {
    if (mX + 5 < 0 || mY + 5 < 0 || mX - 5 > this.display_width || mY - 5 > this.display_height) {
      this.hovered = false;
    }
    else {
      this.hovered = true;
    }
    for (int x = 0; x < this.max_cols; x++) {
      for (int y = 0; y < this.max_rows; y++) {
        int i = y * this.max_cols + x;
        if (i >= this.slots.size()) {
          break;
        }
        this.slots.get(i).mouseMove(mX - 2 - x * this.button_size, mY - 2 - y * this.button_size);
      }
    }
  }

   public void mousePress() {
    for (InventorySlot slot : this.slots) {
      slot.mousePress();
    }
  }

   public void mouseRelease(float mX, float mY) {
    for (int x = 0; x < this.max_cols; x++) {
      for (int y = 0; y < this.max_rows; y++) {
        int i = y * this.max_cols + x;
        if (i >= this.slots.size()) {
          break;
        }
        this.slots.get(i).mouseRelease(mX - 2 - x * this.button_size, mY - 2 - y * this.button_size);
      }
    }
  }


   public String fileString() {
    String fileString = "\nnew: Inventory: " + this.max_rows + ", " + this.max_cols;
    for (int i = 0; i < this.slots.size(); i++) {
      fileString += "\naddSlot:";
      if (this.slots.get(i).item != null) {
        fileString += this.slots.get(i).item.fileString() + ": " + i;
      }
    }
    fileString += "\nend: Inventory";
    return fileString;
  }

   public String internalFileString() {
    String fileString = "";
    for (int i = 0; i < this.slots.size(); i++) {
      if (this.slots.get(i).item != null) {
        fileString += this.slots.get(i).item.fileString() + ": " + i;
      }
    }
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "addSlot":
        this.addSlot();
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for inventory data.");
        break;
    }
  }
}


class DeskInventory extends Inventory {
  class DrawerButton1 extends ImageButton {
    protected boolean opened = false;
    DrawerButton1() {
      super(global.images.getImage("features/desk_drawer1_closed.png"), 0, 0, 0, 0);
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        DeskInventory.this.slots.get(0).deactivated = true;
        DeskInventory.this.slots.get(1).deactivated = true;
        this.moveButton(0, -DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer1_close");
        this.img = global.images.getImage("features/desk_drawer1_closed.png");
      }
      else {
        this.opened = true;
        DeskInventory.this.slots.get(0).deactivated = false;
        DeskInventory.this.slots.get(1).deactivated = false;
        this.moveButton(0, DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer1_open");
        this.img = global.images.getImage("features/desk_drawer1_opened.png");
      }
    }
     public void dehover() {}
     public void release() {}
  }

  class DrawerButton2 extends ImageButton {
    protected boolean opened = false;
    DrawerButton2() {
      super(global.images.getImage("features/desk_drawer2_closed.png"), 0, 0, 0, 0);
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        DeskInventory.this.slots.get(2).deactivated = true;
        this.moveButton(-DeskInventory.this.button_size, -0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_close");
        this.img = global.images.getImage("features/desk_drawer2_closed.png");
      }
      else {
        this.opened = true;
        DeskInventory.this.slots.get(2).deactivated = false;
        this.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_open");
        this.img = global.images.getImage("features/desk_drawer2_opened.png");
      }
    }
     public void dehover() {}
     public void release() {}
  }

  class DrawerButton3 extends ImageButton {
    protected boolean opened = false;
    DrawerButton3() {
      super(global.images.getImage("features/desk_drawer3_closed.png"), 0, 0, 0, 0);
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        DeskInventory.this.slots.get(5).deactivated = true;
        this.moveButton(-DeskInventory.this.button_size, -0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_close");
        this.img = global.images.getImage("features/desk_drawer3_closed.png");
      }
      else {
        this.opened = true;
        DeskInventory.this.slots.get(5).deactivated = false;
        this.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_open");
        this.img = global.images.getImage("features/desk_drawer2_opened.png");
      }
    }
     public void dehover() {}
     public void release() {}
  }

  class DrawerButton4 extends ImageButton {
    protected boolean opened = false;
    DrawerButton4() {
      super(global.images.getImage("features/desk_drawer4_closed.png"), 0, 0, 0, 0);
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        DeskInventory.this.slots.get(8).deactivated = true;
        this.moveButton(-DeskInventory.this.button_size, -0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_close");
        this.img = global.images.getImage("features/desk_drawer4_closed.png");
      }
      else {
        this.opened = true;
        DeskInventory.this.slots.get(8).deactivated = false;
        this.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
        global.sounds.trigger_environment("features/desk_drawer2_open");
        this.img = global.images.getImage("features/desk_drawer2_opened.png");
      }
    }
     public void dehover() {}
     public void release() {}
  }

  protected DrawerButton1 top_drawer = new DrawerButton1();
  protected DrawerButton2 mid_drawer = new DrawerButton2();
  protected DrawerButton3 mid_drawer2 = new DrawerButton3();
  protected DrawerButton4 bottom_drawer = new DrawerButton4();

  DeskInventory() {
    super(3, 3, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }


  // stashes in closed drawers for specialized inventories
   public void stashInDrawers(Item i) {
    this.stash(i, 0, 1, 2, 5, 8);
  }

   public void closeDrawers() {
    this.top_drawer.opened = false;
    this.mid_drawer.opened = false;
    this.bottom_drawer.opened = false;
    this.top_drawer.img = global.images.getImage("features/desk_drawer1_closed.png");
    this.mid_drawer.img = global.images.getImage("features/desk_drawer2_closed.png");
    this.mid_drawer2.img = global.images.getImage("features/desk_drawer3_closed.png");
    this.bottom_drawer.img = global.images.getImage("features/desk_drawer4_closed.png");
    this.deactivateSlots();
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.top_drawer.setLocation(2, 2, 2 + 2 * button_size, 2 + this.button_size);
    if (this.top_drawer.opened) {
      this.top_drawer.moveButton(0, DeskInventory.this.button_size);
    }
    this.mid_drawer.setLocation(2 + 2 * button_size, 2, 2 + 3 * button_size, 2 + this.button_size);
    if (this.mid_drawer.opened) {
      this.mid_drawer.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
    }
    this.mid_drawer2.setLocation(2 + 2 * button_size, 2 + button_size, 2 + 3 * button_size, 2 + 2 * this.button_size);
    if (this.mid_drawer2.opened) {
      this.mid_drawer2.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
    }
    this.bottom_drawer.setLocation(2 + 2 * button_size, 2 + 2 * button_size, 2 + 3 * button_size, 2 + 3 * this.button_size);
    if (this.bottom_drawer.opened) {
      this.bottom_drawer.moveButton(DeskInventory.this.button_size, 0.3f * DeskInventory.this.button_size);
    }
  }

  @Override public 
  void update(int millis) {
    this.drawBackground();
    imageMode(CORNERS);
    image(global.images.getImage("features/desk_inventory.png"), 0, 0, this.display_width, this.display_height);
    if (top_drawer.opened) {
      this.top_drawer.update(millis);
    }
    if (mid_drawer.opened) {
      this.mid_drawer.update(millis);
    }
    if (mid_drawer2.opened) {
      this.mid_drawer2.update(millis);
    }
    if (bottom_drawer.opened) {
      this.bottom_drawer.update(millis);
    }
    super.update(millis, false);
    if (!top_drawer.opened) {
      this.top_drawer.update(millis);
    }
    if (!mid_drawer.opened) {
      this.mid_drawer.update(millis);
    }
    if (!mid_drawer2.opened) {
      this.mid_drawer2.update(millis);
    }
    if (!bottom_drawer.opened) {
      this.bottom_drawer.update(millis);
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.top_drawer.mouseMove(mX, mY);
    this.mid_drawer.mouseMove(mX, mY);
    this.mid_drawer2.mouseMove(mX, mY);
    this.bottom_drawer.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.top_drawer.mousePress();
    this.mid_drawer.mousePress();
    this.mid_drawer2.mousePress();
    this.bottom_drawer.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.top_drawer.mouseRelease(mX, mY);
    this.mid_drawer.mouseRelease(mX, mY);
    this.mid_drawer2.mouseRelease(mX, mY);
    this.bottom_drawer.mouseRelease(mX, mY);
  }
}


class StoveInventory extends Inventory {
  class StoveDoor extends ImageButton {
    protected boolean opened = false;
    StoveDoor() {
      super(global.images.getImage("features/default.png"), 0, 0, 0, 0);
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        return;
      }
      this.opened = true;
      StoveInventory.this.slots.get(26).deactivated = false;
      StoveInventory.this.slots.get(27).deactivated = false;
      StoveInventory.this.slots.get(28).deactivated = false;
      StoveInventory.this.slots.get(31).deactivated = false;
      StoveInventory.this.slots.get(32).deactivated = false;
      StoveInventory.this.slots.get(33).deactivated = false;
      this.img = global.images.getTransparentPixel();
    }
     public void dehover() {}
     public void release() {}
  }

  abstract class KnobButton extends ImageButton {
    protected int value = 0;
    protected int max_value = 0;
    KnobButton(PImage img, int max_value) {
      super(img, 0, 0, 0, 0);
      this.max_value = max_value;
      this.force_left_button = false;
    }

    @Override public 
    void drawButton() {
      super.drawButton();
      imageMode(CENTER);
      translate(this.xCenter(), this.yCenter());
      float curr_rotation = this.knobRotation();
      rotate(curr_rotation);
      image(global.images.getImage("features/stove_knob.png"), 0, 0,
        0.7f * this.button_width(), 0.7f * this.button_height());
      rotate(-curr_rotation);
      translate(-this.xCenter(), -this.yCenter());
    }

    @Override public 
    void mouseMove(float mX, float mY) {
      super.mouseMove(mX, mY);
      if (this.clicked) {
        // rotate (??)
      }
    }

     public abstract float knobRotation();

     public void hover() {}
     public void click() {}
     public void dehover() {}
     public void release() {}
  }

  abstract class KnobButtonBurner extends KnobButton {
    KnobButtonBurner() {
      super(global.images.getImage("features/stove_knob_burner.png"), 6);
    }

     public float knobRotation() {
      switch(this.value) {
        case 0:
          return 0;
        case 1:
          return 0;
        case 2:
          return 0;
        case 3:
          return 0;
        case 4:
          return 0;
        case 5:
          return 0;
        case 6:
          return 0;
        default:
          global.errorMessage("ERROR: Knob value " + this.value +" invalid for BurnerKnob.");
          return 0;
      }
    }
  }

  class Burner1 extends KnobButtonBurner {
    Burner1() {
      super();
    }
  }

  class Burner2 extends KnobButtonBurner {
    Burner2() {
      super();
    }
  }

  class Burner3 extends KnobButtonBurner {
    Burner3() {
      super();
    }
  }

  class Burner4 extends KnobButtonBurner {
    Burner4() {
      super();
    }
  }

  class OvenKnob extends KnobButton {
    OvenKnob() {
      super(global.images.getImage("features/stove_knob_oven.png"), 9);
    }

     public float knobRotation() {
      switch(this.value) {
        case 0:
          return 0;
        case 1:
          return 0;
        case 2:
          return 0;
        case 3:
          return 0;
        case 4:
          return 0;
        case 5:
          return 0;
        case 6:
          return 0;
        case 7:
          return 0;
        case 8:
          return 0;
        case 9:
          return 0;
        default:
          global.errorMessage("ERROR: Knob value " + this.value + " invalid for OvenKnob.");
          return 0;
      }
    }
  }

  protected StoveDoor door = new StoveDoor();
  protected KnobButton[] knobs = new KnobButton[5];

  StoveInventory() {
    super(8, 5, true);
    this.deactivateSlots();
    this.slots.get(1).deactivated = false;
    this.slots.get(3).deactivated = false;
    this.slots.get(11).deactivated = false;
    this.slots.get(13).deactivated = false;
    this.knobs[0] = new Burner1();
    this.knobs[1] = new Burner2();
    this.knobs[2] = new OvenKnob();
    this.knobs[3] = new Burner3();
    this.knobs[4] = new Burner4();
    this.setButtonSize(this.button_size);
  }

   public void closeDrawers() {
    this.door.opened = false;
    this.slots.get(26).deactivated = true;
    this.slots.get(27).deactivated = true;
    this.slots.get(28).deactivated = true;
    this.slots.get(31).deactivated = true;
    this.slots.get(32).deactivated = true;
    this.slots.get(33).deactivated = true;
    this.door.img = global.images.getImage("features/default.png");
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.door.setLocation(2 + button_size, 2 + 5 * button_size,
      2 + 4 * button_size, 2 + 7 * this.button_size);
    for (int i = 0; i < this.knobs.length; i++) {
      this.knobs[i].setLocation(2 + i * button_size, 2 + 3.5f * button_size,
        2 + (i + 1) * button_size, 2 + 4.5f * button_size);
    }
  }

  @Override public 
  void update(int millis) {
    super.update(millis);
    this.door.update(millis);
    for (KnobButton knob : this.knobs) {
      knob.update(millis);
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.door.mouseMove(mX, mY);
    for (KnobButton knob : this.knobs) {
      knob.mouseMove(mX, mY);
    }
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.door.mousePress();
    for (KnobButton knob : this.knobs) {
      knob.mousePress();
    }
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.door.mouseRelease(mX, mY);
    for (KnobButton knob : this.knobs) {
      knob.mouseRelease(mX, mY);
    }
  }
}


class MinifridgeInventory extends Inventory {
  class MinifridgeButton extends RectangleButton {
    protected boolean opened = false;
    MinifridgeButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        MinifridgeInventory.this.deactivateSlots();
        this.moveButton(-2 * MinifridgeInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/minifridge_close");
      }
      else {
        this.opened = true;
        MinifridgeInventory.this.activateSlots();
        this.moveButton(2 * MinifridgeInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/minifridge_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }

  protected MinifridgeButton button = new MinifridgeButton();

  MinifridgeInventory() {
    super(2, 2, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.button.setLocation(2, 2, 2 + 2 * button_size, 2 + 2 * button_size);
    if (this.button.opened) {
      this.button.moveButton(2 * button_size, 0);
    }
  }

  @Override public 
  void update(int millis) {
    PImage closed_img = global.images.getImage("features/minifridge_closed.png");
    float display_w = this.display_height * PApplet.parseFloat(closed_img.width) / closed_img.height;
    if (button.opened) {
      imageMode(CORNER);
      PImage open_img = global.images.getImage("features/minifridge_opened.png");
      float left_side = 0.5f * (this.display_width - display_w);
      float open_display_w = this.display_height * PApplet.parseFloat(open_img.width) / open_img.height;
      image(open_img, left_side, 0, open_display_w, this.display_height);
    }
    super.update(millis, false);
    if (!button.opened) {
      imageMode(CENTER);
      image(closed_img, 0.5f * this.display_width, 0.5f * this.display_height, display_w, this.display_height);
    }
    this.button.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.button.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.button.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.button.mouseRelease(mX, mY);
  }
}


class RefridgeratorInventory extends Inventory {
  class FridgeButton extends RectangleButton {
    protected boolean opened = false;
    FridgeButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        RefridgeratorInventory.this.slots.get(4).deactivated = true;
        RefridgeratorInventory.this.slots.get(5).deactivated = true;
        RefridgeratorInventory.this.slots.get(6).deactivated = true;
        RefridgeratorInventory.this.slots.get(7).deactivated = true;
        RefridgeratorInventory.this.slots.get(8).deactivated = true;
        RefridgeratorInventory.this.slots.get(9).deactivated = true;
        this.moveButton(-2 * RefridgeratorInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/fridge_close");
      }
      else {
        this.opened = true;
        RefridgeratorInventory.this.slots.get(4).deactivated = false;
        RefridgeratorInventory.this.slots.get(5).deactivated = false;
        RefridgeratorInventory.this.slots.get(6).deactivated = false;
        RefridgeratorInventory.this.slots.get(7).deactivated = false;
        RefridgeratorInventory.this.slots.get(8).deactivated = false;
        RefridgeratorInventory.this.slots.get(9).deactivated = false;
        this.moveButton(2 * RefridgeratorInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/fridge_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }


  class FreezerButton extends RectangleButton {
    protected boolean opened = false;
    FreezerButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        RefridgeratorInventory.this.slots.get(0).deactivated = true;
        RefridgeratorInventory.this.slots.get(1).deactivated = true;
        RefridgeratorInventory.this.slots.get(2).deactivated = true;
        RefridgeratorInventory.this.slots.get(3).deactivated = true;
        this.moveButton(-2 * RefridgeratorInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/freezer_close");
      }
      else {
        this.opened = true;
        RefridgeratorInventory.this.slots.get(0).deactivated = false;
        RefridgeratorInventory.this.slots.get(1).deactivated = false;
        RefridgeratorInventory.this.slots.get(2).deactivated = false;
        RefridgeratorInventory.this.slots.get(3).deactivated = false;
        this.moveButton(2 * RefridgeratorInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/freezer_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }

  protected FridgeButton fridge = new FridgeButton();
  protected FreezerButton freezer = new FreezerButton();
  protected int freezer_sound_left = 0;
  protected float offset = 0;

  RefridgeratorInventory() {
    super(5, 2, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.fridge.setLocation(2, 2 + 2 * button_size, 2 + 2 * button_size, 2 + 5 * button_size);
    this.freezer.setLocation(2, 2, 2 + 2 * button_size, 2 + 2 * button_size);
    if (this.fridge.opened) {
      this.fridge.moveButton(2 * button_size, 0);
    }
    if (this.freezer.opened) {
      this.freezer.moveButton(2 * button_size, 0);
    }
  }

  @Override public 
  void update(int time_elapsed) {
    PImage freezer_closed_img = global.images.getImage("features/freezer_closed.png");
    float display_w = 0.4f * this.display_height * PApplet.parseFloat(freezer_closed_img.width) / freezer_closed_img.height;
    PImage fridge_closed_img = global.images.getImage("features/fridge_closed.png");
    float fridge_display_h = display_w * PApplet.parseFloat(fridge_closed_img.height) / fridge_closed_img.width;
    this.offset = min(0, 0.6f * this.display_height - fridge_display_h);
    translate(0, this.offset);
    if (fridge.opened) {
      imageMode(CORNER);
      float left_side = 0.5f * (this.display_width - display_w);
      PImage open_img = global.images.getImage("features/fridge_opened.png");
      float open_display_w = 1.1285f * fridge_display_h * PApplet.parseFloat(open_img.width) / open_img.height;
      image(open_img, left_side, 0.4f * this.display_height, open_display_w, 1.1285f * fridge_display_h);
    }
    if (freezer.opened) {
      imageMode(CORNER);
      float left_side = 0.5f * (this.display_width - display_w);
      PImage open_img = global.images.getImage("features/freezer_opened.png");
      float open_display_w = 1.14935f * 0.4f * this.display_height * PApplet.parseFloat(open_img.width) / open_img.height;
      image(open_img, left_side, - 0.14935f * 0.4f * this.display_height, open_display_w, 1.14935f * 0.4f * this.display_height);
      this.freezer_sound_left -= time_elapsed;
      if (this.freezer_sound_left < 10) {
        global.sounds.trigger_environment("features/freezer_ambience");
        this.freezer_sound_left = 3250;
      }
    }
    super.update(time_elapsed, false);
    if (!fridge.opened) {
      imageMode(CORNER);
      image(fridge_closed_img, 0.5f * (this.display_width - display_w), 0.4f * this.display_height, display_w, fridge_display_h);
    }
    if (!freezer.opened) {
      imageMode(CORNER);
      image(freezer_closed_img, 0.5f * (this.display_width - display_w), 0, display_w, 0.4f * this.display_height);
      global.sounds.silence_environment("features/freezer_ambience");
      this.freezer_sound_left = 0;
    }
    this.fridge.update(time_elapsed);
    this.freezer.update(time_elapsed);
    translate(0, -this.offset);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    mY -= this.offset;
    super.mouseMove(mX, mY);
    this.fridge.mouseMove(mX, mY);
    this.freezer.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.fridge.mousePress();
    this.freezer.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.fridge.mouseRelease(mX, mY);
    this.freezer.mouseRelease(mX, mY);
  }
}


class WasherInventory extends Inventory {
  class WasherButton extends RectangleButton {
    protected boolean opened = false;
    WasherButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        WasherInventory.this.slots.get(5).deactivated = true;
        WasherInventory.this.slots.get(6).deactivated = true;
        WasherInventory.this.slots.get(9).deactivated = true;
        WasherInventory.this.slots.get(10).deactivated = true;
        this.moveButton(2 * WasherInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/washer_close");
      }
      else {
        this.opened = true;
        WasherInventory.this.slots.get(5).deactivated = false;
        WasherInventory.this.slots.get(6).deactivated = false;
        WasherInventory.this.slots.get(9).deactivated = false;
        WasherInventory.this.slots.get(10).deactivated = false;
        this.moveButton(-2 * WasherInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/washer_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }

  protected WasherButton button = new WasherButton();

  WasherInventory() {
    super(4, 4, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.button.setLocation(2 + button_size, 2 + button_size, 2 + 3 * button_size, 2 + 3 * button_size);
    if (this.button.opened) {
      this.button.moveButton(-2 * button_size, 0);
    }
  }

  @Override public 
  void update(int millis) {
    if (button.opened) {
      imageMode(CORNER);
      PImage open_img = global.images.getImage("features/washer_opened.png");
      PImage closed_img = global.images.getImage("features/washer_closed.png");
      float right_side = 0.5f * this.display_height * (1 + PApplet.parseFloat(closed_img.width) / closed_img.height);
      float display_w = this.display_width * PApplet.parseFloat(open_img.width) / open_img.height;
      image(open_img, right_side - display_w, 0, display_w, this.display_height);
    }
    super.update(millis, false);
    if (!button.opened) {
      imageMode(CENTER);
      PImage closed_img = global.images.getImage("features/washer_closed.png");
      float display_w = this.display_height * PApplet.parseFloat(closed_img.width) / closed_img.height;
      image(closed_img, 0.5f * this.display_width, 0.5f * this.display_height, display_w, this.display_height);
    }
    this.button.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.button.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.button.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.button.mouseRelease(mX, mY);
  }
}


class DryerInventory extends Inventory {
  class DryerButton extends RectangleButton {
    protected boolean opened = false;
    DryerButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        DryerInventory.this.slots.get(5).deactivated = true;
        DryerInventory.this.slots.get(6).deactivated = true;
        DryerInventory.this.slots.get(9).deactivated = true;
        DryerInventory.this.slots.get(10).deactivated = true;
        this.moveButton(-2 * DryerInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/dryer_close");
      }
      else {
        this.opened = true;
        DryerInventory.this.slots.get(5).deactivated = false;
        DryerInventory.this.slots.get(6).deactivated = false;
        DryerInventory.this.slots.get(9).deactivated = false;
        DryerInventory.this.slots.get(10).deactivated = false;
        this.moveButton(2 * DryerInventory.this.button_size, 0);
        global.sounds.trigger_environment("features/dryer_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }

  protected DryerButton button = new DryerButton();

  DryerInventory() {
    super(4, 4, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.button.setLocation(2 + button_size, 2 + button_size, 2 + 3 * button_size, 2 + 3 * button_size);
    if (this.button.opened) {
      this.button.moveButton(2 * button_size, 0);
    }
  }

  @Override public 
  void update(int millis) {
    PImage closed_img = global.images.getImage("features/dryer_closed.png");
    float display_w = this.display_height * PApplet.parseFloat(closed_img.width) / closed_img.height;
    if (button.opened) {
      imageMode(CORNER);
      PImage open_img = global.images.getImage("features/dryer_opened.png");
      float left_side = 0.5f * (this.display_width - display_w);
      float open_display_w = this.display_width * PApplet.parseFloat(open_img.width) / open_img.height;
      image(open_img, left_side, 0, open_display_w, this.display_height);
    }
    super.update(millis, false);
    if (!button.opened) {
      imageMode(CENTER);
      image(closed_img, 0.5f * this.display_width, 0.5f * this.display_height, display_w, this.display_height);
    }
    this.button.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.button.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.button.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.button.mouseRelease(mX, mY);
  }
}


class MicrowaveInventory extends Inventory {
  class MicrowaveButton extends RectangleButton {
    protected boolean opened = false;
    MicrowaveButton() {
      super(0, 0, 0, 0);
      this.setColors(color(1, 0), color(1, 0), color(120, 30), color(120, 30), color(1, 0));
      this.noStroke();
      this.force_left_button = false;
    }

     public void hover() {}
     public void click() {
      if (this.opened) {
        this.opened = false;
        MicrowaveInventory.this.slots.get(4).deactivated = true;
        this.setXLocation(-MicrowaveInventory.this.button_size + MicrowaveInventory.
          this.image_offset, 2 + 2 * MicrowaveInventory.this.button_size +
          MicrowaveInventory.this.image_offset);
        global.sounds.trigger_environment("features/microwave_close");
      }
      else {
        this.opened = true;
        MicrowaveInventory.this.slots.get(4).deactivated = false;
        this.setXLocation(-1.5f * MicrowaveInventory.this.button_size +
          MicrowaveInventory.this.image_offset, -0.5f * MicrowaveInventory.
          this.button_size + MicrowaveInventory.this.image_offset);
        global.sounds.trigger_environment("features/microwave_open");
      }
      this.hovered = false;
      this.clicked = false;
    }
     public void dehover() {}
     public void release() {}
  }

  protected MicrowaveButton button = new MicrowaveButton();
  protected float image_offset = 0;

  MicrowaveInventory() {
    super(3, 3, true);
    this.deactivateSlots();
    this.setButtonSize(this.button_size);
  }

  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.image_offset = 0.5f * button_size;
    this.button.setLocation(-button_size + this.image_offset, 2, 2 + 2 *
      button_size + this.image_offset, 2 + 3 * button_size);
    if (this.button.opened) {
      this.button.setLocation(-1.5f * button_size + this.image_offset, 2, -0.5f *
        button_size + this.image_offset, 2 + 3 * button_size);
    }
  }

  @Override public 
  void update(int millis) {
    PImage opened_img = global.images.getImage("features/microwave_opened.png");
    PImage closed_img = global.images.getImage("features/microwave_closed.png");
    float closed_display_w = this.display_height * PApplet.parseFloat(closed_img.width) / closed_img.height;
    float opened_display_w = closed_display_w * PApplet.parseFloat(opened_img.width) / closed_img.width;
    float right_side = 0.5f * (this.display_width + closed_display_w);
    if (button.opened) {
      imageMode(CORNERS);
      float display_h = this.display_height * PApplet.parseFloat(opened_img.height) / closed_img.height;
      image(opened_img, right_side - opened_display_w + this.image_offset, 0,
        right_side + this.image_offset, display_h);
    }
    super.update(millis, false);
    if (!button.opened) {
      imageMode(CORNERS);
      image(closed_img, right_side - closed_display_w + this.image_offset, 0,
        right_side + this.image_offset, this.display_height);
    }
    this.button.update(millis);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.button.mouseMove(mX, mY);
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.button.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.button.mouseRelease(mX, mY);
  }
}


class GarbageInventory extends Inventory {
  protected int drop_time = 100;
  GarbageInventory() {
    super(4, 1, true);
  }

  @Override public 
  void update(int timeElapsed) {
    super.update(timeElapsed);
    this.drop_time -= timeElapsed;
    if (this.drop_time < 0) {
      this.drop_time += 100;
      this.makeItemsFall();
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    this.dehoverBottomItems();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.dehoverBottomItems();
  }

   public void makeItemsFall() {
    for (int i = 0; i < this.slots.size() - 1; i++) {
      if (this.slots.get(i).item != null && this.slots.get(i+1).item == null) {
        this.slots.get(i+1).item = this.slots.get(i).item;
        this.slots.get(i).item = null;
        i++;
      }
    }
  }

   public void dehoverBottomItems() {
    boolean found_item = false;
    for (int i = 0; i < this.slots.size(); i++) {
      if (found_item) {
        this.slots.get(i).button.hovered = false;
      }
      else if (this.slots.get(i).item != null) {
        found_item = true;
      }
    }
  }
}


class RecycleInventory extends GarbageInventory {
  RecycleInventory() {
    super();
  }
}


class CrateInventory extends Inventory {
  CrateInventory() {
    super(2, 2, true);
  }
}


class CardboardBoxInventory extends Inventory {
  CardboardBoxInventory() {
    super(2, 2, true);
  }
}


class WorkbenchInventory extends Inventory {
  class CraftButton extends RectangleButton {
    protected int craft_timer = 0;

    CraftButton() {
      super(0, 0, 0, 0);
      this.disabled = true;
      this.show_message = true;
      this.force_left_button = false;
      this.message = "Craft";
      this.use_time_elapsed = true;
      this.noStroke();
      this.setColors(color(170, 170), color(1, 0), color(200, 100), color(200,
        200), color(0));
    }

    @Override public 
    void update(int timeElapsed) {
      super.update(timeElapsed);
      if (this.clicked && mouseButton == RIGHT) {
        this.craft_timer -= timeElapsed;
        if (this.craft_timer < 0) {
          this.craft_timer = Constants.hero_multicraftTimer;
          this.release();
        }
      }
    }

     public void dehover() {}
     public void hover() {}
     public void click() {
      this.craft_timer = Constants.hero_multicraftTimer;
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      if (WorkbenchInventory.this.craftable_item == null) {
        return;
      }
      WorkbenchInventory.this.craft();
    }
  }


  class ToolsButton extends RectangleButton {
    class ToolsButtonTextBox extends TextBox {
      ToolsButtonTextBox() {
        super(0, 0, 0, 0);
        this.setTitleSize(19);
        this.setTextSize(17);
        this.color_background = global.color_nameDisplayed_background;
        this.color_header = global.color_nameDisplayed_background;
        this.color_stroke = color(1, 0);
        this.color_text = color(255);
        this.color_title = color(255);
        this.scrollbar.setButtonColors(color(170),
          adjust_color_brightness(global.color_nameDisplayed_background, 1.1f),
          adjust_color_brightness(global.color_nameDisplayed_background, 1.2f),
          adjust_color_brightness(global.color_nameDisplayed_background, 0.95f), color(0));
        this.scrollbar.button_upspace.setColors(color(1, 0), color(1, 0),
          color(1, 0), color(0), color(0));
        this.scrollbar.button_downspace.setColors(color(1, 0), color(1, 0),
          color(1, 0), color(0), color(0));
        this.useElapsedTime();
      }
    }

    protected ToolsButtonTextBox description = new ToolsButtonTextBox();

    ToolsButton() {
      super(0, 0, 0, 0);
      this.show_message = true;
      this.force_left_button = false;
      this.message = "Tools";
      this.use_time_elapsed = true;
      this.noStroke();
      this.setColors(color(170, 170), color(1, 0), color(200, 100), color(200, 200), color(0));
    }

     public void update(int timeElapsed) {
      super.update(timeElapsed);
      if (this.hovered) {
        String message_text = "";
        if (WorkbenchInventory.this.slots.get(4).item != null) {
          message_text += WorkbenchInventory.this.slots.get(4).item.display_name() + " Will Add:";
          for (ToolCode code : ToolCode.toolCodesFrom(WorkbenchInventory.this.slots.get(4).item)) {
            message_text += "\n - " + code.displayName();
          }
          message_text += "\n\n";
        }
        if (WorkbenchInventory.this.crafting_recipe != null) {
          message_text += "Tools Needed:";
          for (ToolCode code : WorkbenchInventory.this.crafting_recipe.tools) {
            message_text += "\n - " + code.displayName();
          }
          message_text += "\n\n";
        }
        message_text += "Tools Have:";
        for (ToolCode code : WorkbenchInventory.this.currentTools()) {
          message_text += "\n - " + code.displayName();
        }
        String title_text = "Workbench";
        if (WorkbenchInventory.this.craftable_item != null) {
          title_text = WorkbenchInventory.this.craftable_item.display_name();
        }
        textSize(this.description.text_size);
        float description_width = max(Constants.feature_workbenchMinimumToolsButtonWidth, textWidth(title_text) + 2);
        this.description.setXLocation(this.xf - description_width, this.xf);
        float description_height = textAscent() + textDescent() + 6;
        this.description.setTitleText(title_text);
        this.description.setText(message_text);
        description_height += (2 + this.description.text_lines.size()) *
          (textAscent() + textDescent() + this.description.text_leading);
        this.description.setYLocation(this.yi - description_height, this.yi);
        this.description.update(timeElapsed);
      }
    }

     public void dehover() {
      this.message = "Tools";
    }
     public void hover() {
      if (WorkbenchInventory.this.slots.get(4).item != null) {
        this.message = "Add\nTool";
      }
    }
     public void click() {}
     public void release() {
      if (!this.hovered) {
        return;
      }
      Item i = WorkbenchInventory.this.slots.get(4).item;
      if (i == null || i.remove) {
        return;
      }
      ArrayList<ToolCode> codes = ToolCode.toolCodesFrom(i);
      boolean has_all = true;
      ArrayList<ToolCode> tool_list = WorkbenchInventory.this.currentTools();
      for (ToolCode code : codes) {
        if (!tool_list.contains(code)) {
          has_all = false;
          break;
        }
      }
      if (has_all) {
        return;
      }
      WorkbenchInventory.this.f.items.add(new Item(i));
      WorkbenchInventory.this.slots.get(4).item = null;
      i.remove = true;
    }
  }


  private int curr_crafting_hash_code = 0;
  private Item craftable_item = null;
  private CraftingRecipe crafting_recipe = null;
  private boolean craftable_item_hovered = false;
  protected float last_mX = 0;
  protected float last_mY = 0;
  private CraftButton craft = new CraftButton();
  private ToolsButton tools = new ToolsButton();
  private Feature f;

  WorkbenchInventory(Feature f) {
    super(3, 6, true);
    this.f = f;
    this.deactivateSlots();
    this.slots.get(0).deactivated = false;
    this.slots.get(1).deactivated = false;
    this.slots.get(2).deactivated = false;
    this.slots.get(4).deactivated = false;
    this.slots.get(6).deactivated = false;
    this.slots.get(7).deactivated = false;
    this.slots.get(8).deactivated = false;
    this.slots.get(12).deactivated = false;
    this.slots.get(13).deactivated = false;
    this.slots.get(14).deactivated = false;
  }


   public ArrayList<ToolCode> currentTools() {
    return ToolCode.toolCodesFrom(this.currentToolItems().toArray(new Item[0]));
  }

   public ArrayList<Item> currentToolItems() {
    if (this.f.items == null) {
      return new ArrayList<Item>();
    }
    return this.f.items;
  }


   public void craft() {
    if (this.craftable_item == null) {
      return;
    }
    if (this.slots.get(11).item != null && (this.slots.get(11).item.ID !=
      this.craftable_item.ID || this.slots.get(11).item.maxStack() - this.
      slots.get(11).item.stack < this.craftable_item.stack)) {
      return;
    }
    if (!this.crafting_recipe.hasTools(this.currentTools())) {
      return;
    }
    this.crafting_recipe.useTools(this.currentToolItems());
    this.slots.get(0).removeStack();
    this.slots.get(1).removeStack();
    this.slots.get(2).removeStack();
    this.slots.get(6).removeStack();
    this.slots.get(7).removeStack();
    this.slots.get(8).removeStack();
    this.slots.get(12).removeStack();
    this.slots.get(13).removeStack();
    this.slots.get(14).removeStack();
    if (this.slots.get(11).item == null) {
      this.slots.get(11).item = new Item(this.craftable_item);
    }
    else {
      this.slots.get(11).item.addStack(this.craftable_item.stack);
    }
    this.slots.get(11).deactivated = false;
    this.craftable_item = null;
  }


  @Override public 
  void setButtonSize(float button_size) {
    super.setButtonSize(button_size);
    this.slots.get(4).button.moveButton(0.5f * button_size, 0);
    this.craft.setLocation(2 + 3.5f * button_size, 2 + 2.1f * button_size,
      2 + 5 * button_size, 2 + 2.9f * button_size);
    this.craft.text_size = button_size * 0.35f;
    this.tools.setLocation(2 + 3.5f * button_size, 2, 2 + 4.5f * button_size, 2 + button_size);
    this.tools.text_size = button_size * 0.35f;
  }

  @Override public 
  void update(int timeElapsed) {
    if (!this.slots.get(11).deactivated && this.slots.get(11).item == null) {
      this.slots.get(11).deactivated = true;
      this.slots.get(11).button.hovered = false;
      this.slots.get(11).button.clicked = false;
    }
    super.update(timeElapsed);
    this.curr_crafting_hash_code = this.getCraftingHashCode();
    imageMode(CORNER);
    if (this.slots.get(4).item == null) {
      image(global.images.getImage("icons/tool.png"), 2 + 4.5f * this.button_size,
        2, this.button_size, this.button_size);
    }
    if (global.crafting_recipes.containsKey(this.curr_crafting_hash_code)) {
      this.crafting_recipe = global.crafting_recipes.get(this.curr_crafting_hash_code);
      this.craftable_item = new Item(this.crafting_recipe.output);
      this.craftable_item.stack = this.crafting_recipe.amount;
      this.craft.disabled = !this.crafting_recipe.hasTools(this.currentTools());
      if (this.craft.disabled) {
        image(global.images.getImage("icons/crafting_arrow_red.png"), 2 + 3.5f * this.button_size,
          2 + 1 * this.button_size, this.button_size, this.button_size);
      }
      else {
        image(global.images.getImage("icons/crafting_arrow_green.png"), 2 + 3.5f * this.button_size,
          2 + 1 * this.button_size, this.button_size, this.button_size);
      }
      image(this.craftable_item.getImage(), 2 + 5 * this.button_size,
        2 + 1 * this.button_size, this.button_size, this.button_size);
      if (this.craftable_item.stack > 1) {
        fill(255);
        textSize(14);
        textAlign(RIGHT, BOTTOM);
        text(this.craftable_item.stack, 6 * this.button_size, 2 * this.button_size);
      }
      if (this.craftable_item_hovered) {
        textSize(20);
        float rect_height = textAscent() + textDescent() + 2;
        float rect_width = textWidth(this.craftable_item.display_name()) + 2;
        rectMode(CORNER);
        fill(global.color_nameDisplayed_background);
        stroke(1, 0);
        strokeWeight(0.1f);
        rect(this.last_mX - rect_width - 1, this.last_mY - rect_height - 1, rect_width, rect_height);
        fill(255);
        textAlign(LEFT, TOP);
        text(this.craftable_item.display_name(), this.last_mX - rect_width - 1, this.last_mY - rect_height - 1);
      }
    }
    else {
      this.craftable_item = null;
      this.crafting_recipe = null;
      this.craft.disable();
      image(global.images.getImage("icons/crafting_arrow.png"), 2 + 3.5f * this.button_size,
        2 + 1 * this.button_size, this.button_size, this.button_size);
    }
    this.craft.update(timeElapsed);
    this.tools.update(timeElapsed);
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    this.last_mX = mX;
    this.last_mY = mY;
    super.mouseMove(mX, mY);
    this.craft.mouseMove(mX, mY);
    this.tools.mouseMove(mX, mY);
    if (this.craftable_item == null) {
      this.craftable_item_hovered = false;
    }
    else {
      if (mX > 2 + 5 * this.button_size && mY > 2 + 1 * this.button_size &&
        mX < 2 + 6 * this.button_size && mY < 2 + 2 * this.button_size) {
        this.craftable_item_hovered = true;
      }
      else {
        this.craftable_item_hovered = false;
      }
    }
  }

  @Override public 
  void mousePress() {
    super.mousePress();
    this.craft.mousePress();
    this.tools.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    this.craft.mouseRelease(mX, mY);
    this.tools.mouseRelease(mX, mY);
  }

  @Override public 
  int getCraftingHashCode() {
    int[][] item_grid = new int[3][3];
    if (this.slots.get(0).item != null) {
      item_grid[0][0] = this.slots.get(0).item.ID;
    }
    if (this.slots.get(1).item != null) {
      item_grid[0][1] = this.slots.get(1).item.ID;
    }
    if (this.slots.get(2).item != null) {
      item_grid[0][2] = this.slots.get(2).item.ID;
    }
    if (this.slots.get(6).item != null) {
      item_grid[1][0] = this.slots.get(6).item.ID;
    }
    if (this.slots.get(7).item != null) {
      item_grid[1][1] = this.slots.get(7).item.ID;
    }
    if (this.slots.get(8).item != null) {
      item_grid[1][2] = this.slots.get(8).item.ID;
    }
    if (this.slots.get(12).item != null) {
      item_grid[2][0] = this.slots.get(12).item.ID;
    }
    if (this.slots.get(13).item != null) {
      item_grid[2][1] = this.slots.get(13).item.ID;
    }
    if (this.slots.get(14).item != null) {
      item_grid[2][2] = this.slots.get(14).item.ID;
    }
    return Arrays.deepHashCode(reduceItemGrid(item_grid));
  }
}


class EnderChestInventory extends Inventory {
  EnderChestInventory() {
    super(3, 4, true);
  }
}


class SmallKeyringInventory extends Inventory {
  SmallKeyringInventory() {
    super(3, 3, true);
    this.slots.get(4).deactivated = true;
  }

  @Override public 
  Item stash(Item i) {
    if (!i.key()) {
      return i;
    }
    return super.stash(i);
  }

  @Override public 
  Item placeAt(Item i, int index, boolean replace, boolean ignore_deactivate) {
    if (!i.key()) {
      return i;
    }
    return super.placeAt(i, index, replace, ignore_deactivate);
  }

  @Override public 
  void drawBackground() {
    super.drawBackground();
    imageMode(CORNER);
    image(global.images.getImage("items/small_keyring.png"), 2, 2, 3 * this.button_size, 3 * this.button_size);
  }
}


class LargeKeyringInventory extends Inventory {
  LargeKeyringInventory() {
    super(6, 6, true);
    this.slots.get(0).deactivated = true;
    this.slots.get(5).deactivated = true;
    this.slots.get(9).deactivated = true;
    this.slots.get(10).deactivated = true;
    this.slots.get(14).deactivated = true;
    this.slots.get(15).deactivated = true;
    this.slots.get(16).deactivated = true;
    this.slots.get(20).deactivated = true;
    this.slots.get(21).deactivated = true;
    this.slots.get(22).deactivated = true;
    this.slots.get(30).deactivated = true;
    this.slots.get(35).deactivated = true;
  }

  @Override public 
  Item stash(Item i) {
    if (!i.key()) {
      return i;
    }
    return super.stash(i);
  }

  @Override public 
  Item placeAt(Item i, int index, boolean replace, boolean ignore_deactivate) {
    if (!i.key()) {
      return i;
    }
    return super.placeAt(i, index, replace, ignore_deactivate);
  }

  @Override public 
  void drawBackground() {
    super.drawBackground();
    imageMode(CORNER);
    image(global.images.getImage("items/large_keyring.png"), 2, 2, 6 * this.button_size, 6 * this.button_size);
  }
}


 public Inventory getKhalilInventory(int khalil_code) {
  Inventory inv = null;
  Item i;
  switch(khalil_code) {
    case 0:
      break;
    case 1: // Francis Hall
      inv = new Inventory(1, 10, true);
      i = new Item(2118);
      i.stack = 4;
      inv.stash(i);
      i = new Item(2203);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2301);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2401);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2501);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2601);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2701);
      i.stack = 1;
      inv.stash(i);
      i = new Item(2802);
      i.stack = 12;
      inv.stash(i);
      i = new Item(2809);
      i.stack = 3;
      inv.stash(i);
      i = new Item(2925);
      i.stack = 1;
      inv.stash(i);
      break;
    default:
      global.errorMessage("ERROR: Khalil code " + khalil_code + " not found.");
      break;
  }
  return inv;
}

 public ArrayList<Float> getKhalilInventoryCosts(int khalil_code) {
  ArrayList<Float> costs = new ArrayList<Float>();
  switch(khalil_code) {
    case 0:
      break;
    case 1: // Francis Hall
      costs.add(1.0f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      costs.add(2.12f);
      break;
    default:
      global.errorMessage("ERROR: Khalil code " + khalil_code + " not found.");
      break;
  }
  return costs;
}
class EditItemForm extends EditMapObjectForm {
  protected Item item;

  EditItemForm(Item item) {
    super(item);
    this.item = item;
    this.addField(new FloatFormField("Heals: ", "curr health", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new IntegerFormField("Hunger: ", "hunger", -100, 100));
    this.addField(new IntegerFormField("Thirst: ", "thirst", -100, 100));
    this.addField(new FloatFormField("Money: ", "money", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Health: ", "health", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Attack: ", "attack", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Magic: ", "magic", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Defense: ", "defense", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Resistance: ", "resistance", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Piercing: ", "piercing", -1, 1));
    this.addField(new FloatFormField("Penetration: ", "penetration", -1, 1));
    this.addField(new FloatFormField("Attack Range: ", "attack range", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Attack Cooldown: ", "attack cooldown", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Attack Time: ", "attack time", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Sight: ", "sight", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Speed: ", "speed", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Tenacity: ", "tenacity", -1, 1));
    this.addField(new IntegerFormField("Agility: ", "agility", -10, 10));
    this.addField(new IntegerFormField("Ammo: ", "ammo", 0, Integer.MAX_VALUE - 1));
    this.addField(new IntegerFormField("Stack: ", "stack", 0, Integer.MAX_VALUE - 1));
    this.addField(new IntegerFormField("Durability: ", "durability", 0, Integer.MAX_VALUE - 1));
    this.addField(new SubmitFormField("Finished", false));
    this.updateForm();
  }

   public void updateObject() {
    this.item.curr_health = toFloat(this.fields.get(1).getValue());
    this.item.hunger = toInt(this.fields.get(2).getValue());
    this.item.thirst = toInt(this.fields.get(3).getValue());
    this.item.money = toFloat(this.fields.get(4).getValue());
    this.item.health = toFloat(this.fields.get(5).getValue());
    this.item.attack = toFloat(this.fields.get(6).getValue());
    this.item.magic = toFloat(this.fields.get(7).getValue());
    this.item.defense = toFloat(this.fields.get(8).getValue());
    this.item.resistance = toFloat(this.fields.get(9).getValue());
    this.item.piercing = toFloat(this.fields.get(10).getValue());
    this.item.penetration = toFloat(this.fields.get(11).getValue());
    this.item.attackRange = toFloat(this.fields.get(12).getValue());
    this.item.attackCooldown = toFloat(this.fields.get(13).getValue());
    this.item.attackTime = toFloat(this.fields.get(14).getValue());
    this.item.sight = toFloat(this.fields.get(15).getValue());
    this.item.speed = toFloat(this.fields.get(16).getValue());
    this.item.tenacity = toFloat(this.fields.get(17).getValue());
    this.item.agility = toInt(this.fields.get(18).getValue());
    this.item.ammo = toInt(this.fields.get(19).getValue());
    this.item.stack = toInt(this.fields.get(20).getValue());
    this.item.durability = toInt(this.fields.get(21).getValue());
  }

   public void updateForm() {
    this.fields.get(1).setValueIfNotFocused(Float.toString(this.item.curr_health));
    this.fields.get(2).setValueIfNotFocused(Integer.toString(this.item.hunger));
    this.fields.get(3).setValueIfNotFocused(Integer.toString(this.item.thirst));
    this.fields.get(4).setValueIfNotFocused(Float.toString(this.item.money));
    this.fields.get(5).setValueIfNotFocused(Float.toString(this.item.health));
    this.fields.get(6).setValueIfNotFocused(Float.toString(this.item.attack));
    this.fields.get(7).setValueIfNotFocused(Float.toString(this.item.magic));
    this.fields.get(8).setValueIfNotFocused(Float.toString(this.item.defense));
    this.fields.get(9).setValueIfNotFocused(Float.toString(this.item.resistance));
    this.fields.get(10).setValueIfNotFocused(Float.toString(this.item.piercing));
    this.fields.get(11).setValueIfNotFocused(Float.toString(this.item.penetration));
    this.fields.get(12).setValueIfNotFocused(Float.toString(this.item.attackRange));
    this.fields.get(13).setValueIfNotFocused(Float.toString(this.item.attackCooldown));
    this.fields.get(14).setValueIfNotFocused(Float.toString(this.item.attackTime));
    this.fields.get(15).setValueIfNotFocused(Float.toString(this.item.sight));
    this.fields.get(16).setValueIfNotFocused(Float.toString(this.item.speed));
    this.fields.get(17).setValueIfNotFocused(Float.toString(this.item.tenacity));
    this.fields.get(18).setValueIfNotFocused(Integer.toString(this.item.agility));
    this.fields.get(19).setValueIfNotFocused(Integer.toString(this.item.ammo));
    this.fields.get(20).setValueIfNotFocused(Integer.toString(this.item.stack));
    this.fields.get(21).setValueIfNotFocused(Integer.toString(this.item.durability));
  }
}



class Item extends MapObject {
  protected boolean disappearing = false;
  protected int disappear_timer = 0;
  protected int map_key = -10;

  protected int stack = 1;

  protected float size = Constants.item_defaultSize; // radius
  protected int tier = 1;

  protected float curr_health = 0;
  protected int hunger = 0;
  protected int thirst = 0;
  protected float money = 0;

  protected float health = 0;
  protected float attack = 0;
  protected float magic = 0;
  protected float defense = 0;
  protected float resistance = 0;
  protected float piercing = 0; // percentage from 0 - 1
  protected float penetration = 0; // percentage from 0 - 1
  protected float attackRange = 0;
  protected float attackCooldown = 0;
  protected float attackTime = 0;
  protected float sight = 0;
  protected float speed = 0;
  protected float tenacity = 0; // percentage from 0 - 1
  protected int agility = 0;
  protected float lifesteal = 0; // percentage
  protected boolean save_base_stats = false; // toggle true if manually changing stats

  protected int durability = 1; // when hits 0 item breaks
  protected int ammo = 0; // also used for other things (like key code)
  protected boolean toggled = false; // various uses
  protected Inventory inventory = null; // keyrings, item attachments, etc

  // graphics
  protected BounceInt bounce = new BounceInt(Constants.item_bounceConstant);

  Item(Item i) {
    this(i, 0, 0);
  }
  Item(Item i, float x, float y) {
    super();
    if (i == null) {
      this.remove = true;
      return;
    }
    this.ID = i.ID;
    this.display_name = i.display_name;
    this.type = i.type;
    this.description = i.description;
    this.x = x;
    this.y = y;
    this.curr_height = i.curr_height;
    this.remove = i.remove;
    this.stack = i.stack;
    this.size = i.size;
    this.tier = i.tier;
    this.curr_health = i.curr_health;
    this.hunger = i.hunger;
    this.thirst = i.thirst;
    this.money = i.money;
    this.health = i.health;
    this.attack = i.attack;
    this.magic = i.magic;
    this.defense = i.defense;
    this.resistance = i.resistance;
    this.piercing = i.piercing;
    this.penetration = i.penetration;
    this.attackRange = i.attackRange;
    this.attackCooldown = i.attackCooldown;
    this.attackTime = i.attackTime;
    this.sight = i.sight;
    this.speed = i.speed;
    this.tenacity = i.tenacity;
    this.agility = i.agility;
    this.lifesteal = i.lifesteal;
    this.ammo = i.ammo;
    this.toggled = i.toggled;
    this.durability = i.durability;
    this.inventory = i.inventory; // not a deep copy just a reference copy
  }
  Item(int ID) {
    super(ID);
    switch(ID) {
      // Consumables
      case 2101:
        this.setStrings("Crumb", "Food", "");
        this.hunger = 1;
        break;
      case 2102:
        this.setStrings("Unknown Food", "Food", "");
        this.hunger = 3;
        this.thirst = 1;
        break;
      case 2103:
        this.setStrings("Unknown Food", "Food", "");
        this.hunger = 3;
        this.thirst = 1;
        break;
      case 2104:
        this.setStrings("Unknown Food", "Food", "");
        this.hunger = 3;
        this.thirst = 1;
        break;
      case 2105:
        this.setStrings("Unknown Food", "Food", "");
        this.hunger = 4;
        break;
      case 2106:
        this.setStrings("Pickle", "Food", "");
        this.hunger = 10;
        this.thirst = 5;
        break;
      case 2107:
        this.setStrings("Ketchup", "Food", "");
        this.hunger = 6;
        this.thirst = 3;
        break;
      case 2108:
        this.setStrings("Chicken Wing", "Food", "");
        this.hunger = 25;
        this.thirst = 5;
        break;
      case 2109:
        this.setStrings("Steak", "Food", "");
        this.hunger = 40;
        this.thirst = 10;
        break;
      case 2110:
        this.setStrings("Poptart", "Food", "");
        this.hunger = 20;
        this.thirst = -5;
        break;
      case 2111:
        this.setStrings("Donut", "Food", "");
        this.hunger = 20;
        break;
      case 2112:
        this.setStrings("Chocolate", "Food", "");
        this.hunger = 18;
        break;
      case 2113:
        this.setStrings("Chips", "Food", "");
        this.hunger = 15;
        this.thirst = -5;
        break;
      case 2114:
        this.setStrings("Cheese", "Food", "");
        this.hunger = 12;
        this.thirst = 6;
        break;
      case 2115:
        this.setStrings("Peanuts", "Food", "");
        this.hunger = 15;
        this.thirst = -5;
        break;
      case 2116:
        this.setStrings("Raw Chicken", "Food", "");
        this.hunger = 20;
        this.thirst = 10;
        break;
      case 2117:
        this.setStrings("Cooked Chicken", "Food", "");
        this.hunger = 40;
        this.thirst = 10;
        break;
      case 2118:
        this.setStrings("Chicken Egg", "Food", "");
        this.hunger = 25;
        this.thirst = 10;
        break;
      case 2119:
        this.setStrings("Rotten Flesh", "Food", "");
        this.hunger = 10;
        this.thirst = 10;
        break;
      case 2120:
        this.setStrings("Apple", "Food", "");
        this.hunger = 18;
        this.thirst = 10;
        break;
      case 2121:
        this.setStrings("Banana", "Food", "");
        this.hunger = 16;
        this.thirst = 6;
        break;
      case 2122:
        this.setStrings("Pear", "Food", "");
        this.hunger = 18;
        this.thirst = 8;
        break;
      case 2123:
        this.setStrings("Bread", "Food", "");
        this.hunger = 25;
        break;
      case 2124:
        this.setStrings("Hot Pocket Box", "Package", "");
        break;
      case 2125:
        this.setStrings("Hot Pocket", "Food", "");
        this.hunger = 25;
        this.thirst = 5;
        break;
      case 2131:
        this.setStrings("Water Cup", "Drink", "");
        this.thirst = 12;
        break;
      case 2132:
        this.setStrings("Coke", "Drink", "");
        this.hunger = 6;
        this.thirst = 15;
        break;
      case 2133:
        this.setStrings("Wine", "Drink", "");
        this.hunger = 6;
        this.thirst = 20;
        break;
      case 2134:
        this.setStrings("Beer", "Drink", "");
        this.hunger = 8;
        this.thirst = 20;
        break;
      case 2141:
        this.setStrings("Holy Water", "Drink", "");
        this.tier = 2;
        this.curr_health = 10;
        this.thirst = 50;
        break;
      case 2142:
        this.setStrings("Golden Apple", "Food", "");
        this.tier = 3;
        this.curr_health = 30;
        this.hunger = 35;
        this.thirst = 10;
        break;
      case 2151:
        this.setStrings("One Dollar", "Money", "");
        this.money = 1;
        break;
      case 2152:
        this.setStrings("Five Dollars", "Money", "");
        this.money = 5;
        break;
      case 2153:
        this.setStrings("Ten Dollars", "Money", "");
        this.money = 10;
        break;
      case 2154:
        this.setStrings("Fifty Dollars", "Money", "");
        this.money = 50;
        break;
      case 2155:
        this.setStrings("Zucc Bucc", "Money", "");
        this.tier = 2;
        this.money = 101;
        this.size = 0.3f;
        break;
      case 2156:
        this.setStrings("Wad of 5s", "Money", "");
        this.tier = 2;
        this.money = 500;
        this.size = 0.3f;
        break;
      case 2157:
        this.setStrings("Wad of 10s", "Money", "");
        this.tier = 2;
        this.money = 1000;
        this.size = 0.3f;
        break;
      case 2158:
        this.setStrings("Wad of 50s", "Money", "");
        this.tier = 2;
        this.money = 5000;
        this.size = 0.3f;
        break;
      case 2159:
        this.setStrings("Wad of Zuccs", "Money", "");
        this.tier = 3;
        this.money = 10100;
        this.size = 0.3f;
        break;
      case 2161:
        this.setStrings("Broken Candlestick", "Household Item", "");
        this.size = 0.4f;
        break;
      case 2162:
        this.setStrings("Candlestick", "Household Item", "");
        this.size = 0.4f;
        break;
      case 2163:
        this.setStrings("Candle", "Household Item", "");
        this.size = 0.21f;
        this.ammo = 1200000;
        break;
      case 2164:
        this.setStrings("Lord's Day Candle", "Household Item", "");
        this.size = 0.55f;
        this.tier = 2;
        this.ammo = 1200000;
        break;
      case 2165:
        this.setStrings("Lord's Day Papers", "Household Item", "");
        this.tier = 2;
        break;
      case 2166:
        this.setStrings("Wooden Horse", "Household Item", "");
        this.tier = 3;
        break;

      // Melee Weapons
      case 2201:
        this.setStrings("Foam Sword", "Melee Weapon", "");
        this.attack = 0.8f;
        this.attackRange = 0.12f;
        this.size = 0.3f;
        this.durability = 10;
        break;
      case 2202:
        this.setStrings("Pan", "Melee Weapon", "");
        this.attack = 1.6f;
        this.attackRange = 0.02f;
        this.durability = 30;
        break;
      case 2203:
        this.setStrings("Knife", "Melee Weapon", "");
        this.attack = 2.5f;
        this.attackRange = 0.01f;
        this.piercing = 0.04f;
        this.size = 0.3f;
        this.durability = 45;
        break;
      case 2204:
        this.setStrings("Decoy", "Melee Weapon", "");
        this.attack = 5;
        this.attackRange = 0.1f;
        this.piercing = 0.06f;
        this.size = 0.3f;
        this.durability = 70;
        break;
      case 2205:
        this.setStrings("Wooden Sword", "Melee Weapon", "");
        this.attack = 2.2f;
        this.attackRange = 0.15f;
        this.piercing = 0.01f;
        this.size = 0.3f;
        this.durability = 30;
        break;
      case 2206:
        this.setStrings("Talc Sword", "Melee Weapon", "");
        this.attack = 2;
        this.attackRange = 0.15f;
        this.size = 0.3f;
        this.durability = 10;
        break;
      case 2207:
        this.setStrings("Wooden Spear", "Melee Weapon", "");
        this.attack = 1.9f;
        this.attackRange = 0.35f;
        this.piercing = 0.04f;
        this.size = 0.4f;
        this.durability = 20;
        break;
      case 2208:
        this.setStrings("Talc Spear", "Melee Weapon", "");
        this.attack = 1.7f;
        this.attackRange = 0.35f;
        this.piercing = 0.03f;
        this.size = 0.4f;
        this.durability = 6;
        break;
      case 2211:
        this.setStrings("The Thing", "Melee Weapon", "");
        this.attack = 2;
        this.tier = 7;
        this.attackRange = 0.15f;
        this.piercing = 0.08f;
        this.size = 0.32f;
        this.durability = 100;
        break;
      case 2212:
        this.setStrings("Gypsum Sword", "Melee Weapon", "");
        this.tier = 2;
        this.attack = 6;
        this.attackRange = 0.15f;
        this.piercing = 0.02f;
        this.size = 0.3f;
        this.durability = 20;
        break;
      case 2213:
        this.setStrings("Gypsum Spear", "Melee Weapon", "");
        this.tier = 2;
        this.attack = 5.5f;
        this.attackRange = 0.35f;
        this.piercing = 0.05f;
        this.size = 0.4f;
        this.durability = 14;
        break;
      case 2214:
        this.setStrings("Board with Nails", "Melee Weapon", "");
        this.tier = 2;
        this.attack = 6;
        this.attackRange = 0.2f;
        this.piercing = 0.02f;
        this.size = 0.4f;
        this.speed = -0.2f;
        this.durability = 15;
        break;
      case 2221:
        this.setStrings("Calcite Sword", "Melee Weapon", "");
        this.tier = 3;
        this.attack = 50;
        this.attackRange = 0.15f;
        this.piercing = 0.03f;
        this.size = 0.3f;
        this.durability = 30;
        break;
      case 2222:
        this.setStrings("Calcite Spear", "Melee Weapon", "");
        this.tier = 3;
        this.attack = 45;
        this.attackRange = 0.35f;
        this.piercing = 0.08f;
        this.size = 0.4f;
        this.durability = 21;
        break;
      case 2223:
        this.setStrings("Metal Pipe", "Melee Weapon", "");
        this.tier = 3;
        this.attack = 13;
        this.attackRange = 0.25f;
        this.size = 0.4f;
        this.durability = 60;
        break;
      case 2231:
        this.setStrings("Fluorite Sword", "Melee Weapon", "");
        this.tier = 4;
        this.attack = 120;
        this.attackRange = 0.15f;
        this.piercing = 0.05f;
        this.size = 0.3f;
        this.durability = 50;
        break;
      case 2232:
        this.setStrings("Fluorite Spear", "Melee Weapon", "");
        this.tier = 4;
        this.attack = 108;
        this.attackRange = 0.35f;
        this.piercing = 0.12f;
        this.size = 0.4f;
        this.durability = 35;
        break;
      case 2241:
        this.setStrings("Apatite Sword", "Melee Weapon", "");
        this.tier = 5;
        this.attack = 260;
        this.attackRange = 0.15f;
        this.piercing = 0.06f;
        this.size = 0.3f;
        this.durability = 70;
        break;
      case 2242:
        this.setStrings("Apatite Spear", "Melee Weapon", "");
        this.tier = 5;
        this.attack = 235;
        this.attackRange = 0.35f;
        this.piercing = 0.14f;
        this.size = 0.4f;
        this.durability = 50;
        break;
      case 2251:
        this.setStrings("Orthoclase Sword", "Melee Weapon", "");
        this.tier = 6;
        this.attack = 350;
        this.attackRange = 0.15f;
        this.piercing = 0.07f;
        this.size = 0.3f;
        this.durability = 100;
        break;
      case 2252:
        this.setStrings("Orthoclase Spear", "Melee Weapon", "");
        this.tier = 6;
        this.attack = 315;
        this.attackRange = 0.35f;
        this.piercing = 0.16f;
        this.size = 0.4f;
        this.durability = 70;
        break;
      case 2261:
        this.setStrings("Quartz Sword", "Melee Weapon", "");
        this.tier = 7;
        this.attack = 460;
        this.attackRange = 0.15f;
        this.piercing = 0.08f;
        this.size = 0.3f;
        this.durability = 150;
        break;
      case 2262:
        this.setStrings("Quartz Spear", "Melee Weapon", "");
        this.tier = 7;
        this.attack = 415;
        this.attackRange = 0.35f;
        this.piercing = 0.18f;
        this.size = 0.4f;
        this.durability = 105;
        break;
      case 2271:
        this.setStrings("Topaz Sword", "Melee Weapon", "");
        this.tier = 8;
        this.attack = 980;
        this.attackRange = 0.15f;
        this.piercing = 0.09f;
        this.size = 0.3f;
        this.durability = 250;
        break;
      case 2272:
        this.setStrings("Topaz Spear", "Melee Weapon", "");
        this.tier = 8;
        this.attack = 890;
        this.attackRange = 0.35f;
        this.piercing = 0.2f;
        this.size = 0.4f;
        this.durability = 175;
        break;
      case 2281:
        this.setStrings("Corundum Sword", "Melee Weapon", "");
        this.tier = 9;
        this.attack = 2000;
        this.attackRange = 0.15f;
        this.piercing = 0.1f;
        this.size = 0.3f;
        this.durability = 400;
        break;
      case 2282:
        this.setStrings("Corundum Spear", "Melee Weapon", "");
        this.tier = 9;
        this.attack = 1750;
        this.attackRange = 0.35f;
        this.piercing = 0.22f;
        this.size = 0.4f;
        this.durability = 280;
        break;
      case 2291:
        this.setStrings("Diamond Sword", "Melee Weapon", "");
        this.tier = 10;
        this.attack = 9100;
        this.attackRange = 0.15f;
        this.piercing = 0.11f;
        this.size = 0.3f;
        this.durability = 1000;
        break;
      case 2292:
        this.setStrings("Diamond Spear", "Melee Weapon", "");
        this.tier = 10;
        this.attack = 7400;
        this.attackRange = 0.35f;
        this.piercing = 0.24f;
        this.size = 0.4f;
        this.durability = 700;
        break;

      // Ranged Weapons
      case 2301:
        this.setStrings("Slingshot", "Ranged Weapon", "");
        this.attack = 5;
        this.attackRange = 3;
        this.size = 0.3f;
        this.durability = 30;
        break;
      case 2311:
        this.setStrings("Recurve Bow", "Ranged Weapon", "");
        this.tier = 2;
        this.attack = 8;
        this.attackRange = 5;
        this.piercing = 0.15f;
        this.size = 0.3f;
        this.durability = 50;
        break;
      case 2312:
        this.setStrings("M1911", "Ranged Weapon", "Semi-automatic with medium capacity and power. Effective at close range.");
        this.tier = 2;
        this.attack = 2;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2321:
        this.setStrings("War Machine", "Ranged Weapon", "6 round semi-automatic grenade launcher.");
        this.tier = 3;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2322:
        this.setStrings("Five-Seven", "Ranged Weapon", "Semi-automatic pistol. Versatile and strong overall with a large magazine.");
        this.tier = 3;
        this.attack = 2;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2323:
        this.setStrings("Type25", "Ranged Weapon", "Fully automatic assault rifle. High rate of fire with moderate recoil.");
        this.tier = 3;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2331:
        this.setStrings("Mustang and Sally", "Ranged Weapon", "");
        this.tier = 4;
        this.attack = 3;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2332:
        this.setStrings("FAL", "Ranged Weapon", "Fully automatic assault rifle with high damage. Effective at medium to long range.");
        this.tier = 4;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2333:
        this.setStrings("Python", "Ranged Weapon", "The Python .357 magnum revolver. No thank you, I have reproductive organs of my own.");
        this.tier = 4;
        this.attack = 3;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2341:
        this.setStrings("RPG", "Ranged Weapon", "Free-fire shoulder mounted rocket launcher.");
        this.tier = 5;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.speed = -1;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2342:
        this.setStrings("Dystopic Demolisher", "Ranged Weapon", "");
        this.tier = 5;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2343:
        this.setStrings("Ultra", "Ranged Weapon", "");
        this.tier = 5;
        this.attack = 3;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2344:
        this.setStrings("Strain25", "Ranged Weapon", "");
        this.tier = 5;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2345:
        this.setStrings("Executioner", "Ranged Weapon", "Double-action revolver pistol. Fires 28 gauge shotgun shells.");
        this.tier = 5;
        this.attack = 3;
        this.size = 0.3f;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2351:
        this.setStrings("Galil", "Ranged Weapon", "Fully automatic assault rifle. Effective at medium to long range.");
        this.tier = 6;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2352:
        this.setStrings("WN", "Ranged Weapon", "");
        this.tier = 6;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2353:
        this.setStrings("Ballistic Knife", "Ranged Weapon", "Spring-action knife launcher. Increases melee speed and can fire the blade as a projectile.");
        this.tier = 6;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.speed = 1;
        this.lifesteal = 0.1f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2354:
        this.setStrings("Cobra", "Ranged Weapon", "");
        this.tier = 6;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2355:
        this.setStrings("MTAR", "Ranged Weapon", "Fully automatic assault rifle. Versatile and strong overall.");
        this.tier = 6;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2361:
        this.setStrings("RPD", "Ranged Weapon", "Fully automatic with good power and quick fire rate. Effective at medium to long range.");
        this.tier = 7;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2362:
        this.setStrings("Rocket-Propelled Grievance", "Ranged Weapon", "");
        this.tier = 7;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2363:
        this.setStrings("DSR-50", "Ranged Weapon", "");
        this.tier = 7;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.speed = -1;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2364:
        this.setStrings("Voice of Justice", "Ranged Weapon", "");
        this.tier = 7;
        this.attack = 3;
        this.size = 0.3f;
        this.durability = 120;
        break;
      case 2371:
        this.setStrings("HAMR", "Ranged Weapon", "Fully automatic LMG. Reduces fire rate with less ammo, becoming more accurate.");
        this.tier = 8;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2372:
        this.setStrings("Ray Gun", "Ranged Weapon", "It's weird, but it works.");
        this.tier = 8;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2373:
        this.setStrings("Lamentation", "Ranged Weapon", "");
        this.tier = 8;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2374:
        this.setStrings("The Krauss Refibrillator", "Ranged Weapon", "");
        this.tier = 8;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.speed = 1.5f;
        this.lifesteal = 0.15f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2375:
        this.setStrings("Malevolent Taxonomic Anodized Redeemer", "Ranged Weapon", "");
        this.tier = 8;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2381:
        this.setStrings("Relativistic Punishment Device", "Ranged Weapon", "");
        this.tier = 9;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2382:
        this.setStrings("Dead Specimen Reactor 5000", "Ranged Weapon", "");
        this.tier = 9;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2391:
        this.setStrings("SLDG HAMR", "Ranged Weapon", "");
        this.tier = 10;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;
      case 2392:
        this.setStrings("Porter's X2 Ray Gun", "Ranged Weapon", "");
        this.tier = 10;
        this.attack = 3;
        this.attackRange = 0.04f;
        this.size = 0.35f;
        this.durability = 120;
        break;

      // Headgear
      case 2401:
        this.setStrings("Talc Helmet", "Headgear", "");
        this.defense = 1;
        this.durability = 10;
        break;
      case 2402:
        this.setStrings("Cap", "Headgear", "");
        this.durability = 10;
        break;
      case 2403:
        this.setStrings("Bowl", "Headgear", "");
        this.defense = 1;
        this.durability = 25;
        break;
      case 2404:
        this.setStrings("Pot", "Headgear", "");
        this.defense = 2;
        this.speed = -0.5f;
        this.durability = 60;
        break;
      case 2411:
        this.setStrings("Gypsum Helmet", "Headgear", "");
        this.tier = 2;
        this.defense = 2;
        this.durability = 20;
        break;
      case 2421:
        this.setStrings("Calcite Helmet", "Headgear", "");
        this.tier = 3;
        this.defense = 14;
        this.durability = 30;
        break;
      case 2431:
        this.setStrings("Fluorite Helmet", "Headgear", "");
        this.tier = 4;
        this.defense = 21;
        this.durability = 50;
        break;
      case 2441:
        this.setStrings("Apatite Helmet", "Headgear", "");
        this.tier = 5;
        this.defense = 48;
        this.durability = 70;
        break;
      case 2451:
        this.setStrings("Orthoclase Helmet", "Headgear", "");
        this.tier = 6;
        this.defense = 72;
        this.durability = 100;
        break;
      case 2461:
        this.setStrings("Quartz Helmet", "Headgear", "");
        this.tier = 7;
        this.defense = 100;
        this.durability = 150;
        break;
      case 2471:
        this.setStrings("Topaz Helmet", "Headgear", "");
        this.tier = 8;
        this.defense = 200;
        this.durability = 250;
        break;
      case 2481:
        this.setStrings("Corundum Helmet", "Headgear", "");
        this.tier = 9;
        this.defense = 400;
        this.durability = 450;
        break;
      case 2491:
        this.setStrings("Diamond Helmet", "Headgear", "");
        this.tier = 10;
        this.defense = 1500;
        this.durability = 1000;
        break;

      // Chestgear
      case 2501:
        this.setStrings("Talc Chestplate", "Chestgear", "");
        this.defense = 1;
        this.durability = 10;
        break;
      case 2502:
        this.setStrings("T-Shirt", "Chestgear", "");
        this.attackRange = 0.04f;
        this.durability = 10;
        break;
      case 2503:
        this.setStrings("Bra", "Chestgear", "");
        this.attackRange = 0.02f;
        this.durability = 10;
        break;
      case 2504:
        this.setStrings("Coat", "Chestgear", "");
        this.attackRange = 0.04f;
        this.defense = 1;
        this.durability = 15;
        break;
      case 2511:
        this.setStrings("Gypsum Chestplate", "Chestgear", "");
        this.tier = 2;
        this.defense = 2;
        this.durability = 20;
        break;
      case 2512:
        this.setStrings("Ben's Coat", "Chestgear", "");
        this.tier = 2;
        this.health = 3;
        this.attackRange = 0.05f;
        this.defense = 2;
        this.durability = 35;
        break;
      case 2513:
        this.setStrings("Suit Jacket", "Chestgear", "");
        this.tier = 2;
        this.attackRange = 0.04f;
        this.durability = 15;
        break;
      case 2521:
        this.setStrings("Calcite Chestplate", "Chestgear", "");
        this.tier = 3;
        this.defense = 14;
        this.durability = 30;
        break;
      case 2531:
        this.setStrings("Fluorite Chestplate", "Chestgear", "");
        this.tier = 4;
        this.defense = 21;
        this.durability = 50;
        break;
      case 2541:
        this.setStrings("Apatite Chestplate", "Chestgear", "");
        this.tier = 5;
        this.defense = 48;
        this.durability = 70;
        break;
      case 2551:
        this.setStrings("Orthoclase Chestplate", "Chestgear", "");
        this.tier = 6;
        this.defense = 72;
        this.durability = 100;
        break;
      case 2561:
        this.setStrings("Quartz Chestplate", "Chestgear", "");
        this.tier = 7;
        this.defense = 100;
        this.durability = 150;
        break;
      case 2571:
        this.setStrings("Topaz Chestplate", "Chestgear", "");
        this.tier = 8;
        this.defense = 200;
        this.durability = 250;
        break;
      case 2581:
        this.setStrings("Corundum Chestplate", "Chestgear", "");
        this.tier = 9;
        this.defense = 400;
        this.durability = 450;
        break;
      case 2591:
        this.setStrings("Diamond Chestplate", "Chestgear", "");
        this.tier = 10;
        this.defense = 1500;
        this.durability = 1000;
        break;

      // Leggear
      case 2601:
        this.setStrings("Talc Greaves", "Leggear", "");
        this.defense = 1;
        this.durability = 10;
        break;
      case 2602:
        this.setStrings("Boxers", "Leggear", "");
        this.attackRange = 0.02f;
        this.durability = 10;
        break;
      case 2603:
        this.setStrings("Towel", "Leggear", "");
        this.attackRange = 0.06f;
        this.durability = 8;
        break;
      case 2604:
        this.setStrings("Pants", "Leggear", "");
        this.attackRange = 0.08f;
        this.defense = 1;
        this.durability = 15;
        break;
      case 2611:
        this.setStrings("Gypsum Greaves", "Leggear", "");
        this.tier = 2;
        this.defense = 2;
        this.durability = 20;
        break;
      case 2622:
        this.setStrings("Calcite Greaves", "Leggear", "");
        this.tier = 3;
        this.defense = 14;
        this.durability = 30;
        break;
      case 2631:
        this.setStrings("Fluorite Greaves", "Leggear", "");
        this.tier = 4;
        this.defense = 21;
        this.durability = 50;
        break;
      case 2641:
        this.setStrings("Apatite Greaves", "Leggear", "");
        this.tier = 5;
        this.defense = 48;
        this.durability = 70;
        break;
      case 2651:
        this.setStrings("Orthoclase Greaves", "Leggear", "");
        this.tier = 6;
        this.defense = 72;
        this.durability = 100;
        break;
      case 2661:
        this.setStrings("Quartz Greaves", "Leggear", "");
        this.tier = 7;
        this.defense = 100;
        this.durability = 150;
        break;
      case 2671:
        this.setStrings("Topaz Greaves", "Leggear", "");
        this.tier = 8;
        this.defense = 200;
        this.durability = 250;
        break;
      case 2681:
        this.setStrings("Corundum Greaves", "Leggear", "");
        this.tier = 9;
        this.defense = 400;
        this.durability = 450;
        break;
      case 2691:
        this.setStrings("Diamond Greaves", "Leggear", "");
        this.tier = 10;
        this.defense = 1500;
        this.durability = 1000;
        break;

      // Footgear
      case 2701:
        this.setStrings("Talc Boots", "Footgear", "");
        this.defense = 1;
        this.durability = 10;
        break;
      case 2702:
        this.setStrings("Socks", "Footgear", "");
        this.durability = 8;
        break;
      case 2703:
        this.setStrings("Sandals", "Footgear", "");
        this.speed = 0.2f;
        this.durability = 12;
        break;
      case 2704:
        this.setStrings("Shoes", "Footgear", "");
        this.defense = 1;
        this.speed = 0.4f;
        this.durability = 18;
        break;
      case 2705:
        this.setStrings("Boots", "Footgear", "");
        this.defense = 2;
        this.speed = 0.4f;
        this.durability = 25;
        break;
      case 2711:
        this.setStrings("Gypsum Boots", "Footgear", "");
        this.tier = 2;
        this.defense = 2;
        this.durability = 20;
        break;
      case 2712:
        this.setStrings("Sneakers", "Footgear", "");
        this.tier = 2;
        this.defense = 1;
        this.speed = 0.6f;
        this.durability = 40;
        break;
      case 2713:
        this.setStrings("Steel-Toed Boots", "Footgear", "");
        this.tier = 2;
        this.attack = 1;
        this.defense = 3;
        this.speed = 0.4f;
        this.durability = 60;
        break;
      case 2714:
        this.setStrings("Cowboy Boots", "Footgear", "");
        this.tier = 2;
        this.defense = 2;
        this.speed = 0.6f;
        this.durability = 60;
        break;
      case 2721:
        this.setStrings("Calcite Boots", "Footgear", "");
        this.tier = 3;
        this.defense = 14;
        this.durability = 30;
        break;
      case 2731:
        this.setStrings("Fluorite Boots", "Footgear", "");
        this.tier = 4;
        this.defense = 21;
        this.durability = 50;
        break;
      case 2741:
        this.setStrings("Apatite Boots", "Footgear", "");
        this.tier = 5;
        this.defense = 48;
        this.durability = 70;
        break;
      case 2751:
        this.setStrings("Orthoclase Boots", "Footgear", "");
        this.tier = 6;
        this.defense = 72;
        this.durability = 100;
        break;
      case 2761:
        this.setStrings("Quartz Boots", "Footgear", "");
        this.tier = 7;
        this.defense = 100;
        this.durability = 150;
        break;
      case 2771:
        this.setStrings("Topaz Boots", "Footgear", "");
        this.tier = 8;
        this.defense = 200;
        this.durability = 250;
        break;
      case 2781:
        this.setStrings("Corundum Boots", "Footgear", "");
        this.tier = 9;
        this.defense = 400;
        this.durability = 450;
        break;
      case 2791:
        this.setStrings("Diamond Boots", "Footgear", "");
        this.tier = 10;
        this.defense = 1500;
        this.durability = 1000;
        break;

      // Material
      case 2801:
        this.setStrings("Talc Ore", "Material", "");
        break;
      case 2802:
        this.setStrings("Talc Crystal", "Material", "");
        break;
      case 2803:
        this.setStrings("Talc Powder", "Material", "");
        break;
      case 2804:
        this.setStrings("Soapstone", "Material", "");
        break;
      case 2805:
        this.setStrings("Broken Glass", "Material", "");
        break;
      case 2806:
        this.setStrings("Wire", "Material", "");
        break;
      case 2807:
        this.setStrings("Feather", "Material", "");
        break;
      case 2808:
        this.setStrings("Ashes", "Material", "");
        break;
      case 2809:
        this.setStrings("String", "Material", "");
        break;
      case 2810:
        this.setStrings("Wax", "Material", "");
        break;
      case 2811:
        this.setStrings("Gypsum Ore", "Material", "");
        this.tier = 2;
        break;
      case 2812:
        this.setStrings("Gypsum Crystal", "Material", "");
        this.tier = 2;
        break;
      case 2813:
        this.setStrings("Gypsum Powder", "Material", "");
        this.tier = 2;
        break;
      case 2814:
        this.setStrings("Selenite Crystal", "Material", "");
        this.tier = 2;
        break;
      case 2815:
        this.setStrings("Barbed Wire", "Material", "");
        this.tier = 2;
        break;
      case 2816:
        this.setStrings("Wooden Plank", "Material", "");
        this.tier = 2;
        this.attack = 2.4f;
        this.attackRange = 0.6f;
        this.speed = -0.8f;
        this.size = 0.48f;
        break;
      case 2817:
        this.setStrings("Wooden Handle", "Material", "");
        this.tier = 2;
        this.attack = 2.8f;
        this.attackRange = 0.4f;
        this.size = 0.3f;
        break;
      case 2818:
        this.setStrings("Wooden Piece", "Material", "");
        this.tier = 2;
        this.attack = 0.5f;
        this.attackRange = 0.02f;
        this.size = 0.3f;
        break;
      case 2821:
        this.setStrings("Calcite Ore", "Material", "");
        this.tier = 3;
        break;
      case 2822:
        this.setStrings("Calcite Crystal", "Material", "");
        this.tier = 3;
        break;
      case 2823:
        this.setStrings("Chalk", "Material", "");
        this.tier = 3;
        break;
      case 2824:
        this.setStrings("Iceland Spar", "Material", "");
        this.tier = 3;
        break;
      case 2825:
        this.setStrings("Star Piece", "Material", "");
        this.tier = 3;
        break;
      case 2831:
        this.setStrings("Fluorite Ore", "Material", "");
        this.tier = 4;
        break;
      case 2832:
        this.setStrings("Fluorite Crystal", "Material", "");
        this.tier = 4;
        break;
      case 2833:
        this.setStrings("Iron Crystal", "Material", "");
        this.tier = 4;
        break;
      case 2834:
        this.setStrings("Iron Crystal", "Material", "");
        this.tier = 4;
        break;
      case 2841:
        this.setStrings("Apatite Ore", "Material", "");
        this.tier = 5;
        break;
      case 2842:
        this.setStrings("Apatite Crystal", "Material", "");
        this.tier = 5;
        break;
      case 2843:
        this.setStrings("Iron Handle", "Material", "");
        this.tier = 5;
        this.attack = 12;
        this.attackRange = 0.4f;
        this.size = 0.3f;
        break;
      case 2851:
        this.setStrings("Orthoclase Ore", "Material", "");
        this.tier = 6;
        break;
      case 2852:
        this.setStrings("Orthoclase Chunk", "Material", "");
        this.tier = 6;
        break;
      case 2861:
        this.setStrings("Quartz Ore", "Material", "");
        this.tier = 7;
        break;
      case 2862:
        this.setStrings("Quartz Crystal", "Material", "");
        this.tier = 7;
        break;
      case 2863:
        this.setStrings("Amethyst", "Material", "");
        this.tier = 7;
        break;
      case 2864:
        this.setStrings("Glass", "Material", "");
        this.tier = 7;
        break;
      case 2871:
        this.setStrings("Topaz Ore", "Material", "");
        this.tier = 8;
        break;
      case 2872:
        this.setStrings("Topaz Chunk", "Material", "");
        this.tier = 8;
        break;
      case 2873:
        this.setStrings("Topaz Gem", "Material", "");
        this.tier = 8;
        break;
      case 2881:
        this.setStrings("Corundum Ore", "Material", "");
        this.tier = 9;
        break;
      case 2882:
        this.setStrings("Corundum Chunk", "Material", "");
        this.tier = 9;
        break;
      case 2883:
        this.setStrings("Sapphire", "Material", "");
        this.tier = 9;
        break;
      case 2891:
        this.setStrings("Diamond Ore", "Material", "");
        this.tier = 10;
        break;
      case 2892:
        this.setStrings("Diamond", "Material", "");
        this.tier = 10;
        break;

      // Other
      case 2901:
        this.setStrings("Key", "Key", "");
        break;
      case 2902:
        this.setStrings("Master Key", "Key", "");
        this.tier = 2;
        break;
      case 2903:
        this.setStrings("Skeleton Key", "Key", "");
        this.tier = 3;
        break;
      case 2904:
        this.setStrings("Small Key Ring", "Utility", "A small ring used to " +
          "hold keys. Holds up to 8 keys which can be used directly from the " +
          "keyring.");
        this.tier = 2;
        this.inventory = new SmallKeyringInventory();
        break;
      case 2905:
        this.setStrings("Large Key Ring", "Utility", "A large ring used to " +
          "hold keys. Holds up to 24 keys which can be used directly from the " +
          "keyring.");
        this.tier = 3;
        this.inventory = new LargeKeyringInventory();
        break;
      case 2906:
        this.setStrings("Car Key", "Key", "");
        this.tier = 3;
        break;
      case 2911:
        this.setStrings("Pen", "Office", "");
        this.attack = 0.6f;
        this.durability = 6;
        break;
      case 2912:
        this.setStrings("Pencil", "Office", "");
        this.attack = 0.6f;
        this.durability = 6;
        break;
      case 2913:
        this.setStrings("Paper", "Office", "");
        break;
      case 2914:
        this.setStrings("Document", "Office", "");
        break;
      case 2915:
        this.setStrings("Stapler", "Office", "");
        this.attack = 0.6f;
        this.durability = 15;
        break;
      case 2916:
        this.setStrings("Crumpled Paper", "Office", "");
        break;
      case 2917:
        this.setStrings("Eraser", "Office", "");
        break;
      case 2918:
        this.setStrings("Scissors", "Office", "");
        this.attack = 1.5f;
        this.durability = 12;
        break;
      case 2921:
        this.setStrings("Backpack", "Utility", "");
        this.attackRange = 0.04f;
        break;
      case 2922:
        this.setStrings("Ben's Backpack", "Utility", "");
        this.attackRange = 0.04f;
        break;
      case 2923:
        this.setStrings("Purse", "Utility", "");
        this.attackRange = 0.04f;
        break;
      case 2924:
        this.setStrings("Glass Bottle", "Utility", "");
        this.attack = 0.8f;
        this.piercing = 0.06f;
        this.durability = 2;
        break;
      case 2925:
        this.setStrings("Water Bottle", "Utility", "");
        break;
      case 2926:
        this.setStrings("Canteen", "Utility", "");
        this.tier = 2;
        this.attack = 1;
        this.attackRange = 0.02f;
        break;
      case 2927:
        this.setStrings("Water Jug", "Utility", "");
        this.tier = 3;
        this.attack = 1;
        this.attackRange = 0.02f;
        break;
      case 2928:
        this.setStrings("Cigar", "Utility", "");
        this.ammo = Constants.item_cigarLitTime;
        break;
      case 2929:
        this.setStrings("Gas Can", "Utility", "");
        this.size = 0.28f;
        this.attack = 0.4f;
        this.tier = 3;
        break;
      case 2931:
        this.setStrings("Rock", "Ammo", "");
        this.attack = 1;
        break;
      case 2932:
        this.setStrings("Arrow", "Ammo", "");
        this.attack = 1;
        this.piercing = 0.05f;
        break;
      case 2933:
        this.setStrings("Pebble", "Ammo", "");
        this.size = 0.22f;
        break;
      case 2941:
        this.setStrings(".45 ACP", "Ammo", "");
        this.size = 0.22f;
        break;
      case 2942:
        this.setStrings("7.62x39mm", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2943:
        this.setStrings("5.56x45mm", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2944:
        this.setStrings("Grenade", "Ammo", "");
        this.tier = 2;
        this.attack = 2;
        break;
      case 2945:
        this.setStrings(".357 Magnum", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2946:
        this.setStrings(".50 BMG", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2947:
        this.setStrings("FN 5.7x28mm", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2948:
        this.setStrings("28 Gauge", "Ammo", "");
        this.tier = 2;
        this.size = 0.22f;
        break;
      case 2961:
        this.setStrings("Dandelion", "Nature", "");
        break;
      case 2962:
        this.setStrings("Rose", "Nature", "");
        break;
      case 2963:
        this.setStrings("Stick", "Nature", "");
        this.attack = 0.8f;
        this.attackRange = 0.05f;
        this.durability = 8;
        break;
      case 2964:
        this.setStrings("Kindling", "Nature", "");
        this.attackRange = 0.04f;
        break;
      case 2965:
      case 2966:
      case 2967:
      case 2968:
        this.setStrings("Branch", "Nature", "");
        this.attack = 0.7f;
        this.attackRange = 0.05f;
        this.durability = 8;
        break;
      case 2969:
        this.setStrings("Wooden Log", "Nature", "");
        this.size = 0.6f;
        this.attack = 1.8f;
        this.speed = -1.4f;
        this.tier = 2;
        this.durability = 18;
        break;
      case 2971:
        this.setStrings("Paintbrush", "Tool", "");
        this.durability = 100;
        break;
      case 2972:
        this.setStrings("Clamp", "Tool", "");
        this.attack = 1;
        this.attackRange = 0.02f;
        this.durability = 100;
        break;
      case 2973:
        this.setStrings("Wrench", "Tool", "");
        this.attack = 1;
        this.attackRange = 0.02f;
        this.durability = 100;
        break;
      case 2974:
        this.setStrings("Rope", "Tool", "");
        this.tier = 2;
        this.durability = 100;
        break;
      case 2975:
        this.setStrings("Hammer", "Tool", "");
        this.tier = 2;
        this.attack = 2;
        this.attackRange = 0.02f;
        this.durability = 100;
        break;
      case 2976:
        this.setStrings("Window Breaker", "Tool", "");
        this.tier = 2;
        this.attack = 1;
        this.durability = 100;
        break;
      case 2977:
        this.setStrings("Ax", "Tool", "");
        this.tier = 3;
        this.attack = 3;
        this.attackRange = 0.08f;
        this.piercing = 0.15f;
        this.size = 0.32f;
        this.durability = 100;
        break;
      case 2978:
        this.setStrings("Wire Clippers", "Tool", "");
        this.tier = 3;
        this.attack = 2;
        this.attackRange = 0.1f;
        this.size = 0.32f;
        this.durability = 100;
        break;
      case 2979:
        this.setStrings("Saw", "Tool", "");
        this.tier = 3;
        this.attack = 2;
        this.attackRange = 0.05f;
        this.piercing = 0.05f;
        this.size = 0.32f;
        this.durability = 100;
        break;
      case 2980:
        this.setStrings("Drill", "Tool", "");
        this.tier = 4;
        this.attack = 1;
        this.durability = 100;
        break;
      case 2981:
        this.setStrings("Roundsaw", "Tool", "");
        this.tier = 4;
        this.attack = 1;
        this.piercing = 0.05f;
        this.size = 0.35f;
        this.durability = 100;
        break;
      case 2982:
        this.setStrings("Beltsander", "Tool", "");
        this.tier = 4;
        this.attack = 1;
        this.size = 0.35f;
        this.durability = 100;
        break;
      case 2983:
        this.setStrings("Chainsaw", "Tool", "");
        this.tier = 5;
        this.attack = 5;
        this.attackRange = 0.07f;
        this.piercing = 0.2f;
        this.size = 0.38f;
        this.durability = 100;
        break;
      case 2984:
        this.setStrings("Woodglue", "Tool", "");
        this.tier = 2;
        this.durability = 16;
        break;
      case 2985:
        this.setStrings("Nails", "Tool", "");
        this.durability = 8;
        break;
      case 2986:
        this.setStrings("Screws", "Tool", "");
        this.durability = 8;
        this.tier = 2;
        break;
      case 2987:
        this.setStrings("Flint and Steel", "Tool", "");
        this.attack = 0.5f;
        this.tier = 3;
        break;
      case 2988:
        this.setStrings("Lighter", "Tool", "");
        this.tier = 3;
        break;
      case 2991:
        this.setStrings("Rankin's Third Ball", "Rare Object", "");
        this.tier = 1;
        this.size = 0.22f;
        break;
      case 2992:
        this.setStrings("Soldier's Covenant", "Rare Object", "");
        this.tier = 2;
        break;
      case 2993:
        this.setStrings("Jonah Plush Toy", "Rare Object", "");
        this.tier = 3;
        break;
      case 2999:
        this.setStrings("Bens Eyes", "Rare Object", "");
        this.tier = 9;
        break;

      default:
        global.errorMessage("ERROR: Item ID " + ID + " not found.");
        break;
    }
  }
  Item(int ID, float x, float y) {
    this(ID);
    this.x = x;
    this.y = y;
  }

   public String display_name() {
    switch(this.ID) {
      case 2118: // chicken egg
        if (this.toggled) {
          return "Fertilized " + this.display_name;
        }
        return this.display_name;
      case 2901: // key
        return this.display_name + " (" + this.ammo + ")";
      case 2902: // master key
        return this.display_name + " (" + this.ammo * 10 + " - " + PApplet.parseInt(this.ammo * 10 + 9) + ")";
      case 2903: // skeleton key
        return this.display_name + " (" + this.ammo * 100 + " - " + PApplet.parseInt(this.ammo * 100 + 99) + ")";
      case 2906: // car key
        switch(this.ammo) {
          case 1:
            return "Honda CRV key";
          case 2:
            return "Ford F150 key";
          case 3:
            return "VW Jetta key";
          case 4:
            return "VW Beetle key";
          case 5:
            return "Lamborghini key";
          default:
            return this.display_name;
        }
      case 2928: // cigar
        if (this.toggled) {
          return "Lit " + this.display_name;
        }
        return this.display_name;
      default:
        return this.display_name;
    }
  }
   public String display_name_editor() {
    return this.display_name() + " (" + this.map_key + ")";
  }
   public String type() {
    return this.type;
  }
   public String description() {
    return this.description;
  }
   public String selectedObjectTextboxText() {
    String text = "-- " + this.type() + " --\n";
    if (this.curr_health != 0) {
      text += "\nHealth Regeneration: " + this.curr_health;
    }
    if (this.hunger != 0) {
      text += "\nFood: " + this.hunger;
    }
    if (this.thirst != 0) {
      text += "\nThirst: " + this.thirst;
    }
    if (this.money != 0) {
      text += "\nMoney: " + this.money;
    }
    if (this.health != 0) {
      text += "\nHealth: " + this.health;
    }
    if (this.breakable()) {
      switch(this.ID) {
        case 2984: // woodglue
        case 2985: // nails
        case 2986: // screws
          text += "\nAmount Left: " + this.durability;
          break;
        default:
          text += "\nDurability: " + this.durability;
          break;
      }
    }
    if (this.waterBottle()) {
      text += "\nWater: " + this.ammo + "/" + this.maximumAmmo();
    }
    else if (this.ID == 2929) {
      text += "\nGas: " + 0.1f * this.ammo + "/" + round(0.1f * this.maximumAmmo()) + " gallons";
    }
    if (this.type.equals("Ranged Weapon")) {
      text += "\nAmmo: " + this.ammo + "/" + this.maximumAmmo();
      if (this.shootAttack() != 0) {
        text += "\nAttack: " + this.shootAttack();
      }
      if (this.shootMagic() != 0) {
        text += "\nMagic: " + this.shootMagic();
      }
      if (this.shootPiercing() != 0) {
        text += "\nPiercing: " + this.shootPiercing();
      }
      if (this.shootPenetration() != 0) {
        text += "\nPenetration: " + this.shootPenetration();
      }
      if (this.shootRange() != 0) {
        text += "\nRange: " + this.shootRange();
      }
      text += "\nInaccuracy: " + this.shootInaccuracy();
    }
    else {
      if (this.attack != 0) {
        text += "\nAttack: " + this.attack;
      }
      if (this.magic != 0) {
        text += "\nMagic: " + this.magic;
      }
      if (this.piercing != 0) {
        text += "\nPiercing: " + this.piercing;
      }
      if (this.penetration != 0) {
        text += "\nPenetration: " + this.penetration;
      }
      if (this.attackRange != 0) {
        text += "\nRange: " + this.attackRange;
      }
    }
    if (this.defense != 0) {
      text += "\nDefense: " + this.defense;
    }
    if (this.resistance != 0) {
      text += "\nResistance: " + this.resistance;
    }
    if (this.attackCooldown != 0) {
      text += "\nAttack Cooldown: " + this.attackCooldown;
    }
    if (this.attackTime != 0) {
      text += "\nAttack Time: " + this.attackTime;
    }
    if (this.sight != 0) {
      text += "\nSight: " + this.sight;
    }
    if (this.speed != 0) {
      text += "\nSpeed: " + this.speed;
    }
    if (this.tenacity != 0) {
      text += "\nTenacity: " + this.tenacity;
    }
    if (this.agility != 0) {
      text += "\nAgility: " + this.agility;
    }
    if (this.lifesteal != 0) {
      text += "\nLifesteal: " + this.lifesteal;
    }
    return text + "\n\n" + this.description();
  }

   public void setLocation(float x, float y) {
    this.x = x;
    this.y = y;
  }

   public float xi() {
    return this.x - this.size;
  }
   public float yi() {
    return this.y - this.size;
  }
   public float xf() {
    return this.x + this.size;
  }
   public float yf() {
    return this.y + this.size;
  }
   public float xCenter() {
    return this.x;
  }
   public float yCenter() {
    return this.y;
  }
   public float width() {
    return 2 * this.size;
  }
   public float height() {
    return 2 * this.size;
  }
   public float xRadius() {
    return this.size;
  }
   public float yRadius() {
    return this.size;
  }

   public PImage getImage() {
    String path = "items/";
    switch(this.ID) {
      // Consumables
      case 2101:
        path += "crumb.png";
        break;
      case 2102:
        path += "wasabi.png";
        break;
      case 2103:
        path += "stuffing.jpg";
        break;
      case 2104:
        path += "catbarf.jpg";
        break;
      case 2105:
        path += "ramen.png";
        break;
      case 2106:
        path += "pickle.png";
        break;
      case 2107:
        path += "ketchup.png";
        break;
      case 2108:
        path += "chicken_wing.png";
        break;
      case 2109:
        path += "steak.png";
        break;
      case 2110:
        path += "poptart.png";
        break;
      case 2111:
        path += "donut.png";
        break;
      case 2112:
        path += "chocolate.png";
        break;
      case 2113:
        path += "chips.png";
        break;
      case 2114:
        path += "cheese.png";
        break;
      case 2115:
        path += "peanuts.png";
        break;
      case 2116:
        path += "raw_chicken.png";
        break;
      case 2117:
        path += "cooked_chicken.png";
        break;
      case 2118:
        path += "chicken_egg.png";
        break;
      case 2119:
        path += "rotten_flesh.png";
        break;
      case 2120:
        path += "apple.png";
        break;
      case 2121:
        path += "banana.png";
        break;
      case 2122:
        path += "pear.png";
        break;
      case 2123:
        path += "bread.png";
        break;
      case 2124:
        path += "hotpocket_box.png";
        break;
      case 2125:
        path += "hotpocket.png";
        break;
      case 2131:
        path += "water_cup.png";
        break;
      case 2132:
        path += "coke.png";
        break;
      case 2133:
        path += "wine.png";
        break;
      case 2134:
        path += "beer.png";
        break;
      case 2141:
        path += "holy_water.png";
        break;
      case 2142:
        path += "golden_apple.png";
        break;
      case 2151:
        path += "one_dollar.png";
        break;
      case 2152:
        path += "five_dollars.png";
        break;
      case 2153:
        path += "ten_dollars.png";
        break;
      case 2154:
        path += "fifty_dollars.png";
        break;
      case 2155:
        path += "zucc_bucc.png";
        break;
      case 2156:
        path += "wad_of_fives.png";
        break;
      case 2157:
        path += "wad_of_tens.png";
        break;
      case 2158:
        path += "wad_of_fifties.png";
        break;
      case 2159:
        path += "wad_of_zuccs.png";
        break;
      case 2161:
        path += "broken_candlestick.png";
        break;
      case 2162:
        path += "candlestick.png";
        break;
      case 2163:
        path += "candle.png";
        break;
      case 2164:
        path += "lords_day_candle.png";
        break;
      case 2165:
        path += "lords_day_papers.png";
        break;
      case 2166:
        path += "wooden_horse.png";
        break;
      // Melee Weapons
      case 2201:
        path += "foam_sword.png";
        break;
      case 2202:
        path += "pan.png";
        break;
      case 2203:
        path += "knife.png";
        break;
      case 2204:
        path += "decoy.png";
        break;
      case 2205:
        path += "wooden_sword.png";
        break;
      case 2206:
        path += "talc_sword.png";
        break;
      case 2207:
        path += "wooden_spear.png";
        break;
      case 2208:
        path += "talc_spear.png";
        break;
      case 2211:
        path += "the_thing.png";
        break;
      case 2212:
        path += "gypsum_sword.png";
        break;
      case 2213:
        path += "gypsum_spear.png";
        break;
      case 2214:
        path += "board_with_nails.png";
        break;
      case 2221:
        path += "calcite_sword.png";
        break;
      case 2222:
        path += "calcite_spear.png";
        break;
      case 2223:
        path += "metal_pipe.png";
        break;
      case 2231:
        path += "fluorite_sword.png";
        break;
      case 2232:
        path += "fluorite_spear.png";
        break;
      case 2241:
        path += "apatite_sword.png";
        break;
      case 2242:
        path += "apatite_spear.png";
        break;
      case 2251:
        path += "orthoclase_sword.png";
        break;
      case 2252:
        path += "orthoclase_spear.png";
        break;
      case 2261:
        path += "quartz_sword.png";
        break;
      case 2262:
        path += "quartz_spear.png";
        break;
      case 2271:
        path += "topaz_sword.png";
        break;
      case 2272:
        path += "topaz_spear.png";
        break;
      case 2281:
        path += "corundum_sword.png";
        break;
      case 2282:
        path += "corundum_spear.png";
        break;
      case 2291:
        path += "diamond_sword.png";
        break;
      case 2292:
        path += "diamond_spear.png";
        break;
      // Ranged Weapons
      case 2301:
        if (this.ammo > 0) {
          path += "slingshot_loaded.png";
        }
        else {
          path += "slingshot_unloaded.png";
        }
        break;
      case 2311:
        if (this.ammo > 0) {
          path += "recurve_bow_loaded.png";
        }
        else {
          path += "recurve_bow_unloaded.png";
        }
        break;
      case 2312:
        path += "m1911.png";
        break;
      case 2321:
        path += "war_machine.png";
        break;
      case 2322:
        path += "five_seven.png";
        break;
      case 2323:
        path += "type25.png";
        break;
      case 2331:
        path += "mustang_and_sally.png";
        break;
      case 2332:
        path += "fal.png";
        break;
      case 2333:
        path += "python.png";
        break;
      case 2341:
        path += "rpg.png";
        break;
      case 2342:
        path += "dystopic_demolisher.png";
        break;
      case 2343:
        path += "ultra.png";
        break;
      case 2344:
        path += "strain25.png";
        break;
      case 2345:
        path += "executioner.png";
        break;
      case 2351:
        path += "galil.png";
        break;
      case 2352:
        path += "wn.png";
        break;
      case 2353:
        if (this.ammo > 0) {
          path += "ballistic_knife_loaded.png";
        }
        else {
          path += "ballistic_knife.png";
        }
        break;
      case 2354:
        path += "cobra.png";
        break;
      case 2355:
        path += "mtar.png";
        break;
      case 2361:
        path += "rpd.png";
        break;
      case 2362:
        path += "rocket_propelled_grievance.png";
        break;
      case 2363:
        path += "dsr-50.png";
        break;
      case 2364:
        path += "voice_of_justice.png";
        break;
      case 2371:
        path += "hamr.png";
        break;
      case 2372:
        path += "ray_gun.png";
        break;
      case 2373:
        path += "lamentation.png";
        break;
      case 2374:
        path += "the_krauss_refibrillator.png";
        break;
      case 2375:
        path += "malevolent_taxonomic_anodized_redeemer.png";
        break;
      case 2381:
        path += "relativistic_punishment_device.png";
        break;
      case 2382:
        path += "dead_specimen_reactor_5000.png";
        break;
      case 2391:
        path += "sldg_hamr.png";
        break;
      case 2392:
        path += "porters_x2_ray_gun.png";
        break;
      // Headgear
      case 2401:
        path += "talc_helmet.png";
        break;
      case 2402:
        path += "cap.png";
        break;
      case 2403:
        path += "bowl.png";
        break;
      case 2404:
        path += "pot.png";
        break;
      case 2411:
        path += "gypsum_helmet.png";
        break;
      case 2421:
        path += "calcite_helmet.png";
        break;
      case 2431:
        path += "fluorite_helmet.png";
        break;
      case 2441:
        path += "apatite_helmet.png";
        break;
      case 2451:
        path += "orthoclase_helmet.png";
        break;
      case 2461:
        path += "quartz_helmet.png";
        break;
      case 2471:
        path += "topaz_helmet.png";
        break;
      case 2481:
        path += "corundum_helmet.png";
        break;
      case 2491:
        path += "diamond_helmet.png";
        break;
      // Chestgear
      case 2501:
        path += "talc_chestplate.png";
        break;
      case 2502:
        path += "tshirt.png";
        break;
      case 2503:
        path += "bra.png";
        break;
      case 2504:
        path += "coat.png";
        break;
      case 2511:
        path += "gypsum_chestplate.png";
        break;
      case 2512:
        path += "bens_coat.png";
        break;
      case 2513:
        path += "suit_jacket.png";
        break;
      case 2521:
        path += "calcite_chestplate.png";
        break;
      case 2531:
        path += "fluorite_chestplate.png";
        break;
      case 2541:
        path += "apatite_chestplate.png";
        break;
      case 2551:
        path += "orthoclase_chestplate.png";
        break;
      case 2561:
        path += "quartz_chestplate.png";
        break;
      case 2571:
        path += "topaz_chestplate.png";
        break;
      case 2581:
        path += "corundum_chestplate.png";
        break;
      case 2591:
        path += "diamond_chestplate.png";
        break;
      // Leggear
      case 2601:
        path += "talc_greaves.png";
        break;
      case 2602:
        path += "boxers.png";
        break;
      case 2603:
        path += "towel.png";
        break;
      case 2604:
        path += "pants.png";
        break;
      case 2611:
        path += "gypsum_greaves.png";
        break;
      case 2621:
        path += "calcite_greaves.png";
        break;
      case 2631:
        path += "fluorite_greaves.png";
        break;
      case 2641:
        path += "apatite_greaves.png";
        break;
      case 2651:
        path += "orthoclase_greaves.png";
        break;
      case 2661:
        path += "quartz_greaves.png";
        break;
      case 2671:
        path += "topaz_greaves.png";
        break;
      case 2681:
        path += "corundum_greaves.png";
        break;
      case 2691:
        path += "diamond_greaves.png";
        break;
      // Footgear
      case 2701:
        path += "talc_boots.png";
        break;
      case 2702:
        path += "socks.png";
        break;
      case 2703:
        path += "sandals.png";
        break;
      case 2704:
        path += "shoes.png";
        break;
      case 2705:
        path += "boots.png";
        break;
      case 2711:
        path += "gypsum_boots.png";
        break;
      case 2712:
        path += "sneakers.png";
        break;
      case 2713:
        path += "steel-toed_boots.png";
        break;
      case 2714:
        path += "cowboy_boots.png";
        break;
      case 2721:
        path += "calcite_boots.png";
        break;
      case 2731:
        path += "fluorite_boots.png";
        break;
      case 2741:
        path += "apatite_boots.png";
        break;
      case 2751:
        path += "orthoclase_boots.png";
        break;
      case 2761:
        path += "quartz_boots.png";
        break;
      case 2771:
        path += "topaz_boots.png";
        break;
      case 2781:
        path += "corundum_boots.png";
        break;
      case 2791:
        path += "diamond_boots.png";
        break;
      // Materials
      case 2801:
        path += "talc_ore.png";
        break;
      case 2802:
        path += "talc_crystal.png";
        break;
      case 2803:
        path += "talc_powder.png";
        break;
      case 2804:
        path += "soapstone.png";
        break;
      case 2805:
        path += "broken_glass.png";
        break;
      case 2806:
        path += "wire.png";
        break;
      case 2807:
        path += "feather.png";
        break;
      case 2808:
        path += "ashes.png";
        break;
      case 2809:
        path += "string.png";
        break;
      case 2810:
        path += "wax.png";
        break;
      case 2811:
        path += "gypsum_ore.png";
        break;
      case 2812:
        path += "gypsum_crystal.png";
        break;
      case 2813:
        path += "gypsum_powder.png";
        break;
      case 2814:
        path += "selenite_crystal.png";
        break;
      case 2815:
        path += "barbed_wire.png";
        break;
      case 2816:
        path += "wooden_plank.png";
        break;
      case 2817:
        path += "wooden_handle.png";
        break;
      case 2818:
        path += "wooden_piece.png";
        break;
      case 2821:
        path += "calcite_ore.png";
        break;
      case 2822:
        path += "calcite_crystal.png";
        break;
      case 2823:
        path += "chalk.png";
        break;
      case 2824:
        path += "iceland_spar.png";
        break;
      case 2825:
        int frame = constrain(PApplet.parseInt(floor(Constants.item_starPieceFrames * (millis() %
          Constants.item_starPieceAnimationTime) / Constants.item_starPieceAnimationTime)),
          0, Constants.item_starPieceFrames - 1);
        path += "star_piece_" + frame + ".png";
        break;
      case 2831:
        path += "fluorite_ore.png";
        break;
      case 2832:
        path += "fluorite_crystal.png";
        break;
      case 2833:
        path += "iron_ore.png";
        break;
      case 2834:
        path += "iron_chunk.png";
        break;
      case 2841:
        path += "apatite_ore.png";
        break;
      case 2842:
        path += "apatite_crystal.png";
        break;
      case 2843:
        path += "iron_handle.png";
        break;
      case 2851:
        path += "orthoclase_ore.png";
        break;
      case 2852:
        path += "orthoclase_chunk.png";
        break;
      case 2861:
        path += "quartz_ore.png";
        break;
      case 2862:
        path += "quartz_crystal.png";
        break;
      case 2863:
        path += "amethyst.png";
        break;
      case 2864:
        path += "glass.png";
        break;
      case 2871:
        path += "topaz_ore.png";
        break;
      case 2872:
        path += "topaz_chunk.png";
        break;
      case 2873:
        path += "topaz_gem.png";
        break;
      case 2881:
        path += "corundum_ore.png";
        break;
      case 2882:
        path += "corundum_chunk.png";
        break;
      case 2883:
        path += "sapphire.png";
        break;
      case 2891:
        path += "diamond_ore.png";
        break;
      case 2892:
        path += "diamond.png";
        break;
      // Other
      case 2901:
        path += "key.png";
        break;
      case 2902:
        path += "master_key.png";
        break;
      case 2903:
        path += "skeleton_key.png";
        break;
      case 2904:
        path += "small_keyring.png";
        break;
      case 2905:
        path += "large_keyring.png";
        break;
      case 2906:
        path += "car_key.png";
        break;
      case 2911:
        path += "pen.png";
        break;
      case 2912:
        path += "pencil.png";
        break;
      case 2913:
        path += "paper.png";
        break;
      case 2914:
        path += "document.png";
        break;
      case 2915:
        path += "stapler.png";
        break;
      case 2916:
        path += "crumpled_paper.png";
        break;
      case 2917:
        path += "eraser.png";
        break;
      case 2918:
        path += "scissors.png";
        break;
      case 2921:
        path += "backpack.png";
        break;
      case 2922:
        path += "bens_backpack.png";
        break;
      case 2923:
        path += "purse.png";
        break;
      case 2924:
        float water_percent = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        if (water_percent > 0.95f) {
          path += "glass_bottle_water_full.png";
        }
        else if (water_percent > 0.8f) {
          path += "glass_bottle_water_85.png";
        }
        else if (water_percent > 0.65f) {
          path += "glass_bottle_water_70.png";
        }
        else if (water_percent > 0.5f) {
          path += "glass_bottle_water_55.png";
        }
        else if (water_percent > 0.35f) {
          path += "glass_bottle_water_40.png";
        }
        else if (water_percent > 0.2f) {
          path += "glass_bottle_water_25.png";
        }
        else if (water_percent > 0) {
          path += "glass_bottle_water_10.png";
        }
        else {
          path += "glass_bottle.png";
        }
        break;
      case 2925:
        path += "water_bottle.png";
        break;
      case 2926:
        path += "canteen.png";
        break;
      case 2927:
        path += "water_jug.png";
        break;
      case 2928:
        if (this.toggled) {
          path += "cigar_lit.png";
        }
        else {
          path += "cigar.png";
        }
        break;
      case 2929:
        path += "gas_can.png";
        break;
      case 2931:
        path += "rock.png";
        break;
      case 2932:
        path += "arrow.png";
        break;
      case 2933:
        path += "pebble.png";
        break;
      case 2941:
        path += "45_acp.png";
        break;
      case 2942:
        path += "762_39mm.png";
        break;
      case 2943:
        path += "556_45mm.png";
        break;
      case 2944:
        path += "grenade.png";
        break;
      case 2945:
        path += "357_magnum.png";
        break;
      case 2946:
        path += "50_bmg.png";
        break;
      case 2947:
        path += "fn_57_28mm.png";
        break;
      case 2948:
        path += "28_gauge.png";
        break;
      case 2961:
        path += "dandelion.png";
        break;
      case 2962:
        path += "rose.png";
        break;
      case 2963:
        path += "stick.png";
        break;
      case 2964:
        path += "kindling.png";
        break;
      case 2965:
        path += "branch_maple.png";
        break;
      case 2966:
        path += "branch_unknown.png";
        break;
      case 2967:
        path += "branch_cedar.png";
        break;
      case 2968:
        path += "branch_pine.png";
        break;
      case 2969:
        path += "wooden_log.png";
        break;
      case 2971:
        path += "paintbrush.png";
        break;
      case 2972:
        path += "clamp.png";
        break;
      case 2973:
        path += "wrench.png";
        break;
      case 2974:
        path += "rope.png";
        break;
      case 2975:
        path += "hammer.png";
        break;
      case 2976:
        path += "window_breaker.png";
        break;
      case 2977:
        path += "ax.png";
        break;
      case 2978:
        path += "wire_clippers.png";
        break;
      case 2979:
        path += "saw.png";
        break;
      case 2980:
        path += "drill.png";
        break;
      case 2981:
        path += "roundsaw.png";
        break;
      case 2982:
        path += "beltsander.png";
        break;
      case 2983:
        path += "chainsaw.png";
        break;
      case 2984:
        path += "woodglue.png";
        break;
      case 2985:
        path += "nails.png";
        break;
      case 2986:
        path += "screws.png";
        break;
      case 2987:
        path += "flint_and_steel.png";
        break;
      case 2988:
        path += "lighter.png";
        break;
      case 2991:
        path += "rankins_third_ball.png";
        break;
      case 2992:
        path += "soldiers_covenant.png";
        break;
      case 2993:
        path += "jonah_plush_toy.png";
        break;
      case 2999:
        path += "bens_eyes.png";
        break;
      default:
        global.errorMessage("ERROR: Item ID " + ID + " not found.");
        path += "default.png";
        break;
    }
    return global.images.getImage(path);
  }


   public boolean targetable(Unit u) {
    return true;
  }


   public boolean equippable(GearSlot slot) {
    switch(slot) {
      case WEAPON:
        return true;
      case HEAD:
        if (this.type.equals("Headgear")) {
          return true;
        }
        return false;
      case CHEST:
        if (this.type.equals("Chestgear")) {
          return true;
        }
        return false;
      case LEGS:
        if (this.type.equals("Leggear")) {
          return true;
        }
        return false;
      case FEET:
        if (this.type.equals("Footgear")) {
          return true;
        }
        return false;
      case OFFHAND:
        if (this.type.equals("Offhand")) {
          return true;
        }
        return false;
      case BELT_LEFT:
        if (this.type.equals("Belt")) {
          return true;
        }
        return false;
      case BELT_RIGHT:
        if (this.type.equals("Belt")) {
          return true;
        }
        return false;
      default:
        return false;
    }
  }

   public float speedWhenHolding() {
    if (this.weapon()) {
      return this.speed;
    }
    switch(this.ID) {
      case 2816: // woden plank
      case 2969: // wooden log
        return this.speed;
      default:
        return 0;
    }
  }

   public boolean weapon() {
    if (this.type.contains("Weapon") || this.throwable()) {
      return true;
    }
    return false;
  }

   public boolean armor() {
    switch(this.type) {
      case "Headgear":
      case "Chestgear":
      case "Leggear":
      case "Footgear":
        return true;
      default:
        return false;
    }
  }

   public int maxStack() {
    if (this.toggled) {
      return 1;
    }
    switch(this.ID) {
      case 2101: // crumb
      case 2102: // unknown food
      case 2103: // unknown food
      case 2104: // unknown food
      case 2105: // unknown food
      case 2106: // pickle
      case 2107: // ketchup
      case 2108: // chicken wing
      case 2109: // steak
      case 2110: // poptart
      case 2111: // donut
      case 2112: // chocolate
      case 2113: // chips
      case 2114: // cheese
      case 2115: // peanuts
      case 2116: // raw chicken
      case 2117: // cooked chicken
      case 2118: // chicken egg
      case 2119: // rotten flesh
      case 2120: // apple
      case 2121: // banana
      case 2122: // pear
      case 2123: // bread
      case 2125: // hot pocket
        return 8;
      case 2131: // water cup
      case 2132: // coke
      case 2133: // wine
      case 2134: // beer
      case 2141: // holy water
      case 2142: // golden apple
        return 4;
      case 2151: // one dollar
      case 2152: // five dollars
      case 2153: // ten dollars
      case 2154: // fifty dollars
      case 2155: // zucc bucc
      case 2156: // wad of 5s
      case 2157: // wad of 10s
      case 2158: // wad of 50s
      case 2159: // wad of zuccs
        return 100;
      case 2801: // talc ore
      case 2802: // talc crystal
      case 2803: // talc powder
      case 2804: // soapstone
      case 2805: // broken glass
      case 2806: // wire
      case 2807: // feather
      case 2811: // gypsum ore
      case 2812: // gypsum crystal
      case 2813: // gypsum powder
      case 2814: // selenite crystal
      case 2815: // barbed wire
      case 2821: // calcite ore
      case 2822: // calcite crystal
      case 2823: // chalk
      case 2824: // iceland spar
      case 2825: // star piece
      case 2831: // fluorite ore
      case 2832: // fluorite crystal
      case 2833: // iron ore
      case 2834: // iron chunk
      case 2841: // apatite ore
      case 2842: // apatite crystal
      case 2851: // orthoclase ore
      case 2852: // orthoclase chunk
      case 2853: // moonstone
      case 2861: // quartz ore
      case 2862: // quartz crystal
      case 2863: // amethyst
      case 2864: // glass
      case 2871: // topaz ore
      case 2872: // topaz chunk
      case 2873: // topaz gem
      case 2881: // corundum ore
      case 2882: // corundum chunk
      case 2883: // sapphire
      case 2891: // diamond ore
      case 2892: // diamond
        return 60;
      case 2816: // wooden plank
        return 4;
      case 2817: // wooden handle
      case 2818: // wooden piece
      case 2843: // iron handle
        return 16;
      case 2911: // pen
      case 2912: // pencil
      case 2913: // paper
      case 2914: // document
      case 2916: // crumpled paper
      case 2917: // eraser
        return 12;
      case 2931: // rock
      case 2932: // arrow
      case 2933: // pebble
        return 20;
      case 2941: // .45 ACP
      case 2942: // 7.62
      case 2943: // 5.56
      case 2945: // .357 magnum
      case 2946: // .50 BMG
      case 2947: // FN 4.7
      case 2948: // 28 gauge
        return 100;
      case 2944: // grenade
        return 4;
      case 2961: // dandelion
      case 2962: // rose
      case 2963: // stick
      case 2964: // kindling
      case 2965: // branch (maple)
      case 2966: // branch (unknown)
      case 2967: // branch (cedar)
      case 2968: // branch (pine)
        return 12;
      default:
        return 1;
    }
  }

   public void addStack() {
    this.addStack(1);
  }
   public void addStack(int amount) {
    this.stack += amount;
    if (this.stack <= 0) {
      this.remove = true;
    }
    if (this.stack > this.maxStack()) {
      global.errorMessage("ERROR: Stack of " + this.display_name() + " too big.");
    }
  }

   public void removeStack() {
    this.removeStack(1);
  }
   public void removeStack(int amount) {
    this.stack -= amount;
    if (this.stack <= 0) {
      this.remove = true;
    }
  }

   public boolean usable() {
    return this.consumable() || this.reloadable() || this.money() || this.utility() || this.openable();
  }

   public boolean openable() {
    return this.type.equals("Package");
  }

   public boolean waterBottle() {
    switch(this.ID) {
      case 2924: // glass bottle
      case 2925: // water bottle
      case 2926: // canteen
      case 2927: // water jug
        return true;
      default:
        return false;
    }
  }

   public boolean utility() {
    return this.type.equals("Utility");
  }

   public boolean key() {
    return this.type.equals("Key");
  }

   public boolean money() {
    return this.type.equals("Money");
  }

   public boolean consumable() {
    return this.type.equals("Food") || this.type.equals("Drink");
  }

   public void consumed() {
    this.removeStack();
  }

   public boolean unlocks(int lock_code) {
    switch(this.ID) {
      case 2901: // key
        return this.ammo == lock_code;
      case 2902: // master key
        return this.ammo == lock_code / 10;
      case 2903: // skeleton key
        return this.ammo == lock_code / 100;
      case 2904: // small keyring
      case 2905: // large keyring
        for (Item i : this.inventory.items()) {
          if (i == null || i.remove) {
            continue;
          }
          if (i.unlocks(lock_code)) {
            return true;
          }
        }
        return false;
      case 2906: // car key
        switch(lock_code) {
          case 501: // Honda CRV
            return this.ammo == 1;
          case 502: // Ford F150
            return this.ammo == 2;
          case 503: // VS Jetta
            return this.ammo == 3;
          case 504: // VS Beetle
            return this.ammo == 4;
          case 505: // Lamborghini
            return this.ammo == 5;
          default:
            return false;
        }
      default:
        return false;
    }
  }

   public boolean reloadable() {
    if (this.type.equals("Ranged Weapon") && this.availableAmmo() < this.maximumAmmo()) {
      return true;
    }
    return false;
  }

   public ArrayList<Integer> possibleAmmo() {
    ArrayList<Integer> possible_ammo = new ArrayList<Integer>();
    switch(this.ID) {
      case 2301: // Slingshot
        possible_ammo.add(2931);
        possible_ammo.add(2933);
        break;
      case 2311: // Recurve Bow
        possible_ammo.add(2932);
        break;
      case 2312: // M1911
        possible_ammo.add(2941);
        break;
      case 2321: // War Machine
        possible_ammo.add(2944);
        break;
      case 2322: // Five-Seven
        possible_ammo.add(2947);
        break;
      case 2323: // Type25
        possible_ammo.add(2943);
        break;
      case 2331: // Mustang and Sally
        possible_ammo.add(2944);
        break;
      case 2332: // FAL
        possible_ammo.add(2942);
        break;
      case 2333: // Python
        possible_ammo.add(2945);
        break;
      case 2341: // RPG
        possible_ammo.add(2944);
        break;
      case 2342: // Dystopic Demolisher
        possible_ammo.add(2944);
        break;
      case 2343: // Ultra
        possible_ammo.add(2947);
        break;
      case 2344: // Strain25
        possible_ammo.add(2943);
        break;
      case 2345: // Executioner
        possible_ammo.add(2948);
        break;
      case 2351: // Galil
        possible_ammo.add(2943);
        break;
      case 2352: // WN
        possible_ammo.add(2942);
        break;
      case 2353: // Ballistic Knife
        possible_ammo.add(2203);
        break;
      case 2354: // Cobra
        possible_ammo.add(2945);
        break;
      case 2355: // MTAR
        possible_ammo.add(2943);
        break;
      case 2361: // RPD
        possible_ammo.add(2942);
        break;
      case 2362: // Rocket-Propelled Grievance
        possible_ammo.add(2944);
        break;
      case 2363: // DSR-50
        possible_ammo.add(2946);
        break;
      case 2364: // Voice of Justice
        possible_ammo.add(2948);
        break;
      case 2371: // HAMR
        possible_ammo.add(2942);
        break;
      case 2372: // Ray Gun
        break;
      case 2373: // Lamentation
        possible_ammo.add(2942);
        break;
      case 2374: // The Krauss Refibrillator
        possible_ammo.add(2203);
        break;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        possible_ammo.add(2943);
        break;
      case 2381: // Relativistic Punishment Device
        possible_ammo.add(2942);
        break;
      case 2382: // Dead Specimen Reactor 5000
        possible_ammo.add(2946);
        break;
      case 2391: // SLDG HAMR
        possible_ammo.add(2942);
        break;
      case 2392: // Porter's X2 Ray Gun
        break;
      default:
        break;
    }
    return possible_ammo;
  }

   public boolean shootable() {
    if (this.remove) {
      return false;
    }
    if (this.throwable()) {
      return true;
    }
    else if (this.type.equals("Ranged Weapon") && this.availableAmmo() > 0 && !this.toggled) {
      return true;
    }
    return false;
  }

   public boolean throwable() {
    if (this.remove) {
      return false;
    }
    switch(this.ID) {
      case 2118:
      case 2924:
      case 2931:
      case 2932:
      case 2933:
      case 2944:
        return true;
      default:
        return false;
    }
  }

   public boolean meleeAttackable() {
    if (!this.shootable()) {
      return true;
    }
    if (this.throwable()) {
      return true;
    }
    switch(this.ID) {
      case 2353: // Ballistic Knife
      case 2374: // The Krauss Refibrillator
        return true;
      default:
        return false;
    }
  }

   public void shot() {
    this.lowerDurability();
    if (this.throwable()) {
      this.removeStack();
    }
    else {
      this.ammo--;
    }
  }

   public void attacked() {
    this.lowerDurability();
  }


   public boolean automatic() {
    switch(this.ID) {
      case 2323: // Type25
      case 2344: // Strain25
      case 2351: // Galil
      case 2355: // MTAR
      case 2361: // RPD
      case 2362: // Rocket-Propelled Grievance
      case 2371: // HAMR
      case 2372: // Ray Gun
      case 2373: // Lamentation
      case 2375: // MAlevolent Taxonomic Anodized Redeemer
      case 2381: // Relativistic Punishment Device
      case 2391: // SLDG HAMR
      case 2392: // Porter's X2 Ray Gun
        return true;
      default:
        return false;
    }
  }


   public float shootAttack() {
    switch(this.ID) {
      case 2118: // Chicken Egg (thrown)
        return 2;
      case 2301: // Slingshot
        return 5;
      case 2311: // Recurve Bow
        return 8;
      case 2312: // M1911
        return 20;
      case 2321: // War Machine
        return 8;
      case 2322: // Five-Seven
        return 160;
      case 2323: // Type25
        return 110;
      case 2331: // Mustang and Sally
        return 1000;
      case 2332: // FAL
        return 160;
      case 2333: // Python
        return 1000;
      case 2341: // RPG
        return 600;
      case 2342: // Dystopic Demolisher
        return 600;
      case 2343: // Ultra
        return 300;
      case 2344: // Strain25
        return 160;
      case 2345: // Executioner
        return 1040;
      case 2351: // Galil
        return 150;
      case 2352: // WN
        return 240;
      case 2353: // Ballistic Knife
        return 500;
      case 2354: // Cobra
        return 1000;
      case 2355: // MTAR
        return 140;
      case 2361: // RPD
        return 140;
      case 2362: // Rocket-Propelled Grievance
        return 1200;
      case 2363: // DSR-50
        return 800;
      case 2364: // Voice of Justice
        return 4200;
      case 2371: // HAMR
        return 190;
      case 2372: // Ray Gun
        return 500;
      case 2373: // Lamentation
        return 220;
      case 2374: // The Krauss Refibrillator
        return 1000;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 210;
      case 2381: // Relativistic Punishment Device
        return 180;
      case 2382: // Dead Specimen Reactor 5000
        return 1000;
      case 2391: // SLDG HAMR
        return 250;
      case 2392: // Porter's X2 Ray Gun
        return 600;
      case 2924: // Glass Bottle (thrown)
        return 1;
      case 2931: // Rock (thrown)
        return 2;
      case 2932: // Arrow (thrown)
        return 2;
      case 2933: // Pebble (thrown)
        return 1;
      case 2944: // Grenade (thrown)
        return 3;
      default:
        return 0;
    }
  }

   public float shootMagic() {
    switch(this.ID) {
      case 2372: // Ray Gun
        return 500;
      case 2392: // Porter's X2 Ray Gun
        return 600;
      default:
        return 0;
    }
  }

   public float shootPiercing() {
    switch(this.ID) {
      case 2311: // Recurve Bow
        return 0.15f;
      case 2312: // M1911
        return 0.12f;
      case 2321: // War Machine
        return 0.05f;
      case 2322: // Five-Seven
        return 0.1f;
      case 2323: // Type25
        return 0.18f;
      case 2331: // Mustang and Sally
        return 0.05f;
      case 2332: // FAL
        return 0.15f;
      case 2333: // Python
        return 0.15f;
      case 2341: // RPG
        return 0.06f;
      case 2342: // Dystopic Demolisher
        return 0.15f;
      case 2343: // Ultra
        return 0.15f;
      case 2344: // Strain25
        return 0.24f;
      case 2345: // Executioner
        return 0.1f;
      case 2351: // Galil
        return 0.16f;
      case 2352: // WN
        return 0.2f;
      case 2353: // Ballistic Knife
        return 0.25f;
      case 2354: // Cobra
        return 0.15f;
      case 2355: // MTAR
        return 0.16f;
      case 2361: // RPD
        return 0.15f;
      case 2362: // Rocket-Propelled Grievance
        return 0.08f;
      case 2363: // DSR-50
        return 0.3f;
      case 2364: // Voice of Justice
        return 0.12f;
      case 2371: // HAMR
        return 0.2f;
      case 2372: // Ray Gun
        return 0;
      case 2373: // Lamentation
        return 0.22f;
      case 2374: // The Krauss Refibrillator
        return 0.35f;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 0.2f;
      case 2381: // Relativistic Punishment Device
        return 0.2f;
      case 2382: // Dead Specimen Reactor 5000
        return 0.45f;
      case 2391: // SLDG HAMR
        return 0.25f;
      case 2392: // Porter's X2 Ray Gun
        return 0;
      case 2924: // Glass Bottle (thrown)
        return 0.06f;
      case 2932: // Arrow (thrown)
        return 0.06f;
      default:
        return 0;
    }
  }

   public float shootPenetration() {
    switch(this.ID) {
      case 2372: // Ray Gun
        return 0.08f;
      case 2392: // Porter's X2 Ray Gun
        return 0.12f;
      default:
        return 0;
    }
  }

   public float shootRange() {
    switch(this.ID) {
      case 2118: // Chicken Egg (thrown)
        return 3;
      case 2301: // Slingshot
        return 5.5f;
      case 2311: // Recurve Bow
        return 6.5f;
      case 2312: // M1911
        return 6;
      case 2321: // War Machine
        return 10;
      case 2322: // Five-Seven
        return 7;
      case 2323: // Type25
        return 9;
      case 2331: // Mustang and Sally
        return 12;
      case 2332: // FAL
        return 10;
      case 2333: // Python
        return 7;
      case 2341: // RPG
        return 10;
      case 2342: // Dystopic Demolisher
        return 12;
      case 2343: // Ultra
        return 8;
      case 2344: // Strain25
        return 10;
      case 2345: // Executioner
        return 4;
      case 2351: // Galil
        return 10;
      case 2352: // WN
        return 11;
      case 2353: // Ballistic Knife
        return 7;
      case 2354: // Cobra
        return 7;
      case 2355: // MTAR
        return 11;
      case 2361: // RPD
        return 11;
      case 2362: // Rocket-Propelled Grievance
        return 12;
      case 2363: // DSR-50
        return 16;
      case 2364: // Voice of Justice
        return 5;
      case 2371: // HAMR
        return 10;
      case 2372: // Ray Gun
        return 9;
      case 2373: // Lamentation
        return 11;
      case 2374: // The Krauss Refibrillator
        return 8;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 12;
      case 2381: // Relativistic Punishment Device
        return 12;
      case 2382: // Dead Specimen Reactor 5000
        return 18;
      case 2391: // SLDG HAMR
        return 11;
      case 2392: // Porter's X2 Ray Gun
        return 9;
      case 2924: // Glass Bottle (thrown)
        return 4;
      case 2931: // Rock (thrown)
        return 4.5f;
      case 2932: // Arrow (thrown)
        return 3;
      case 2933: // Pebble (thrown)
        return 3.5f;
      case 2944: // Grenade (thrown)
        return 5.5f;
      default:
        return 0;
    }
  }

   public float shootCooldown() {
    float ammo_ratio = 0;
    switch(this.ID) {
      case 2301: // Slingshot
        return 1300;
      case 2311: // Recurve Bow
        return 1500;
      case 2312: // M1911
        return 96;
      case 2321: // War Machine
        return 250;
      case 2322: // Five-Seven
        return 80;
      case 2323: // Type25
        return 64;
      case 2331: // Mustang and Sally
        return 200;
      case 2332: // FAL
        return 112;
      case 2333: // Python
        return 96;
      case 2341: // RPG
        return 320;
      case 2342: // Dystopic Demolisher
        return 250;
      case 2343: // Ultra
        return 80;
      case 2344: // Strain25
        return 64;
      case 2345: // Executioner
        return 128;
      case 2351: // Galil
        return 80;
      case 2352: // WN
        return 112;
      case 2353: // Ballistic Knife
        return 200;
      case 2354: // Cobra
        return 96;
      case 2355: // MTAR
        return 80;
      case 2361: // RPD
        return 80;
      case 2362: // Rocket-Propelled Grievance
        return 320;
      case 2363: // DSR-50
        return 1200;
      case 2364: // Voice of Justice
        return 128;
      case 2371: // HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 200 - 120 * ammo_ratio;
      case 2372: // Ray Gun
        return 331;
      case 2373: // Lamentation
        return 80;
      case 2374: // The Krauss Refibrillator
        return 200;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 80;
      case 2381: // Relativistic Punishment Device
        return 80;
      case 2382: // Dead Specimen Reactor 5000
        return 1200;
      case 2391: // SLDG HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 200 - 120 * ammo_ratio;
      case 2392: // Porter's X2 Ray Gun
        return 331;
      default:
        return 300;
    }
  }

   public float shootTime() {
    float ammo_ratio = 0;
    switch(this.ID) {
      case 2301: // Slingshot
        return 350;
      case 2311: // Recurve Bow
        return 300;
      case 2312: // M1911
        return 10;
      case 2321: // War Machine
        return 25;
      case 2322: // Five-Seven
        return 8;
      case 2323: // Type25
        return 6;
      case 2331: // Mustang and Sally
        return 20;
      case 2332: // FAL
        return 11;
      case 2333: // Python
        return 10;
      case 2341: // RPG
        return 32;
      case 2342: // Dystopic Demolisher
        return 25;
      case 2343: // Ultra
        return 8;
      case 2344: // Strain25
        return 6;
      case 2345: // Executioner
        return 13;
      case 2351: // Galil
        return 8;
      case 2352: // WN
        return 11;
      case 2353: // Ballistic Knife
        return 5;
      case 2354: // Cobra
        return 10;
      case 2355: // MTAR
        return 8;
      case 2361: // RPD
        return 8;
      case 2362: // Rocket-Propelled Grievance
        return 32;
      case 2363: // DSR-50
        return 120;
      case 2364: // Voice of Justice
        return 13;
      case 2371: // HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 20 - 12 * ammo_ratio;
      case 2372: // Ray Gun
        return 33;
      case 2373: // Lamentation
        return 8;
      case 2374: // The Krauss Refibrillator
        return 5;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 8;
      case 2381: // Relativistic Punishment Device
        return 8;
      case 2382: // Dead Specimen Reactor 5000
        return 120;
      case 2391: // SLDG HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 20 - 12 * ammo_ratio;
      case 2392: // Porter's X2 Ray Gun
        return 33;
      default:
        return 60;
    }
  }

   public float shootRecoil() {
    switch(this.ID) {
      case 2312: // M1911
        return 0.005f;
      case 2321: // War Machine
        return 0.1f;
      case 2322: // Five-Seven
        return 0.002f;
      case 2323: // Type25
        return 0.02f;
      case 2331: // Mustang and Sally
        return 0.08f;
      case 2332: // FAL
        return 0.02f;
      case 2333: // Python
        return 0.015f;
      case 2341: // RPG
        return 0.12f;
      case 2342: // Dystopic Demolisher
        return 0.1f;
      case 2343: // Ultra
        return 0.002f;
      case 2344: // Strain25
        return 0.015f;
      case 2345: // Executioner
        return 0.02f;
      case 2351: // Galil
        return 0.01f;
      case 2352: // WN
        return 0.02f;
      case 2353: // Ballistic Knife
        return 0;
      case 2354: // Cobra
        return 0.015f;
      case 2355: // MTAR
        return 0.015f;
      case 2361: // RPD
        return 0.02f;
      case 2362: // Rocket-Propelled Grievance
        return 0.12f;
      case 2363: // DSR-50
        return 0.25f;
      case 2364: // Voice of Justice
        return 0.02f;
      case 2371: // HAMR
        return 0.02f;
      case 2372: // Ray Gun
        return 0;
      case 2373: // Lamentation
        return 0.01f;
      case 2374: // The Krauss Refibrillator
        return 0;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 0.015f;
      case 2381: // Relativistic Punishment Device
        return 0.02f;
      case 2382: // Dead Specimen Reactor 5000
        return 0.2f;
      case 2391: // SLDG HAMR
        return 0.02f;
      case 2392: // Porter's X2 Ray Gun
        return 0;
      default:
        return 0;
    }
  }

   public float shootInaccuracy() {
    float ammo_ratio = 0;
    switch(this.ID) {
      case 2118: // Chicken Egg (thrown)
        return 0.1f;
      case 2301: // Slingshot
        return 0.12f;
      case 2311: // Recurve Bow
        return 0.12f;
      case 2312: // M1911
        return 0.12f;
      case 2321: // War Machine
        return 0.05f;
      case 2322: // Five-Seven
        return 0.08f;
      case 2323: // Type25
        return 0.15f;
      case 2331: // Mustang and Sally
        return 0.08f;
      case 2332: // FAL
        return 0.1f;
      case 2333: // Python
        return 0.08f;
      case 2341: // RPG
        return 0.08f;
      case 2342: // Dystopic Demolisher
        return 0.05f;
      case 2343: // Ultra
        return 0.06f;
      case 2344: // Strain25
        return 0.1f;
      case 2345: // Executioner
        return 0.05f;
      case 2351: // Galil
        return 0.06f;
      case 2352: // WN
        return 0.08f;
      case 2353: // Ballistic Knife
        return 0.05f;
      case 2354: // Cobra
        return 0.07f;
      case 2355: // MTAR
        return 0.08f;
      case 2361: // RPD
        return 0.1f;
      case 2362: // Rocket-Propelled Grievance
        return 0.08f;
      case 2363: // DSR-50
        return 0.04f;
      case 2364: // Voice of Justice
        return 0.05f;
      case 2371: // HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 0.05f + 0.1f * ammo_ratio;
      case 2372: // Ray Gun
        return 0.05f;
      case 2373: // Lamentation
        return 0.06f;
      case 2374: // The Krauss Refibrillator
        return 0.03f;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 0.08f;
      case 2381: // Relativistic Punishment Device
        return 0.08f;
      case 2382: // Dead Specimen Reactor 5000
        return 0.02f;
      case 2391: // SLDG HAMR
        ammo_ratio = PApplet.parseFloat(this.ammo) / this.maximumAmmo();
        return 0.05f + 0.1f * ammo_ratio;
      case 2392: // Porter's X2 Ray Gun
        return 0.05f;
      case 2924: // Glass Bottle
        return 0.15f;
      case 2931: // Rock (throw)
        return 0.1f;
      case 2932: // Arrow (throw)
        return 0.15f;
      case 2933: // Pebble (throw)
        return 0.1f;
      case 2944: // Grenade (throw)
        return 0.1f;
      default:
        return 0;
    }
  }


   public void lowerDurability() {
    this.lowerDurability(1);
  }
   public void lowerDurability(int amount) {
    if (!this.breakable()) {
      return;
    }
    this.durability -= amount;
    if (this.durability < 1) {
      switch(this.ID) {
        case 2312: // M1911
        case 2321: // War Machine
        case 2322: // Five-Seven
        case 2323: // Type25
        case 2331: // Mustang and Sally
        case 2332: // FAL
        case 2333: // Python
        case 2341: // RPG
        case 2342: // Dystopic Demolisher
        case 2343: // Ultra
        case 2344: // Strain25
        case 2345: // Executioner
        case 2351: // Galil
        case 2352: // WN
        case 2353: // Ballistic Knife
        case 2354: // Cobra
        case 2355: // MTAR
        case 2361: // RPD
        case 2362: // Rocket-Propelled Grievance
        case 2363: // DSR-50
        case 2364: // Voice of Justice
        case 2371: // HAMR
        case 2372: // Ray Gun
        case 2373: // Lamentation
        case 2374: // The Krauss Refibrillator
        case 2375: // Malevolent Taxonomic Anodized Redeemer
        case 2381: // Relativistic Punishment Device
        case 2382: // Dead Specimen Reactor 5000
        case 2391: // SLDG HAMR
        case 2392: // Porter's X2 Ray Gun
          //this.toggled = true; // needs cleaned
          break;
        default:
          this.remove = true;
          break;
      }
    }
  }
   public boolean breakable() { // if item uses durability
    if (this.ID > 2200 && this.ID < 2801) {
      return true;
    }
    switch(this.ID) {
      case 2911: // pen
      case 2912: // pencil
      case 2915: // stapler
      case 2918: // scissors
      case 2924: // glass bottle
      case 2963: // stick
      case 2965: // branch
      case 2966: // branch
      case 2967: // branch
      case 2968: // branch
      case 2969: // wooden log
      case 2971: // paintbrush
      case 2972: // clamp
      case 2973: // wrench
      case 2974: // rope
      case 2975: // hammer
      case 2976: // window breaker
      case 2977: // ax
      case 2978: // wire clippers
      case 2979: // saw
      case 2980: // drill
      case 2981: // roundsaw
      case 2982: // beltsander
      case 2983: // chainsaw
      case 2984: // woodglue
      case 2985: // nails
      case 2986: // screws
        return true;
      default:
        return false;
    }
  }


   public void changeAmmo(int amount) {
    this.ammo += amount;
    if (this.ammo < 0) {
      this.ammo = 0;
    }
    if (this.ammo > this.maximumAmmo()) {
      this.ammo = this.maximumAmmo();
    }
  }
   public int availableAmmo() {
    return this.ammo;
  }
   public int maximumAmmo() {
    switch(this.ID) {
      case 2301: // Slingshot
        return 1;
      case 2311: // Recurve Bow
        return 1;
      case 2312: // M1911
        return 8;
      case 2321: // War Machine
        return 6;
      case 2322: // Five-Seven
        return 20;
      case 2323: // Type25
        return 30;
      case 2331: // Mustang and Sally
        return 6;
      case 2332: // FAL
        return 20;
      case 2333: // Python
        return 6;
      case 2341: // RPG
        return 1;
      case 2342: // Dystopic Demolisher
        return 6;
      case 2343: // Ultra
        return 20;
      case 2344: // Strain25
        return 30;
      case 2345: // Executioner
        return 5;
      case 2351: // Galil
        return 35;
      case 2352: // WN
        return 30;
      case 2353: // Ballistic Knife
        return 1;
      case 2354: // Cobra
        return 12;
      case 2355: // MTAR
        return 30;
      case 2361: // RPD
        return 100;
      case 2362: // Rocket-Propelled Grievance
        return 8;
      case 2363: // DSR-50
        return 4;
      case 2364: // Voice of Justice
        return 5;
      case 2371: // HAMR
        return 125;
      case 2372: // Ray Gun
        return 20;
      case 2373: // Lamentation
        return 35;
      case 2374: // The Krauss Refibrillator
        return 1;
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 30;
      case 2381: // Relativistic Punishment Device
        return 125;
      case 2382: // Dead Specimen Reactor 5000
        return 8;
      case 2391: // SLDG HAMR
        return 125;
      case 2392: // Porter's X2 Ray Gun
        return 40;
      case 2924: // Glass Bottle
        return 30;
      case 2925: // Water Bottle
        return 100;
      case 2926: // Canteen
        return 400;
      case 2927: // Water Jug
        return 2500;
      case 2929: // Gas Can
        return 50;
      default:
        return 0;
    }
  }

   public float useTime() {
    switch(this.ID) {
      case 2101: // crumb
      case 2102: // unknown food
      case 2103: // unknown food
      case 2104: // unknown food
      case 2105: // unknown food
      case 2106: // pickle
      case 2107: // ketchup
      case 2108: // chicken wing
      case 2109: // steak
      case 2110: // poptart
      case 2111: // donut
      case 2112: // chocolate
      case 2113: // chips
      case 2114: // cheese
      case 2115: // peanuts
      case 2116: // raw chicken
      case 2117: // cooked chicken
      case 2118: // chicken egg
      case 2119: // rotten flesh
      case 2120: // apple
      case 2121: // banana
      case 2122: // pear
      case 2123: // bread
      case 2125: // hot pocket
      case 2142: // golden apple
        return 1300;
      case 2131: // water cup
      case 2132: // coke
      case 2133: // wine
      case 2134: // beer
      case 2141: // holy water
      case 2924: // Glass Bottle
      case 2925: // Water Bottle
      case 2926: // Canteen
      case 2927: // Water Jug
        return 1650;
      case 2124: // hot pocket package
        return 1400;
      case 2301: // Slingshot
        return 800;
      case 2311: // Recurve Bow
        return 1100;
      case 2312: // M1911
        return 1000;
      case 2321: // War Machine
        return 6400;
      case 2322: // Five-Seven
      case 2343: // Ultra
        return 1100;
      case 2323: // Type25
      case 2344: // Strain25
        return 860;
      case 2331: // Mustang and Sally
        return 1850;
      case 2332: // FAL
      case 2352: // WN
        return 1300;
      case 2333: // Python
      case 2354: // Cobra
        return 2650;
      case 2341: // RPG
      case 2362: // Rocket-Propelled Grievance
        return 550;
      case 2342: // Dystopic Demolisher
        return 1950;
      case 2345: // Executioner
      case 2364: // Voice of Justice
        return 3770;
      case 2351: // Galil
      case 2373: // Lamentation
        return 1600;
      case 2353: // Ballistic Knife
      case 2374: // The Krauss Refibrillator
        return 180;
      case 2355: // MTAR
      case 2375: // Malevolent Taxonomic Anodized Redeemer
        return 1000;
      case 2361: // RPD
      case 2381: // Relativistic Punishment Device
        return 6300;
      case 2363: // DSR-50
      case 2382: // Dead Specimen Reactor 5000
        return 1950;
      case 2371: // HAMR
      case 2391: // SLDG HAMR
        return 2200;
      case 2372: // Ray Gun
      case 2392: // Porter's X2 Ray Gun
        return 2600;
      default:
        return 0;
    }
  }


  // pickup
   public void pickupSound() {
    String sound_name = "items/pickup/";
    switch(this.ID) {
      case 2204: // Decoy
      case 2211: // The Thing
        sound_name += "sword";
        break;
      case 2980: // Drill
        sound_name = "items/melee/drill" + randomInt(1, 3);
        break;
      case 2981: // Roundsaw
        sound_name += "roundsaw";
        break;
      case 2983: // Chainsaw
        sound_name += "chainsaw";
        break;
      default:
        sound_name += "default";
        break;
    }
    global.sounds.trigger_units(sound_name);
  }

  // equip
   public void equipSound() {
    String sound_name = "player/";
    switch(this.ID) {
      case 2402: // Cap
      case 2502: // T-shirt
      case 2503: // Bra
      case 2504: // Coat
      case 2512: // Ben's Coat
      case 2513: // Suit Jacket
      case 2602: // Boxers
      case 2603: // Towel
      case 2604: // Pants
      case 2702: // Socks
      case 2703: // Sandals
      case 2704: // Shoes
      case 2705: // Boots
      case 2712: // Sneakers
        sound_name += "armor_cloth";
        break;
      default:
        sound_name += "armor_metal";
        break;
    }
    global.sounds.trigger_player(sound_name);
  }

  // melee attack
   public void attackSound() {
    String sound_name = "items/melee/";
    switch(this.ID) {
      case 2203: // knife
      case 2353: // ballistic knife
      case 2374: // the krauss refibrillator
        sound_name += "knife";
        break;
      case 2204: // decoy
      case 2211: // the thing
        sound_name += "sword_swing";
        break;
      case 2206: // talc sword
      case 2212: // gypsum sword
      case 2221: // calcite sword
      case 2231: // fluorite sword
      case 2241: // apatite sword
      case 2251: // orthoclase sword
      case 2261: // quartz sword
      case 2271: // topaz sword
      case 2281: // corundum sword
      case 2291: // diamond sword
        sound_name += "sword";
        break;
      case 2208: // talc spear
      case 2213: // gypsum spear
      case 2222: // calcite spear
      case 2232: // fluorite spear
      case 2242: // apatite spear
      case 2252: // orthoclase spear
      case 2262: // quartz spear
      case 2272: // topaz spear
      case 2282: // corundum spear
      case 2292: // diamond spear
        sound_name += "spear";
        break;
      case 2977: // ax
        sound_name += "ax";
        break;
      case 2979: // saw
        sound_name += "saw";
        break;
      case 2980: // drill
        sound_name += "drill" + randomInt(1, 3);
        break;
      case 2983: // chainsaw
        sound_name += "chainsaw";
        break;
      default:
        sound_name += "default";
        break;
    }
    global.sounds.trigger_units(sound_name);
  }


   public float interactionDistance() {
    switch(this.ID) {
      default:
        return Constants.item_defaultInteractionDistance;
    }
  }


   public void update(int timeElapsed) {
    this.bounce.add(timeElapsed);
    if (this.disappearing) {
      this.disappear_timer -= timeElapsed;
      if (disappear_timer < 0) {
        this.remove = true;
      }
    }
    switch(this.ID) {
      case 2163: // candle
        if (this.toggled) { // lit
          this.ammo -= timeElapsed;
          if (this.ammo < 0) {
            this.toggled = false;
            //this.remove = true;
          }
        }
        break;
      case 2164: // lords day candle
        if (this.toggled) { // lit
          this.ammo -= timeElapsed;
          if (this.ammo < 0) {
            this.toggled = false;
            //this.remove = true;
          }
        }
        break;
      case 2928: // cigar
        if (this.toggled) { // lit
          this.ammo -= timeElapsed;
          if (this.ammo < 0) {
            this.remove = true;
          }
        }
        break;
      default:
        break;
    }
  }

   public String fileString() {
    return this.fileString(null);
  }
   public String fileString(GearSlot slot) {
    String fileString = "\nnew: Item: " + this.ID;
    fileString += this.objectFileString();
    fileString += "\ndisappearing: " + this.disappearing;
    fileString += "\ndisappear_timer: " + this.disappear_timer;
    fileString += "\nstack: " + this.stack;
    if (this.save_base_stats) {
      fileString += "\nsave_base_stats: " + this.save_base_stats;
      fileString += "\nsize: " + this.size;
      fileString += "\ncurr_health: " + this.curr_health;
      fileString += "\nhunger: " + this.hunger;
      fileString += "\nthirst: " + this.thirst;
      fileString += "\nmoney: " + this.money;
      fileString += "\nhealth: " + this.health;
      fileString += "\nattack: " + this.attack;
      fileString += "\nmagic: " + this.magic;
      fileString += "\ndefense: " + this.defense;
      fileString += "\nresistance: " + this.resistance;
      fileString += "\npiercing: " + this.piercing;
      fileString += "\npenetration: " + this.penetration;
      fileString += "\nattackRange: " + this.attackRange;
      fileString += "\nattackCooldown: " + this.attackCooldown;
      fileString += "\nattackTime: " + this.attackTime;
      fileString += "\nsight: " + this.sight;
      fileString += "\nspeed: " + this.speed;
      fileString += "\ntenacity: " + this.tenacity;
      fileString += "\nagility: " + this.agility;
      fileString += "\nlifesteal: " + this.lifesteal;
    }
    fileString += "\ndurability: " + this.durability;
    fileString += "\nammo: " + this.ammo;
    fileString += "\ntoggled: " + this.toggled;
    if (this.inventory != null) {
      fileString += this.inventory.internalFileString();
    }
    fileString += "\nend: Item";
    if (slot != null) {
      fileString += ": " + slot.slot_name();
    }
    return fileString;
  }

   public void addData(String datakey, String data) {
    if (this.addObjectData(datakey, data)) {
      return;
    }
    switch(datakey) {
      case "disappearing":
        this.disappearing = toBoolean(data);
        break;
      case "disappear_timer":
        this.disappear_timer = toInt(data);
        break;
      case "stack":
        this.stack = toInt(data);
        break;
      case "size":
        this.size = toFloat(data);
        break;
      case "save_base_stats":
        this.save_base_stats = toBoolean(data);
        break;
      case "curr_health":
        this.curr_health = toFloat(data);
        break;
      case "hunger":
        this.hunger = toInt(data);
        break;
      case "thirst":
        this.thirst = toInt(data);
        break;
      case "money":
        this.money = toFloat(data);
        break;
      case "health":
        this.health = toFloat(data);
        break;
      case "attack":
        this.attack = toFloat(data);
        break;
      case "magic":
        this.magic = toFloat(data);
        break;
      case "defense":
        this.defense = toFloat(data);
        break;
      case "resistance":
        this.resistance = toFloat(data);
        break;
      case "piercing":
        this.piercing = toFloat(data);
        break;
      case "penetration":
        this.penetration = toFloat(data);
        break;
      case "attackRange":
        this.attackRange = toFloat(data);
        break;
      case "attackCooldown":
        this.attackCooldown = toFloat(data);
        break;
      case "attackTime":
        this.attackTime = toFloat(data);
        break;
      case "sight":
        this.sight = toFloat(data);
        break;
      case "speed":
        this.speed = toFloat(data);
        break;
      case "tenacity":
        this.tenacity = toFloat(data);
        break;
      case "agility":
        this.agility = toInt(data);
        break;
      case "lifesteal":
        this.lifesteal = toFloat(data);
        break;
      case "durability":
        this.durability = toInt(data);
        break;
      case "ammo":
        this.ammo = toInt(data);
        break;
      case "toggled":
        this.toggled = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for Item data.");
        break;
    }
  }
}
class Linker {
  private Rectangle rect1 = new Rectangle();
  private Rectangle rect2 = new Rectangle();

  Linker() {}
  Linker(Rectangle rect1, Rectangle rect2) {
    this.rect1 = rect1;
    this.rect2 = rect2;
  }

   public boolean port(Unit u, String map_name) {
    if (this.rect1.contains(u, map_name)) {
      return true;
    }
    return false;
  }

   public String fileString() {
    String fileString = "\nnew: Linker";
    fileString += "\nrect1: " + this.rect1.fileString();
    fileString += "\nrect2: " + this.rect2.fileString();
    fileString += "\nend: Linker\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "rect1":
        this.rect1.addData(data);
        break;
      case "rect2":
        this.rect2.addData(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for linker data.");
        break;
    }
  }
}



enum DayCycle {
  DAWN, DAY, DUSK, NIGHT;

  public static DayCycle dayTime(float time) {
    if (time > 21) {
      return DayCycle.NIGHT;
    }
    else if (time > 20.5f) {
      return DayCycle.DUSK;
    }
    else if (time > 6.5f) {
      return DayCycle.DAY;
    }
    else if (time > 6) {
      return DayCycle.DAWN;
    }
    else {
      return DayCycle.NIGHT;
    }
  }

  public static float lightFraction(float time) {
    if (time > 21) {
      return Constants.level_nightLightLevel;
    }
    else if (time > 20.5f) {
      return Constants.level_nightLightLevel + 2.0f * (21 - time) *
        (Constants.level_dayLightLevel - Constants.level_nightLightLevel);
    }
    else if (time > 6.5f) {
      return Constants.level_dayLightLevel;
    }
    else if (time > 6) {
      return Constants.level_nightLightLevel + 2.0f * (time - 6) *
        (Constants.level_dayLightLevel - Constants.level_nightLightLevel);
    }
    else {
      return Constants.level_nightLightLevel;
    }
  }
}


class ZombieSpawnParams {
  private float max_zombies_per_square = 0.05f;
  private int max_zombies = 100;
  private int min_level = 0;
  private int max_level = 100;
  private int del_level = 3;
  private int group_size = 3;
  private int del_group_size = 2;
  private float group_radius = 2.5f;
  private float min_distance = 5;
  private float max_distance = 25;
  private boolean save_params = false;
  private int try_spawn_timer = 50;

  ZombieSpawnParams() {
  }

   public int getLevel(int player_level) {
    int level = PApplet.parseInt(player_level - this.del_level + random(1 + 2 * this.del_level));
    if (level < this.min_level) {
      level = this.min_level;
    }
    if (level > this.max_level) {
      level = this.max_level;
    }
    return level;
  }

   public boolean badSpawnSpace(float x, float y, AbstractGameMap map) {
    if (PApplet.parseInt(x) < map.mapXI() || PApplet.parseInt(x) >= map.mapXF() || PApplet.parseInt(y) < map.mapYI() || PApplet.parseInt(y) >= map.mapYF()) {
      return true;
    }
    GameMapSquare square = map.mapSquare(PApplet.parseInt(x), PApplet.parseInt(y));
    if (square == null || square.isWall() || square.feature_elevation > 4 || square.light_level > 5) {
      return true;
    }
    return false;
  }

   public int getZombieID() {
    if (randomChance(0.8f)) {
      return 1291;
    }
    if (randomChance(0.5f)) {
      return 1292;
    }
    else {
      return 1293;
    }
  }

   public void update(int time_elapsed, Level level) {
    if (level.currMap == null || !level.currMap.outside_map || level.player == null) {
      return;
    }
    this.try_spawn_timer -= time_elapsed;
    if (this.try_spawn_timer > 0) {
      return;
    }
    this.try_spawn_timer = 50;
    if (level.currMap.zombie_counter > this.max_zombies) {
      return;
    }
    if (level.currMap.zombie_counter > this.max_zombies_per_square * level.currMap.currWidth() * level.currMap.currHeight()) {
      return;
    }
    float x_facing = random(-1.0f, 1.0f);
    float y_facing = 1.0f - abs(x_facing);
    if (randomChance(0.5f)) {
      y_facing = -y_facing;
    }
    float distance = random(5, 25);
    float x = level.player.x + x_facing * distance;
    float y = level.player.y + y_facing * distance;
    if (this.badSpawnSpace(x, y, level.currMap)) {
      return;
    }
    // successful 'group spawn'
    this.try_spawn_timer = 5000;
    int source_id = this.getZombieID();
    Unit zambo = new Unit(source_id);
    zambo.setLevel(this.getLevel(level.player.level));
    level.currMap.addUnit(zambo, x, y);
    int group_size = PApplet.parseInt(this.group_size - this.del_group_size + random(1 + 2 * this.del_group_size));
    for (int i = 0; i < group_size; i++) {
      x_facing = random(-1.0f, 1.0f);
      y_facing = 1.0f - abs(x_facing);
      if (randomChance(0.5f)) {
        y_facing = -y_facing;
      }
      distance = random(this.group_radius);
      float x_group = x + x_facing * distance;
      float y_group = y + y_facing * distance;
      if (this.badSpawnSpace(x_group, y_group, level.currMap)) {
        continue;
      }
      if (randomChance(0.5f)) {
        zambo = new Unit(source_id);
      }
      else {
        zambo = new Unit(this.getZombieID());
      }
      zambo.setLevel(this.getLevel(level.player.level));
      level.currMap.addUnit(zambo, x_group, y_group);
    }
  }
}



class Level {
  protected String folderPath; // to level folder
  protected String levelName = "error";
  protected Location location = Location.ERROR;
  protected boolean nullify = false;
  protected boolean completed = false;
  protected boolean completing = false;
  protected int completing_timer = 5000;
  protected int completion_code = 0;

  protected LevelForm level_form = null;
  protected LevelQuestBox level_questbox = null;
  protected LevelChatBox level_chatbox = null;
  protected AbstractGameMap currMap;
  protected String currMapName = null;
  protected ArrayList<String> mapNames = new ArrayList<String>();
  protected String album_name = null;

  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;

  protected ArrayList<Linker> linkers = new ArrayList<Linker>();
  protected int nextTriggerKey = 1;
  protected HashMap<Integer, Trigger> triggers = new HashMap<Integer, Trigger>();
  protected HashMap<Integer, Quest> quests = new HashMap<Integer, Quest>();
  protected ClockFloat time = new ClockFloat(24, 6.5f); // day cycle
  protected ZombieSpawnParams zombie_spawn_params = new ZombieSpawnParams();

  protected Rectangle player_start_location = null;
  protected Rectangle player_spawn_location = null;
  protected Hero player;
  protected boolean was_viewing_hero_tree = false;
  protected boolean respawning = false;
  protected int respawn_timer = 0;
  protected boolean sleeping = false;
  protected int sleep_timer = 0;
  protected boolean in_control = true;

  protected int last_update_time = millis();
  protected boolean restart_timers = false;

  Level() {}
  Level(String folderPath, String levelName) {
    this.folderPath = folderPath;
    this.levelName = levelName;
    this.open();
  }
  Level(String folderPath, Location location) {
    this.folderPath = folderPath;
    this.location = location;
    this.levelName = location.display_name();
    this.open();
  }
  // test map
  Level(AbstractGameMap testMap) {
    this.folderPath = "";
    this.levelName = testMap.mapName;
    this.currMap = testMap;
    this.currMapName = testMap.mapName;
  }


   public String timeString() {
    return this.timeString(false, false);
  }
   public String timeString(boolean military_time, boolean show_seconds) {
    float minutes = 60.0f * (this.time.value - floor(this.time.value));
    float seconds = 60.0f * (minutes - floor(minutes));
    String hrs = Integer.toString(PApplet.parseInt(floor(this.time.value)));
    String mins = Integer.toString(PApplet.parseInt(floor(minutes)));
    while(mins.length() < 2) {
      mins = "0" + mins;
    }
    String secs = Integer.toString(PApplet.parseInt(floor(seconds)));
    while(secs.length() < 2) {
      secs = "0" + secs;
    }
    if (military_time) {
      if (show_seconds) {
        return hrs + ":" + mins + ":" + secs;
      }
      else {
        return hrs + ":" + mins;
      }
    }
    else {
      String suffix = " am";
      if (this.time.value > 12) {
        suffix = " pm";
        hrs = Integer.toString(PApplet.parseInt(floor(this.time.value - 12)));
      }
      if (show_seconds) {
        return hrs + ":" + mins + ":" + secs + suffix;
      }
      else {
        return hrs + ":" + mins + suffix;
      }
    }
  }


   public void decisionForm(int i) {
    if (this.level_form != null) {
      global.log("WARNING: Decision form being created while level form " +
        this.level_form.getClass().toString() + " exists.");
    }
    this.level_form = new DecisionForm(i);
  }


   public void gainControl() {
    this.in_control = true;
    global.player_blinks_left = 6;
    global.player_blinking = true;
    global.player_blink_time = Constants.level_questBlinkTime;
    if (this.currMap != null) {
      this.currMap.in_control = true;
    }
    if (this.player != null) {
      this.player.in_control = true;
    }
  }

   public void loseControl() {
    this.in_control = false;
    global.player_blinks_left = 6;
    global.player_blinking = false;
    global.player_blink_time = Constants.level_questBlinkTime;
    if (this.currMap != null) {
      this.currMap.in_control = false;
    }
    if (this.player != null) {
      this.player.in_control = false;
    }
  }


   public String getCurrMapNameDisplay() {
    if (this.currMapName == null) {
      return "No current map (see default)";
    }
    else {
      return "Current map: " + this.currMapName;
    }
  }

   public String getPlayerStartLocationDisplay() {
    if (this.player_start_location == null) {
      return "No player start location";
    }
    else {
      return "Player starts on " + this.player_start_location.mapName + " at (" +
        this.player_start_location.centerX() + ", " + this.player_start_location.centerY() + ")";
    }
  }

   public String getPlayerSpawnLocationDisplay() {
    if (this.player_spawn_location == null) {
      return "No player spawn location";
    }
    else {
      return "Player respawns at " + this.player_spawn_location.mapName + " at (" +
        this.player_spawn_location.centerX() + ", " + this.player_spawn_location.centerY() + ")";
    }
  }


   public void addTestPlayer() {
    Hero h = new Hero(HeroCode.BEN);
    this.addPlayer(h);
  }

   public void addPlayer(Hero h) {
    if (this.player != null) {
      global.errorMessage("ERROR: Trying to add player when player already exists.");
      return;
    }
    this.player = h;
    this.player.location = this.location;
    this.player.in_control = this.in_control;
    if (this.currMap != null) {
      this.currMap.addPlayer(this.player);
    }
  }

   public void setPlayer(Hero player) {
    if (this.player != null) {
      global.errorMessage("ERROR: Trying to add player when player already exists.");
      return;
    }
    if (this.player_start_location == null || !this.hasMap(this.player_start_location.mapName)) {
      if (this.mapNames.size() > 0) {
        this.openMap(this.mapNames.get(0));
        player.setLocation(0, 0);
      }
      else {
        player.setLocation(0, 0);
      }
    }
    else {
      this.openMap(this.player_start_location.mapName);
      if (this.currMap != null && GameMapArea.class.isInstance(this.currMap)) {
        GameMapArea area_map = (GameMapArea)this.currMap;
        println(area_map.defaultSpawnX(), area_map.defaultSpawnY(), area_map.default_spawn_chunk.x);
        player.setLocation(area_map.defaultSpawnX(), area_map.defaultSpawnY());
      }
      else {
        player.setLocation(this.player_start_location.centerX(), this.player_start_location.centerY());
      }
    }
    if (this.currMap == null || this.currMap.nullify) {
      this.nullify = true;
      global.errorMessage("ERROR: Can't open default map.");
    }
    else {
      this.currMap.addPlayer(player);
    }
    this.player = player;
    this.player.location = this.location;
    this.player.in_control = this.in_control;
  }

   public void respawnPlayer() {
    if (this.player == null) {
      global.errorMessage("ERROR: Trying to respawn player when player doesn't exists.");
      return;
    }
    this.player.remove = false;
    this.player.curr_health = this.player.health();
    this.player.curr_mana = 0;
    this.player.hunger = Constants.hero_maxHunger;
    this.player.thirst = Constants.hero_maxThirst;
    this.player.experience *= PApplet.parseInt(floor(Constants.hero_experienceRespawnMultiplier));
    if (this.player_spawn_location != null && this.hasMap(this.player_spawn_location.mapName)) {
      this.openMap(this.player_spawn_location.mapName);
      if (this.currMap != null && GameMapArea.class.isInstance(this.currMap)) {
        GameMapArea area_map = (GameMapArea)this.currMap;
        player.setLocation(area_map.defaultSpawnX(), area_map.defaultSpawnY());
      }
      else {
        player.setLocation(this.player_spawn_location.centerX(), this.player_spawn_location.centerY());
      }
    }
    else if (this.player_start_location != null && this.hasMap(this.player_start_location.mapName)) {
      this.openMap(this.player_start_location.mapName);
      player.setLocation(this.player_start_location.centerX(), this.player_start_location.centerY());
    }
    else {
      if (this.mapNames.size() > 0) {
        this.openMap(this.mapNames.get(0));
        player.setLocation(0, 0);
      }
      else {
        player.setLocation(0, 0);
      }
    }
    if (this.currMap == null || this.currMap.nullify) {
      this.nullify = true;
      global.errorMessage("ERROR: Can't open map with name " + this.currMapName + ".");
    }
    else {
      this.currMap.addPlayer(player);
      this.currMap.setViewLocation(player.x, player.y);
    }
  }


   public boolean hasMap(String queryMapName) {
    for (String mapName : this.mapNames) {
      if (queryMapName.equals(mapName)) {
        return true;
      }
    }
    return false;
  }

   public void removeMap(String mapName) {
    for (int i = 0; i < this.mapNames.size(); i++) {
      if (mapName.equals(this.mapNames.get(i))) {
        this.mapNames.remove(i);
        return;
      }
    }
  }


   public void movePlayerTo(Rectangle rect) {
    if (this.player == null || rect == null) {
      return;
    }
    if (!this.hasMap(rect.mapName)) {
      return;
    }
    this.openMap(rect.mapName);
    this.player.setLocation(rect.centerX(), rect.centerY());
    this.player.stopAction();
    this.currMap.addPlayer(player);
    this.currMap.addHeaderMessage(GameMapCode.display_name(this.currMap.code));
  }

   public void openCurrMap() {
    this.openMap(this.currMapName);
    if (this.currMap == null || this.currMap.nullify) {
      this.nullify = true;
      global.errorMessage("ERROR: Can't open curr map: " + this.currMapName + ".");
    }
  }

   public String mapSuffix() {
    if (this.location.isArea()) {
      return "area";
    }
    return "map";
  }

   public void openMap(String mapName) {
    if (mapName == null) {
      return;
    }
    if (!fileExists(this.finalFolderPath() + "/" + mapName + "." + this.mapSuffix() + ".lnz")) {
      global.errorMessage("ERROR: Level " + this.levelName + " has no map " +
        "with name " + mapName + " at location " + this.finalFolderPath() + ".");
      this.nullify = true;
      return;
    }
    if (mapName.equals(this.currMapName) && this.currMap != null) {
      return;
    }
    this.currMapName = mapName;
    if (this.currMap != null) {
      this.currMap.save(this.finalFolderPath());
    }
    if (this.location.isArea()) {
      this.currMap = new GameMapArea(mapName, this.finalFolderPath());
      this.currMap.open(this.finalFolderPath());
      ((GameMapArea)this.currMap).initializeArea();
    }
    else {
      this.currMap = new GameMap(mapName, this.finalFolderPath());
    }
    this.currMap.setLocation(this.xi, this.yi, this.xf, this.yf);
    this.currMap.in_control = this.in_control;
  }

   public void closeMap() {
    if (this.currMap != null) {
      this.currMap.save(this.finalFolderPath());
    }
    this.currMap = null;
    this.currMapName = null;
  }


   public void addLinker(Linker linker) {
    if (linker == null) {
      global.errorMessage("ERROR: Can't add null linker to linkers.");
      return;
    }
    this.linkers.add(linker);
  }
   public void removeLinker(int index) {
    if (index < 0 || index >= this.linkers.size()) {
      global.errorMessage("ERROR: Linker index " + index + " out of range.");
      return;
    }
    this.linkers.remove(index);
  }

   public void addTrigger(Trigger trigger) {
    if (trigger == null) {
      global.errorMessage("ERROR: Can't add null trigger to triggers.");
      return;
    }
    this.addTrigger(this.nextTriggerKey, trigger);
    this.nextTriggerKey++;
  }
   public void addTrigger(int triggerCode, Trigger trigger) {
    if (trigger == null) {
      global.errorMessage("ERROR: Can't add null trigger to triggers.");
      return;
    }
    trigger.triggerID = triggerCode;
    this.triggers.put(triggerCode, trigger);
  }
   public void removeTrigger(int triggerKey) {
    if (!this.triggers.containsKey(triggerKey)) {
      global.errorMessage("ERROR: No trigger with key " + triggerKey + ".");
      return;
    }
    this.triggers.remove(triggerKey);
  }

   public void addQuest(int quest_id) {
    this.addQuest(new Quest(quest_id));
  }
   public void addQuest(Quest quest) {
    if (this.quests.containsKey(quest.ID)) {
      return;
    }
    this.quests.put(quest.ID, quest);
    global.sounds.trigger_player("player/quest");
  }
   public void removeQuest(int quest_id) {
    if (this.quests.containsKey(quest_id)) {
      this.quests.remove(quest_id);
    }
  }


   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    if (this.currMap != null) {
      this.currMap.setLocation(xi, yi, xf, yf);
    }
    if (this.player != null) {
      this.player.heroTree.setLocation(xi, yi, xf, yf);
    }
  }


   public void drawLeftPanel(int millis) {
    if (this.currMap != null) {
      this.currMap.drawLeftPanel(millis);
    }
    if (this.player != null) {
      this.player.drawLeftPanel(millis, this.xi);
    }
  }

   public boolean leftPanelElementsHovered() {
    if (this.currMap != null) {
      return this.currMap.leftPanelElementsHovered();
    }
    return false;
  }

   public void drawRightPanel(int millis) {
    if (this.level_questbox == null) {
      this.level_questbox = new LevelQuestBox();
    }
    this.level_questbox.setXLocation(this.xf + Constants.mapEditor_listBoxGap, width - Constants.mapEditor_listBoxGap);
    this.level_questbox.update(millis);
    if (this.level_chatbox == null) {
      this.level_chatbox = new LevelChatBox();
    }
    this.level_chatbox.setXLocation(this.xf + Constants.mapEditor_listBoxGap, width - Constants.mapEditor_listBoxGap);
    this.level_chatbox.update(millis);
  }


   public void heroFeatureInteraction(Hero h, boolean use_item) {
    if (this.currMap == null || h == null || h.object_targeting == null || h.object_targeting.remove) {
      return;
    }
    if (h.weapon() == null) {
      use_item = false;
    }
    if (!Feature.class.isInstance(h.object_targeting)) {
      global.errorMessage("ERROR: Hero " + h.display_name() + " trying to " +
        "interact with feature " + h.display_name() + " but it's not a feature.");
      return;
    }
    Feature f = (Feature)h.object_targeting;
    Feature new_f;
    int item_id = 0;
    Item new_i;
    float random_number = random(1);
    switch(f.ID) {
      case 11: // khalil
        if (f.toggle) {
          this.level_form = new KhalilForm(f, h);
          global.defaultCursor();
          f.toggle = false;
        }
        else {
          f.toggle = true;
          if (randomChance(0.5f)) {
            this.chat("Traveling Buddy: I am a caterpillar. Well, that's not " +
              "entirely true. My mother was a caterpillar, my father was a worm, " +
              "but I'm okay with that now.");
          }
          else {
            this.chat("Traveling Buddy: I am a small business operator; a " +
              "traveling salesman. I sell Persian rugs door-to-door!");
          }
          this.currMap.addVisualEffect(4009, f.x + 0.6f, f.y - 0.4f);
        }
        break;
      case 12: // chuck quizmo
        if (f.toggle) {
          this.level_form = new QuizmoForm(f, h);
          global.defaultCursor();
          f.toggle = false;
        }
        else {
          f.toggle = true;
          this.chat("Chuck Quizmo: Chuck Quizmo's the name, and quizzes are my " +
            "game! You want quizzes, I got 'em! If you can manage to answer my " +
            "brain-busting questions correctly, then... Y... Yaa... Yaaaaaahooo! " +
            "I'll give you a Star Piece!");
          this.currMap.addVisualEffect(4009, f.x + 0.7f, f.y - 0.4f);
        }
        break;
      case 21: // workbench
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 22: // ender chest
        global.viewingEnderChest();
        if (global.state == ProgramState.MAPEDITOR_INTERFACE) {
          f.inventory = new EnderChestInventory();
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_units("features/chest", f.xCenter() -
          this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 101: // wooden table
      case 106: // small wooden table
      case 107:
      case 108: // ping pong table
      case 111: // wooden chair
      case 112:
      case 113:
      case 114:
      case 125: // wooden bench
      case 126:
      case 127:
      case 128:
      case 129:
      case 130:
        if (!h.holding(2977, 2979, 2980, 2981, 2983)) {
          break;
        }
        switch(h.weapon().ID) {
          case 2977: // ax
            f.number -= 3;
            global.sounds.trigger_units("items/melee/ax", f.xCenter() -
              this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 2979: // saw
            f.number -= 1;
            global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
              this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 2980: // drill
            f.number -= 1;
            global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 2981: // roundsaw
            f.number -= 2;
            global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
              this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 2983: // chainsaw
            f.number -= 2;
            global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
              this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
        }
        h.weapon().lowerDurability();
        if (f.number < 1) {
          f.destroy(this.currMap);
        }
        break;
      case 102: // wooden desk
      case 103:
      case 104:
      case 105:
        if (use_item && h.holding(2977, 2979, 2980, 2981, 2983)) {
          switch(h.weapon().ID) {
            case 2977: // ax
              f.number -= 3;
              global.sounds.trigger_units("items/melee/ax", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2979: // saw
              f.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2980: // drill
              f.number -= 1;
              global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
                f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2981: // roundsaw
              f.number -= 2;
              global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2983: // chainsaw
              f.number -= 2;
              global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
          }
          h.weapon().lowerDurability();
          if (f.number < 1) {
            f.destroy(this.currMap);
          }
          break;
        }
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 115: // coordinator chair
      case 121: // couch
      case 122:
      case 123:
      case 124:
        if (use_item && h.holding(2977, 2979, 2980, 2981, 2983)) {
          switch(h.weapon().ID) {
            case 2977: // ax
              f.number -= 3;
              global.sounds.trigger_units("items/melee/ax", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2979: // saw
              f.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2980: // drill
              f.number -= 1;
              global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
                f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2981: // roundsaw
              f.number -= 2;
              global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2983: // chainsaw
              f.number -= 2;
              global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
          }
          h.weapon().lowerDurability();
          if (f.number < 1) {
            f.destroy(this.currMap);
          }
          break;
        }
        global.sounds.trigger_environment("features/couch_shuffle", f.xCenter() -
          this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        if (!f.toggle) {
          this.currMap.addHeaderMessage("This " + f.display_name() + " has nothing in it.");
          break;
        }
        if (random_number > 0.99f) {
          item_id = 2154;
        }
        else if (random_number > 0.96f) {
          item_id = 2153;
        }
        else if (random_number > 0.9f) {
          item_id = 2152;
        }
        else if (random_number > 0.75f) {
          item_id = 2151;
        }
        else if (random_number > 0.72f) {
          item_id = 2101;
        }
        else if (random_number > 0.69f) {
          item_id = 2102;
        }
        else if (random_number > 0.66f) {
          item_id = 2103;
        }
        else if (random_number > 0.63f) {
          item_id = 2104;
        }
        else if (random_number > 0.6f) {
          item_id = 2105;
        }
        else if (random_number > 0.58f) {
          item_id = 2107;
        }
        else if (random_number > 0.57f) {
          item_id = 2110;
        }
        else if (random_number > 0.56f) {
          item_id = 2112;
        }
        else if (random_number > 0.55f) {
          item_id = 2113;
        }
        else if (random_number > 0.54f) {
          item_id = 2132;
        }
        else if (random_number > 0.53f) {
          item_id = 2134;
        }
        else if (random_number > 0.52f) {
          item_id = 2402;
        }
        else if (random_number > 0.51f) {
          item_id = 2502;
        }
        else if (random_number > 0.5f) {
          item_id = 2602;
        }
        else if (random_number > 0.49f) {
          item_id = 2603;
        }
        else if (random_number > 0.48f) {
          item_id = 2604;
        }
        else if (random_number > 0.45f) {
          item_id = 2702;
        }
        else if (random_number > 0.44f) {
          item_id = 2703;
        }
        else if (random_number > 0.43f) {
          item_id = 2911;
        }
        else if (random_number > 0.42f) {
          item_id = 2912;
        }
        else if (random_number > 0.41f) {
          item_id = 2913;
        }
        else if (random_number > 0.39f) {
          item_id = 2916;
        }
        else if (random_number > 0.38f) {
          item_id = 2917;
        }
        else if (random_number > 0.35f) {
          item_id = 2924;
        }
        else if (random_number > 0.33f) {
          item_id = 2931;
        }
        else if (random_number > 0.31f) {
          item_id = 2933;
        }
        else {
          f.toggle = false;
          this.currMap.addHeaderMessage("This " + f.display_name() + " has nothing left in it.");
          break;
        }
        new_i = new Item(item_id, h.frontX(), h.frontY());
        if (h.canPickup()) {
          h.pickup(new_i);
          new_i.pickupSound();
        }
        else {
          this.currMap.addItem(new_i);
        }
        this.currMap.addHeaderMessage("You found a " + new_i.display_name() + ".");
        break;
      case 131: // bed
      case 132:
      case 133:
      case 134:
        if (use_item && h.holding(2977, 2979, 2980, 2981, 2983)) {
          switch(h.weapon().ID) {
            case 2977: // ax
              f.number -= 3;
              global.sounds.trigger_units("items/melee/ax", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2979: // saw
              f.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2980: // drill
              f.number -= 1;
              global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
                f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2981: // roundsaw
              f.number -= 2;
              global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2983: // chainsaw
              f.number -= 2;
              global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
          }
          h.weapon().lowerDurability();
          if (f.number < 1) {
            f.destroy(this.currMap);
          }
          break;
        }
        if (DayCycle.dayTime(this.time.value) == DayCycle.NIGHT) {
          this.sleeping = true;
          this.sleep_timer = Constants.feature_bedSleepTimer;
          this.loseControl();
          h.stopAction();
        }
        else {
          this.currMap.addHeaderMessage("You can only sleep at night.");
        }
        break;
      case 141: // wardrobe
      case 142:
        if (use_item && h.holding(2977, 2979, 2980, 2981, 2983)) {
          switch(h.weapon().ID) {
            case 2977: // ax
              f.number -= 3;
              global.sounds.trigger_units("items/melee/ax", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2979: // saw
              f.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2980: // drill
              f.number -= 1;
              global.sounds.trigger_units("items/melee/drill" + randomInt(1, 3),
                f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2981: // roundsaw
              f.number -= 2;
              global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2983: // chainsaw
              f.number -= 2;
              global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
          }
          h.weapon().lowerDurability();
          if (f.number < 1) {
            f.destroy(this.currMap);
          }
          break;
        }
        global.sounds.trigger_environment("features/wardrobe_shuffle", f.xCenter() -
          this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        if (!f.toggle) {
          this.currMap.addHeaderMessage("This " + f.display_name() + " has nothing in it.");
          break;
        }
        if (random_number > 0.99f) {
          item_id = 2154;
        }
        else if (random_number > 0.98f) {
          item_id = 2153;
        }
        else if (random_number > 0.95f) {
          item_id = 2152;
        }
        else if (random_number > 0.9f) {
          item_id = 2151;
        }
        else if (random_number > 0.88f) {
          item_id = 2101;
        }
        else if (random_number > 0.87f) {
          item_id = 2102;
        }
        else if (random_number > 0.86f) {
          item_id = 2103;
        }
        else if (random_number > 0.85f) {
          item_id = 2104;
        }
        else if (random_number > 0.84f) {
          item_id = 2105;
        }
        else if (random_number > 0.83f) {
          item_id = 2107;
        }
        else if (random_number > 0.82f) {
          item_id = 2110;
        }
        else if (random_number > 0.81f) {
          item_id = 2111;
        }
        else if (random_number > 0.8f) {
          item_id = 2112;
        }
        else if (random_number > 0.785f) {
          item_id = 2113;
        }
        else if (random_number > 0.77f) {
          item_id = 2132;
        }
        else if (random_number > 0.755f) {
          item_id = 2133;
        }
        else if (random_number > 0.74f) {
          item_id = 2134;
        }
        else if (random_number > 0.73f) {
          item_id = 2141;
        }
        else if (random_number > 0.71f) {
          item_id = 2203;
        }
        else if (random_number > 0.68f) {
          item_id = 2402;
        }
        else if (random_number > 0.65f) {
          item_id = 2502;
        }
        else if (random_number > 0.63f) {
          item_id = 2504;
        }
        else if (random_number > 0.62f) {
          item_id = 2513;
        }
        else if (random_number > 0.6f) {
          item_id = 2602;
        }
        else if (random_number > 0.58f) {
          item_id = 2603;
        }
        else if (random_number > 0.56f) {
          item_id = 2604;
        }
        else if (random_number > 0.53f) {
          item_id = 2702;
        }
        else if (random_number > 0.51f) {
          item_id = 2703;
        }
        else if (random_number > 0.5f) {
          item_id = 2704;
        }
        else if (random_number > 0.49f) {
          item_id = 2705;
        }
        else if (random_number > 0.48f) {
          item_id = 2712;
        }
        else if (random_number > 0.47f) {
          item_id = 2713;
        }
        else if (random_number > 0.46f) {
          item_id = 2714;
        }
        else if (random_number > 0.45f) {
          item_id = 2911;
        }
        else if (random_number > 0.44f) {
          item_id = 2912;
        }
        else if (random_number > 0.43f) {
          item_id = 2913;
        }
        else if (random_number > 0.42f) {
          item_id = 2914;
        }
        else if (random_number > 0.41f) {
          item_id = 2916;
        }
        else if (random_number > 0.4f) {
          item_id = 2917;
        }
        else if (random_number > 0.37f) {
          item_id = 2924;
        }
        else if (random_number > 0.36f) {
          item_id = 2925;
        }
        else {
          f.toggle = false;
          this.currMap.addHeaderMessage("This " + f.display_name() + " has nothing left in it.");
          break;
        }
        new_i = new Item(item_id, h.frontX(), h.frontY());
        if (h.canPickup()) {
          h.pickup(new_i);
          new_i.pickupSound();
        }
        else {
          this.currMap.addItem(new_i);
        }
        this.currMap.addHeaderMessage("You found a " + new_i.display_name() + ".");
        break;
      case 151: // sign
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
        try {
          this.currMap.addHeaderMessage(trim(split(f.description,
            Constants.feature_signDescriptionDelimiter)[1]));
        } catch(ArrayIndexOutOfBoundsException e) {
          this.currMap.addHeaderMessage("-- the sign has nothing written on it --");
        }
        f.number = Constants.feature_signCooldown;
        break;
      case 161: // water fountain
        global.sounds.trigger_environment("features/water_fountain",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        if (h.holding(2924, 2925, 2926, 2927) && (h.weapon().maximumAmmo() - h.weapon().availableAmmo() > 0)) {
          h.weapon().changeAmmo(3);
        }
        // if holding a dirty item clean it (?)
        else {
          h.increaseThirst(3);
          global.sounds.trigger_environment("features/water_fountain_drink",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        }
        break;
      case 162: // sink
        if (use_item && h.holding(2924, 2925, 2926, 2927)) {
          h.weapon().changeAmmo(4);
        }
        // if holding a dirty item clean it (?)
        else {
          h.increaseThirst(2);
          global.sounds.trigger_environment("features/water_fountain_drink",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        }
        global.sounds.trigger_environment("features/sink",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 163: // shower stall
        f.number = Constants.feature_showerStallCooldown;
        // if holding a dirty item clean it (?)
        // if you are dirty clean yourself
        h.increaseThirst(1);
        global.sounds.trigger_environment("features/shower_stall",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 164: // urinal
        f.number = Constants.feature_urinalCooldown;
        if (h.thirst < Constants.hero_thirstThreshhold) {
          h.increaseThirst(3);
        }
        global.sounds.trigger_environment("features/urinal",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 165: // toilet
        f.number = Constants.feature_toiletCooldown;
        if (h.thirst < Constants.hero_thirstThreshhold) {
          h.increaseThirst(3);
        }
        global.sounds.trigger_environment("features/toilet",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 171: // stove
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_environment("features/stove_open",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 172: // vending machine
      case 173:
        this.level_form = new VendingForm(f, h);
        global.defaultCursor();
        break;
      case 174: // minifridge
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 175: // refridgerator
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 176: // washer
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 177: // dryer
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 178: // microwave
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        break;
      case 180: // lamp
        f.toggle = !f.toggle;
        f.refresh_map_image = true;
        if (f.toggle) {
          global.sounds.trigger_environment("features/switch_on",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          this.currMap.timer_refresh_fog = 0;
        }
        else {
          global.sounds.trigger_environment("features/switch_off",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          this.currMap.timer_refresh_fog = 0;
        }
        break;
      case 181: // garbage can
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_environment("features/trash_can",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 182: // recycle can
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_environment("features/trash_can",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 183: // crate
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_environment("features/crate",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 184: // cardboard box
        if (h.inventory.viewing) {
          break;
        }
        h.inventory.featureInventory(f.inventory);
        h.inventory.viewing = true;
        global.sounds.trigger_environment("features/cardboard_box",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 185: // pickle jar
        if (use_item && h.holding(2975)) {
          f.destroy(this.currMap);
          global.sounds.trigger_environment("items/glass_bottle_hit",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          break;
        }
        if (h.canPickup()) {
          f.number = Constants.feature_pickleJarCooldown;
          new_i = new Item(2106);
          h.pickup(new_i);
          new_i.pickupSound();
        }
        break;
      case 195: // light switch
      case 196:
      case 197:
      case 198:
        f.toggle = !f.toggle;
        f.refresh_map_image = true;
        if (f.toggle) {
          global.sounds.trigger_environment("features/switch_on",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          this.currMap.timer_refresh_fog = 0;
        }
        else {
          global.sounds.trigger_environment("features/switch_off",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          this.currMap.timer_refresh_fog = 0;
        }
        break;
      case 211: // wire fence
      case 212:
      case 213:
      case 214:
      case 215:
      case 216:
      case 217:
      case 218:
      case 219:
      case 220:
      case 221:
      case 222:
      case 223:
      case 224:
      case 225:
      case 226:
        if (use_item && h.holding(2978)) {
          f.destroy(this.currMap);
          h.weapon().lowerDurability();
          global.sounds.trigger_environment("items/wire_clipper",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          break;
        }
        else if (h.agility() >= 2) {
          h.setLocation(f.xCenter(), f.yCenter());
          global.sounds.trigger_units("features/climb_fence",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          if (randomChance(0.3f)) {
            h.addStatusEffect(StatusEffectCode.BLEEDING, 2000);
          }
        }
        break;
      case 231: // barbed wire fence
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
        if (h.agility() >= 3) {
          h.setLocation(f.xCenter(), f.yCenter());
          global.sounds.trigger_units("features/climb_fence",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          if (randomChance(0.8f)) {
            h.addStatusEffect(StatusEffectCode.BLEEDING, 2500);
          }
        }
        break;
      case 301: // movable brick wall
      case 302:
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
        f.remove = true;
        global.sounds.trigger_units("features/movable_wall",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        this.currMap.addHeaderMessage("The wall easily slid over");
        break;
      case 321: // window (open)
        if (use_item && h.holding(2976)) {
          f.destroy(this.currMap);
          h.weapon().lowerDurability();
          global.sounds.trigger_environment("items/window_break",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          break;
        }
        f.remove = true;
        new_f = new Feature(322, f.x, f.y, false);
        this.currMap.addFeature(new_f);
        new_f.hovered = true;
        this.currMap.hovered_object = new_f;
        global.sounds.trigger_environment("features/window_close",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 322: // window (closed)
        if (use_item && h.holding(2976)) {
          f.destroy(this.currMap);
          h.weapon().lowerDurability();
          global.sounds.trigger_environment("items/window_break",
            f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          break;
        }
        f.remove = true;
        new_f = new Feature(321, f.x, f.y, false);
        this.currMap.addFeature(new_f);
        new_f.hovered = true;
        this.currMap.hovered_object = new_f;
        global.sounds.trigger_environment("features/window_open",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 323: // window (locked)
        if (!h.holding(2976)) {
          this.currMap.addHeaderMessage("The window is locked");
          break;
        }
        f.destroy(this.currMap);
        h.weapon().lowerDurability();
        global.sounds.trigger_environment("items/window_break",
          f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        break;
      case 331: // wooden door (open)
      case 332:
      case 333:
      case 334:
      case 335:
      case 336:
      case 337:
      case 338:
      case 339: // wooden door (closed)
      case 340:
      case 341:
      case 342:
      case 343: // wooden door (locked)
      case 344:
      case 345:
      case 346:
        if (use_item && h.holding(2977, 2979, 2983)) {
          f.destroy(this.currMap);
          h.weapon().lowerDurability();
          break;
        }
        switch(f.ID) {
          case 331: // door open (up)
            f.remove = true;
            new_f = new Feature(339, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 332:
            f.remove = true;
            new_f = new Feature(339, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 333: // door open (left)
            f.remove = true;
            new_f = new Feature(340, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 334:
            f.remove = true;
            new_f = new Feature(340, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 335: // door open (diagonal left)
            f.remove = true;
            new_f = new Feature(341, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 336:
            f.remove = true;
            new_f = new Feature(341, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 337: // door open (diagonal right)
            f.remove = true;
            new_f = new Feature(342, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 338:
            f.remove = true;
            new_f = new Feature(342, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 339: // door closed (up)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(332, f.x, f.y);
            }
            else {
              new_f = new Feature(331, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 340: // door closed (left)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(334, f.x, f.y);
            }
            else {
              new_f = new Feature(333, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 341: // door closed (diagonal left)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(336, f.x, f.y);
            }
            else {
              new_f = new Feature(335, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 342: // door closed (diagonal right)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(338, f.x, f.y);
            }
            else {
              new_f = new Feature(337, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 343: // door locked (up)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else if (h.holding(2904, 2905)) {
                this.currMap.addHeaderMessage("No key on this ring unlocks the door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(339, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 344: // door locked (left)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else if (h.holding(2904, 2905)) {
                this.currMap.addHeaderMessage("No key on this ring unlocks the door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(340, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 345: // door locked (diagonal left)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else if (h.holding(2904, 2905)) {
                this.currMap.addHeaderMessage("No key on this ring unlocks the door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(341, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/wooden_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 346: // door locked (diagonal right)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else if (h.holding(2904, 2905)) {
                this.currMap.addHeaderMessage("No key on this ring unlocks the door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(342, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/stee_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
        }
        break;
      case 351: // steel door (open)
      case 352:
      case 353:
      case 354:
      case 355:
      case 356:
      case 357:
      case 358:
      case 359: // steel door (closed)
      case 360:
      case 361:
      case 362:
      case 363: // steel door (locked)
      case 364:
      case 365:
      case 366:
        switch(f.ID) {
          case 351: // door open (up)
            f.remove = true;
            new_f = new Feature(359, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 352:
            f.remove = true;
            new_f = new Feature(359, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 353: // door open (left)
            f.remove = true;
            new_f = new Feature(360, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 354:
            f.remove = true;
            new_f = new Feature(360, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 355: // door open (diagonal left)
            f.remove = true;
            new_f = new Feature(361, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 356:
            f.remove = true;
            new_f = new Feature(361, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 357: // door open (diagonal right)
            f.remove = true;
            new_f = new Feature(362, f.x, f.y, false);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 358:
            f.remove = true;
            new_f = new Feature(362, f.x, f.y, true);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_close",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 359: // door closed (up)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(352, f.x, f.y);
            }
            else {
              new_f = new Feature(351, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 360: // door closed (left)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(354, f.x, f.y);
            }
            else {
              new_f = new Feature(353, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 361: // door closed (diagonal left)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(356, f.x, f.y);
            }
            else {
              new_f = new Feature(355, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 362: // door closed (diagonal right)
            f.remove = true;
            if (f.toggle) {
              new_f = new Feature(358, f.x, f.y);
            }
            else {
              new_f = new Feature(357, f.x, f.y);
            }
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_open",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 363: // door locked (up)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(359, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 364: // door locked (left)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(360, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 365: // door locked (diagonal left)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(361, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
          case 366: // door locked (diagonal right)
            if (h.weapon() == null || !h.weapon().unlocks(f.number)) {
              if (h.weapon() != null && h.weapon().type.equals("Key")) {
                this.currMap.addHeaderMessage("The key doesn't unlock this door");
              }
              else {
                this.currMap.addHeaderMessage("The door is locked");
              }
              break;
            }
            f.remove = true;
            new_f = new Feature(362, f.x, f.y, f.toggle);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
            global.sounds.trigger_environment("features/steel_door_unlock",
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            break;
        }
        break;
      case 401: // dandelion
        if (h.canPickup()) {
          f.remove = true;
          new_i = new Item(2961);
          h.pickup(new_i);
          new_i.pickupSound();
        }
        break;
      case 411: // gravel (pebbles)
        if (h.canPickup()) {
          new_i = new Item(2933);
          h.pickup(new_i);
          new_i.pickupSound();
          f.number--;
          if (f.number < 1) {
            f.remove = true;
          }
        }
        break;
      case 412: // Gravel (rocks)
        if (h.canPickup()) {
          new_i = new Item(2931);
          h.pickup(new_i);
          new_i.pickupSound();
          f.number--;
          if (f.number < 1) {
            f.remove = true;
            new_f = new Feature(411, f.x, f.y);
            this.currMap.addFeature(new_f);
            new_f.hovered = true;
            this.currMap.hovered_object = new_f;
          }
        }
        break;
      case 421: // Tree (maple)
      case 422: // Tree (unknown)
      case 423: // Tree (cedar)
      case 424: // Tree (dead)
      case 425: // Tree (large)
      case 426: // Tree (pine)
      case 444: // large trees
      case 445:
      case 446:
      case 447:
      case 448:
      case 449:
        int branch_id = 0;
        switch(f.ID) {
          case 421:
          case 444:
            branch_id = 2965;
            break;
          case 422:
          case 445:
            branch_id = 2966;
            break;
          case 423:
          case 446:
            branch_id = 2967;
            break;
          case 424:
          case 447:
            branch_id = 2963;
            break;
          case 425:
          case 448:
            branch_id = 2965;
            break;
          case 426:
          case 449:
            branch_id = 2968;
            break;
        }
        if (!use_item || !h.holding(2977, 2979, 2981, 2983)) {
          if (f.toggle) {
            this.currMap.addItem(new Item(branch_id, h.frontX(), h.frontY()));
            global.sounds.trigger_units("features/break_branch" + randomInt(1, 6),
              f.xCenter() - this.currMap.viewX, f.yCenter() - this.currMap.viewY);
            if (randomChance(Constants.feature_treeChanceEndBranches)) {
              f.toggle = false;
            }
          }
        }
        else {
          switch(h.weapon().ID) {
            case 2977: // ax
              f.number -= 2;
              global.sounds.trigger_units("items/melee/ax", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2979: // saw
              f.number -= 1;
              global.sounds.trigger_units("items/saw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2981: // roundsaw
              f.number -= 1;
              global.sounds.trigger_units("items/roundsaw_cut_wood", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
            case 2983: // chainsaw
              f.number -= 4;
              global.sounds.trigger_units("items/chainsaw_long", f.xCenter() -
                this.currMap.viewX, f.yCenter() - this.currMap.viewY);
              break;
          }
          h.weapon().lowerDurability();
          if (randomChance(Constants.feature_treeDropChance)) {
            this.currMap.addItem(new Item(branch_id, h.frontX(), h.frontY()));
          }
          if (f.number < 1) {
            f.destroy(this.currMap);
          }
        }
        break;
      case 441: // bush
      case 442:
      case 443:
        if (use_item && h.holding(2204, 2211)) {
          f.number--;
          if (randomChance(Constants.feature_bushDropChance)) {
            this.currMap.addItem(new Item(2964, f.x + 0.2f + random(0.6f), f.y + 0.2f + random(0.6f)));
          }
          h.weapon().lowerDurability();
          if (f.number < 1) {
            f.remove = true;
          }
          global.sounds.trigger_units("features/sword_bush", f.xCenter() -
            this.currMap.viewX, f.yCenter() - this.currMap.viewY);
        }
        break;
      case 501: // car
      case 502:
      case 503:
      case 504:
      case 505:
        if (h.holding(2929)) {
          if (h.weapon().ammo < 1) {
            this.currMap.addHeaderMessage("The gas can is empty");
          }
          else if (f.number >= f.gasTankSize()) {
            this.currMap.addHeaderMessage("The car's gas tank is full");
          }
          else {
            int amount_to_fill = min(h.weapon().ammo, f.gasTankSize() - f.number, 8);
            h.weapon().ammo -= amount_to_fill;
            f.number += amount_to_fill;
            global.sounds.trigger_units("player/pour_fuel", f.xCenter() -
              this.currMap.viewX, f.yCenter() - this.currMap.viewY);
          }
        }
        else if (h.holding(2906)) {
          if (h.weapon().unlocks(f.ID)) {
            if (f.number > 0) {
              this.level_form = new VehicleForm(f, h);
              global.defaultCursor();
            }
            else {
              this.currMap.addHeaderMessage("The car is out of gas");
            }
          }
          else {
            this.currMap.addHeaderMessage("This key doesn't operate that car");
          }
        }
        else {
          this.currMap.addHeaderMessage("You need a key to operate this car");
        }
        break;
      default:
        global.errorMessage("ERROR: Hero " + h.display_name() + " trying to " +
          "interact with feature " + f.display_name() + " but no interaction logic found.");
        break;
    }
  }


   public void complete() {
    this.complete(0);
  }
   public void complete(int completion_code) {
    if (this.completing || this.completed) {
      return;
    }
    this.completion_code = completion_code;
    this.completing = true;
    this.save();
    global.sounds.play_background("victory");
  }


   public void restartTimers() {
    this.restart_timers = true;
  }
   public void restartTimers(int millis) {
    this.last_update_time = millis;
    if (this.currMap != null) {
      this.currMap.lastUpdateTime = millis;
    }
  }


   public void update(int millis) {
    if (this.restart_timers) {
      this.restart_timers = false;
      this.restartTimers(millis);
    }
    int time_elapsed = millis - this.last_update_time;
    if (this.completing || this.completed) {
      if (this.currMap != null) {
        this.currMap.drawMap();
      }
      else {
        rectMode(CORNERS);
        noStroke();
        fill(color(60));
        rect(this.xi, this.yi, this.xf, this.yf);
      }
      this.completing_timer -= time_elapsed;
      if (this.completing_timer < 0) {
        this.completed = true;
      }
      rectMode(CORNERS);
      fill(100, 100);
      noStroke();
      rect(this.xi, this.yi, this.xf, this.yf);
      fill(255);
      textSize(90);
      textAlign(CENTER, CENTER);
      text("You are Victorious!", 0.5f * width, 0.5f * height);
      this.last_update_time = millis;
      return;
    }
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.was_viewing_hero_tree = true;
        if (this.player.heroTree.set_screen_location) {
          this.player.heroTree.set_screen_location = false;
          global.defaultCursor();
          this.player.heroTree.setLocation(this.xi, this.yi, this.xf, this.yf);
        }
        this.player.heroTree.update(time_elapsed);
        this.last_update_time = millis;
        return;
      }
      else if (this.was_viewing_hero_tree) {
        this.was_viewing_hero_tree = false;
        this.restartTimers();
        global.defaultCursor();
      }
    }
    if (this.level_form != null) {
      this.level_form.update(millis);
      if (this.level_form.canceled) {
        this.level_form = null;
        this.restartTimers(millis);
      }
      this.last_update_time = millis;
      return;
    }
    this.time.add(time_elapsed * Constants.level_timeConstants);
    if (this.currMap != null) {
      this.currMap.base_light_level = DayCycle.lightFraction(this.time.value);
      if (this.respawning) {
        this.currMap.terrain_display.filter(GRAY);
      }
      this.currMap.update(millis);
      this.zombie_spawn_params.update(time_elapsed, this);
      for (Map.Entry<Integer, Trigger> entry : this.triggers.entrySet()) {
        entry.getValue().update(time_elapsed, this);
      }
      if (this.player != null) {
        if (this.player.curr_action == UnitAction.HERO_INTERACTING_WITH_FEATURE) {
          this.heroFeatureInteraction(this.player, false);
          this.player.stopAction();
        }
        else if (this.player.curr_action == UnitAction.HERO_INTERACTING_WITH_FEATURE_WITH_ITEM) {
          this.heroFeatureInteraction(this.player, true);
          this.player.stopAction();
        }
        for (Linker linker : this.linkers) {
          if (linker.rect1.contains(this.player, this.currMapName)) {
            this.movePlayerTo(linker.rect2);
          }
        }
        if (this.player.inventory.item_dropping != null) {
          this.currMap.addItem(new Item(this.player.inventory.item_dropping,
            this.player.frontX(), this.player.frontY()));
          this.player.inventory.item_dropping = null;
        }
        for (Item i : this.player.inventory.more_items_dropping) {
          this.currMap.addItem(new Item(i, this.player.frontX(), this.player.frontY()));
        }
        this.player.inventory.more_items_dropping.clear();
        if (this.player.inventory.viewing) {
          if (this.player.inventory.item_holding != null) {
            this.currMap.selected_object = this.player.inventory.item_holding;
          }
        }
        if (this.player.messages.peek() != null) {
          this.currMap.addHeaderMessage(this.player.messages.poll());
        }
      }
    }
    else {
      rectMode(CORNERS);
      noStroke();
      fill(color(60));
      rect(this.xi, this.yi, this.xf, this.yf);
    }
    if (this.player != null) {
      if (this.respawning) {
        this.respawn_timer -= time_elapsed;
        if (this.respawn_timer < 0) {
          this.respawnPlayer();
          this.respawning = false;
        }
      }
      else if (this.sleeping) {
        this.sleep_timer -= time_elapsed;
        if (this.sleep_timer < 0) {
          this.gainControl();
          this.sleeping = false;
          this.player_spawn_location = new Rectangle(this.currMapName, this.player);
          this.time.set(6);
          if (this.currMap != null) {
            this.currMap.addHeaderMessage("Spawn Point Reset");
          }
        }
      }
      else {
        this.player.update_hero(time_elapsed);
        for (Map.Entry<Integer, Quest> entry : this.quests.entrySet()) {
          entry.getValue().update(this, time_elapsed);
        }
        if (this.player.seesTime()) {
          fill(255);
          textSize(14);
          textAlign(LEFT, TOP);
          float line_height = textAscent() + textDescent() + 2;
          String time_line = this.timeString();
          text(time_line, this.xf - 40 - textWidth(time_line), 1);
        }
        if (this.player.remove && !this.respawning) {
          this.respawning = true;
          this.respawn_timer = Constants.level_defaultRespawnTimer;
        }
      }
    }
    if (this.respawning) {
      fill(255);
      textSize(90);
      textAlign(CENTER, BOTTOM);
      text("You Died", 0.5f * width, 0.5f * height);
      textSize(45);
      textAlign(CENTER, TOP);
      text("Respawning in " + PApplet.parseInt(ceil(this.respawn_timer * 0.001f)) + " s", 0.5f * width, 0.5f * height + 5);
    }
    if (this.sleeping) {
      rectMode(CORNERS);
      noStroke();
      float alpha_amount = PApplet.parseInt(255 * (1 - this.sleep_timer / PApplet.parseFloat(Constants.feature_bedSleepTimer)));
      fill(color(0, alpha_amount));
      rect(this.xi, this.yi, this.xf, this.yf);
    }
    this.last_update_time = millis;
  }

   public void displayNerdStats() {
    if (this.currMap != null) {
      this.currMap.displayNerdStats();
    }
    else {
      fill(255);
      textSize(14);
      textAlign(LEFT, TOP);
      float y_stats = 1;
      float line_height = textAscent() + textDescent() + 2;
      text("FPS: " + PApplet.parseInt(global.lastFPS), this.xi + 1, y_stats);
      y_stats += line_height;
      text("Active Threads: " + Thread.getAllStackTraces().size(), this.xi + 1, y_stats);
    }
  }

   public void mouseMove(float mX, float mY) {
    if (this.completing || this.completed) {
      return;
    }
    if (this.level_questbox != null) {
      this.level_questbox.mouseMove(mX, mY);
    }
    if (this.level_chatbox != null) {
      this.level_chatbox.mouseMove(mX, mY);
    }
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.mouseMove(mX, mY);
        if (this.player.left_panel_menu != null) {
          this.player.left_panel_menu.mouseMove(mX, mY);
        }
        return;
      }
      else {
        this.player.mouseMove_hero(mX, mY);
      }
    }
    if (this.level_form != null) {
      this.level_form.mouseMove(mX, mY);
      return;
    }
    if (this.currMap != null) {
      this.currMap.mouseMove(mX, mY);
      if (this.player != null && this.player.inventory_bar.hovered) {
        this.currMap.hovered_object = null;
        global.defaultCursor("icons/cursor_interact.png", "icons/cursor_attack.png", "icons/cursor_pickup.png");
      }
    }
  }

   public void mousePress() {
    if (this.level_questbox != null) {
      this.level_questbox.mousePress();
    }
    if (this.level_chatbox != null) {
      this.level_chatbox.mousePress();
    }
    if (this.completing || this.completed) {
      return;
    }
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.mousePress();
        if (this.player.left_panel_menu != null) {
          this.player.left_panel_menu.mousePress();
        }
        return;
      }
      else {
        this.player.mousePress_hero();
      }
    }
    if (this.level_form != null) {
      this.level_form.mousePress();
      return;
    }
    if (this.currMap != null) {
      this.currMap.mousePress();
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.level_questbox != null) {
      this.level_questbox.mouseRelease(mX, mY);
    }
    if (this.level_chatbox != null) {
      this.level_chatbox.mouseRelease(mX, mY);
    }
    if (this.completing || this.completed) {
      return;
    }
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.mouseRelease(mX, mY);
        if (this.player.left_panel_menu != null) {
          this.player.left_panel_menu.mouseRelease(mX, mY);
        }
        if (!this.player.heroTree.curr_viewing) {
          this.was_viewing_hero_tree = false;
          this.restartTimers();
          global.defaultCursor();
        }
        return;
      }
      else {
        this.player.mouseRelease_hero(mX, mY);
      }
    }
    if (this.level_form != null) {
      this.level_form.mouseRelease(mX, mY);
      return;
    }
    if (this.currMap != null) {
      this.currMap.mouseRelease(mX, mY);
    }
  }

   public void scroll(int amount) {
    if (this.level_questbox != null) {
      this.level_questbox.scroll(amount);
    }
    if (this.level_chatbox != null) {
      this.level_chatbox.scroll(amount);
    }
    if (this.completing || this.completed) {
      return;
    }
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.scroll(amount);
        return;
      }
      else {
        this.player.scroll_hero(amount);
      }
    }
    if (this.level_form != null) {
      this.level_form.scroll(amount);
      return;
    }
    if (this.currMap != null) {
      this.currMap.scroll(amount);
    }
  }

   public void keyPress() {
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.keyPress();
        if (key == CODED) {
          switch(keyCode) {
          }
        }
        else {
          switch(key) {
            case ESC:
              this.player.heroTree.curr_viewing = false;
              this.restartTimers();
              global.defaultCursor();
              break;
            case 't':
            case 'T':
              if (global.holding_ctrl) {
                this.player.heroTree.curr_viewing = false;
                this.restartTimers();
                global.defaultCursor();
              }
              break;
          }
        }
        if (!this.player.heroTree.curr_viewing) {
          this.was_viewing_hero_tree = false;
          this.restartTimers();
          global.defaultCursor();
        }
        return;
      }
      else {
        this.player.keyPress_hero();
      }
    }
    if (this.level_form != null) {
      this.level_form.keyPress();
      return;
    }
    if (this.currMap != null) {
      this.currMap.keyPress();
    }
    if (key == CODED) {
      switch(keyCode) {
      }
    }
    else {
      switch(key) {
        case 't':
        case 'T':
          if (global.holding_ctrl && this.player != null) {
            this.player.heroTree.curr_viewing = true;
            global.defaultCursor();
            this.player.heroTree.setLocation(this.xi, this.yi, this.xf, this.yf);
          }
          break;
        case 'c':
        case 'C':
          if (global.holding_ctrl && this.player != null) {
            this.complete();
          }
          break;
      }
    }
  }

   public void keyRelease() {
    if (this.player != null) {
      if (this.player.heroTree.curr_viewing) {
        this.player.heroTree.keyRelease();
        return;
      }
      else {
        this.player.keyRelease_hero();
      }
    }
    if (this.level_form != null) {
      this.level_form.keyRelease();
      return;
    }
    if (this.currMap != null) {
      this.currMap.keyRelease();
    }
  }


   public void loseFocus() {
    if (this.currMap != null) {
      this.currMap.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.currMap != null) {
      this.currMap.gainFocus();
    }
  }


   public String finalFolderPath() {
    String finalFolderPath = this.folderPath;
    if (this.location == Location.ERROR) {
      finalFolderPath += "/" + this.levelName;
    }
    else {
      finalFolderPath += "/" + this.location.file_name();
    }
    return finalFolderPath;
  }


   public void save() {
    this.save(true);
  }
   public void save(boolean saveMap) {
    String finalFolderPath = this.finalFolderPath();
    if (!folderExists(finalFolderPath)) {
      mkdir(finalFolderPath);
    }
    PrintWriter file = createWriter(finalFolderPath + "/level.lnz");
    file.println("new: Level");
    file.println("levelName: " + this.levelName);
    file.println("location: " + this.location.file_name());
    file.println("completed: " + this.completed);
    file.println("completing: " + this.completing);
    file.println("completion_code: " + this.completion_code);
    file.println("time: " + this.time.value);
    file.println("respawning: " + this.respawning);
    file.println("respawn_timer: " + this.respawn_timer);
    file.println("sleeping: " + this.sleeping);
    file.println("sleep_timer: " + this.sleep_timer);
    file.println("in_control: " + this.in_control);
    if (this.zombie_spawn_params.save_params) {
      file.println("max_zombies_per_square: " + this.zombie_spawn_params.max_zombies_per_square);
      file.println("max_zombies: " + this.zombie_spawn_params.max_zombies);
      file.println("min_level: " + this.zombie_spawn_params.min_level);
      file.println("max_level: " + this.zombie_spawn_params.max_level);
      file.println("del_level: " + this.zombie_spawn_params.del_level);
      file.println("group_size: " + this.zombie_spawn_params.group_size);
      file.println("del_group_size: " + this.zombie_spawn_params.del_group_size);
      file.println("group_radius: " + this.zombie_spawn_params.group_radius);
      file.println("min_distance: " + this.zombie_spawn_params.min_distance);
      file.println("max_distance: " + this.zombie_spawn_params.max_distance);
    }
    if (this.currMapName != null) {
      file.println("currMapName: " + this.currMapName);
    }
    String mapNameList = "";
    for (int i = 0; i < this.mapNames.size(); i++) {
      if (i > 0) {
        mapNameList += ", ";
      }
      mapNameList += this.mapNames.get(i);
    }
    file.println("mapNames: " + mapNameList);
    for (Linker linker : this.linkers) {
      file.println(linker.fileString());
    }
    for (Map.Entry<Integer, Trigger> entry : this.triggers.entrySet()) {
      file.println("nextTriggerKey: " + entry.getKey());
      file.println(entry.getValue().fileString());
    }
    if (this.album_name != null) {
      file.println("album_name: " + this.album_name);
    }
    if (this.player_start_location != null) {
      file.println("player_start_location: " + this.player_start_location.fileString());
    }
    if (this.player_spawn_location != null) {
      file.println("player_spawn_location: " + this.player_spawn_location.fileString());
    }
    file.println("end: Level");
    file.flush();
    file.close();
    if (saveMap && this.currMap != null) {
      this.currMap.save(finalFolderPath);
    }
    global.profile.save(); // needed for ender chest to work properly
  }


   public void open() {
    this.open2Data(this.open1File());
  }


   public String[] open1File() {
    String finalFolderPath = this.finalFolderPath();
    String[] lines;
    lines = loadStrings(finalFolderPath + "/level.lnz");
    if (lines == null) {
      global.errorMessage("ERROR: Reading level at path " + finalFolderPath + " but no level file exists.");
      this.nullify = true;
    }
    return lines;
  }


   public void open2Data(String[] lines) {
    if (lines == null) {
      this.nullify = true;
      global.errorMessage("ERROR: Null file data for level; possibly missing " +
        "file at " + this.finalFolderPath() + ".");
      return;
    }
    Stack<ReadFileObject> object_queue = new Stack<ReadFileObject>();

    Linker curr_linker = null;
    int max_trigger_key = 0;
    Trigger curr_trigger = null;
    Condition curr_condition = null;
    Effect curr_effect = null;

    for (String line : lines) {
      String[] parameters = split(line, ':');
      if (parameters.length < 2) {
        continue;
      }

      String datakey = trim(parameters[0]);
      String data = trim(parameters[1]);
      for (int i = 2; i < parameters.length; i++) {
        data += ":" + parameters[i];
      }
      if (datakey.equals("new")) {
        ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
        switch(type) {
          case LEVEL:
            object_queue.push(type);
            break;
          case LINKER:
            object_queue.push(type);
            curr_linker = new Linker();
            break;
          case TRIGGER:
            object_queue.push(type);
            curr_trigger = new Trigger();
            break;
          case CONDITION:
            object_queue.push(type);
            curr_condition = new Condition();
            break;
          case EFFECT:
            object_queue.push(type);
            curr_effect = new Effect();
            break;
          default:
            global.errorMessage("ERROR: Can't add a " + type + " type to Level data.");
            break;
        }
      }
      else if (datakey.equals("end")) {
        ReadFileObject type = ReadFileObject.objectType(data);
        if (object_queue.empty()) {
          global.errorMessage("ERROR: Tring to end a " + type.name + " object but not inside any object.");
        }
        else if (type.name.equals(object_queue.peek().name)) {
          switch(object_queue.pop()) {
            case LEVEL:
              return;
            case LINKER:
              if (curr_linker == null) {
                global.errorMessage("ERROR: Trying to end a null linker.");
              }
              this.addLinker(curr_linker);
              curr_linker = null;
              break;
            case TRIGGER:
              if (curr_trigger == null) {
                global.errorMessage("ERROR: Trying to end a null trigger.");
              }
              if (this.nextTriggerKey > max_trigger_key) {
                max_trigger_key = this.nextTriggerKey;
              }
              this.addTrigger(curr_trigger);
              curr_trigger = null;
              break;
            case CONDITION:
              if (curr_condition == null) {
                global.errorMessage("ERROR: Trying to end a null condition.");
              }
              if (object_queue.peek() != ReadFileObject.TRIGGER) {
                global.errorMessage("ERROR: Trying to end a condition while not in a TRIGGER.");
              }
              if (curr_trigger == null) {
                global.errorMessage("ERROR: Trying to end an condition but curr_trigger is null.");
              }
              curr_condition.setName();
              curr_trigger.conditions.add(curr_condition);
              curr_condition = null;
              break;
            case EFFECT:
              if (curr_effect == null) {
                global.errorMessage("ERROR: Trying to end a null effect.");
              }
              if (object_queue.peek() != ReadFileObject.TRIGGER) {
                global.errorMessage("ERROR: Trying to end a effect while not in a TRIGGER.");
              }
              if (curr_trigger == null) {
                global.errorMessage("ERROR: Trying to end an effect but curr_trigger is null.");
              }
              curr_effect.setName();
              curr_trigger.effects.add(curr_effect);
              curr_effect = null;
              break;
            default:
              break;
          }
        }
        else {
          global.errorMessage("ERROR: Tring to end a " + type.name + " object while inside a " + object_queue.peek().name + " object.");
        }
      }
      else {
        switch(object_queue.peek()) {
          case LEVEL:
            this.addData(datakey, data);
            break;
          case LINKER:
            if (curr_linker == null) {
              global.errorMessage("ERROR: Trying to add linker data to null linker.");
            }
            curr_linker.addData(datakey, data);
            break;
          case TRIGGER:
            if (curr_trigger == null) {
              global.errorMessage("ERROR: Trying to add trigger data to null trigger.");
            }
            curr_trigger.addData(datakey, data);
            break;
          case CONDITION:
            if (curr_condition == null) {
              global.errorMessage("ERROR: Trying to add condition data to null trigger.");
            }
            curr_condition.addData(datakey, data);
            break;
          case EFFECT:
            if (curr_effect == null) {
              global.errorMessage("ERROR: Trying to add effect data to null trigger.");
            }
            curr_effect.addData(datakey, data);
            break;
          default:
            // before or after actual file data
            break;
        }
      }
    }

    this.nextTriggerKey = max_trigger_key + 1;
  }


   public void addData(String datakey, String data) {
    switch(datakey) {
      case "levelName":
        this.levelName = data;
        break;
      case "location":
        this.location = Location.location(data);
        break;
      case "completed":
        this.completed = toBoolean(data);
        break;
      case "completing":
        this.completing = toBoolean(data);
        break;
      case "completion_code":
        this.completion_code = toInt(data);
        break;
      case "time":
        this.time.set(toFloat(data));
        break;
      case "respawning":
        this.respawning = toBoolean(data);
        break;
      case "respawn_timer":
        this.respawn_timer = toInt(data);
        break;
      case "sleeping":
        this.sleeping = toBoolean(data);
        break;
      case "sleep_timer":
        this.sleep_timer = toInt(data);
        break;
      case "max_zombies_per_square":
        this.zombie_spawn_params.max_zombies_per_square = toFloat(data);
        break;
      case "max_zombies":
        this.zombie_spawn_params.max_zombies = toInt(data);
        break;
      case "min_level":
        this.zombie_spawn_params.min_level = toInt(data);
        break;
      case "max_level":
        this.zombie_spawn_params.max_level = toInt(data);
        break;
      case "del_level":
        this.zombie_spawn_params.del_level = toInt(data);
        break;
      case "group_size":
        this.zombie_spawn_params.group_size = toInt(data);
        break;
      case "del_group_size":
        this.zombie_spawn_params.del_group_size = toInt(data);
        break;
      case "group_radius":
        this.zombie_spawn_params.group_radius = toFloat(data);
        break;
      case "min_distance":
        this.zombie_spawn_params.min_distance = toFloat(data);
        break;
      case "max_distance":
        this.zombie_spawn_params.max_distance = toFloat(data);
        break;
      case "in_control":
        if (toBoolean(data)) {
          this.gainControl();
        }
        else {
          this.loseControl();
        }
        break;
      case "currMapName":
        this.currMapName = data;
        break;
      case "album_name":
        this.album_name = data;
        break;
      case "mapNames":
        String[] map_names = split(data, ',');
        for (String map_name : map_names) {
          if (!map_name.equals("")) {
            this.mapNames.add(trim(map_name));
          }
        }
        break;
      case "nextTriggerKey":
        this.nextTriggerKey = toInt(data);
        break;
      case "player_start_location":
        this.player_start_location = new Rectangle();
        this.player_start_location.addData(data);
        break;
      case "player_spawn_location":
        this.player_spawn_location = new Rectangle();
        this.player_spawn_location.addData(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for Level object.");
        break;
    }
  }



  class LevelQuestBox extends ListTextBox {
    LevelQuestBox() {
      super(width, Constants.mapEditor_listBoxGap, width, Constants.
        level_questBoxHeightRatio * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.setTitleText("Quests");
    }

    @Override public 
    void update(int millis) {
      this.clearText();
      boolean first = true;
      ArrayList<Quest> quests = new ArrayList<Quest>();
      for (Map.Entry<Integer, Quest> entry : Level.this.quests.entrySet()) {
        quests.add(entry.getValue());
        if (first) {
          this.setText(entry.getValue().name());
          first = false;
        }
        else {
          this.addLine(entry.getValue().name());
        }
      }
      if (this.line_hovered >= this.text_lines_ref.size()) {
        this.line_hovered = -1;
      }
      if (this.line_clicked >= this.text_lines_ref.size()) {
        this.line_clicked = this.text_lines_ref.size() - 1;
      }
      int timeElapsed = millis - this.lastUpdateTime;
      rectMode(CORNERS);
      fill(this.color_background);
      stroke(this.color_stroke);
      strokeWeight(1);
      rect(this.xi, this.yi, this.xf, this.yf);
      float currY = this.yi + 1;
      if (this.text_title_ref != null) {
        fill(this.color_header);
        textSize(this.title_size);
        rect(this.xi, this.yi, this.xf, this.yi + textAscent() + textDescent() + 1);
        fill(this.color_title);
        textAlign(CENTER, TOP);
        text(this.text_title, this.xi + 0.5f * (this.xf - this.xi), currY);
        currY += textAscent() + textDescent() + 2;
      }
      textAlign(LEFT, TOP);
      textSize(this.text_size);
      float text_height = textAscent() + textDescent();
      for (int i = PApplet.parseInt(floor(this.scrollbar.value)); i < this.text_lines.size(); i++, currY += text_height + this.text_leading) {
        if (currY + text_height + 1 > this.yf) {
          break;
        }
        if (i < 0 || i >= quests.size()) {
          continue;
        }
        fill(this.color_text);
        if (quests.get(i).blinking) {
          fill(color(170));
        }
        if (this.wordWrap) {
          text(this.text_lines.get(i), this.xi + 2, currY);
        }
        else {
          text(this.truncateLine(this.text_lines.get(i)), this.xi + 2, currY);
        }
        if (quests.get(i).met) {
          fill(0);
          line(this.xi + 1, currY + 0.5f * text_height, this.xf - 1, currY + 0.5f * text_height);
        }
      }
      if (this.scrollbar.maxValue != this.scrollbar.minValue) {
        this.scrollbar.update(millis);
      }
      if (!this.wordWrap) {
        if (this.scrollbar_horizontal.maxValue != this.scrollbar_horizontal.minValue) {
          this.scrollbar_horizontal.update(millis);
        }
      }
      this.lastUpdateTime = millis;
      if (this.doubleclickTimer > 0) {
        this.doubleclickTimer -= timeElapsed;
      }
      currY = this.yi + 1;
      if (this.text_title_ref != null) {
        textSize(this.title_size);
        currY += textAscent() + textDescent() + 2;
      }
      textSize(this.text_size);
      text_height = textAscent() + textDescent();
      if (this.line_hovered >= floor(this.scrollbar.value)) {
        float hovered_yi = currY + (this.line_hovered - floor(this.scrollbar.value)) * (text_height + this.text_leading);
        if (hovered_yi + text_height + 1 < this.yf) {
          rectMode(CORNERS);
          fill(this.hover_color);
          strokeWeight(0.001f);
          stroke(this.hover_color);
          rect(this.xi + 1, hovered_yi, this.xf - 2 - this.scrollbar.bar_size, hovered_yi + text_height);
        }
      }
      if (this.line_clicked >= floor(this.scrollbar.value)) {
        float clicked_yi = currY + (this.line_clicked - floor(this.scrollbar.value)) * (text_height + this.text_leading);
        if (clicked_yi + text_height + 1 < this.yf) {
          rectMode(CORNERS);
          fill(this.highlight_color);
          strokeWeight(0.001f);
          stroke(this.highlight_color);
          rect(this.xi + 1, clicked_yi, this.xf - 2 - this.scrollbar.bar_size, clicked_yi + text_height);
          if (this.line_hovered == this.line_clicked) {
            try {
              String tooltip = quests.get(this.line_clicked).shortDescription();
              float tooltip_width = textWidth(tooltip) + 2;
              noStroke();
              fill(global.color_nameDisplayed_background);
              rect(mouseX - tooltip_width - 2, mouseY + 2, mouseX - 2, mouseY + 2 + text_height + 2);
              fill(global.color_nameDisplayed_text);
              textAlign(LEFT, TOP);
              text(tooltip, mouseX - tooltip_width - 1, mouseY + 1);
            } catch(Exception e) {}
          }
        }
      }
    }

     public void click() {
    }

     public void doubleclick() {
    }
  }


   public void chat(String message) {
    this.level_chatbox.chat(message);
  }

  class LevelChatBox extends TextBox {
    boolean first_message = true;

    LevelChatBox() {
      super(width, Constants.level_questBoxHeightRatio * height, width,
        0.9f * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.setTitleText("Chat Log");
    }

     public void chat(String message) {
      global.sounds.trigger_player("player/chat");
      if (this.first_message) {
        this.addText(message);
        this.first_message = false;
      }
      else {
        this.addText("\n\n" + message);
      }
      this.scrollbar.scrollMax();
    }
  }



  abstract class LevelForm extends FormLNZ {
    LevelForm(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.scrollbar_max_width = 35;
      this.setTitleSize(18);
      this.color_background = color(211, 188, 141);
      this.color_header = color(220, 200, 150);
      global.defaultCursor();
      this.min_x = Level.this.xi;
      this.min_y = Level.this.yi;
      this.max_x = Level.this.xf;
      this.max_y = Level.this.yf;
    }
  }



  class DecisionForm extends LevelForm {
    protected int ID = 0;

    DecisionForm(int ID) {
      super(0.5f * (width - Constants.level_decisionFormWidth), 0.5f * (height - Constants.level_decisionFormHeight),
        0.5f * (width + Constants.level_decisionFormWidth), 0.5f * (height + Constants.level_decisionFormHeight));
      this.ID = ID;
      this.cancel = null;
      this.setFieldCushion(0);
      this.addField(new SpacerFormField(20));

      switch(ID) {
        case 1: // francis hall initial cut scene
          this.addField(new MessageFormField("Ben puts in earbuds to drown out the stupid conversation."));
          this.addField(new SpacerFormField(20));
          RadiosFormField radios = new RadiosFormField("What music does he play?");
          radios.addRadio("Thompson Twins");
          radios.addRadio("Now 2");
          this.addField(radios);
          this.addField(new SpacerFormField(20));
          this.addField(new SubmitFormField("Listen"));
          break;
        default:
          global.errorMessage("ERROR: Decision form ID " + ID + " not recognized.");
          break;
      }
    }

     public void cancel() {}

     public void submit() {
      switch(ID) {
        case 1: // francis hall initial cut scene
          switch(this.fields.get(3).getValue()) {
            case "0":
              global.sounds.play_background("thompson");
              break;
            case "1":
              global.sounds.play_background("now2");
              break;
            default:
              global.sounds.play_background("starset");
              break;
          }
          try {
            global.profile.options.volume_music = 100;
            global.profile.options.volume_music_muted = false;
            global.profile.options.change();
          } catch(Exception e) {}
          break;
        default:
          global.errorMessage("ERROR: Decision form ID " + ID + " not recognized.");
          break;
      }
      this.canceled = true;
    }
  }



  class VendingForm extends LevelForm {
    protected Feature vending_machine;
    protected Hero hero_looking;

    VendingForm(Feature f, Hero h) {
      super(0.5f * (width - Constants.level_vendingFormWidth), 0.5f * (height - Constants.level_vendingFormHeight),
        0.5f * (width + Constants.level_vendingFormWidth), 0.5f * (height + Constants.level_vendingFormHeight));
      this.vending_machine = f;
      this.hero_looking = h;
      this.setTitleText(this.vending_machine.display_name());

      this.addField(new SpacerFormField(20));
      ButtonsFormField insert_money = new ButtonsFormField("Insert $1", "Insert $5");
      insert_money.button1.setColors(color(170), color(236, 213, 166), color(211,
        188, 141), color(190, 165, 120), color(0));
      insert_money.button2.setColors(color(170), color(236, 213, 166), color(211,
        188, 141), color(190, 165, 120), color(0));
      this.addField(insert_money);
      this.addField(new MessageFormField("$" + this.vending_machine.number));
      this.addField(new MessageFormField(""));
      RadiosFormField choices = new RadiosFormField("Choices");
      switch(this.vending_machine.ID) {
        case 172: // food
          choices.addRadio("Chips, $1");
          choices.addRadio("Pretzels, $1");
          choices.addRadio("Chocolate, $2");
          choices.addRadio("Donut, $2");
          choices.addRadio("Poptart, $2");
          choices.addRadio("Peanuts, $1");
          break;
        case 173: // drink
          choices.addRadio("Water, $1");
          choices.addRadio("Coke, $1");
          choices.addRadio("Diet Coke, $1");
          choices.addRadio("Juice, $1");
          choices.addRadio("Energy Drink, $2");
          break;
        default:
          global.errorMessage("ERROR: Can't create VendingForm with feature of " +
            "ID " + this.vending_machine.ID + ".");
          break;
      }
      this.addField(choices);
      SubmitFormField vend = new SubmitFormField(" Vend ");
      vend.button.setColors(color(170), color(236, 213, 166), color(211,
        188, 141), color(190, 165, 120), color(0));
      this.addField(vend);
    }

    @Override public 
    void buttonPress(int i) {
      if (i != 1) {
        global.errorMessage("ERROR: Pressed button other than insert on VendingForm.");
        return;
      }
      int money_inserted = 1 + 4 * toInt(this.fields.get(1).getValue());
      if (this.hero_looking.money < money_inserted) {
        this.fields.get(3).setValue("You don't have $" + money_inserted + " to insert.");
        return;
      }
      this.hero_looking.money -= money_inserted;
      global.sounds.trigger_environment("features/vending_machine_coin",
        this.vending_machine.xCenter() - Level.this.currMap.viewX,
        this.vending_machine.yCenter() - Level.this.currMap.viewY);
      if (randomChance(Constants.feature_vendingEatMoneyChance)) {
        this.fields.get(3).setValue("The vending machine ate your money.");
        return;
      }
      this.vending_machine.number += money_inserted;
      this.fields.get(2).setValue("$" + this.vending_machine.number);
      this.fields.get(3).setValue("Please make your selection.");
    }

     public void submit() {
      int selection = toInt(this.fields.get(4).getValue());
      if (selection < 0) {
        this.fields.get(3).setValue("Please make a selection.");
        return;
      }
      int cost = 0;
      int item_id = 0;
      switch(this.vending_machine.ID) {
        case 172: // food
          switch(selection) {
            case 0:
              cost = 1;
              item_id = 2113;
              break;
            case 1:
              this.fields.get(3).setValue("Out of stock.");
              return;
            case 2:
              cost = 2;
              item_id = 2112;
              break;
            case 3:
              cost = 2;
              item_id = 2111;
              break;
            case 4:
              cost = 2;
              item_id = 2110;
              break;
            case 5:
              cost = 1;
              item_id = 2115;
              break;
          }
          break;
        case 173: // drink
          switch(selection) {
            case 0:
              cost = 1;
              item_id = 2924;
              break;
            case 1:
              cost = 1;
              item_id = 2132;
              break;
            case 2:
              this.fields.get(3).setValue("Out of stock.");
              return;
            case 3:
              cost = 1;
              item_id = 2133;
              break;
            case 4:
              this.fields.get(3).setValue("Out of stock.");
              return;
          }
          break;
      }
      if (this.vending_machine.number < cost) {
        this.fields.get(3).setValue("Please insert more money to purchase.");
        return;
      }
      this.vending_machine.number -= cost;
      Item new_item = new Item(item_id, this.vending_machine.x +
        0.2f + random(0.4f), this.vending_machine.y + 0.85f);
      if (item_id == 2924) {
        new_item.ammo = new_item.maximumAmmo();
      }
      Level.this.currMap.addItem(new_item);
      global.sounds.trigger_environment("features/vending_machine_vend",
        this.vending_machine.xCenter() - Level.this.currMap.viewX,
        this.vending_machine.yCenter() - Level.this.currMap.viewY);
      this.fields.get(2).setValue("$" + this.vending_machine.number);
      this.fields.get(3).setValue("Thank you for your purchase.");
    }
  }



  class QuizmoForm extends LevelForm {
    protected Feature chuck_quizmo;
    protected Hero hero;
    protected float last_update_time = 0;
    protected float time_before_cancel = Constants.level_quizmoTimeDelay;
    protected boolean canceling = false;
    protected boolean correct_guess = false;
    protected boolean guessed = false;

    QuizmoForm(Feature f, Hero h) {
      super(0.5f * (width - Constants.level_quizmoFormWidth), 0.5f * (height - Constants.level_quizmoFormHeight),
        0.5f * (width + Constants.level_quizmoFormWidth), 0.5f * (height + Constants.level_quizmoFormHeight));
      this.chuck_quizmo = f;
      this.hero = h;
      this.setTitleText(this.chuck_quizmo.display_name());

      RadiosFormField question = new RadiosFormField("");
      switch(this.chuck_quizmo.number) {
        case 0:
          question.setMessage("Test Question.");
          question.addRadio("Answer 1");
          question.addRadio("Answer 2");
          question.addRadio("Answer 3");
          question.addRadio("Answer 4");
          break;
        case 1: // Tutorial
          question.setMessage("Which of these is not part of Ben's penance?");
          question.addRadio("The Golden Rule");
          question.addRadio("Praying to Mary");
          question.addRadio("Telling everyone how much he hates them");
          question.addRadio("Being kinder to those around him");
          break;
        case 2: // Francis Hall
          question.setMessage("Which of these were options for Ben to listen to?");
          question.addRadio("Kalin Twins");
          question.addRadio("Now3");
          question.addRadio("Thompson Twins");
          question.addRadio("Joe Fagin");
          break;
        default:
          global.errorMessage("ERROR: Chuck Quizmo ID " + this.chuck_quizmo.number +
            " not found.");
          break;
      }

      this.addField(new SpacerFormField(120));
      this.addField(question);
      this.addField(new SpacerFormField(20));
      this.addField(new SubmitCancelFormField("Guess!", "Leave"));
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      imageMode(CORNER);
      image(this.hero.getImage(), this.xi + 20, this.yi + 40, 100, 100);
      image(global.images.getImage("features/chuck_quizmo.png"), this.xi + 210, this.yi + 40, 100, 100);
      int frame = constrain(PApplet.parseInt(floor(Constants.gif_quizmoQuestion_frames * (millis() %
        Constants.gif_quizmoQuestion_time) / Constants.gif_quizmoQuestion_time)),
        0, Constants.gif_quizmoQuestion_frames);
      if (this.canceling) {
        this.time_before_cancel -= millis - this.last_update_time;
        if (this.time_before_cancel < 0) {
          this.canceled = true;
        }
        if (this.correct_guess) {
          image(global.images.getImage("features/vanna_t_smiling.png"), this.xi + 300, this.yi + 60, 80, 80);
          image(global.images.getImage("gifs/quizmo_correct/" + frame + ".png"),
            this.xi + 140, this.yi + 80, 60, 60);
        }
        else if (this.guessed) {
          image(global.images.getImage("features/vanna_t.png"), this.xi + 300, this.yi + 60, 80, 80);
          image(global.images.getImage("gifs/quizmo_wrong/" + frame + ".png"),
            this.xi + 140, this.yi + 80, 60, 60);
        }
        else {
          image(global.images.getImage("features/vanna_t.png"), this.xi + 300, this.yi + 60, 80, 80);
          image(global.images.getImage("gifs/quizmo_question/" + frame + ".png"),
            this.xi + 140, this.yi + 80, 60, 60);
        }
      }
      else {
        image(global.images.getImage("features/vanna_t.png"), this.xi + 300, this.yi + 60, 80, 80);
        image(global.images.getImage("gifs/quizmo_question/" + frame + ".png"),
          this.xi + 140, this.yi + 80, 60, 60);
      }
      this.last_update_time = millis;
    }

    @Override public 
    void cancel() {
      this.canceling = true;
      Level.this.chat("Chuck Quizmo: Well, well... so long, farewell. 'Til we meet again!");
      Level.this.currMap.addVisualEffect(4009, this.chuck_quizmo.x + 0.7f, this.chuck_quizmo.y - 0.4f);
    }

     public void submit() {
      int guess = toInt(this.fields.get(1).getValue());
      if (guess < 0) {
        Level.this.chat("Chuck Quizmo: You haven't made a guess!");
        Level.this.currMap.addVisualEffect(4009, this.chuck_quizmo.x + 0.7f, this.chuck_quizmo.y - 0.4f);
        return;
      }
      if (this.guessed) {
        return;
      }
      this.guessed = true;
      this.fields.get(3).disable();
      int correct_answer = -1;
      switch(this.chuck_quizmo.number) {
        case 0:
          correct_answer = 1;
          break;
        case 1: // Tutorial
          correct_answer = 3;
          break;
        case 2: // Francis Hall
          correct_answer = 2;
          break;
        default:
          global.errorMessage("ERROR: Chuck Quizmo ID " + this.chuck_quizmo.number +
            " not found.");
          break;
      }
      if (guess == correct_answer) {
        if (global.profile.answeredChuckQuizmo(this.chuck_quizmo.number)) {
          if (hero.canPickup()) {
            hero.pickup(new Item(2825));
          }
          else {
            Level.this.currMap.addItem(new Item(2825, this.hero.frontX(), this.hero.frontY()));
          }
          Level.this.chat("Chuck Quizmo: Congratulations! Here's your Star Piece!");
        }
        else {
          Level.this.chat("Chuck Quizmo: You've already won this Star Piece!");
        }
        hero.addExperience(5 + pow(min(this.chuck_quizmo.number, 10), 8));
        Level.this.currMap.addVisualEffect(4009, this.chuck_quizmo.x + 0.7f, this.chuck_quizmo.y - 0.4f);
        this.correct_guess = true;
      }
      else {
        Level.this.chat("Chuck Quizmo: Too bad!");
        Level.this.currMap.addVisualEffect(4009, this.chuck_quizmo.x + 0.7f, this.chuck_quizmo.y - 0.4f);
        this.correct_guess = false;
      }
      this.chuck_quizmo.destroy(Level.this.currMap);
      this.canceling = true;
    }
  }



  class KhalilForm extends LevelForm {
    protected Inventory original_stock;
    protected Feature khalil;
    protected Hero hero;
    protected ArrayList<Float> costs;

    KhalilForm(Feature f, Hero h) {
      super(0.5f * (width - Constants.level_khalilFormWidth), 0.5f * (height - Constants.level_khalilFormHeight),
        0.5f * (width + Constants.level_khalilFormWidth), 0.5f * (height + Constants.level_khalilFormHeight));
      this.color_background = color(102, 153, 204);
      this.color_header = color(72, 120, 170);
      this.original_stock = getKhalilInventory(f.number);
      this.costs = getKhalilInventoryCosts(f.number);
      if (this.original_stock == null || this.costs == null) {
        this.canceled = true;
        return;
      }
      this.khalil = f;
      this.hero = h;
      this.setTitleText(this.khalil.display_name());
      if (this.khalil.inventory == null) {
        this.khalil.createKhalilInventory();
      }

      MessageFormField khalilMessageField = new MessageFormField("Please take a look at my inventory of goods.");
      khalilMessageField.setTextSize(18, true);
      RadiosFormField radiosField = new RadiosFormField("Inventory");
      for (int i = 0; i < this.original_stock.slots.size(); i++) {
        String item_name = this.original_stock.slots.get(i).item.display_name();
        Item stock_item = this.khalil.inventory.slots.get(i).item;
        int stock_amount = 0;
        if (stock_item != null && !stock_item.remove) {
          stock_amount = stock_item.stack;
        }
        if (stock_amount > 0) {
          radiosField.addRadio(item_name + " (" + stock_amount + " left): $" + this.costs.get(i));
        }
        else {
          radiosField.addDisabledRadio(item_name + " (out of stock): $" + this.costs.get(i));
        }
      }
      SubmitCancelFormField buttons = new SubmitCancelFormField("Purchase", "Leave");
      buttons.button1.setColors(color(170), color(127, 178, 229), color(102,
        153, 204), color(80, 128, 179), color(0));
      buttons.button2.setColors(color(170), color(127, 178, 229), color(102,
        153, 204), color(80, 128, 179), color(0));

      this.addField(new SpacerFormField(110));
      this.addField(khalilMessageField);
      this.addField(new SpacerFormField(5));
      this.addField(radiosField);
      this.addField(new SpacerFormField(20));
      this.addField(buttons);
    }


    @Override public 
    void update(int millis) {
      super.update(millis);
      imageMode(CENTER);
      image(this.khalil.getImage(), this.xCenter(), this.yStart + 65, 240, 120);
    }


    @Override public 
    void cancel() {
      this.canceled = true;
      Level.this.chat("Traveling Buddy: Sooo loooong traveling buddyyyy");
      Level.this.currMap.addVisualEffect(4009, this.khalil.x + 0.6f, this.khalil.y - 0.4f);
    }

     public void submit() {
      int selection = toInt(this.fields.get(3).getValue());
      if (selection < 0) {
        this.fields.get(1).setValue("Please make a selection.");
        return;
      }
      float cost = this.costs.get(selection);
      if (this.hero.money < cost) {
        this.fields.get(1).setValue("It seems you don't have enough money to afford that.");
        return;
      }
      Item i = this.khalil.inventory.slots.get(selection).item;
      if (i == null || i.remove) {
        this.fields.get(1).setValue("That item is out of stock.");
        return;
      }
      this.fields.get(1).setValue("Thank you for your purchase.");
      Item bought_item = new Item(i);
      i.removeStack();
      bought_item.stack = 1;
      this.hero.money -= cost;
      if (this.hero.canPickup()) {
        this.hero.pickup(bought_item);
      }
      else {
        Item leftover = this.hero.inventory.stash(bought_item);
        if (leftover != null && !leftover.remove) {
          Level.this.currMap.addItem(leftover, this.khalil.x + 1, this.khalil.y + 1);
        }
      }
      RadioButton button = ((RadiosFormField)this.fields.get(3)).radios.get(selection);
      if (i.remove) {
        button.message = i.display_name() + " (out of stock): $" + this.costs.get(selection);
        button.disabled = true;
        button.color_text = color(80);
      }
      else {
        button.message = i.display_name() + " (" + i.stack + " left): $" + this.costs.get(selection);
      }
    }
  }



  class VehicleForm extends LevelForm {
    private Feature car = null;
    private Hero hero = null;
    private int timer_idle_sound = 0;
    private int last_update_time = 0;
    private boolean first_update = true;

    VehicleForm(Feature f, Hero h) {
      super(0.5f * (width - Constants.level_vehicleFormWidth), 0.5f * (height - Constants.level_vehicleFormHeight),
        0.5f * (width + Constants.level_vehicleFormWidth), 0.5f * (height + Constants.level_vehicleFormHeight));
      if (f == null || f.remove || h == null || h.remove) {
        global.errorMessage("ERROR: Null parameter passed into VehicleForm.");
        return;
      }
      this.car = f;
      this.hero = h;
      this.setTitleText(f.display_name());
      this.setFieldCushion(10);

      String message_body = this.getMessageBody(); // from level location / car
      MessageFormField message = new MessageFormField(message_body);
      SubmitCancelFormField submit = new SubmitCancelFormField("Drive Away", "Exit Vehicle");
      submit.button1.setColors(color(170), color(236, 213, 166), color(211,
        188, 141), color(190, 165, 120), color(0));
      submit.button2.setColors(color(170), color(236, 213, 166), color(211,
        188, 141), color(190, 165, 120), color(0));

      this.addField(new SpacerFormField(210));
      this.addField(new MessageFormField("You started the car"));
      this.addField(message);
      this.addField(submit);

      global.sounds.trigger_player("player/car_start");
    }

     public String getMessageBody() {
      switch(Level.this.location) {
        case FRANCISCAN_LEV2_FRONTDOOR:
          switch(this.car.ID) {
            case 501: // ahimdoor
            case 502: // outside egan
            case 503: // behindcaf
            case 504: // lower lot
              return "Drive off-campus to find a more remote area?";
            default:
              break;
          }
          break;
        default:
          break;
      }
      return "Error";
    }

    @Override public 
    void update(int millis) {
      if (this.first_update) {
        this.first_update = false;
        this.last_update_time = millis;
      }
      int time_elapsed = millis - this.last_update_time;
      this.timer_idle_sound -= time_elapsed;
      if (this.timer_idle_sound < 0) {
        this.timer_idle_sound = 6900;
        global.sounds.trigger_player("player/car_idle");
      }
      super.update(millis);
      imageMode(CENTER);
      float image_width = this.car.width() * 200.0f / this.car.height();
      image(this.car.getImage(), this.xCenter(), this.yStart + 105, image_width, 200);
      this.last_update_time = millis;
    }

    @Override public 
    void cancel() {
      super.cancel();
      global.sounds.trigger_player("player/car_off");
      global.sounds.silence_player("player/car_idle");
      this.timer_idle_sound = 500;
    }


     public void submit() {
      boolean found_action = false;
      switch(Level.this.location) {
        case FRANCISCAN_LEV2_FRONTDOOR:
          switch(this.car.ID) {
            case 501: // ahimdoor
            case 502: // outside egan
            case 503: // behindcaf
            case 504: // lower lot
              found_action = true;
              Level.this.complete(1);
            default:
              break;
          }
          break;
        default:
          break;
      }
      if (!found_action) {
        global.errorMessage("ERROR: Location " + Level.this.location.file_name() +
          "with vehicle " + this.car.ID + " not found in VehicleForm::submit().");
      }
      this.canceled = true;
    }
  }
}



class LevelEditor extends Level {
  protected Rectangle last_rectangle = null;

  LevelEditor() {
  }
  LevelEditor(String folderPath, String levelName) {
    this.folderPath = folderPath;
    this.levelName = levelName;
    this.open();
  }

  @Override public 
  void openMap(String mapName) {
    if (mapName == null) {
      return;
    }
    if (!fileExists(this.finalFolderPath() + "/" + mapName + "." + this.mapSuffix() + ".lnz")) {
      global.errorMessage("ERROR: Level " + this.levelName + " has no map " +
        "with name " + mapName + " at location " + this.finalFolderPath() + ".");
      return;
    }
    if (mapName.equals(this.currMapName)) {
      return;
    }
    this.currMapName = mapName;
    if (this.location.isArea()) {
      this.currMap = new GameMapAreaEditor(mapName, this.finalFolderPath());
    }
    else {
      this.currMap = new GameMapLevelEditor(mapName, this.finalFolderPath());
    }
    this.currMap.setLocation(this.xi, this.yi, this.xf, this.yf);
  }


   public void newLinker() {
    if (this.last_rectangle == null) {
      return;
    }
    if (this.currMap == null) {
      return;
    }
    if (!GameMapLevelEditor.class.isInstance(this.currMap)) {
      return;
    }
    if (((GameMapLevelEditor)this.currMap).rectangle_dropping == null) {
      return;
    }
    Linker linker = new Linker(this.last_rectangle, ((GameMapLevelEditor)this.currMap).rectangle_dropping);
    this.addLinker(linker);
  }


   public Rectangle getCurrentRectangle() {
    if (this.currMap == null) {
      return null;
    }
    if (!GameMapLevelEditor.class.isInstance(this.currMap)) {
      return null;
    }
    return ((GameMapLevelEditor)this.currMap).rectangle_dropping;
  }


   public void newTrigger() {
    this.addTrigger(new Trigger("Trigger " + this.nextTriggerKey));
  }


  @Override public 
  void update(int millis) {
    if (this.currMap != null) {
      this.currMap.update(millis);
    }
    else {
      rectMode(CORNERS);
      noStroke();
      fill(color(60));
      rect(this.xi, this.yi, this.xf, this.yf);
    }
    if (this.currMap != null && this.last_rectangle != null && this.last_rectangle.mapName.equals(this.currMapName)) {
      fill(170, 100);
      rectMode(CORNERS);
      noStroke();
      float rect_xi = max(this.currMap.startSquareX, this.last_rectangle.xi);
      float rect_yi = max(this.currMap.startSquareY, this.last_rectangle.yi);
      float rect_xf = min(this.currMap.startSquareX + this.currMap.visSquareX, this.last_rectangle.xf);
      float rect_yf = min(this.currMap.startSquareY + this.currMap.visSquareY, this.last_rectangle.yf);
      rect(this.currMap.xi_map + (rect_xi - this.currMap.startSquareX) * this.currMap.zoom,
        this.currMap.yi_map + (rect_yi - this.currMap.startSquareY) * this.currMap.zoom,
        this.currMap.xi_map + (rect_xf - this.currMap.startSquareX) * this.currMap.zoom,
        this.currMap.yi_map + (rect_yf - this.currMap.startSquareY) * this.currMap.zoom);
    }
  }

  @Override public 
  void keyPress() {
    super.keyPress();
    if (key == CODED) {
      switch(keyCode) {}
    }
    else {
      switch(key) {
        case 's':
          if (this.currMap != null && GameMapLevelEditor.class.isInstance(this.currMap)) {
            this.last_rectangle = ((GameMapLevelEditor)this.currMap).rectangle_dropping;
            ((GameMapLevelEditor)this.currMap).rectangle_dropping = null;
            this.currMap.addHeaderMessage("Rectangle saved");
          }
          break;
        case 'S':
          if (this.currMap != null && GameMapLevelEditor.class.isInstance(this.currMap)) {
            this.last_rectangle = ((GameMapLevelEditor)this.currMap).rectangle_dropping;
            ((GameMapLevelEditor)this.currMap).rectangle_dropping = null;
            this.currMap.addHeaderMessage("Rectangle saved");
            if (this.last_rectangle != null) {
              if (global.holding_ctrl) {
                this.player_spawn_location = this.last_rectangle;
                this.currMap.addHeaderMessage("Player respawn location set");
              }
              else {
                this.player_start_location = this.last_rectangle;
                this.currMap.addHeaderMessage("Player start location set");
              }
              this.last_rectangle = null;
            }
          }
          break;
      }
    }
  }

  @Override public 
  String finalFolderPath() {
    return this.folderPath + "/" + this.levelName;
  }
}
// level location
enum Location {
  ERROR, TUTORIAL,

  FRANCISCAN_FRANCIS, FRANCISCAN_LEV2_FRONTDOOR, FRANCISCAN_LEV2_AHIMDOOR,
  FRANCISCAN_LEV2_CHAPELDOOR, FRANCISCAN_LEV2_BROTHERSDOOR, FRANCISCAN_LEV2_CUSTODIALDOOR,
  FRANCISCAN_LEV3_KILLEDHECK, FRANCISCAN_LEV3_AROUNDCODA,
  AREA_FERNWOOD;

  private static final List<Location> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String display_name() {
    return Location.display_name(this);
  }
  public static String display_name(Location a) {
    switch(a) {
      case TUTORIAL:
        return "Tutorial";
      case FRANCISCAN_FRANCIS:
        return "Francis Hall";
      case FRANCISCAN_LEV2_FRONTDOOR:
      case FRANCISCAN_LEV2_AHIMDOOR:
      case FRANCISCAN_LEV2_CHAPELDOOR:
      case FRANCISCAN_LEV2_BROTHERSDOOR:
      case FRANCISCAN_LEV2_CUSTODIALDOOR:
      case FRANCISCAN_LEV3_KILLEDHECK:
      case FRANCISCAN_LEV3_AROUNDCODA:
        return "Franciscan Campus";
      case AREA_FERNWOOD:
        return "Fernwood State Forest";
      default:
        return "-- Error --";
    }
  }

  public String file_name() {
    return Location.file_name(this);
  }
  public static String file_name(Location a) {
    switch(a) {
      case TUTORIAL:
        return "tutorial";
      case FRANCISCAN_FRANCIS:
        return "franciscan_francis";
      case FRANCISCAN_LEV2_FRONTDOOR:
        return "franciscan_lev2_frontdoor";
      case FRANCISCAN_LEV2_AHIMDOOR:
        return "franciscan_lev2_ahimdoor";
      case FRANCISCAN_LEV2_CHAPELDOOR:
        return "franciscan_lev2_chapeldoor";
      case FRANCISCAN_LEV2_BROTHERSDOOR:
        return "franciscan_lev2_brothersdoor";
      case FRANCISCAN_LEV2_CUSTODIALDOOR:
        return "franciscan_lev2_custodialdoor";
      case FRANCISCAN_LEV3_KILLEDHECK:
        return "franciscan_lev3_killedheck";
      case FRANCISCAN_LEV3_AROUNDCODA:
        return "franciscan_lev3_aroundcoda";
      case AREA_FERNWOOD:
        return "area_fernwood";
      default:
        return "ERROR";
    }
  }

  public static Location location(String display_name) {
    for (Location location : Location.VALUES) {
      if (location == Location.ERROR) {
        continue;
      }
      if (Location.display_name(location).equals(display_name) ||
        Location.file_name(location).equals(display_name)) {
        return location;
      }
    }
    return Location.ERROR;
  }

  public Location nextLocation(int completion_code) {
    return Location.nextLocation(this, completion_code);
  }
  public static Location nextLocation(Location a, int completion_code) {
    Location return_location = Location.ERROR;
    switch(a) {
      case FRANCISCAN_FRANCIS:
        switch(completion_code) {
          case 0: // ctrl-c
            return_location = Location.FRANCISCAN_LEV2_FRONTDOOR;
            break;
          case 1:
            return_location = Location.FRANCISCAN_LEV2_FRONTDOOR;
            break;
          case 2:
            return_location = Location.FRANCISCAN_LEV2_AHIMDOOR;
            break;
          case 3:
            return_location = Location.FRANCISCAN_LEV2_CHAPELDOOR;
            break;
          case 4:
            return_location = Location.FRANCISCAN_LEV2_BROTHERSDOOR;
            break;
          case 5:
            return_location = Location.FRANCISCAN_LEV2_CUSTODIALDOOR;
            break;
          default:
            return_location = Location.ERROR;
            break;
        }
        break;
      case FRANCISCAN_LEV2_FRONTDOOR:
        switch(completion_code) {
          case 0: // ctrl-c
            return_location = Location.FRANCISCAN_LEV3_KILLEDHECK;
            break;
          case 1: // ahimdoor car
            return_location = Location.AREA_FERNWOOD;
            break;
          case 2: // lot boss car
            return_location = Location.AREA_FERNWOOD;
            break;
          case 3: // killed heck
            return_location = Location.FRANCISCAN_LEV3_KILLEDHECK;
            break;
          case 4: // around coda
            return_location = Location.FRANCISCAN_LEV3_AROUNDCODA;
            break;
          default:
            return_location = Location.ERROR;
            break;
        }
        break;
      case FRANCISCAN_LEV3_KILLEDHECK:
        switch(completion_code) {
          case 0:
            return_location = Location.AREA_FERNWOOD;
            break;
          case 1: // down hill boss
            return_location = Location.AREA_FERNWOOD;
            break;
          case 2: // starvaggi car
            return_location = Location.AREA_FERNWOOD;
            break;
          default:
            return_location = Location.ERROR;
            break;
        }
        break;
      case FRANCISCAN_LEV3_AROUNDCODA:
        switch(completion_code) {
          case 0:
            return_location = Location.AREA_FERNWOOD;
            break;
          case 1: // down hill boss
            return_location = Location.AREA_FERNWOOD;
            break;
          default:
            return_location = Location.ERROR;
            break;
        }
        break;
      case FRANCISCAN_LEV2_AHIMDOOR:
      case FRANCISCAN_LEV2_CHAPELDOOR:
      case FRANCISCAN_LEV2_BROTHERSDOOR:
      case FRANCISCAN_LEV2_CUSTODIALDOOR:
        switch(completion_code) {
          case 0:
            return_location = Location.AREA_FERNWOOD;
            break;
          default:
            return_location = Location.ERROR;
            break;
        }
        break;
      default:
        return_location = Location.ERROR;
        break;
    }
    return return_location;
  }

  public boolean isCampaignStart() {
    return Location.isCampaignStart(this);
  }
  public static boolean isCampaignStart(Location a) {
    switch(a) {
      case FRANCISCAN_FRANCIS:
        return true;
      default:
        return false;
    }
  }

  public Location getCampaignStart() {
    return Location.getCampaignStart(this);
  }
  public static Location getCampaignStart(Location a) {
    switch(a) {
      case FRANCISCAN_FRANCIS:
      case FRANCISCAN_LEV2_FRONTDOOR:
      case FRANCISCAN_LEV2_AHIMDOOR:
      case FRANCISCAN_LEV2_CHAPELDOOR:
      case FRANCISCAN_LEV2_BROTHERSDOOR:
      case FRANCISCAN_LEV2_CUSTODIALDOOR:
      case FRANCISCAN_LEV3_KILLEDHECK:
      case FRANCISCAN_LEV3_AROUNDCODA:
        return Location.FRANCISCAN_FRANCIS;
      default:
        return Location.ERROR;
    }
  }

  public boolean isArea() {
    return Location.isArea(this);
  }
  public static boolean isArea(Location a) {
    switch(a) {
      case AREA_FERNWOOD:
        return true;
      default:
        return false;
    }
  }

  public Location areaLocation() {
    return Location.areaLocation(this);
  }
  public static Location areaLocation(Location a) {
    switch(a) {
      case FRANCISCAN_FRANCIS:
      case FRANCISCAN_LEV2_FRONTDOOR:
      case FRANCISCAN_LEV2_AHIMDOOR:
      case FRANCISCAN_LEV2_CHAPELDOOR:
      case FRANCISCAN_LEV2_BROTHERSDOOR:
      case FRANCISCAN_LEV2_CUSTODIALDOOR:
      case FRANCISCAN_LEV3_KILLEDHECK:
      case FRANCISCAN_LEV3_AROUNDCODA:
        return Location.AREA_FERNWOOD;
      default:
        return Location.ERROR;
    }
  }

  public ArrayList<Location> locationsFromArea() {
    return Location.locationsFromArea(this);
  }
  public static ArrayList<Location> locationsFromArea(Location a) {
    ArrayList<Location> locations = new ArrayList<Location>();
    switch(a) {
      case AREA_FERNWOOD:
        locations.add(Location.FRANCISCAN_FRANCIS);
        break;
      default:
        break;
    }
    return locations;
  }
}
class MainMenuInterface extends InterfaceLNZ {

  abstract class MainMenuGrowButton extends RippleRectangleButton {
    protected float xf_grow;
    protected float ratio; // ratio when shrunk (can have it be > 1 to make it shrink when hovered)
    protected float grow_speed = 0.7f; // pixels / ms
    protected PImage icon;
    protected boolean collapsing = false;

    MainMenuGrowButton(float xi, float yi, float xf, float yf, float ratio) {
      super(xi, yi, xf * ratio, yf);
      this.xf_grow = xf;
      this.ratio = ratio;
      this.maxRippleDistance = xf - xi;
      this.icon = this.getIcon();
      this.text_size = 24;
      this.noStroke();
      this.setColors(color(170), color(1, 0), color(150, 90, 90, 150), color(240, 180, 180), color(255));
      this.refreshColor();
    }

     public abstract PImage getIcon();

    @Override public 
    void update(int millis) {
      int timeElapsed = millis - this.lastUpdateTime;
      float pixelsMoved = timeElapsed * this.grow_speed;
      super.update(millis);
      float pixelsLeft = 0;
      if (this.collapsing) {
        if (this.hovered) {
          pixelsLeft = this.xf_grow - this.xf;
          if (pixelsLeft < pixelsMoved) {
            this.collapsing = false;
            this.refreshColor();
            pixelsMoved = pixelsLeft;
          }
          this.stretchButton(pixelsMoved, RIGHT);
        }
        else {
          pixelsMoved *= -1;
          pixelsLeft = this.xf_grow * this.ratio - this.xf;
          if (pixelsLeft > pixelsMoved) {
            this.collapsing = false;
            this.refreshColor();
            pixelsMoved = pixelsLeft;
          }
          this.stretchButton(pixelsMoved, RIGHT);
        }
      }
      if (!this.hovered && !this.collapsing) {
        imageMode(CENTER);
        image(this.icon, this.xCenter(), this.yCenter(), this.button_width(), this.button_height());
      }
    }

     public void reset() {
      this.stretchButton(this.xf_grow * this.ratio - this.xf, RIGHT);
      this.collapsing = false;
      this.clicked = false;
      this.hovered = false;
      this.show_message = false;
      this.refreshColor();
    }

    @Override public 
    int fillColor() {
      if (this.collapsing) {
        if (this.clicked) {
          return this.color_click;
        }
        else {
          return this.color_hover;
        }
      }
      return super.fillColor();
    }

     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn4");
      this.collapsing = true;
      super.hover();
      this.show_message = true;
    }

     public void dehover() {
      this.collapsing = true;
      super.dehover();
      this.show_message = false;
      this.clicked = false;
      this.color_text = color(255);
    }

     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick6");
      super.click();
      this.color_text = color(0);
    }

     public void release() {
      super.release();
      this.color_text = color(255);
      this.reset();
    }
  }


  class MainMenuGrowButton1 extends MainMenuGrowButton {
    MainMenuGrowButton1() {
      super(0, height - 60, 200, height, 0.3f);
      this.message = "Exit";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/power.png");
    }

    @Override public 
    void release() {
      if (this.hovered) {
        global.exitDelay();
      }
      super.release();
    }
  }

  class MainMenuGrowButton2 extends MainMenuGrowButton {
    MainMenuGrowButton2() {
      super(0, height - 160, 200, height - 100, 0.3f);
      this.message = "Options";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/gear.png");
    }

    @Override public 
    void release() {
      if (this.hovered) {
        MainMenuInterface.this.form = new OptionsForm();
      }
      super.release();
    }
  }

  class MainMenuGrowButton3 extends MainMenuGrowButton {
    MainMenuGrowButton3() {
      super(0, height - 260, 200, height - 200, 0.3f);
      this.message = "Achievements";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/achievements.png");
    }

    @Override public 
    void release() {
      if (this.hovered) {
        MainMenuInterface.this.form = new AchievementsForm();
      }
      super.release();
    }
  }

  class MainMenuGrowButton4 extends MainMenuGrowButton {
    MainMenuGrowButton4() {
      super(0, height - 360, 200, height - 300, 0.3f);
      this.message = "Map Editor";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/map.png");
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
    }

    @Override public 
    void release() {
      if (this.hovered) {
        global.state = ProgramState.ENTERING_MAPEDITOR;
      }
      super.release();
    }
  }

  class MainMenuGrowButton5 extends MainMenuGrowButton {
    MainMenuGrowButton5() {
      super(0, height - 460, 200, height - 400, 0.3f);
      this.message = "Tutorial";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/tutorial.png");
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
    }

    @Override public 
    void release() {
      if (this.hovered) {
        global.state = ProgramState.ENTERING_TUTORIAL;
      }
      super.release();
    }
  }

  class MainMenuGrowButton6 extends MainMenuGrowButton {
    MainMenuGrowButton6() {
      super(0, height - 560, 200, height - 500, 0.3f);
      this.message = "Minigames";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/minigame.png");
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
    }

    @Override public 
    void release() {
      if (this.hovered) {
        global.state = ProgramState.ENTERING_MINIGAMES;
      }
      super.release();
    }
  }


  class BannerButton extends ImageButton {
    BannerButton() {
      super(global.images.getImage("banner_default.png"), 0, 0, 0, 0);
      float banner_width = min(Constants.banner_maxWidthRatio * width, Constants.banner_maxHeightRatio * height * this.img.width / this.img.height);
      float banner_height = min(Constants.banner_maxHeightRatio * height, banner_width * this.img.height / this.img.width);
      banner_width = banner_height * this.img.width / this.img.height;
      float xi = 0.5f * (width - banner_width);
      float yi = -10;
      float xf = 0.5f * (width + banner_width) - 10;
      float yf = banner_height;
      this.setLocation(xi, yi, xf, yf);
    }

    @Override public 
    void drawButton() {
      imageMode(CORNERS);
      image(this.img, this.xi, this.yi, this.xf, this.yf);
    }

     public void hover() {
      this.setImg(global.images.getImage("banner_hovered.png"));
    }

     public void dehover() {
      this.setImg(global.images.getImage("banner_default.png"));
    }

     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick1");
      this.setImg(global.images.getImage("banner_clicked.png"));
    }

     public void release() {
      if (this.hovered) {
        this.setImg(global.images.getImage("banner_default.png"));
        MainMenuInterface.this.form = new CreditsForm();
        this.hovered = false;
        this.clicked = false;
      }
    }
  }


  class PlayButton extends LeagueButton {
    PlayButton() {
      super(0.5f * width, height - 10, 300 * Constants.playButton_scaleFactor,
        400 * Constants.playButton_scaleFactor, 0.2f * PI, 40 * Constants.playButton_scaleFactor,
        12 * Constants.playButton_scaleFactor);
      this.setColors(color(170), color(120, 200, 120), color(150, 250, 150), color(30, 120, 30), color(50, 10, 50));
      this.message = "Play Game";
      this.show_message = true;
      this.text_size = 22 * Constants.playButton_scaleFactor;
    }
     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn2");
    }
     public void dehover() {}
     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick2");
      this.color_text = color(255, 190, 255);
    }
     public void release() {
      this.color_text = color(50, 10, 50);
      if (this.hovered) {
        if (global.profile.upgraded(PlayerTreeCode.CAN_PLAY)) {
          global.state = ProgramState.ENTERING_PLAYING;
        }
        else if (global.profile.achievementUnlocked(AchievementCode.COMPLETED_TUTORIAL)) {
          MainMenuInterface.this.form = new UnlockPlayForm();
        }
        else {
          MainMenuInterface.this.form = new CompleteTutorialForm();
        }
      }
    }
  }


  class ProfileButton extends RippleCircleButton {
    protected float grow_speed = 0.9f; // pixels / ms
    protected PImage icon = global.images.getImage("units/ben.png");
    protected boolean collapsing = false;

    ProfileButton() {
      super(width - Constants.profileButton_offset, height - Constants.profileButton_offset, 2 * Constants.profileButton_offset);
      this.message = "Profile";
      this.maxRippleDistance = (xf - xi) * Constants.profileButton_growfactor;
      this.text_size = 32;
      this.noStroke();
      this.setColors(color(170), color(1, 0), color(1, 0), color(60, 60, 20, 200), color(255));
      this.refreshColor();
    }

    @Override public 
    void update(int millis) {
      int timeElapsed = millis - this.lastUpdateTime;
      float pixelsMoved = timeElapsed * this.grow_speed;
      super.update(millis);
      float pixelsLeft = 0;
      if (this.collapsing) {
        if (this.hovered) {
          pixelsLeft = 4 * Constants.profileButton_offset * Constants.profileButton_growfactor - (this.xf - this.xi);
          if (pixelsLeft < pixelsMoved) {
            this.collapsing = false;
            this.refreshColor();
            pixelsMoved = pixelsLeft;
          }
          this.stretchButton(pixelsMoved, LEFT);
          this.stretchButton(pixelsMoved, UP);
        }
        else {
          pixelsMoved *= -1;
          pixelsLeft = 4 * Constants.profileButton_offset - (this.xf - this.xi);
          if (pixelsLeft > pixelsMoved) {
            this.collapsing = false;
            this.refreshColor();
            pixelsMoved = pixelsLeft;
          }
          this.stretchButton(pixelsMoved, LEFT);
          this.stretchButton(pixelsMoved, UP);
        }
      }
      imageMode(CENTER);
      image(this.icon, this.xCenter(), this.yCenter() - 0.2f * (this.yf - this.yi),
        0.4f * this.button_width(), 0.4f * this.button_height());
    }

    @Override public 
    void writeText() {
      if (this.show_message) {
        fill(this.color_text);
        textAlign(CENTER, TOP);
        textSize(this.text_size);
        if (this.adjust_for_text_descent) {
          text(this.message, this.xCenter(), this.yCenter() - textDescent());
        }
        else {
          text(this.message, this.xCenter(), this.yCenter());
        }
      }
    }

     public void reset() {
      this.icon = global.images.getImage("units/ben.png");
      this.color_text = color(255);
      this.stretchButton(4 * Constants.profileButton_offset - (this.xf - this.xi), LEFT);
      this.stretchButton(4 * Constants.profileButton_offset - (this.yf - this.yi), UP);
      this.collapsing = false;
      this.clicked = false;
      this.hovered = false;
      this.show_message = false;
      this.refreshColor();
    }

    @Override public 
    int fillColor() {
      if (this.collapsing) {
        if (this.clicked) {
          return this.color_click;
        }
        else {
          return this.color_hover;
        }
      }
      return super.fillColor();
    }

     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn3");
      this.icon = global.images.getImage("units/ben_whiteborder.png");
      this.collapsing = true;
      super.hover();
      this.show_message = true;
    }

     public void dehover() {
      this.icon = global.images.getImage("units/ben.png");
      this.color_text = color(255);
      this.collapsing = true;
      super.dehover();
      this.show_message = false;
      this.clicked = false;
    }

     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick5");
      this.icon = global.images.getImage("units/ben_blueborder.png");
      this.color_text = color(0, 0, 255);
      super.click();
    }

     public void release() {
      this.icon = global.images.getImage("units/ben.png");
      this.color_text = color(255);
      super.release();
      if (this.hovered) {
        MainMenuInterface.this.viewProfile();
      }
      this.reset();
    }
  }


  class ProfileForm extends FormLNZ {
    ProfileForm() {
      super(0.5f * (width - Constants.profileForm_width), 0.5f * (height - Constants.profileForm_height),
        0.5f * (width + Constants.profileForm_width), 0.5f * (height + Constants.profileForm_height));
      this.setTitleText(global.profile.display_name);
      this.setTitleSize(18);
      this.setFieldCushion(0);
      this.color_background = color(180, 180, 250);
      this.color_header = color(90, 90, 200);

      SubmitFormField logout = new SubmitFormField("Logout");
      logout.button.setColors(color(180), color(190, 190, 240),
        color(140, 140, 190), color(90, 90, 140), color(0));

      this.addField(new SpacerFormField(20));
      this.addField(logout);
    }

     public void submit() {
      global.profile.save();
      global.profile = null;
      MainMenuInterface.this.loadExistingProfile();
    }
  }


  class CreditsForm extends FormLNZ {
    CreditsForm() {
      super(0.5f * (width - Constants.creditsForm_width), 0.5f * (height - Constants.creditsForm_height),
        0.5f * (width + Constants.creditsForm_width), 0.5f * (height + Constants.creditsForm_height));
      this.setTitleText("Credits");
      this.setTitleSize(18);
      this.color_background = color(250, 180, 250);
      this.color_header = color(170, 30, 170);

      SubmitFormField submit = new SubmitFormField("  Ok  ");
      submit.button.setColors(color(220), color(240, 190, 240),
        color(190, 140, 190), color(140, 90, 140), color(0));
      this.addField(new SpacerFormField(0));
      this.addField(new TextBoxFormField(Constants.credits, 200));
      this.addField(submit);
    }
     public void submit() {
      this.canceled = true;
    }
  }


  class LoadProfileForm extends FormLNZ {
    private ArrayList<Path> profiles;

    LoadProfileForm() {
      super(0.5f * (width - Constants.newProfileForm_width), 0.5f * (height - Constants.newProfileForm_height),
        0.5f * (width + Constants.newProfileForm_width), 0.5f * (height + Constants.newProfileForm_height));
      this.setTitleText("Load Profile");
      this.setTitleSize(18);
      this.setFieldCushion(0);
      this.color_background = color(250, 180, 180);
      this.color_header = color(180, 50, 50);

      RadiosFormField radios = new RadiosFormField("Choose a profile:");
      this.profiles = listFolders("data/profiles");
      if (this.profiles.size() == 0) {
        MainMenuInterface.this.createNewProfile();
        return;
      }
      for (Path p : this.profiles) {
        radios.addRadio(p.getFileName().toString() + "  ");
      }
      MessageFormField error = new MessageFormField("");
      error.text_color = color(150, 20, 20);
      error.setTextSize(18);
      CheckboxFormField checkbox = new CheckboxFormField("Save as default profile  ");
      checkbox.setTextSize(16);
      checkbox.checkbox.checked = true;
      SubmitFormField submit = new SubmitFormField("Play Profile");
      submit.button.setColors(color(180), color(240, 190, 190),
        color(190, 140, 140), color(140, 90, 90), color(0));
      ButtonFormField newProfileButton = new ButtonFormField("Create New Profile");
      newProfileButton.button.setColors(color(180), color(240, 190, 190),
        color(190, 140, 140), color(140, 90, 90), color(0));

      this.addField(new SpacerFormField(20));
      this.addField(radios);
      this.addField(error);
      this.addField(new SpacerFormField(20));
      this.addField(checkbox);
      this.addField(new SpacerFormField(8));
      this.addField(submit);
      this.addField(new SpacerFormField(20));
      this.addField(newProfileButton);
    }

     public void submit() {
      String profileIndex = this.fields.get(1).getValue();
      if (!isInt(profileIndex)) {
        this.fields.get(2).setValue("Select a profile to play");
        return;
      }
      int index = toInt(profileIndex);
      if (index < 0 || index >= this.profiles.size()) {
        this.fields.get(2).setValue("Select a profile to play");
        return;
      }
      String profileName = this.profiles.get(index).getFileName().toString();
      if (MainMenuInterface.this.loadProfile(profileName)) {
        this.canceled = true;
        if (this.fields.get(4).getValue().equals("true")) {
          global.configuration.default_profile_name = profileName;
          global.configuration.save();
        }
        global.log("Opened profile: " + profileName);
      }
      else {
        this.fields.get(2).setValue("There was an error opening the profile");
      }
    }

    @Override public 
    void cancel() {
      this.fields.get(2).setValue("You must select a profile");
    }

    @Override public 
    void buttonPress(int i) {
      MainMenuInterface.this.createNewProfile();
    }
  }


  class NewProfileForm extends FormLNZ {
    NewProfileForm() {
      super(0.5f * (width - Constants.newProfileForm_width), 0.5f * (height - Constants.newProfileForm_height),
        0.5f * (width + Constants.newProfileForm_width), 0.5f * (height + Constants.newProfileForm_height));
      this.setTitleText("New Profile");
      this.setTitleSize(18);
      this.setFieldCushion(0);
      this.color_background = color(250, 180, 180);
      this.color_header = color(180, 50, 50);

      StringFormField input = new StringFormField("  ", "Enter profile name");
      input.input.typing = true;
      MessageFormField error = new MessageFormField(" ");
      error.text_color = color(150, 20, 20);
      error.setTextSize(18);
      CheckboxFormField checkbox = new CheckboxFormField(" Save as default profile  ");
      checkbox.setTextSize(16);
      checkbox.checkbox.checked = true;
      SubmitFormField submit = new SubmitFormField("Create New Profile");
      submit.button.setColors(color(180), color(240, 190, 190),
        color(190, 140, 140), color(140, 90, 90), color(0));
      ButtonFormField loadProfileButton = new ButtonFormField("Load Existing Profile");
      loadProfileButton.button.setColors(color(180), color(240, 190, 190),
        color(190, 140, 140), color(140, 90, 90), color(0));
      ArrayList<Path> profiles = listFolders("data/profiles");
      if (profiles.size() == 0) {
        loadProfileButton.button.disabled = true;
      }

      this.addField(new SpacerFormField(20));
      this.addField(input);
      this.addField(error);
      this.addField(new SpacerFormField(20));
      this.addField(checkbox);
      this.addField(new SpacerFormField(8));
      this.addField(submit);
      this.addField(new SpacerFormField(20));
      this.addField(loadProfileButton);
    }

     public void submit() {
      String possibleProfileName = this.fields.get(1).getValue();
      int errorcode = isValidProfileName(possibleProfileName);
      switch(errorcode) {
        case 0:
          Profile p = new Profile(possibleProfileName);
          p.save();
          global.profile = p;
          this.canceled = true;
          if (this.fields.get(4).getValue().equals("true")) {
            global.configuration.default_profile_name = possibleProfileName;
            global.configuration.save();
          }
          global.log("Creating new profile: " + possibleProfileName);
          break;
        case 1:
          this.fields.get(2).setValue("Enter a profile name.");
          break;
        case 2:
          this.fields.get(2).setValue("Profile name must start with a letter.");
          break;
        case 3:
          this.fields.get(2).setValue("Profile name must be alphanumeric.");
          break;
        case 4:
          this.fields.get(2).setValue("That profile already exists.");
          break;
        default:
          this.fields.get(2).setValue("An unknown error occured.");
          break;
      }
    }

    @Override public 
    void cancel() {
      this.fields.get(2).setValue("You must create a profile");
    }

    @Override public 
    void buttonPress(int i) {
      MainMenuInterface.this.loadExistingProfile();
    }
  }


  class CompleteTutorialForm extends FormLNZ {
    protected float arrow_x = 0;
    protected float arrow_y = 0;
    CompleteTutorialForm() {
      super(0.5f * width - 120, 0.5f * height - 120, 0.5f * width + 120, 0.5f * height + 120);
      this.setTitleText("Play Game");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));

      SubmitFormField submit = new SubmitFormField("  Ok  ");
      submit.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      TextBoxFormField textbox = new TextBoxFormField("Please complete the tutorial " +
        "before launching the game.\nThe tutorial can be found here and normally takes " +
        "about 15 minutes to complete.", 120);
      textbox.textbox.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));
      this.addField(textbox);
      this.addField(submit);

      MainMenuGrowButton button = null;
      try {
        button = MainMenuInterface.this.growButtons[4];
        this.arrow_x = button.xf + 70;
        this.arrow_y = button.yCenter();
      } catch(ArrayIndexOutOfBoundsException e) {}
    }

     public void update(int millis) {
      super.update(millis);
      int frame = PApplet.parseInt(floor(Constants.gif_arrow_frames * (millis %
        Constants.gif_arrow_time) / (1 + Constants.gif_arrow_time)));
      translate(this.arrow_x, this.arrow_y);
      rotate(PI);
      imageMode(CENTER);
      image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
      rotate(-PI);
      translate(-this.arrow_x, -this.arrow_y);
    }
     public void submit() {
      this.canceled = true;
    }
  }


  class UnlockPlayForm extends FormLNZ {
    protected float arrow_x = 0;
    protected float arrow_y = 0;
    UnlockPlayForm() {
      super(0.5f * width - 120, 0.5f * height - 120, 0.5f * width + 120, 0.5f * height + 120);
      this.setTitleText("Play Game");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));

      SubmitFormField submit = new SubmitFormField("  Ok  ");
      submit.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      TextBoxFormField textbox = new TextBoxFormField("You must unlock the " +
        "ability to play the game in your perk tree. You can open your perk " +
        "tree with 'ctrl-p' or from the Achievements view.", 120);
      textbox.textbox.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));
      this.addField(textbox);
      this.addField(submit);

      MainMenuGrowButton button = null;
      try {
        button = MainMenuInterface.this.growButtons[2];
        this.arrow_x = button.xf + 70;
        this.arrow_y = button.yCenter();
      } catch(ArrayIndexOutOfBoundsException e) {}
    }

     public void update(int millis) {
      super.update(millis);
      int frame = PApplet.parseInt(floor(Constants.gif_arrow_frames * (millis %
        Constants.gif_arrow_time) / (1 + Constants.gif_arrow_time)));
      translate(this.arrow_x, this.arrow_y);
      rotate(PI);
      imageMode(CENTER);
      image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
      rotate(-PI);
      translate(-this.arrow_x, -this.arrow_y);
    }
     public void submit() {
      this.canceled = true;
    }
  }


  class BackgroundImageThread extends Thread {
    private PImage img = createImage(width, height, ARGB);
    private float distance_threshhold = 150;
    private float mX = mouseX;
    private float mY = mouseY;

    BackgroundImageThread() {
      super("BackgroundImageThread");
      this.setDaemon(true);
    }

    @Override public 
    void run() {
      DImg dimg = new DImg(this.img);
      dimg.transparencyGradientFromPoint(this.mX, this.mY, this.distance_threshhold);
      this.img = dimg.img;
    }
  }


  private MainMenuGrowButton[] growButtons = new MainMenuGrowButton[6];
  private BannerButton banner = new BannerButton();
  private PlayButton play = new PlayButton();
  private ProfileButton profile = new ProfileButton();
  private PImage backgroundImagePicture;
  private PImage backgroundImage;
  private BackgroundImageThread thread = new BackgroundImageThread();

  MainMenuInterface() {
    super();
    this.backgroundImagePicture = resizeImage(global.images.getImage("hillary.png"), width, height);
    this.backgroundImage = createPImage(color(0), width, height);
    this.growButtons[0] = new MainMenuGrowButton1();
    this.growButtons[1] = new MainMenuGrowButton2();
    this.growButtons[2] = new MainMenuGrowButton3();
    this.growButtons[3] = new MainMenuGrowButton4();
    this.growButtons[4] = new MainMenuGrowButton5();
    this.growButtons[5] = new MainMenuGrowButton6();
    if (global.profile == null) {
      this.loadProfile();
    }
    this.thread.start();
  }

   public void loadProfile() {
    ArrayList<Path> profiles = listFolders("data/profiles");
    for (Path p : profiles) {
      if (global.configuration.default_profile_name.toLowerCase().equals(p.getFileName().toString().toLowerCase())) {
        if (!loadProfile(global.configuration.default_profile_name)) {
          global.log("Failed to load default profile: " + global.configuration.default_profile_name);
          break;
        }
        global.log("Loading default profile: " + global.configuration.default_profile_name);
        return;
      }
    }
    if (profiles.size() > 0) {
      this.form = new LoadProfileForm();
    }
    else {
      this.createNewProfile();
    }
  }
  // returns true if profile loaded
   public boolean loadProfile(String profile_name) {
    mkdir("data/profiles", false, true);
    if (!folderExists("data/profiles/" + profile_name.toLowerCase())) {
      global.log("Profile: No profile folder exists with name " + profile_name + ".");
      return false;
    }
    if (!fileExists("data/profiles/" + profile_name.toLowerCase() + "/profile.lnz")) {
      global.errorMessage("ERROR: Profile file missing for " + profile_name + ".");
      return false;
    }
    if (!fileExists("data/profiles/" + profile_name.toLowerCase() + "/heroes.lnz")) {
      global.errorMessage("ERROR: Heroes file missing for " + profile_name + ".");
      return false;
    }
    if (!fileExists("data/profiles/" + profile_name.toLowerCase() + "/options.lnz")) {
      global.errorMessage("ERROR: Options file missing for " + profile_name + ".");
      return false;
    }
    global.profile = readProfile(sketchPath("data/profiles/" + profile_name.toLowerCase()));
    return true;
  }
  // create new profile
   public void createNewProfile() {
    this.form = new NewProfileForm();
  }
  // load profile
   public void loadExistingProfile() {
    this.form = new LoadProfileForm();
  }
  // Open profile
   public void viewProfile() {
    this.form = new ProfileForm();
  }

   public Hero getCurrentHeroIfExists() {
    return null;
  }

   public void update(int millis) {
    // draw background
    imageMode(CORNER);
    image(this.backgroundImagePicture, 0, 0);
    image(this.backgroundImage, 0, 0);
    // update elements
    for (MainMenuGrowButton button : this.growButtons) {
      button.update(millis);
    }
    this.banner.update(millis);
    this.play.update(millis);
    this.profile.update(millis);
    // restart thread
    if (!this.thread.isAlive()) {
      this.backgroundImage = this.thread.img;
      this.thread = new BackgroundImageThread();
      this.thread.start();
    }
  }

   public void showNerdStats() {
    showDefaultNerdStats(color(255));
  }

   public void mouseMove(float mX, float mY) {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mouseMove(mX, mY);
    }
    this.banner.mouseMove(mX, mY);
    this.play.mouseMove(mX, mY);
    this.profile.mouseMove(mX, mY);
  }

   public void mousePress() {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mousePress();
    }
    this.banner.mousePress();
    this.play.mousePress();
    this.profile.mousePress();
  }

   public void mouseRelease(float mX, float mY) {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mouseRelease(mX, mY);
    }
    this.banner.mouseRelease(mX, mY);
    this.play.mouseRelease(mX, mY);
    this.profile.mouseRelease(mX, mY);
  }

   public void scroll(int amount) {}
   public void keyPress() {}
   public void openEscForm() {}
   public void keyRelease() {}


   public void loseFocus() {}
   public void gainFocus() {}
   public void restartTimers() {}
   public void saveAndExitToMainMenu() {}
}
enum MapEditorPage {
  MAPS, AREAS, LEVELS, TERRAIN, FEATURES, UNITS, ITEMS, TESTMAP, OPENING_MAPEDITOR,
  CREATING_MAP, OPENING_TESTMAP, OPENING_TESTLEVEL, LEVEL_INFO, LEVEL_MAPS,
  LINKERS, TRIGGERS, TRIGGER_EDITOR, CONDITION_EDITOR, EFFECT_EDITOR, TESTLEVEL,
  EDITING_AREA, TESTING_AREA;
}


enum RightPanelElementLocation {
  BOTTOM, TOP, WHOLE;
}


class MapEditorInterface extends InterfaceLNZ {

  abstract class MapEditorButton extends RectangleButton {
    MapEditorButton() {
      super(0, 0.94f * height, 0, height - Constants.mapEditor_buttonGapSize);
      this.raised_border = true;
      this.roundness = 0;
      this.setColors(color(170), color(222, 184, 135), color(244, 164, 96), color(205, 133, 63), color(0));
      this.show_message = true;
    }
     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn2");
    }
     public void dehover() {
      this.clicked = false;
    }
     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick1");
    }
  }

  class MapEditorButton1 extends MapEditorButton {
    MapEditorButton1() {
      super();
      this.message = "Toggle\nDisplay";
    }
     public void release() {
      MapEditorInterface.this.buttonClick1();
    }
  }

  class MapEditorButton2 extends MapEditorButton {
    MapEditorButton2() {
      super();
      this.message = "";
    }
     public void release() {
      this.stayDehovered();
      MapEditorInterface.this.buttonClick2();
    }
  }

  class MapEditorButton3 extends MapEditorButton {
    MapEditorButton3() {
      super();
      this.message = "";
    }
     public void release() {
      this.stayDehovered();
      MapEditorInterface.this.buttonClick3();
    }
  }

  class MapEditorButton4 extends MapEditorButton {
    MapEditorButton4() {
      super();
      this.message = "Main\nMenu";
    }
     public void release() {
      this.stayDehovered();
      MapEditorInterface.this.buttonClick4();
    }
  }

  class MapEditorButton5 extends MapEditorButton {
    MapEditorButton5() {
      super();
      this.setLocation(0, 0.9f * height + Constants.mapEditor_buttonGapSize,
        0, 0.94f * height - Constants.mapEditor_buttonGapSize);
      this.message = "Help";
    }
     public void release() {
      this.stayDehovered();
      MapEditorInterface.this.buttonClick5();
    }
  }


  class MapEditorListTextBox extends ListTextBox {
    class RightClickListTextBox extends MaxListTextBox {
      RightClickListTextBox(float mX, float mY, MapEditorPage page) {
        super(mX - Constants.mapEditor_rightClickBoxWidth, mY, mX, mY + Constants.mapEditor_rightClickBoxMaxHeight);
        switch(page) {
          case MAPS:
            this.setText("Open Map");
            this.addLine("Rename Map");
            this.addLine("Test Map");
            this.addLine("Delete Map");
            break;
          case AREAS:
            this.setText("Open Area");
            this.addLine("Rename Area");
            this.addLine("Test Area");
            this.addLine("Delete Area");
            break;
          case LEVELS:
            this.setText("Open Level");
            this.addLine("Rename Level");
            this.addLine("Test Level");
            this.addLine("Delete Level");
            break;
        }
        this.highlight_color = color(1, 0);
        this.hover_color = color(200, 150, 140, 100);
      }

       public void click() {
        MapEditorListTextBox.this.clickOption(this.line_clicked);
      }

       public void doubleclick() {}
    }

    class RenameInputBox extends InputBox {
      RenameInputBox(int line_index) {
        super(MapEditorListTextBox.this.xi + 1, 0, MapEditorListTextBox.this.xf - 1, 0);
        this.setText(MapEditorListTextBox.this.text_lines_ref.get(line_index));
        this.hint_text = "Enter a filename";
        float currY = MapEditorListTextBox.this.yi + 1;
        if (MapEditorListTextBox.this.text_title_ref != null) {
          textSize(MapEditorListTextBox.this.title_size);
          currY += textAscent() + textDescent() + 2;
        }
        textSize(MapEditorListTextBox.this.text_size);
        float text_height = textAscent() + textDescent();
        float input_yi = currY + (line_index - floor(MapEditorListTextBox.this.
          scrollbar.value)) * (text_height + MapEditorListTextBox.this.text_leading);
        this.setYLocation(input_yi, input_yi + text_height);
        this.typing = true;
        this.location_cursor = this.text.length();
        this.location_display = this.text.length();
        this.updateDisplayText();
      }
    }

    protected boolean active = false;
    protected RightClickListTextBox rightClickMenu;
    protected RenameInputBox renameInputBox;
    protected MapEditorPage previous_page = MapEditorPage.LEVEL_INFO;
    protected float scroll_maps = 0;
    protected float scroll_areas = 0;
    protected float scroll_levels = 0;
    protected float scroll_terrain = 0;
    protected float scroll_features = 0;
    protected float scroll_units = 0;
    protected float scroll_items = 0;
    protected String text_ref_maps = null;
    protected String text_ref_areas = null;
    protected String text_ref_levels = null;
    protected String text_ref_terrain = null;
    protected String text_ref_features = null;
    protected String text_ref_units = null;
    protected String text_ref_items = null;
    protected String text_ref_levelMaps = null;

    MapEditorListTextBox() {
      super(width, Constants.mapEditor_listBoxGap, width, 0.9f * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      if (this.rightClickMenu != null) {
        this.rightClickMenu.update(millis);
      }
      else if (this.renameInputBox != null) {
        this.renameInputBox.update(millis);
      }
    }

    @Override public 
    void mouseMove(float mX, float mY) {
      if (this.rightClickMenu != null) {
        this.rightClickMenu.mouseMove(mX, mY);
      }
      else if (this.renameInputBox != null) {
        this.renameInputBox.mouseMove(mX, mY);
      }
      else {
        super.mouseMove(mX, mY);
      }
    }

    @Override public 
    void mousePress() {
      if (this.rightClickMenu != null) {
        if (this.rightClickMenu.hovered) {
          this.rightClickMenu.mousePress();
        }
        else {
          this.rightClickMenu = null;
        }
      }
      else if (this.renameInputBox != null) {
        if (this.renameInputBox.hovered) {
          this.renameInputBox.mousePress();
        }
        else {
          this.removeRenameInputBox();
        }
      }
      else {
        super.mousePress();
        if (("").equals(this.highlightedLine())) {
          this.line_clicked = -1;
        }
      }
    }

    @Override public 
    void mouseRelease(float mX, float mY) {
      if (this.rightClickMenu != null) {
        this.rightClickMenu.mouseRelease(mX, mY);
      }
      else if (this.renameInputBox != null) {
        this.renameInputBox.mouseRelease(mX, mY);
      }
      else {
        super.mouseRelease(mX, mY);
      }
    }

    @Override public 
    void scroll(int amount) {
      if (this.rightClickMenu != null) {
        this.rightClickMenu.scroll(amount);
      }
      else {
        super.scroll(amount);
      }
    }

     public void keyPress() {
      if (this.renameInputBox != null) {
        this.renameInputBox.keyPress();
        if (key != CODED && (key == ENTER || key == RETURN)) {
          this.removeRenameInputBox();
        }
      }
    }

     public void keyRelease() {
      if (this.renameInputBox != null) {
        this.renameInputBox.keyRelease();
      }
    }

     public void removeRenameInputBox() {
      if (this.renameInputBox == null) {
        return;
      }
      if (this.line_clicked < 0 || this.line_clicked >= this.text_lines_ref.size()) {
        return;
      }
      String targetName = this.renameInputBox.text;
      if (targetName != null && !targetName.equals("")) {
        switch(MapEditorInterface.this.page) {
          case MAPS:
            MapEditorInterface.this.renameMapFile(this.highlightedLine(), this.renameInputBox.text);
            break;
          case AREAS:
            MapEditorInterface.this.renameAreaFile(this.highlightedLine(), this.renameInputBox.text);
            break;
          case LEVELS:
            MapEditorInterface.this.renameLevelFolder(this.highlightedLine(), this.renameInputBox.text);
            break;
          default:
            break;
        }
      }
      this.renameInputBox = null;
      this.refresh();
    }

     public void clickOption(int option) {
      switch(MapEditorInterface.this.page) {
        case MAPS:
          switch(option) {
            case 0:
              MapEditorInterface.this.openMapEditor(this.highlightedLine());
              break;
            case 1:
              if (this.line_clicked < 0 || this.line_clicked >= this.text_lines_ref.size()) {
                break;
              }
              this.renameInputBox = new RenameInputBox(this.line_clicked);
              break;
            case 2:
              MapEditorInterface.this.testMap();
              break;
            case 3:
              MapEditorInterface.this.deleteMap();
              break;
            default:
              global.errorMessage("ERROR: Option index " + option + " not recognized.");
              break;
          }
          break;
        case AREAS:
          switch(option) {
            case 0:
              MapEditorInterface.this.openAreaEditor(this.highlightedLine());
              break;
            case 1:
              if (this.line_clicked < 0 || this.line_clicked >= this.text_lines_ref.size()) {
                break;
              }
              this.renameInputBox = new RenameInputBox(this.line_clicked);
              break;
            case 2:
              MapEditorInterface.this.testArea(this.highlightedLine());
              break;
            case 3:
              MapEditorInterface.this.deleteArea();
              break;
            default:
              global.errorMessage("ERROR: Option index " + option + " not recognized.");
              break;
          }
          break;
        case LEVELS:
          switch(option) {
            case 0:
              MapEditorInterface.this.openLevelEditor(this.highlightedLine());
              break;
            case 1:
              if (this.line_clicked < 0 || this.line_clicked >= this.text_lines_ref.size()) {
                break;
              }
              this.renameInputBox = new RenameInputBox(this.line_clicked);
              break;
            case 2:
              MapEditorInterface.this.testLevel();
              break;
            case 3:
              MapEditorInterface.this.deleteLevel();
              break;
            default:
              global.errorMessage("ERROR: Option index " + option + " not recognized.");
              break;
          }
          break;
        default:
          break;
      }
      this.rightClickMenu = null;
    }

     public void setPosition(RightPanelElementLocation position) {
      switch(position) {
        case TOP:
          this.setYLocation(Constants.mapEditor_listBoxGap, 0.45f * height - Constants.mapEditor_listBoxGap);
          break;
        case BOTTOM:
          this.setYLocation(0.45f * height + Constants.mapEditor_listBoxGap, 0.9f * height - Constants.mapEditor_listBoxGap);
          break;
        case WHOLE:
          this.setYLocation(Constants.mapEditor_listBoxGap, 0.9f * height - Constants.mapEditor_listBoxGap);
          break;
      }
    }

     public void setList(MapEditorPage page) {
      if (page == null) {
        return;
      }
      switch(this.previous_page) {
        case MAPS:
          this.scroll_maps = this.scrollbar.value;
          break;
        case AREAS:
          this.scroll_areas = this.scrollbar.value;
          break;
        case LEVELS:
          this.scroll_levels = this.scrollbar.value;
          break;
        case TERRAIN:
          this.scroll_terrain = this.scrollbar.value;
          break;
        case FEATURES:
          this.scroll_features = this.scrollbar.value;
          break;
        case UNITS:
          this.scroll_units = this.scrollbar.value;
          break;
        case ITEMS:
          this.scroll_items = this.scrollbar.value;
          break;
        default:
          break;
      }
      this.previous_page = page;
      this.clearText();
      this.line_hovered = -1;
      this.line_clicked = -1;
      this.active = true;
      switch(page) {
        case MAPS:
          this.setTitleText("Maps");
          if (this.text_ref_maps == null) {
            this.setMapsText();
          }
          else {
            this.setText(this.text_ref_maps);
          }
          this.scrollbar.updateValue(this.scroll_maps);
          break;
        case AREAS:
          this.setTitleText("Areas");
          if (this.text_ref_areas == null) {
            this.setAreasText();
          }
          else {
            this.setText(this.text_ref_areas);
          }
          this.scrollbar.updateValue(this.scroll_areas);
          break;
        case LEVELS:
          this.setTitleText("Levels");
          if (this.text_ref_levels == null) {
            this.setLevelsText();
          }
          else {
            this.setText(this.text_ref_levels);
          }
          this.scrollbar.updateValue(this.scroll_levels);
          break;
        case TERRAIN:
          this.setTitleText("Terrain");
          if (this.text_ref_terrain == null) {
            this.setTerrainText();
          }
          else {
            this.setText(this.text_ref_terrain);
          }
          this.scrollbar.updateValue(this.scroll_terrain);
          break;
        case FEATURES:
          this.setTitleText("Features");
          if (this.text_ref_features == null) {
            this.setFeaturesText();
          }
          else {
            this.setText(this.text_ref_features);
          }
          this.scrollbar.updateValue(this.scroll_features);
          break;
        case UNITS:
          this.setTitleText("Units");
          if (this.text_ref_units == null) {
            this.setUnitsText();
          }
          else {
            this.setText(this.text_ref_units);
          }
          this.scrollbar.updateValue(this.scroll_units);
          break;
        case ITEMS:
          this.setTitleText("Items");
          if (this.text_ref_items == null) {
            this.setItemsText();
          }
          else {
            this.setText(this.text_ref_items);
          }
          this.scrollbar.updateValue(this.scroll_items);
          break;
        case LEVEL_MAPS:
          this.setTitleText("Saved Maps");
          if (this.text_ref_levelMaps == null) {
            this.setLevelMapsText();
          }
          else {
            this.setText(this.text_ref_levelMaps);
          }
          break;
        default:
          this.active = false;
          break;
      }
    }

     public void setMapsText() {
      if (folderExists("data/maps")) {
        boolean first = true;
        for (Path p : listFiles("data/maps/")) {
          String filename = p.getFileName().toString();
          if (!filename.endsWith(".map.lnz")) {
            continue;
          }
          String mapName = split(filename, '.')[0];
          if (first) {
            this.setText(mapName);
            first = false;
          }
          else {
            this.addLine(mapName);
          }
        }
      }
      else {
        mkdir("data/maps");
      }
      //this.text_ref_maps = this.text_ref; // need to refresh whenever a map is made/deleted/renamed
    }

     public void setAreasText() {
      if (folderExists("data/areas")) {
        boolean first = true;
        for (Path p : listFiles("data/areas/")) {
          String filename = p.getFileName().toString();
          if (!filename.endsWith(".area.lnz")) {
            continue;
          }
          String mapName = split(filename, '.')[0];
          if (first) {
            this.setText(mapName);
            first = false;
          }
          else {
            this.addLine(mapName);
          }
        }
      }
      else {
        mkdir("data/areas");
      }
      //this.text_ref_areas = this.text_ref;
    }

     public void setLevelsText() {
      if (folderExists("data/levels")) {
        boolean first = true;
        for (Path p : listFolders("data/levels")) {
          String levelName = p.getFileName().toString();
          if (first) {
            this.setText(levelName);
            first = false;
          }
          else {
            this.addLine(levelName);
          }
        }
      }
      else {
        mkdir("data/levels");
      }
      //this.text_ref_levels = this.text_ref;
    }

     public void setTerrainText() {
      boolean first_terrain = true;
      if (fileExists("data/terrains.lnz")) {
        for (String line : loadStrings(sketchPath("data/terrains.lnz"))) {
          if (first_terrain) {
            first_terrain = false;
            this.setText(line);
          }
          else {
            this.addLine(line);
          }
        }
      }
      this.text_ref_terrain = this.text_ref;
    }

     public void setFeaturesText() {
      boolean first_feature = true;
      if (fileExists("data/features.lnz")) {
        for (String line : loadStrings(sketchPath("data/features.lnz"))) {
          if (first_feature) {
            first_feature = false;
            this.setText(line);
          }
          else {
            this.addLine(line);
          }
        }
      }
      this.text_ref_features = this.text_ref;
    }

     public void setUnitsText() {
      boolean first_unit = true;
      if (fileExists("data/units.lnz")) {
        for (String line : loadStrings(sketchPath("data/units.lnz"))) {
          if (first_unit) {
            first_unit = false;
            this.setText(line);
          }
          else {
            this.addLine(line);
          }
        }
      }
      this.text_ref_units = this.text_ref;
    }

     public void setItemsText() {
      boolean first_item = true;
      if (fileExists("data/items.lnz")) {
        for (String line : loadStrings(sketchPath("data/items.lnz"))) {
          if (first_item) {
            first_item = false;
            this.setText(line);
          }
          else {
            this.addLine(line);
          }
        }
      }
      this.text_ref_items = this.text_ref;
    }

     public void setLevelMapsText() {
      if (folderExists("data/maps")) {
        boolean first = true;
        for (Path p : listFiles("data/maps/")) {
          String filename = p.getFileName().toString();
          if (!filename.endsWith(".map.lnz")) {
            continue;
          }
          String mapName = split(filename, '.')[0];
          if (first) {
            this.setText(mapName);
            first = false;
          }
          else {
            this.addLine(mapName);
          }
        }
      }
      else {
        mkdir("data/maps");
      }
      this.text_ref_levelMaps = this.text_ref;
    }

     public void refresh() {
      switch(MapEditorInterface.this.page) {
        case MAPS:
          this.text_ref_maps = null;
          break;
        case AREAS:
          this.text_ref_areas = null;
          break;
        case LEVELS:
          this.text_ref_levels = null;
          break;
        case LEVEL_MAPS:
          this.text_ref_levelMaps = null;
          break;
      }
      this.setList(MapEditorInterface.this.page);
    }

     public void click() {
      switch(MapEditorInterface.this.page) {
        case MAPS:
          if (mouseButton == RIGHT) {
            this.rightClickMenu = new RightClickListTextBox(mouseX, mouseY, MapEditorInterface.this.page);
          }
          break;
        case AREAS:
          if (mouseButton == RIGHT) {
            this.rightClickMenu = new RightClickListTextBox(mouseX, mouseY, MapEditorInterface.this.page);
          }
          break;
        case LEVELS:
          if (mouseButton == RIGHT) {
            this.rightClickMenu = new RightClickListTextBox(mouseX, mouseY, MapEditorInterface.this.page);
          }
          break;
        case TERRAIN:
          break;
        case FEATURES:
          break;
        case UNITS:
          break;
        case ITEMS:
          break;
        case LEVEL_MAPS:
          break;
        default:
          global.errorMessage("ERROR: MapEditorPage " + page + " not found.");
          break;
      }
    }

     public void doubleclick() {
      switch(MapEditorInterface.this.page) {
        case MAPS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.openMapEditor(this.highlightedLine());
          }
          break;
        case AREAS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.openAreaEditor(this.highlightedLine());
          }
          break;
        case LEVELS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.openLevelEditor(this.highlightedLine());
          }
          break;
        case TERRAIN:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.dropTerrain(this.highlightedLine());
          }
          break;
        case FEATURES:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.dropFeature(this.highlightedLine());
          }
          break;
        case UNITS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.dropUnit(this.highlightedLine());
          }
          break;
        case ITEMS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.dropItem(this.highlightedLine());
          }
          break;
        case LEVEL_MAPS:
          if (mouseButton == LEFT) {
            MapEditorInterface.this.addMapToLevel(this.highlightedLine());
          }
          break;
        default:
          global.errorMessage("ERROR: MapEditorPage " + page + " not found.");
          break;
      }
    }
  }


  class LevelEditorListTextBox extends ListTextBox {
    protected boolean active = false;
    protected MapEditorPage previous_page = MapEditorPage.LEVEL_INFO;
    protected float scroll_maps = 0;
    protected float scroll_linkers = 0;
    protected float scroll_triggers = 0;
    protected float scroll_components = 0;

    LevelEditorListTextBox() {
      super(width, Constants.mapEditor_listBoxGap, width, 0.9f * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
    }

     public void setPosition(RightPanelElementLocation position) {
      switch(position) {
        case TOP:
          this.setYLocation(Constants.mapEditor_listBoxGap, 0.45f * height - Constants.mapEditor_listBoxGap);
          break;
        case BOTTOM:
          this.setYLocation(0.45f * height + Constants.mapEditor_listBoxGap, 0.9f * height - Constants.mapEditor_listBoxGap);
          break;
        case WHOLE:
          this.setYLocation(Constants.mapEditor_listBoxGap, 0.9f * height - Constants.mapEditor_listBoxGap);
          break;
      }
    }

     public void setList(MapEditorPage page) {
      if (page == null) {
        return;
      }
      switch(this.previous_page) {
        case LEVEL_INFO:
        case LEVEL_MAPS:
          this.scroll_maps = this.scrollbar.value;
          break;
        case LINKERS:
          this.scroll_linkers = this.scrollbar.value;
          break;
        case TRIGGERS:
          this.scroll_triggers = this.scrollbar.value;
          break;
        case TRIGGER_EDITOR:
        case CONDITION_EDITOR:
        case EFFECT_EDITOR:
          this.scroll_components = this.scrollbar.value;
          break;
        default:
          break;
      }
      this.previous_page = page;
      this.clearText();
      this.line_hovered = -1;
      this.line_clicked = -1;
      this.active = true;
      switch(page) {
        case LEVEL_INFO:
        case LEVEL_MAPS:
          this.setTitleText("Maps");
          if (MapEditorInterface.this.curr_level != null) {
            boolean first = true;
            for (String mapName : MapEditorInterface.this.curr_level.mapNames) {
              if (first) {
                this.setText(mapName);
                first = false;
              }
              else {
                this.addLine(mapName);
              }
            }
          }
          this.scrollbar.updateValue(this.scroll_maps);
          break;
        case LINKERS:
          this.setTitleText("Linkers");
          if (MapEditorInterface.this.curr_level != null) {
            boolean first = true;
            for (Linker linker : MapEditorInterface.this.curr_level.linkers) {
              if (first) {
                this.setText(linker.rect1.fileString());
                this.addLine(linker.rect2.fileString());
                first = false;
              }
              else {
                this.addLine("");
                this.addLine(linker.rect1.fileString());
                this.addLine(linker.rect2.fileString());
              }
            }
          }
          this.scrollbar.updateValue(this.scroll_linkers);
          break;
        case TRIGGERS:
          this.setTitleText("Triggers");
          if (MapEditorInterface.this.curr_level != null) {
            boolean first = true;
            for (Map.Entry<Integer, Trigger> entry : MapEditorInterface.this.curr_level.triggers.entrySet()) {
              Trigger trigger = entry.getValue();
              if (first) {
                this.setText(entry.getKey() + ": " + trigger.triggerName);
                first = false;
              }
              else {
                this.addLine(entry.getKey() + ": " + trigger.triggerName);
              }
            }
          }
          this.scrollbar.updateValue(this.scroll_triggers);
          break;
        case TRIGGER_EDITOR:
        case CONDITION_EDITOR:
        case EFFECT_EDITOR:
          if (MapEditorInterface.this.curr_trigger == null) {
            break;
          }
          this.setTitleText("Trigger " + MapEditorInterface.this.curr_trigger.triggerID + " Components");
          boolean first = true;
          for (Condition condition : MapEditorInterface.this.curr_trigger.conditions) {
            if (first) {
              this.setText(condition.display_name);
              first = false;
            }
            else {
              this.addLine(condition.display_name);
            }
          }
          if (first) {
            this.setText("");
            first = false;
          }
          else {
            this.addLine("");
          }
          for (Effect effect : MapEditorInterface.this.curr_trigger.effects) {
            if (first) {
              this.setText(effect.display_name);
              first = false;
            }
            else {
              this.addLine(effect.display_name);
            }
          }
          this.scrollbar.updateValue(this.scroll_components);
          break;
        default:
          this.active = false;
          break;
      }
    }

     public void refresh() {
      float scroll_value = this.scrollbar.value;
      this.setList(MapEditorInterface.this.page);
      this.scrollbar.updateValue(scroll_value);
    }

    @Override public 
    void mousePress() {
      super.mousePress();
      if (("").equals(this.highlightedLine())) {
        this.line_clicked = -1;
      }
    }

     public void keyPress() {
      if (key == CODED) {
      }
      else {
        switch(key) {
          case 'a':
            switch(MapEditorInterface.this.page) {
              case LINKERS:
                MapEditorInterface.this.addLinkerToLevel();
                break;
              case TRIGGERS:
                MapEditorInterface.this.addTriggerToLevel();
                break;
              default:
                break;
            }
            break;
          case 'd':
            switch(MapEditorInterface.this.page) {
              case LEVEL_MAPS:
                MapEditorInterface.this.removeMapFromLevel(this.highlightedLine());
                break;
              case LINKERS:
                if (this.line_clicked < 0 || this.line_clicked % 3 == 0) {
                  break;
                }
                int linker_index = PApplet.parseInt(floor(this.line_clicked/3.0f));
                MapEditorInterface.this.removeLinkerFromLevel(linker_index);
                break;
              case TRIGGERS:
                if (this.highlightedLine() == null) {
                  break;
                }
                int triggerKey = toInt(trim(split(this.highlightedLine(), ':')[0]));
                if (triggerKey == 0) {
                  break;
                }
                MapEditorInterface.this.removeTriggerFromLevel(triggerKey);
                break;
              case TRIGGER_EDITOR:
              case CONDITION_EDITOR:
              case EFFECT_EDITOR:
                if (MapEditorInterface.this.curr_trigger == null) {
                  break;
                }
                if (this.line_clicked > MapEditorInterface.this.curr_trigger.conditions.size()) {
                  MapEditorInterface.this.removeEffectFromTrigger(this.line_clicked -
                    MapEditorInterface.this.curr_trigger.conditions.size() - 1);
                }
                else if (this.line_clicked != -1 && this.line_clicked !=
                  MapEditorInterface.this.curr_trigger.conditions.size()) {
                  MapEditorInterface.this.removeConditionFromTrigger(this.line_clicked);
                }
                break;
              default:
                break;
            }
            break;
        }
      }
    }

     public void keyRelease() {
    }

     public void click() {
      switch(page) {
        case LEVEL_INFO:
          break;
        case LEVEL_MAPS:
          break;
        case LINKERS:
          break;
        case TRIGGERS:
          break;
        case TRIGGER_EDITOR:
          break;
        case CONDITION_EDITOR:
          break;
        case EFFECT_EDITOR:
          break;
        default:
          break;
      }
    }
     public void doubleclick() {
      switch(page) {
        case LEVEL_INFO:
        case LEVEL_MAPS:
          if (MapEditorInterface.this.curr_level != null && this.highlightedLine() != null) {
            if (this.highlightedLine().equals(MapEditorInterface.this.curr_level.currMapName)) {
              MapEditorInterface.this.curr_level.closeMap();
            }
            else {
              MapEditorInterface.this.curr_level.openMap(this.highlightedLine());
            }
          }
          break;
        case LINKERS:
          // open linker form ?
          break;
        case TRIGGERS:
          if (MapEditorInterface.this.curr_level == null || this.highlightedLine() == null) {
            break;
          }
          int triggerKey = toInt(trim(split(this.highlightedLine(), ':')[0]));
          if (triggerKey == 0) {
            break;
          }
          MapEditorInterface.this.openTriggerEditor(triggerKey);
          break;
        case TRIGGER_EDITOR:
        case CONDITION_EDITOR:
        case EFFECT_EDITOR:
          if (MapEditorInterface.this.curr_trigger == null) {
            break;
          }
          if (this.line_clicked > MapEditorInterface.this.curr_trigger.conditions.size()) {
            MapEditorInterface.this.openEffectEditor(this.line_clicked -
              MapEditorInterface.this.curr_trigger.conditions.size() - 1);
          }
          else if (this.line_clicked != -1 && this.line_clicked !=
            MapEditorInterface.this.curr_trigger.conditions.size()) {
            MapEditorInterface.this.openConditionEditor(this.line_clicked);
          }
          break;
        default:
          break;
      }
    }
  }


  class LevelHeroSelectorForm extends FormLNZ {
    protected Level level;
    protected boolean added_hero = false;

    LevelHeroSelectorForm(Level level) {
      super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
        0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
        this.setTitleText("Hero Selector");
        this.setTitleSize(18);
        this.color_background = color(180, 250, 180);
        this.color_header = color(30, 170, 30);
        this.setFieldCushion(10);
        this.level = level;
        if (this.level == null) {
          this.canceled = true;
          return;
        }

        SubmitFormField submit = new SubmitFormField(" Ok ");
        submit.button.setColors(color(220), color(190, 240, 190),
          color(140, 190, 140), color(90, 140, 90), color(0));

        this.addField(new SpacerFormField(10));
        this.addField(new IntegerFormField("Hero ID: ", 1101, 1102));
        this.addField(new IntegerFormField("Hero Level: ", 0, 100));
        this.addField(new IntegerFormField("Level Tokens: ", 0, 5050));
        this.addField(new FloatFormField("Curr Mana: ", 0, 100));
        this.addField(new SpacerFormField(10));
        this.addField(submit);
    }

    @Override public 
    void cancel() {
      if (!this.added_hero && this.level != null) {
        this.level.setPlayer(new Hero(HeroCode.BEN));
      }
      super.cancel();
    }

     public void submit() {
      Hero h = new Hero(toInt(this.fields.get(1).getValue()));
      h.level = toInt(this.fields.get(2).getValue());
      h.level_tokens = toInt(this.fields.get(3).getValue());
      h.curr_mana = toFloat(this.fields.get(4).getValue());
      this.level.setPlayer(h);
      this.added_hero = true;
      this.canceled = true;
    }
  }


  class HeroSelectorForm extends FormLNZ {
    protected Level level;
    protected boolean added_hero = false;

    HeroSelectorForm(Level level) {
      super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
        0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
        this.setTitleText("Hero Selector");
        this.setTitleSize(18);
        this.color_background = color(180, 250, 180);
        this.color_header = color(30, 170, 30);
        this.setFieldCushion(10);
        this.level = level;
        if (this.level == null) {
          this.canceled = true;
          return;
        }

        SubmitFormField submit = new SubmitFormField(" Ok ");
        submit.button.setColors(color(220), color(190, 240, 190),
          color(140, 190, 140), color(90, 140, 90), color(0));

        this.addField(new SpacerFormField(10));
        this.addField(new IntegerFormField("Hero ID: ", 1101, 1102));
        this.addField(new IntegerFormField("Hero Level: ", 0, 100));
        this.addField(new IntegerFormField("Level Tokens: ", 0, 5050));
        this.addField(new FloatFormField("Curr Mana: ", 0, 100));
        this.addField(new FloatFormField("Location (x): ", 0, Float.MAX_VALUE - 1));
        this.addField(new FloatFormField("Location (y): ", 0, Float.MAX_VALUE - 1));
        this.addField(new SpacerFormField(10));
        this.addField(submit);
    }

    @Override public 
    void cancel() {
      if (!this.added_hero && this.level != null) {
        this.level.addTestPlayer();
      }
      super.cancel();
    }

     public void submit() {
      Hero h = new Hero(toInt(this.fields.get(1).getValue()));
      h.level = toInt(this.fields.get(2).getValue());
      h.level_tokens = toInt(this.fields.get(3).getValue());
      h.curr_mana = toFloat(this.fields.get(4).getValue());
      h.setLocation(toFloat(this.fields.get(5).getValue()), toFloat(this.fields.get(6).getValue()));
      this.level.addPlayer(h);
      this.added_hero = true;
      this.canceled = true;
    }
  }


  class NewMapForm extends FormLNZ {
    NewMapForm() {
      super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
        0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
      this.setTitleText("New Map");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.setFieldCushion(0);

      MessageFormField error = new MessageFormField("");
      error.text_color = color(150, 20, 20);
      error.setTextSize(16);
      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(20));
      this.addField(new StringFormField("", "Map Name"));
      this.addField(error);
      this.addField(new SpacerFormField(10));
      this.addField(new IntegerFormField("", "Map Width", 1, 3000));
      this.addField(new SpacerFormField(20));
      this.addField(new IntegerFormField("", "Map Height", 1, 3000));
      this.addField(new SpacerFormField(20));
      this.addField(submit);
    }

     public void submit() {
      if (fileExists("data/maps/" + this.fields.get(1).getValue() + ".map.lnz")) {
        this.fields.get(2).setValue("A map with that name already exists");
        return;
      }
      MapEditorInterface.this.navigate(MapEditorPage.CREATING_MAP);
      MapEditorInterface.this.create_map_thread = new NewMapThread(this.fields.get(1).getValue(),
        toInt(this.fields.get(4).getValue()), toInt(this.fields.get(6).getValue()));
      MapEditorInterface.this.create_map_thread.start();
      this.canceled = true;
    }
  }


  class NewAreaForm extends FormLNZ {
    NewAreaForm() {
      super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
        0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
      this.setTitleText("New Area");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.setFieldCushion(0);

      MessageFormField error = new MessageFormField("");
      error.text_color = color(150, 20, 20);
      error.setTextSize(16);
      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(20));
      this.addField(new StringFormField("", "Area Name"));
      this.addField(error);
      this.addField(new SpacerFormField(10));
      this.addField(new IntegerFormField("", "Chunks from zero", 0, 30000));
      this.addField(new SpacerFormField(20));
      this.addField(submit);
    }

     public void submit() {
      if (fileExists("data/areas/" + this.fields.get(1).getValue() + ".area.lnz")) {
        this.fields.get(2).setValue("An area with that name already exists");
        return;
      }
      MapEditorInterface.this.createArea(this.fields.get(1).getValue());
      this.canceled = true;
    }
  }


  class NewLevelForm extends FormLNZ {
    NewLevelForm() {
      super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
        0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
      this.setTitleText("New Level");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.setFieldCushion(0);

      MessageFormField error = new MessageFormField("");
      error.text_color = color(150, 20, 20);
      error.setTextSize(16);
      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(20));
      this.addField(new StringFormField("", "Level Name"));
      this.addField(error);
      this.addField(new SpacerFormField(20));
      this.addField(submit);
    }

     public void submit() {
      if (folderExists("data/levels/" + this.fields.get(1).getValue())) {
        this.fields.get(2).setValue("A level with that name already exists");
        return;
      }
      MapEditorInterface.this.newLevel(this.fields.get(1).getValue());
      this.canceled = true;
    }
  }


  class MessageForm extends FormLNZ {
    MessageForm(String title, String message) {
      super(0.5f * (width - Constants.mapEditor_formWidth_small), 0.5f * (height - Constants.mapEditor_formHeight_small),
        0.5f * (width + Constants.mapEditor_formWidth_small), 0.5f * (height + Constants.mapEditor_formHeight_small));
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);

      SubmitFormField submit = new SubmitFormField("  Ok  ");
      submit.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      this.addField(new TextBoxFormField(message, 120));
      this.addField(submit);
    }
     public void submit() {
      this.canceled = true;
    }
  }


  class DeleteMapForm extends ConfirmForm {
    private String mapName;
    DeleteMapForm(String mapName) {
      super("Delete Map", "Are you sure you want to delete this map?\n" + mapName);
      this.mapName = mapName;
    }
     public void submit() {
      deleteFile("data/maps/" + this.mapName + ".map.lnz");
      this.canceled = true;
      MapEditorInterface.this.listBox1.refresh();
    }
  }


  class DeleteAreaForm extends ConfirmForm {
    private String area_name;
    DeleteAreaForm(String area_name) {
      super("Delete Area", "Are you sure you want to delete this area?\n" + area_name);
      this.area_name = area_name;
    }
     public void submit() {
      deleteFile("data/areas/" + this.area_name + ".area.lnz");
      this.canceled = true;
      MapEditorInterface.this.listBox1.refresh();
    }
  }


  class DeleteLevelForm extends ConfirmForm {
    private String levelName;
    DeleteLevelForm(String levelName) {
      super("Delete Level", "Are you sure you want to delete this level?\n" + levelName);
      this.levelName = levelName;
    }
     public void submit() {
      deleteFolder("data/levels/" + this.levelName);
      this.canceled = true;
      MapEditorInterface.this.listBox1.refresh();
    }
  }


  class GoToMainMenuForm extends ConfirmForm {
    GoToMainMenuForm() {
      super("Main Menu", "Are you sure you want to exit to the main menu?\nAll unsaved changes will be lost.");
    }
     public void submit() {
      this.canceled = true;
      MapEditorInterface.this.exitToMainMenu();
    }
  }


  class HelpForm extends ConfirmForm {
    HelpForm(String helpString) {
      super("Help", helpString, true);
    }
     public void submit() {
      this.canceled = true;
    }
  }


  class ChooseSeedForm extends FormLNZ {
    ChooseSeedForm() {
      super(0.5f * (width - Constants.mapEditor_formWidth_small), 0.5f * (height - Constants.mapEditor_formHeight_small),
        0.5f * (width + Constants.mapEditor_formWidth_small), 0.5f * (height + Constants.mapEditor_formHeight_small));
      this.setTitleText("Choose Seed");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);

      SubmitFormField submit = new SubmitFormField(" Load ");
      submit.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      this.addField(new SpacerFormField(0));
      this.addField(new MessageFormField("Choose new seed to reload area."));
      this.addField(new IntegerFormField("   ", "Enter an integer"));
      this.addField(submit);

      this.fields.get(2).focus();
    }
     public void submit() {
      this.canceled = true;
      MapEditorInterface.this.specificAreaSeed(toInt(this.fields.get(2).getValue()));
    }
  }


  class AreaEditorForm extends Form {
    protected GameMapArea area;

    AreaEditorForm(GameMapArea area, float xi, float xf) {
      super(xi, Constants.mapEditor_listBoxGap, xf, 0.9f * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.setFieldCushion(10);
      this.setTitleText("Area Editor");
      this.area = area;

      IntegerFormField area_edge_xi = new IntegerFormField("Edge XI: ", "Enter integer", -1000000, 1000000);
      IntegerFormField area_edge_yi = new IntegerFormField("Edge YI: ", "Enter integer", -1000000, 1000000);
      IntegerFormField area_edge_xf = new IntegerFormField("Edge XF: ", "Enter integer", -1000000, 1000000);
      IntegerFormField area_edge_yf = new IntegerFormField("Edge YF: ", "Enter integer", -1000000, 1000000);
      IntegerFormField spawn_chunk_x = new IntegerFormField("Spawn Chunk X: ", "Enter integer", -1000000, 1000000);
      IntegerFormField spawn_chunk_y = new IntegerFormField("Spawn Chunk Y: ", "Enter integer", -1000000, 1000000);
      SubmitFormField button = new SubmitFormField(" Reload\nMap");
      button.setButtonHeight(45);
      button.button.setColors(color(220), color(240, 190, 150), color(190, 140, 115),
        color(140, 90, 50), color(0));

      this.addField(new SpacerFormField(30));
      this.addField(area_edge_xi);
      this.addField(area_edge_yi);
      this.addField(area_edge_xf);
      this.addField(area_edge_yf);
      this.addField(new SpacerFormField(0));
      this.addField(spawn_chunk_x);
      this.addField(spawn_chunk_y);
      this.addField(new SpacerFormField(0));
      this.addField(button);

      this.setValues();
    }

     public void setValues() {
      this.fields.get(1).setValue(this.area.mapEdgeXi);
      this.fields.get(2).setValue(this.area.mapEdgeYi);
      this.fields.get(3).setValue(this.area.mapEdgeXf);
      this.fields.get(4).setValue(this.area.mapEdgeYf);
      this.fields.get(6).setValue(this.area.default_spawn_chunk.x);
      this.fields.get(7).setValue(this.area.default_spawn_chunk.y);
    }

     public void cancel() {}
     public void buttonPress(int i) {}

     public void submit() {
      int area_edge_xi = toInt(this.fields.get(1).getValue());
      int area_edge_yi = toInt(this.fields.get(2).getValue());
      int area_edge_xf = toInt(this.fields.get(3).getValue());
      if (area_edge_xf <= area_edge_xi) {
        area_edge_xf = area_edge_xi + 1;
      }
      int area_edge_yf = toInt(this.fields.get(4).getValue());
      if (area_edge_yf <= area_edge_yi) {
        area_edge_yf = area_edge_yi + 1;
      }
      int spawn_chunk_x = toInt(this.fields.get(6).getValue());
      if (spawn_chunk_x < area_edge_xi) {
        spawn_chunk_x = area_edge_xi;
      }
      else if (spawn_chunk_x > area_edge_xf) {
        spawn_chunk_x = area_edge_xf;
      }
      int spawn_chunk_y = toInt(this.fields.get(7).getValue());
      if (spawn_chunk_y < area_edge_yi) {
        spawn_chunk_y = area_edge_yi;
      }
      else if (spawn_chunk_y > area_edge_yf) {
        spawn_chunk_y = area_edge_yf;
      }
      this.area.mapEdgeXi = area_edge_xi;
      this.area.mapEdgeYi = area_edge_yi;
      this.area.mapEdgeXf = area_edge_xf;
      this.area.mapEdgeYf = area_edge_yf;
      this.area.default_spawn_chunk = new IntegerCoordinate(spawn_chunk_x, spawn_chunk_y);
      this.setValues();
      this.area.save("data/areas");
      MapEditorInterface.this.reloadArea();
    }
  }


  abstract class LevelEditorForm extends Form {
    LevelEditorForm(float xi, float xf) {
      super(xi, Constants.mapEditor_listBoxGap, xf, 0.45f * height - Constants.mapEditor_listBoxGap);
      this.color_background = color(250, 190, 140);
      this.color_header = color(220, 180, 130);
      this.scrollbar.setButtonColors(color(220), color(220, 160, 110), color(
        240, 180, 130), color(200, 140, 90), color(0));
      this.scrollbar.button_upspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.scrollbar.button_downspace.setColors(color(170), color(255, 200, 150),
        color(255, 200, 150), color(60, 30, 0), color(0));
      this.setFieldCushion(0);
    }

    @Override public 
    void update(int millis) {
      super.update(millis);
      this.submitForm();
    }

     public void cancel() {
    }

     public abstract void updateFields();
  }


  class LevelInfoForm extends LevelEditorForm {
    LevelInfoForm(float xi, float xf) {
      super(xi, xf);
      if (MapEditorInterface.this.curr_level != null) {
        this.setTitleText(MapEditorInterface.this.curr_level.levelName);
        this.addField(new SpacerFormField(20));
        this.addField(new MessageFormField(MapEditorInterface.this.curr_level.getCurrMapNameDisplay()));
        this.addField(new SpacerFormField(20));
        this.addField(new MessageFormField("Location: " + MapEditorInterface.this.curr_level.location.display_name()));
        this.addField(new SpacerFormField(20));
        this.addField(new MessageFormField(MapEditorInterface.this.curr_level.getPlayerStartLocationDisplay()));
        this.addField(new SpacerFormField(10));
        this.addField(new MessageFormField(MapEditorInterface.this.curr_level.getPlayerSpawnLocationDisplay()));
      }
    }

     public void submit() {
      this.updateFields();
    }

     public void buttonPress(int i) {
    }

     public void updateFields() {
      if (MapEditorInterface.this.curr_level == null) {
        return;
      }
      this.fields.get(1).setValue(MapEditorInterface.this.curr_level.getCurrMapNameDisplay());
      this.fields.get(3).setValue("Location: " + MapEditorInterface.this.curr_level.location.display_name());
      this.fields.get(5).setValue(MapEditorInterface.this.curr_level.getPlayerStartLocationDisplay());
      this.fields.get(7).setValue(MapEditorInterface.this.curr_level.getPlayerSpawnLocationDisplay());
    }
  }


  class TriggerEditorForm extends LevelEditorForm {
    protected Trigger trigger;

    TriggerEditorForm(Trigger trigger, float xi, float xf) {
      super(xi, xf);
      this.trigger = trigger;
      this.addField(new SpacerFormField(20));
      this.addField(new StringFormField("  ", "Trigger Name"));
      this.addField(new SpacerFormField(20));
      this.addField(new CheckboxFormField("     Active:  "));
      this.addField(new CheckboxFormField("  Looping:  "));
      this.addField(new CheckboxFormField("Amalgam:  "));
      this.addField(new SpacerFormField(45));
      ButtonsFormField buttons = new ButtonsFormField("Add\nCondition", "Add\nEffect");
      buttons.setButtonHeight(45);
      buttons.button1.setColors(color(220), color(240, 190, 150), color(190, 140, 115),
        color(140, 90, 50), color(0));
      buttons.button2.setColors(color(220), color(240, 190, 150), color(190, 140, 115),
        color(140, 90, 50), color(0));
      this.addField(buttons);
      this.updateFields();
    }

     public void submit() {
      this.trigger.triggerName = this.fields.get(1).getValue();
      this.trigger.active = toBoolean(this.fields.get(3).getValue());
      this.trigger.looping = toBoolean(this.fields.get(4).getValue());
      this.trigger.amalgam = toBoolean(this.fields.get(5).getValue());
    }

     public void buttonPress(int i) {
      if (i != 7) {
        return;
      }
      if (!isInt(this.fields.get(7).getValue())) {
        return;
      }
      int buttonPressed = toInt(this.fields.get(7).getValue());
      if (buttonPressed == 0) {
        MapEditorInterface.this.addConditionToTrigger();
      }
      else if (buttonPressed == 1) {
        MapEditorInterface.this.addEffectToTrigger();
      }
    }

     public void updateFields() {
      this.setTitleText(trigger.triggerName);
      this.fields.get(1).setValueIfNotFocused(this.trigger.triggerName);
      this.fields.get(3).setValueIfNotFocused(Boolean.toString(this.trigger.active));
      this.fields.get(4).setValueIfNotFocused(Boolean.toString(this.trigger.looping));
      this.fields.get(5).setValueIfNotFocused(Boolean.toString(this.trigger.amalgam));
    }
  }


  class ConditionEditorForm extends LevelEditorForm {
    Condition condition;

    ConditionEditorForm(Condition condition, float xi, float xf) {
      super(xi, xf);
      condition.setName();
      this.condition = condition;
      this.addField(new SpacerFormField(20));
      this.addField(new IntegerFormField("ID: ", "Enter an integer from 0-17", 0, 17));
      this.addField(new SpacerFormField(20));
      this.addField(new IntegerFormField("Number 1: ", "enter an integer", 0, Integer.MAX_VALUE - 1));
      this.addField(new IntegerFormField("Number 2: ", "enter an integer", 0, Integer.MAX_VALUE - 1));
      this.addField(new SpacerFormField(20));
      this.addField(new MessageFormField("Rectangle: "));
      this.addField(new SpacerFormField(10));
      this.addField(new CheckboxFormField("Not: "));
      this.updateFields();
    }

     public void submit() {
      this.condition.setID(toInt(this.fields.get(1).getValue()));
      this.condition.number1 = toInt(this.fields.get(3).getValue());
      this.condition.number2 = toInt(this.fields.get(4).getValue());
      this.condition.setName();
      this.setTitleText(condition.display_name);
      this.condition.not_condition = toBoolean(this.fields.get(8).getValue());
      this.updateFields();
    }

     public void buttonPress(int i) {}

     public void updateFields() {
      this.setTitleText(condition.display_name);
      this.fields.get(1).setValueIfNotFocused(Integer.toString(this.condition.ID));
      this.fields.get(3).setValueIfNotFocused(Integer.toString(this.condition.number1));
      this.fields.get(4).setValueIfNotFocused(Integer.toString(this.condition.number2));
      this.fields.get(6).setValueIfNotFocused("Rectangle: " + this.condition.rectangle.fileString());
      this.fields.get(8).setValueIfNotFocused(Boolean.toString(this.condition.not_condition));
    }

    @Override public 
    void keyPress() {
      super.keyPress();
      if (key == 'a') {
        MapEditorInterface.this.addRectangleToCondition(this);
      }
    }
  }


  class EffectEditorForm extends LevelEditorForm {
    Effect effect;

    EffectEditorForm(Effect effect, float xi, float xf) {
      super(xi, xf);
      effect.setName();
      this.effect = effect;
      this.addField(new SpacerFormField(20));
      this.addField(new IntegerFormField("ID: ", "enter an integer from 0-66", 0, 66));
      this.addField(new SpacerFormField(20));
      this.addField(new IntegerFormField("Number: ", "enter an integer", Integer.MIN_VALUE + 1, Integer.MAX_VALUE - 1));
      this.addField(new SpacerFormField(20));
      this.addField(new FloatFormField("Decimal1: ", "enter a float", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
      this.addField(new SpacerFormField(20));
      this.addField(new FloatFormField("Decimal2: ", "enter a float", -Float.MAX_VALUE + 1, Float.MAX_VALUE - 1));
      this.addField(new SpacerFormField(20));
      this.addField(new StringFormField("Message: ", "enter a string"));
      this.addField(new SpacerFormField(20));
      this.addField(new MessageFormField("Rectangle: "));
      this.updateFields();
    }

     public void submit() {
      this.effect.setID(toInt(this.fields.get(1).getValue()));
      this.effect.number = toInt(this.fields.get(3).getValue());
      this.effect.decimal1 = toFloat(this.fields.get(5).getValue());
      this.effect.decimal2 = toFloat(this.fields.get(7).getValue());
      this.effect.message = this.fields.get(9).getValue();
      this.effect.setName();
      this.setTitleText(this.effect.display_name);
      this.updateFields();
    }

     public void buttonPress(int i) {}

     public void updateFields() {
      this.setTitleText(effect.display_name);
      this.fields.get(1).setValueIfNotFocused(Integer.toString(this.effect.ID));
      this.fields.get(3).setValueIfNotFocused(Integer.toString(this.effect.number));
      this.fields.get(5).setValueIfNotFocused(Float.toString(this.effect.decimal1));
      this.fields.get(7).setValueIfNotFocused(Float.toString(this.effect.decimal2));
      this.fields.get(9).setValueIfNotFocused(this.effect.message);
      this.fields.get(11).setValueIfNotFocused("Rectangle: " + this.effect.rectangle.fileString());
    }

    @Override public 
    void keyPress() {
      super.keyPress();
      if (key == 'a') {
        MapEditorInterface.this.addRectangleToEffect(this);
      }
    }
  }


  class NewMapThread extends Thread {
    private GameMapEditor map_creating;
    private String curr_status = "";
    private String mapName = "";
    private int mapWidth = 1;
    private int mapHeight = 1;

    NewMapThread(String mapName, int mapWidth, int mapHeight) {
      this.mapName = mapName;
      this.mapWidth = mapWidth;
      this.mapHeight = mapHeight;
    }

    @Override public 
    void run () {
      this.curr_status = "Creating Map";
      this.map_creating = new GameMapEditor();
      this.map_creating.mapName = this.mapName;
      this.map_creating.mapWidth = this.mapWidth;
      this.map_creating.mapHeight = this.mapHeight;
      this.map_creating.initializeSquares();
      if (this.map_creating.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nSaving Map";
      this.map_creating.save(sketchPath("data/maps/"));
      if (this.map_creating.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
      this.curr_status += "\nGenerating Map Image";
      this.map_creating.initializeTerrain();
      if (this.map_creating.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
    }
  }


  class OpenMapEditorThread extends Thread {
    private String mapName;
    private String folderPath;
    private GameMapEditor map_opening;
    private String curr_status = "";

    OpenMapEditorThread(String mapName, String folderPath) {
      super("OpenMapEditorThread");
      this.mapName = mapName;
      this.folderPath = folderPath;
    }

    @Override public 
    void run() {
      this.curr_status = "Opening File";
      this.map_opening = new GameMapEditor();
      this.map_opening.mapName = this.mapName;
      String[] lines = this.map_opening.open1File(this.folderPath);
      if (this.map_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nSetting Data";
      this.map_opening.open2Data(lines);
      if (this.map_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
      this.curr_status += "\nGenerating Images";
      this.map_opening.initializeTerrain();
      if (this.map_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
    }
  }


  class OpenTestMapThread extends Thread {
    private String mapName;
    private Level level_opening;
    private String curr_status = "";

    OpenTestMapThread(String mapName) {
      super("OpenTestMapThread");
      this.mapName = mapName;
    }

    @Override public 
    void run() {
      this.curr_status = "Opening File";
      GameMap map_testing = new GameMap();
      map_testing.mapName = this.mapName;
      String[] lines = map_testing.open1File("data/maps/");
      if (map_testing.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nSetting Data";
      map_testing.open2Data(lines);
      if (map_testing.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
      this.curr_status += "\nGenerating Images";
      map_testing.initializeTerrain();
      if (map_testing.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nCreating Level";
      this.level_opening = new Level(map_testing);
      delay(500);
    }
  }


  class OpenTestLevelThread extends Thread {
    private String levelName;
    private Level level_opening;
    private String curr_status = "";

    OpenTestLevelThread(String levelName) {
      super("OpenTestLevelThread");
      this.levelName = levelName;
    }

    @Override public 
    void run() {
      this.curr_status = "Opening File";
      this.level_opening = new Level("data/levels", this.levelName);
      if (this.level_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nCopying Data";
      deleteFolder("data/profiles/" + global.profile.display_name.toLowerCase() + "/leveltester");
      mkdir("data/profiles/" + global.profile.display_name.toLowerCase() + "/leveltester");
      copyFolder("data/levels/" + this.levelName, "data/profiles/" + global.
        profile.display_name.toLowerCase() + "/leveltester/" + this.levelName);
      this.level_opening.folderPath = "data/profiles/" + global.profile.display_name.toLowerCase() + "/leveltester";
      this.level_opening.save();
      if (this.level_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
      this.curr_status += "\nGenerating Images";
      if (this.level_opening.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
    }
  }


  private MapEditorPage page;

  private MapEditorButton[] buttons = new MapEditorButton[5];
  private Panel leftPanel = new Panel(LEFT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);
  private Panel rightPanel = new Panel(RIGHT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);
  private MapEditorListTextBox listBox1 = new MapEditorListTextBox();
  private LevelEditorListTextBox listBox2 = new LevelEditorListTextBox();
  private LevelEditorForm levelForm;
  private AreaEditorForm areaForm;

  private GameMapEditor curr_map;
  private GameMapAreaEditor curr_area;
  private Level curr_level;
  private Trigger curr_trigger;
  private int curr_trigger_component = -1;

  private OpenMapEditorThread open_mapEditor_thread;
  private NewMapThread create_map_thread;
  private OpenTestMapThread open_testMap_thread;
  private OpenTestLevelThread open_testLevel_thread;


  MapEditorInterface() {
    this.buttons[0] = new MapEditorButton1();
    this.buttons[1] = new MapEditorButton2();
    this.buttons[2] = new MapEditorButton3();
    this.buttons[3] = new MapEditorButton4();
    this.buttons[4] = new MapEditorButton5();
    this.leftPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.rightPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.leftPanel.color_background = global.color_panelBackground;
    this.rightPanel.color_background = global.color_panelBackground;
    this.navigate(MapEditorPage.MAPS);
    this.resizeButtons();
  }


   public void navigate(MapEditorPage page) {
    this.page = page;
    this.listBox1.setList(this.page);
    this.listBox2.setList(this.page);
    boolean nullifyAreaForm = true;
    boolean nullifyLevelForm = true;
    boolean nullifyCurrTrigger = true;
    switch(this.page) {
      case MAPS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "New\nMap";
        this.buttons[2].message = "Test\nMap";
        this.listBox1.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case AREAS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "New\nArea";
        this.buttons[2].message = "";
        this.listBox1.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case LEVELS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "New\nLevel";
        this.buttons[2].message = "Test\nLevel";
        this.listBox1.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case TERRAIN:
      case FEATURES:
      case UNITS:
      case ITEMS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "Save\nMap";
        this.buttons[2].message = "Cancel\nMap";
        this.listBox1.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case TESTMAP:
        this.buttons[0].message = "";
        this.buttons[1].message = "Save\nMap";
        this.buttons[2].message = "Cancel\nMap";
        break;
      case OPENING_MAPEDITOR:
      case CREATING_MAP:
      case OPENING_TESTMAP:
      case OPENING_TESTLEVEL:
        this.buttons[0].message = "";
        this.buttons[1].message = "";
        this.buttons[2].message = "";
        break;
      case LEVEL_INFO:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        this.levelForm = new LevelInfoForm(width - this.rightPanel.size_curr +
          Constants.mapEditor_listBoxGap, width - Constants.mapEditor_listBoxGap);
        nullifyLevelForm = false;
        this.listBox2.setPosition(RightPanelElementLocation.BOTTOM);
        break;
      case LEVEL_MAPS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        this.listBox1.setPosition(RightPanelElementLocation.TOP);
        this.listBox2.setPosition(RightPanelElementLocation.BOTTOM);
        break;
      case LINKERS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        this.listBox2.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case TRIGGERS:
        this.buttons[0].message = "Toggle\nDisplay";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        this.listBox2.setPosition(RightPanelElementLocation.WHOLE);
        break;
      case TRIGGER_EDITOR:
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        this.buttons[0].message = "Return";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        nullifyLevelForm = false;
        nullifyCurrTrigger = false;
        this.listBox2.setPosition(RightPanelElementLocation.BOTTOM);
        break;
      case TESTLEVEL:
        this.buttons[0].message = "";
        this.buttons[1].message = "Save\nLevel";
        this.buttons[2].message = "Cancel\nLevel";
        break;
      case EDITING_AREA:
        this.buttons[0].message = "Random\nSeed";
        this.buttons[1].message = "Input\nSeed";
        this.buttons[2].message = "Cancel\nArea";
        nullifyAreaForm = false;
        this.areaForm = new AreaEditorForm(this.curr_area, width - this.rightPanel.size_curr +
          Constants.mapEditor_listBoxGap, width - Constants.mapEditor_listBoxGap);
        break;
      case TESTING_AREA:
        this.buttons[0].message = "";
        this.buttons[1].message = "";
        this.buttons[2].message = "Cancel\nLevel";
        break;
      default:
        global.errorMessage("ERROR: MapEditorPage " + this.page + " not found.");
        break;
    }
    if (nullifyAreaForm) {
      this.areaForm = null;
    }
    if (nullifyLevelForm) {
      this.levelForm = null;
    }
    if (nullifyCurrTrigger) {
      this.curr_trigger = null;
    }
  }

   public void resizeButtons() {
    float buttonSize = (this.rightPanel.size_curr - 5 * Constants.mapEditor_buttonGapSize) / 4.0f;
    float xi = width - this.rightPanel.size_curr + Constants.mapEditor_buttonGapSize;
    this.buttons[0].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[1].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[2].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[3].setXLocation(xi, xi + buttonSize);
    this.buttons[4].setXLocation(xi, xi + buttonSize);
    this.listBox1.setXLocation(width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
      width - Constants.mapEditor_listBoxGap);
    this.listBox2.setXLocation(width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
      width - Constants.mapEditor_listBoxGap);
    if (this.levelForm != null) {
      this.levelForm.setXLocation(width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
        width - Constants.mapEditor_listBoxGap);
    }
  if (this.areaForm != null) {
    this.areaForm.setXLocation(width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
      width - Constants.mapEditor_listBoxGap);
  }
  }

   public void buttonClick1() {
    switch(this.page) {
      case MAPS:
        this.navigate(MapEditorPage.AREAS);
        break;
      case AREAS:
        this.navigate(MapEditorPage.LEVELS);
        break;
      case LEVELS:
        this.navigate(MapEditorPage.MAPS);
        break;
      case TERRAIN:
        this.navigate(MapEditorPage.FEATURES);
        break;
      case FEATURES:
        this.navigate(MapEditorPage.UNITS);
        break;
      case UNITS:
        this.navigate(MapEditorPage.ITEMS);
        break;
      case ITEMS:
        this.navigate(MapEditorPage.TERRAIN);
        break;
      case TESTMAP:
        break;
      case OPENING_MAPEDITOR:
      case CREATING_MAP:
        break;
      case OPENING_TESTMAP:
      case OPENING_TESTLEVEL:
        break;
      case LEVEL_INFO:
        this.navigate(MapEditorPage.LEVEL_MAPS);
        break;
      case LEVEL_MAPS:
        this.navigate(MapEditorPage.LINKERS);
        break;
      case LINKERS:
        this.navigate(MapEditorPage.TRIGGERS);
        break;
      case TRIGGERS:
        this.navigate(MapEditorPage.LEVEL_INFO);
        break;
      case TRIGGER_EDITOR:
        this.navigate(MapEditorPage.TRIGGERS);
        break;
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        this.levelForm = new TriggerEditorForm(this.curr_trigger,
          width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
            width - Constants.mapEditor_listBoxGap);
        this.navigate(MapEditorPage.TRIGGER_EDITOR);
        break;
      case TESTLEVEL:
      case TESTING_AREA:
        break;
      case EDITING_AREA:
        this.randomAreaSeed();
        break;
      default:
        global.errorMessage("ERROR: MapEditorPage " + this.page + " not found.");
        break;
    }
  }

   public void buttonClick2() {
    switch(this.page) {
      case MAPS:
        this.form = new NewMapForm();
        break;
      case AREAS:
        this.form = new NewAreaForm();
        break;
      case LEVELS:
        this.form = new NewLevelForm();
        break;
      case TERRAIN:
      case FEATURES:
      case UNITS:
      case ITEMS:
        this.saveMapEditor();
        break;
      case TESTMAP:
        this.saveMapTester();
        break;
      case OPENING_MAPEDITOR:
      case CREATING_MAP:
        break;
      case OPENING_TESTMAP:
      case OPENING_TESTLEVEL:
      case TESTING_AREA:
        break;
      case LEVEL_INFO:
      case LEVEL_MAPS:
      case LINKERS:
      case TRIGGERS:
      case TRIGGER_EDITOR:
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        this.saveLevelEditor();
        break;
      case TESTLEVEL:
        this.saveLevelTester();
        break;
      case EDITING_AREA:
        this.inputAreaSeed();
        break;
      default:
        global.errorMessage("ERROR: MapEditorPage " + this.page + " not found.");
        break;
    }
  }

   public void buttonClick3() {
    switch(this.page) {
      case MAPS:
        this.testMap();
        break;
      case AREAS:
        //this.testArea();
        break;
      case LEVELS:
        this.testLevel();
        break;
      case TERRAIN:
      case FEATURES:
      case UNITS:
      case ITEMS:
        this.closeMapEditor();
        break;
      case TESTMAP:
        this.closeMapTester();
        break;
      case OPENING_MAPEDITOR:
      case CREATING_MAP:
        break;
      case OPENING_TESTMAP:
      case OPENING_TESTLEVEL:
        break;
      case LEVEL_INFO:
      case LEVEL_MAPS:
      case LINKERS:
      case TRIGGERS:
      case TRIGGER_EDITOR:
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        this.closeLevelEditor();
        break;
      case TESTLEVEL:
        this.closeLevelTester();
        break;
      case EDITING_AREA:
      case TESTING_AREA:
        this.closeAreaTester();
        break;
      default:
        global.errorMessage("ERROR: MapEditorPage " + this.page + " not found.");
        break;
    }
  }

   public void buttonClick4() {
    switch(this.page) {
      case MAPS:
      case AREAS:
      case LEVELS:
        MapEditorInterface.this.curr_map = null;
        MapEditorInterface.this.curr_level = null;
        global.state = ProgramState.ENTERING_MAINMENU;
        break;
      default:
        this.form = new GoToMainMenuForm();
        break;
    }
  }

   public void buttonClick5() {
    switch(this.page) {
      case MAPS:
        this.form = new HelpForm(Constants.help_mapEditor_maps);
        break;
      case AREAS:
        this.form = new HelpForm(Constants.help_mapEditor_areas);
        break;
      case LEVELS:
        this.form = new HelpForm(Constants.help_mapEditor_levels);
        break;
      case TERRAIN:
        this.form = new HelpForm(Constants.help_mapEditor_terrain);
        break;
      case FEATURES:
        this.form = new HelpForm(Constants.help_mapEditor_features);
        break;
      case UNITS:
        this.form = new HelpForm(Constants.help_mapEditor_units);
        break;
      case ITEMS:
        this.form = new HelpForm(Constants.help_mapEditor_items);
        break;
      case TESTMAP:
      case OPENING_MAPEDITOR:
      case CREATING_MAP:
      case OPENING_TESTMAP:
      case OPENING_TESTLEVEL:
      case TESTLEVEL:
      case EDITING_AREA:
      case TESTING_AREA:
        break;
      case LEVEL_INFO:
        this.form = new HelpForm(Constants.help_mapEditor_levelInfo);
        break;
      case LEVEL_MAPS:
        this.form = new HelpForm(Constants.help_mapEditor_levelMaps);
        break;
      case LINKERS:
        this.form = new HelpForm(Constants.help_mapEditor_linkers);
        break;
      case TRIGGERS:
        this.form = new HelpForm(Constants.help_mapEditor_triggers);
        break;
      case TRIGGER_EDITOR:
        this.form = new HelpForm(Constants.help_mapEditor_triggerEditor);
        break;
      case CONDITION_EDITOR:
        this.form = new HelpForm(Constants.help_mapEditor_conditionEditor);
        break;
      case EFFECT_EDITOR:
        this.form = new HelpForm(Constants.help_mapEditor_effectEditor);
        break;
      default:
        global.errorMessage("ERROR: MapEditorPage " + this.page + " not found.");
        break;
    }
  }


   public void testMap() {
    String mapName = this.listBox1.highlightedLine();
    if (mapName == null) {
      this.form = new MessageForm("Test Map", "No map selected to test.");
    }
    else {
      this.navigate(MapEditorPage.OPENING_TESTMAP);
      this.open_testMap_thread = new OpenTestMapThread(mapName);
      this.open_testMap_thread.start();
    }
  }

   public void deleteMap() {
    String mapName = this.listBox1.highlightedLine();
    if (mapName == null) {
      this.form = new MessageForm("Delete Map", "No map selected to delete.");
    }
    else {
      this.form = new DeleteMapForm(mapName);
    }
  }

   public void setCurrMap(GameMapEditor map) {
    this.curr_map = map;
    this.curr_map.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
    this.navigate(MapEditorPage.TERRAIN);
  }

   public void renameMapFile(String mapName, String targetName) {
    if (!entryExists("data/maps/" + mapName + ".map.lnz")) {
      global.errorMessage("ERROR: Can't rename map file that doesn't exist.");
      return;
    }
    if (entryExists("data/maps/" + targetName + ".map.lnz")) {
      return; // name exists
    }
    GameMap map = new GameMap();
    map.mapName = mapName;
    String[] lines = map.open1File("data/maps/");
    PrintWriter mapFile = createWriter("data/maps/" + targetName + ".map.lnz");
    for (String line : lines) {
      if (trim(split(line, ':')[0]).equals("mapName")) {
        line = "mapName: " + targetName;
      }
      mapFile.println(line);
    }
    mapFile.flush();
    mapFile.close();
    deleteFile("data/maps/" + mapName + ".map.lnz");
  }

   public void openMapEditor(String mapName) {
    this.navigate(MapEditorPage.OPENING_MAPEDITOR);
    this.open_mapEditor_thread = new OpenMapEditorThread(mapName, sketchPath("data/maps/"));
    this.open_mapEditor_thread.start();
  }

   public void saveMapEditor() {
    if (this.curr_map != null) {
      this.curr_map.save(sketchPath("data/maps/"));
    }
    this.closeMapEditor();
  }

   public void closeMapEditor() {
    this.curr_map = null;
    this.navigate(MapEditorPage.MAPS);
  }

   public void saveMapTester() {
    if (this.curr_level != null) {
      if (this.curr_level.currMap != null) {
        this.curr_level.currMap.save(sketchPath("data/maps/"));
      }
    }
    this.closeMapTester();
  }

   public void closeMapTester() {
    this.curr_level = null;
    global.viewing_ender_chest = false;
    this.navigate(MapEditorPage.MAPS);
  }


   public void createArea(String area_name) {
    if (area_name == null || area_name.equals("")) {
      return;
    }
    if (fileExists("data/areas/" + area_name + ".area.lnz")) {
      return;
    }
    deleteFolder("data/areas/temp");
    this.curr_area = new GameMapAreaEditor(area_name, "data/areas/temp");
    this.curr_area.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
    this.curr_area.initializeArea();
    this.curr_area.save(sketchPath("data/areas/"));
    this.navigate(MapEditorPage.EDITING_AREA);
  }

   public void inputAreaSeed() {
    this.form = new ChooseSeedForm();
  }
   public void randomAreaSeed() {
    this.specificAreaSeed(PApplet.parseInt(map(random(1), 0, 1, 0, Integer.MAX_VALUE - 1)));
  }
   public void specificAreaSeed(int new_seed) {
    if (this.curr_area == null || this.page != MapEditorPage.EDITING_AREA) {
      return;
    }
    boolean old_draw_grid = this.curr_area.draw_grid;
    boolean old_draw_fog = this.curr_area.draw_fog;
    float old_zoom = this.curr_area.zoom;
    this.curr_area.seed = new_seed;
    this.curr_area.nextFeatureKey = 0;
    String area_name = this.curr_area.mapName;
    this.saveAreaTester();
    this.openAreaEditor(area_name);
    this.curr_area.draw_grid = old_draw_grid;
    this.curr_area.draw_fog = old_draw_fog;
    this.curr_area.setZoom(old_zoom);
    this.curr_area.viewDefaultChunk();
    this.curr_area.addHeaderMessage("Now using seed: " + this.curr_area.seed);
  }

   public void reloadArea() {
    if (this.curr_area == null || this.page != MapEditorPage.EDITING_AREA) {
      return;
    }
    this.specificAreaSeed(this.curr_area.seed);
  }

   public void saveAreaTester() {
    if (this.curr_area == null) {
      return;
    }
    this.curr_area.save("data/areas");
    this.closeAreaTester();
  }

   public void closeAreaTester() {
    deleteFolder("data/areas/temp");
    this.curr_area = null;
    this.curr_level = null;
    this.navigate(MapEditorPage.AREAS);
  }

   public void openAreaEditor(String area_name) {
    if (area_name == null || area_name.equals("")) {
      return;
    }
    if (!fileExists("data/areas/" + area_name + ".area.lnz")) {
      return;
    }
    deleteFolder("data/areas/temp");
    this.curr_area = new GameMapAreaEditor(area_name, "data/areas/temp");
    this.curr_area.open("data/areas");
    this.curr_area.initializeArea();
    this.curr_area.viewDefaultChunk();
    this.curr_area.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
    this.navigate(MapEditorPage.EDITING_AREA);
  }

   public void testArea(String area_name) {
    if (area_name == null || area_name.equals("")) {
      return;
    }
    if (!fileExists("data/areas/" + area_name + ".area.lnz")) {
      return;
    }
    deleteFolder("data/areas/temp");
    GameMapArea area = new GameMapArea(area_name, "data/areas/temp");
    area.open("data/areas");
    area.initializeArea();
    area.viewDefaultChunk();
    this.curr_level = new Level(area);
    this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
    this.form = new LevelHeroSelectorForm(this.curr_level);
    this.curr_level.restartTimers();
    this.navigate(MapEditorPage.TESTING_AREA);
  }

   public void deleteArea() {
    String area_name = this.listBox1.highlightedLine();
    if (area_name == null) {
      this.form = new MessageForm("Delete Area", "No area selected to delete.");
    }
    else {
      this.form = new DeleteAreaForm(area_name);
    }
  }

   public void renameAreaFile(String area_name, String target_name) {
    if (!entryExists("data/areas/" + area_name + ".area.lnz")) {
      global.errorMessage("ERROR: Can't rename area file that doesn't exist.");
      return;
    }
    if (entryExists("data/areas/" + target_name + ".area.lnz")) {
      return;
    }
    GameMapAreaEditor map = new GameMapAreaEditor(area_name, "data/areas/temp");
    map.mapName = area_name;
    String[] lines = map.open1File("data/areas/");
    PrintWriter mapFile = createWriter("data/areas/" + target_name + ".area.lnz");
    for (String line : lines) {
      if (trim(split(line, ':')[0]).equals("mapName")) {
        line = "mapName: " + target_name;
      }
      mapFile.println(line);
    }
    mapFile.flush();
    mapFile.close();
    deleteFile("data/areas/" + area_name + ".area.lnz");
  }


   public void newLevel(String levelName) {
    Level new_level = new LevelEditor();
    new_level.folderPath = "data/levels/";
    new_level.levelName = levelName;
    new_level.save();
    this.curr_level = new_level;
    this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
    this.navigate(MapEditorPage.LEVEL_INFO);
  }

   public void testLevel() {
    String levelName = this.listBox1.highlightedLine();
    if (levelName == null) {
      this.form = new MessageForm("Test Level", "No level selected to test.");
      return;
    }
    this.navigate(MapEditorPage.OPENING_TESTLEVEL);
    this.open_testLevel_thread = new OpenTestLevelThread(levelName);
    this.open_testLevel_thread.start();
  }

   public void deleteLevel() {
    String levelName = this.listBox1.highlightedLine();
    if (levelName == null) {
      this.form = new MessageForm("Delete Level", "No level selected to delete.");
    }
    else {
      this.form = new DeleteLevelForm(levelName);
    }
  }

   public void renameLevelFolder(String levelName, String targetName) {
    if (!entryExists("data/levels/" + levelName)) {
      global.errorMessage("ERROR: Can't rename level that doesn't exist.");
      return;
    }
    if (entryExists("data/levels/" + targetName)) {
      global.errorMessage("ERROR: Can't rename level to a name that already exists.");
      return;
    }
    moveFolder("data/levels/" + levelName, "data/levels/" + targetName);
    Level level = new Level();
    level.folderPath = "data/levels/";
    level.levelName = targetName;
    String[] lines = level.open1File();
    PrintWriter levelFile = createWriter(level.finalFolderPath() + "/level.lnz");
    for (String line : lines) {
      if (trim(split(line, ':')[0]).equals("levelName")) {
        line = "levelName: " + targetName;
      }
      levelFile.println(line);
    }
    levelFile.flush();
    levelFile.close();
  }

   public void openLevelEditor(String levelName) {
    this.curr_level = new LevelEditor("data/levels", levelName);
    if (this.curr_level.nullify) {
      this.curr_level = null;
      this.navigate(MapEditorPage.LEVELS);
    }
    else {
      this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      this.navigate(MapEditorPage.LEVEL_INFO);
    }
  }

   public void addMapToLevel(String mapName) {
    if (mapName == null) {
      this.form = new MessageForm("Add Map", "No map selected to add to level.");
      return;
    }
    if (!fileExists("data/maps/" + mapName + ".map.lnz")) {
      this.form = new MessageForm("Add Map", "Map is missing from maps folder:\n" + mapName);
      return;
    }
    if (this.curr_level == null) {
      this.form = new MessageForm("Add Map", "No current level to add map to.");
      return;
    }
    if (this.curr_level.hasMap(mapName)) {
      return;
    }
    copyFile("data/maps/" + mapName + ".map.lnz", "data/levels/" +
      this.curr_level.levelName + "/" + mapName + ".map.lnz");
    this.curr_level.mapNames.add(mapName);
    this.curr_level.save(false);
    this.listBox2.refresh();
  }

   public void removeMapFromLevel(String mapName) {
    if (mapName == null) {
      this.form = new MessageForm("Remove Map", "No map selected to remove from level.");
      return;
    }
    if (!fileExists("data/levels/" + this.curr_level.levelName + "/" + mapName + ".map.lnz")) {
      this.form = new MessageForm("Remove Map", "Map is missing from level folder:\n" + mapName);
      return;
    }
    if (this.curr_level == null) {
      this.form = new MessageForm("Remove Map", "No current level to remove map from.");
      return;
    }
    if (!this.curr_level.hasMap(mapName)) {
      return;
    }
    deleteFile("data/levels/" + this.curr_level.levelName + "/" + mapName + ".map.lnz");
    this.curr_level.removeMap(mapName);
    this.curr_level.save(false);
    this.listBox2.refresh();
  }

   public void saveLevelEditor() {
    if (this.curr_level != null) {
      this.curr_level.save();
    }
  }

   public void closeLevelEditor() {
    this.curr_level = null;
    this.navigate(MapEditorPage.LEVELS);
  }

   public void saveLevelTester() {
    if (this.curr_level != null) {
      this.curr_level.folderPath = "data/levels";
      this.curr_level.save();
    }
    this.closeLevelTester();
  }

   public void closeLevelTester() {
    this.curr_level = null;
    global.viewing_ender_chest = false;
    deleteFolder("data/profiles/" + global.profile.display_name.toLowerCase() + "/leveltester");
    this.navigate(MapEditorPage.LEVELS);
  }

   public void openTriggerEditor(int triggerKey) {
    if (this.curr_level == null) {
      return;
    }
    if (!this.curr_level.triggers.containsKey(triggerKey)) {
      return;
    }
    this.curr_trigger = this.curr_level.triggers.get(triggerKey);
    this.levelForm = new TriggerEditorForm(this.curr_trigger,
      width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
        width - Constants.mapEditor_listBoxGap);
    this.navigate(MapEditorPage.TRIGGER_EDITOR);
  }

   public void openConditionEditor(int conditionIndex) {
    if (this.curr_trigger == null) {
      return;
    }
    if (conditionIndex < 0 || conditionIndex >= this.curr_trigger.conditions.size()) {
      return;
    }
    if (conditionIndex == this.curr_trigger_component && ConditionEditorForm.class.isInstance(this.levelForm)) {
      this.curr_trigger_component = -1;
      this.levelForm = new TriggerEditorForm(this.curr_trigger,
        width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
          width - Constants.mapEditor_listBoxGap);
      this.navigate(MapEditorPage.TRIGGER_EDITOR);
      return;
    }
    this.curr_trigger_component = conditionIndex;
    this.levelForm = new ConditionEditorForm(this.curr_trigger.conditions.get(
      conditionIndex), width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
      width - Constants.mapEditor_listBoxGap);
      this.navigate(MapEditorPage.CONDITION_EDITOR);
  }

   public void openEffectEditor(int effectIndex) {
    if (this.curr_trigger == null) {
      return;
    }
    if (effectIndex < 0 || effectIndex >= this.curr_trigger.effects.size()) {
      return;
    }
    if (effectIndex == this.curr_trigger_component && EffectEditorForm.class.isInstance(this.levelForm)) {
      this.curr_trigger_component = -1;
      this.levelForm = new TriggerEditorForm(this.curr_trigger,
        width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
          width - Constants.mapEditor_listBoxGap);
      this.navigate(MapEditorPage.TRIGGER_EDITOR);
      return;
    }
    this.curr_trigger_component = effectIndex;
    this.levelForm = new EffectEditorForm(this.curr_trigger.effects.get(
      effectIndex), width - this.rightPanel.size_curr + Constants.mapEditor_listBoxGap,
      width - Constants.mapEditor_listBoxGap);
      this.navigate(MapEditorPage.EFFECT_EDITOR);
  }

   public void addRectangleToCondition(ConditionEditorForm form) {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    Rectangle rect = ((LevelEditor)this.curr_level).getCurrentRectangle();
    if (rect == null) {
      return;
    }
    form.condition.rectangle = rect;
  }

   public void addRectangleToEffect(EffectEditorForm form) {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    Rectangle rect = ((LevelEditor)this.curr_level).getCurrentRectangle();
    if (rect == null) {
      return;
    }
    form.effect.rectangle = rect;
  }


   public void dropTerrain(String line) {
    if (this.curr_map == null) {
      return;
    }
    String[] line_split = split(line, ':');
    if (line_split.length < 2) {
      return;
    }
    String terrainID = trim(line_split[1]);
    if (isInt(terrainID)) {
      this.curr_map.dropTerrain(toInt(terrainID));
    }
  }

   public void dropFeature(String line) {
    if (this.curr_map == null) {
      return;
    }
    String[] line_split = split(line, ':');
    if (line_split.length < 2) {
      return;
    }
    String featureID = trim(line_split[1]);
    if (isInt(featureID)) {
      this.curr_map.dropping_object = new Feature(toInt(featureID));
      this.curr_map.dropping_terrain = false;
    }
  }

   public void dropUnit(String line) {
    if (this.curr_map == null) {
      return;
    }
    String[] line_split = split(line, ':');
    if (line_split.length < 2) {
      return;
    }
    String unitID = trim(line_split[1]);
    if (isInt(unitID)) {
      this.curr_map.dropping_object = new Unit(toInt(unitID));
      this.curr_map.dropping_terrain = false;
    }
  }

   public void dropItem(String line) {
    if (this.curr_map == null) {
      return;
    }
    String[] line_split = split(line, ':');
    if (line_split.length < 2) {
      return;
    }
    String itemID = trim(line_split[1]);
    if (isInt(itemID)) {
      this.curr_map.dropping_object = new Item(toInt(itemID));
      this.curr_map.dropping_terrain = false;
    }
  }

   public void addLinkerToLevel() {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    ((LevelEditor)this.curr_level).newLinker();
    this.listBox2.refresh();
    this.listBox2.scrollBottom();
  }

   public void removeLinkerFromLevel(int linker_index) {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    ((LevelEditor)this.curr_level).removeLinker(linker_index);
    this.listBox2.refresh();
  }

   public void addTriggerToLevel() {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    ((LevelEditor)this.curr_level).newTrigger();
    this.listBox2.refresh();
    this.listBox2.scrollBottom();
  }

   public void removeTriggerFromLevel(int trigger_key) {
    if (this.curr_level == null) {
      return;
    }
    if (!LevelEditor.class.isInstance(this.curr_level)) {
      return;
    }
    ((LevelEditor)this.curr_level).removeTrigger(trigger_key);
    this.listBox2.refresh();
  }

   public void addConditionToTrigger() {
    if (this.curr_trigger == null) {
      return;
    }
    this.curr_trigger.conditions.add(new Condition());
    this.listBox2.refresh();
  }

   public void addEffectToTrigger() {
    if (this.curr_trigger == null) {
      return;
    }
    this.curr_trigger.effects.add(new Effect());
    this.listBox2.refresh();
  }

   public void removeConditionFromTrigger(int index) {
    if (this.curr_trigger == null) {
      return;
    }
    if (index < 0 || index >= this.curr_trigger.conditions.size()) {
      return;
    }
    this.curr_trigger.conditions.remove(index);
    this.listBox2.refresh();
  }

   public void removeEffectFromTrigger(int index) {
    if (this.curr_trigger == null) {
      return;
    }
    if (index < 0 || index >= this.curr_trigger.effects.size()) {
      return;
    }
    this.curr_trigger.effects.remove(index);
    this.listBox2.refresh();
  }


   public Hero getCurrentHeroIfExists() {
    if (this.curr_level != null) {
      return this.curr_level.player;
    }
    return null;
  }


   public void exitToMainMenu() {
    MapEditorInterface.this.curr_map = null;
    MapEditorInterface.this.curr_level = null;
    global.state = ProgramState.ENTERING_MAINMENU;
  }

   public void saveAndExitToMainMenu() {
    switch(this.page) {
      case TERRAIN:
      case FEATURES:
      case UNITS:
      case ITEMS:
        this.saveMapEditor();
        break;
      case TESTMAP:
        this.saveMapTester();
        break;
      case TESTLEVEL:
        this.saveLevelTester();
        break;
      case LEVEL_INFO:
      case LEVEL_MAPS:
      case LINKERS:
      case TRIGGERS:
      case TRIGGER_EDITOR:
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        this.saveLevelEditor();
        break;
      default:
        break;
    }
    this.exitToMainMenu();
  }


   public void update(int millis) {
    boolean refreshMapLocation = false;
    switch(this.page) {
      case CREATING_MAP:
        if (this.create_map_thread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.create_map_thread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.create_map_thread.map_creating.nullify) {
            this.curr_map = null;
            this.navigate(MapEditorPage.MAPS);
          }
          else {
            this.curr_map = this.create_map_thread.map_creating;
            this.curr_map.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.navigate(MapEditorPage.TERRAIN);
          }
          this.create_map_thread = null;
          return;
        }
        break;
      case OPENING_MAPEDITOR:
        if (this.open_mapEditor_thread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.open_mapEditor_thread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.open_mapEditor_thread.map_opening.nullify) {
            this.curr_map = null;
            this.navigate(MapEditorPage.MAPS);
          }
          else {
            this.curr_map = this.open_mapEditor_thread.map_opening;
            this.curr_map.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.navigate(MapEditorPage.TERRAIN);
          }
          this.open_mapEditor_thread = null;
          return;
        }
        break;
      case OPENING_TESTMAP:
        if (this.open_testMap_thread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.open_testMap_thread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.open_testMap_thread.level_opening == null || this.open_testMap_thread.level_opening.nullify) {
            this.curr_level = null;
            this.navigate(MapEditorPage.MAPS);
          }
          else {
            this.curr_level = this.open_testMap_thread.level_opening;
            this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.navigate(MapEditorPage.TESTMAP);
            this.form = new HeroSelectorForm(this.curr_level);
            this.curr_level.restartTimers();
          }
          this.open_testMap_thread = null;
          return;
        }
        break;
      case OPENING_TESTLEVEL:
        if (this.open_testLevel_thread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.open_testLevel_thread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.open_testLevel_thread.level_opening == null || this.open_testLevel_thread.level_opening.nullify) {
            this.curr_level = null;
            this.navigate(MapEditorPage.LEVELS);
          }
          else {
            this.curr_level = this.open_testLevel_thread.level_opening;
            this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.navigate(MapEditorPage.TESTLEVEL);
            this.form = new LevelHeroSelectorForm(this.curr_level);
            this.curr_level.restartTimers();
          }
          this.open_testLevel_thread = null;
          return;
        }
        break;
      default:
        if (this.curr_level != null) {
          this.curr_level.update(millis);
          if (this.leftPanel.collapsing || this.rightPanel.collapsing) {
            refreshMapLocation = true;
          }
        }
        else if (this.curr_map != null) {
          this.curr_map.update(millis);
          if (this.leftPanel.collapsing || this.rightPanel.collapsing) {
            refreshMapLocation = true;
          }
        }
        else if (this.curr_area != null) {
          this.curr_area.update(millis);
          if (this.leftPanel.collapsing || this.rightPanel.collapsing) {
            refreshMapLocation = true;
          }
        }
        else {
          rectMode(CORNERS);
          noStroke();
          fill(color(60));
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
        }
        break;
    }
    this.leftPanel.update(millis);
    this.rightPanel.update(millis);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (MapEditorButton button : this.buttons) {
        button.update(millis);
      }
      if (this.listBox1.active) {
        this.listBox1.update(millis);
      }
      if (this.listBox2.active) {
        this.listBox2.update(millis);
      }
      if (this.areaForm != null) {
        this.areaForm.update(millis);
      }
      if (this.levelForm != null) {
        this.levelForm.update(millis);
      }
      if (this.curr_level != null) {
        switch(this.page) {
          case TESTMAP:
          case TESTLEVEL:
            this.curr_level.drawRightPanel(millis);
            break;
        }
      }
    }
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.curr_level != null) {
        this.curr_level.drawLeftPanel(millis);
      }
      else if (this.curr_map != null) {
        this.curr_map.drawLeftPanel(millis);
      }
      else if (this.curr_area != null) {
        this.curr_area.drawLeftPanel(millis);
      }
    }
    if (refreshMapLocation) {
      if (this.curr_level != null) {
        this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
      else if (this.curr_map != null) {
        this.curr_map.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
      else if (this.curr_area != null) {
        this.curr_area.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
  }

   public void showNerdStats() {
    if (this.curr_level != null) {
      this.curr_level.displayNerdStats();
    }
    else if (this.curr_map != null) {
      this.curr_map.displayNerdStats();
    }
    else if (this.curr_area != null) {
      this.curr_area.displayNerdStats();
    }
    else {
      this.showDefaultNerdStats(color(255));
    }
  }

   public void mouseMove(float mX, float mY) {
    boolean refreshMapLocation = false;
    // map / level mouse move
    if (this.curr_level != null) {
      this.curr_level.mouseMove(mX, mY);
      if (this.leftPanel.clicked || this.rightPanel.clicked) {
        refreshMapLocation = true;
      }
    }
    else if (this.curr_map != null) {
      this.curr_map.mouseMove(mX, mY);
      if (this.leftPanel.clicked || this.rightPanel.clicked) {
        refreshMapLocation = true;
      }
    }
    else if (this.curr_area != null) {
      this.curr_area.mouseMove(mX, mY);
      if (this.leftPanel.clicked || this.rightPanel.clicked) {
        refreshMapLocation = true;
      }
    }
    // left panel mouse move
    this.leftPanel.mouseMove(mX, mY);
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.curr_level != null) {
        if (this.curr_level.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
      else if (this.curr_map != null) {
        if (this.curr_map.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
      else if (this.curr_area != null) {
        if (this.curr_area.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
    }
    // right panel mouse move
    this.rightPanel.mouseMove(mX, mY);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (MapEditorButton button : this.buttons) {
        button.mouseMove(mX, mY);
      }
      if (this.listBox1.active) {
        this.listBox1.mouseMove(mX, mY);
        if (this.listBox1.rightClickMenu != null && this.listBox1.rightClickMenu.hovered) {
          this.rightPanel.hovered = false;
        }
      }
      if (this.listBox2.active) {
        this.listBox2.mouseMove(mX, mY);
      }
      if (this.areaForm != null) {
        this.areaForm.mouseMove(mX, mY);
      }
      if (this.levelForm != null) {
        this.levelForm.mouseMove(mX, mY);
      }
    }
    // refresh map location
    if (refreshMapLocation) {
      if (this.curr_level != null) {
        this.curr_level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
      else if (this.curr_map != null) {
        this.curr_map.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
      else if (this.curr_area != null) {
        this.curr_area.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
    // cursor icon resolution
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      this.resizeButtons();
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png", "icons/cursor_resizeh.png");
    }
  }

   public void mousePress() {
    if (this.curr_level != null) {
      this.curr_level.mousePress();
    }
    else if (this.curr_map != null) {
      this.curr_map.mousePress();
    }
    else if (this.curr_area != null) {
      this.curr_area.mousePress();
    }
    this.leftPanel.mousePress();
    this.rightPanel.mousePress();
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (MapEditorButton button : this.buttons) {
        button.mousePress();
      }
      if (this.listBox1.active) {
        this.listBox1.mousePress();
      }
      if (this.listBox2.active) {
        this.listBox2.mousePress();
      }
      if (this.areaForm != null) {
        this.areaForm.mousePress();
      }
      if (this.levelForm != null) {
        this.levelForm.mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.curr_level != null) {
      this.curr_level.mouseRelease(mX, mY);
    }
    else if (this.curr_map != null) {
      this.curr_map.mouseRelease(mX, mY);
    }
    else if (this.curr_area != null) {
      this.curr_area.mouseRelease(mX, mY);
    }
    this.leftPanel.mouseRelease(mX, mY);
    this.rightPanel.mouseRelease(mX, mY);
    if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh.png", "icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (MapEditorButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
      if (this.listBox1.active) {
        this.listBox1.mouseRelease(mX, mY);
      }
      if (this.listBox2.active) {
        this.listBox2.mouseRelease(mX, mY);
      }
      if (this.levelForm != null) {
        this.levelForm.mouseRelease(mX, mY);
      }
      if (this.areaForm != null) {
        this.areaForm.mouseRelease(mX, mY);
      }
    }
  }

   public void scroll(int amount) {
    if (this.curr_level != null) {
      this.curr_level.scroll(amount);
    }
    else if (this.curr_map != null) {
      this.curr_map.scroll(amount);
    }
    else if (this.curr_area != null) {
      this.curr_area.scroll(amount);
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      if (this.listBox1.active) {
        this.listBox1.scroll(amount);
      }
      if (this.listBox2.active) {
        this.listBox2.scroll(amount);
      }
      if (this.levelForm != null) {
        this.levelForm.scroll(amount);
      }
      if (this.areaForm != null) {
        this.areaForm.scroll(amount);
      }
    }
  }

   public void keyPress() {
    switch(this.page) {
      case TRIGGER_EDITOR:
      case CONDITION_EDITOR:
      case EFFECT_EDITOR:
        break;
      default:
        if (this.curr_level != null) {
          this.curr_level.keyPress();
        }
        else if (this.curr_map != null) {
          this.curr_map.keyPress();
        }
        else if (this.curr_area != null) {
          this.curr_area.keyPress();
        }
        break;
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      if (this.listBox1.active) {
        this.listBox1.keyPress();
      }
      if (this.listBox2.active) {
        this.listBox2.keyPress();
      }
      if (this.levelForm != null) {
        this.levelForm.keyPress();
      }
      if (this.areaForm != null) {
        this.areaForm.keyPress();
      }
    }
  }

   public void openEscForm() {
    this.form = new EscForm();
  }

   public void keyRelease() {
    if (this.curr_level != null) {
      this.curr_level.keyRelease();
    }
    else if (this.curr_map != null) {
      this.curr_map.keyRelease();
    }
    else if (this.curr_area != null) {
      this.curr_area.keyRelease();
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      if (this.listBox1.active) {
        this.listBox1.keyRelease();
      }
      if (this.listBox2.active) {
        this.listBox2.keyRelease();
      }
      if (this.levelForm != null) {
        this.levelForm.keyRelease();
      }
      if (this.areaForm != null) {
        this.areaForm.keyRelease();
      }
    }
  }


   public void loseFocus() {
    if (this.curr_level != null) {
      this.curr_level.loseFocus();
    }
    else if (this.curr_map != null) {
      this.curr_map.loseFocus();
    }
    else if (this.curr_area != null) {
      this.curr_area.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.curr_level != null) {
      this.curr_level.gainFocus();
    }
    else if (this.curr_map != null) {
      this.curr_map.gainFocus();
    }
    else if (this.curr_area != null) {
      this.curr_area.gainFocus();
    }
  }

   public void restartTimers() {
    if (this.curr_level != null) {
      this.curr_level.restartTimers();
    }
  }
}
abstract class EditMapObjectForm extends FormLNZ {
  EditMapObjectForm(MapObject mapObject) {
    super(0.5f * (width - Constants.mapEditor_formWidth), 0.5f * (height - Constants.mapEditor_formHeight),
      0.5f * (width + Constants.mapEditor_formWidth), 0.5f * (height + Constants.mapEditor_formHeight));
    this.setTitleText(mapObject.display_name_editor());
    this.setTitleSize(18);
    this.addField(new SpacerFormField(1));
    this.color_background = color(160, 220, 220);
    this.color_header = color(30, 150, 150);
  }

  @Override public 
  void update(int millis) {
    super.update(millis);
    this.submitForm();
  }

   public void submit() {
    this.updateObject();
    this.updateForm();
  }

   public abstract void updateObject();
   public abstract void updateForm();
}


abstract class MapObject {
  protected int ID = 0;
  protected String display_name = "-- Error --";
  protected String type = "-- Error --";
  protected String description = "";

  protected float x = 0;
  protected float y = 0;

  protected int curr_height = 0; // bottom of object

  protected boolean hovered = false;
  protected boolean in_view = false;
  protected boolean remove = false; // GameMap will remove object

  MapObject() {}
  MapObject(int ID) {
    this.ID = ID;
  }

   public void setStrings(String display_name, String type, String description) {
    this.display_name = display_name;
    this.type = type;
    this.description = description;
  }

   public abstract String display_name();
   public String display_name_editor() {
    return this.display_name();
  }
   public abstract String type();
   public abstract String description();
   public void setDescription(String description) {
    this.description = description;
  }
   public abstract String selectedObjectTextboxText();

   public abstract void setLocation(float x, float y);
   public abstract float xi();
   public abstract float yi();
   public abstract float xf();
   public abstract float yf();
   public abstract float xCenter();
   public abstract float yCenter();
   public abstract float width();
   public abstract float height();
   public abstract float xRadius();
   public abstract float yRadius();

   public boolean inMap(int mapXI, int mapYI, int mapXF, int mapYF) {
    if (this.xi() >= mapXI && this.yi() >= mapYI && this.xf() <= mapXF && this.yf() <= mapYF) {
      return true;
    }
    return false;
  }
   public boolean inMapX(int mapXI, int mapXF) {
    if (this.xi() >= mapXI && this.xf() <= mapXF) {
      return true;
    }
    return false;
  }
   public boolean inMapY(int mapYI, int mapYF) {
    if (this.yi() >= mapYI && this.yf() <= mapYF) {
      return true;
    }
    return false;
  }

   public boolean inView(float xStart, float yStart, float xEnd, float yEnd) {
    if (this.xi() >= xStart - Constants.small_number && this.yi() >= yStart - Constants.small_number &&
      this.xf() <= xEnd + Constants.small_number && this.yf() <= yEnd + Constants.small_number) {
      this.in_view = true;
      return true;
    }
    this.in_view = false;
    return false;
  }

   public float distance(MapObject object) {
    float xDistance = max(0, abs(this.xCenter() - object.xCenter()) - this.xRadius() - object.xRadius());
    float yDistance = max(0, abs(this.yCenter() - object.yCenter()) - this.yRadius() - object.yRadius());
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }
   public float centerDistance(MapObject object) {
    float xDistance = abs(this.xCenter() - object.xCenter());
    float yDistance = abs(this.yCenter() - object.yCenter());
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }
   public float distance(float pointX, float pointY) {
    float xDistance = max(0, abs(this.xCenter() - pointX) - this.xRadius());
    float yDistance = max(0, abs(this.yCenter() - pointY) - this.yRadius());
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }
   public float distanceFromPoint(float pointX, float pointY) {
    float xDistance = this.xCenter() - pointX;
    float yDistance = this.yCenter() - pointY;
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }

   public boolean touching(MapObject object) {
    if ( ((abs(this.xCenter() - object.xCenter()) - this.xRadius() - object.xRadius()) <= 0) ||
      ((abs(this.yCenter() - object.yCenter()) - this.yRadius() - object.yRadius()) <= 0) ) {
        return true;
    }
    return false;
  }

  // returns arraylist of squares the unit is on
   public ArrayList<IntegerCoordinate> getSquaresOn() {
    ArrayList<IntegerCoordinate> squares_on = new ArrayList<IntegerCoordinate>();
    for (int i = round(floor(this.xi())); i < round(ceil(this.xf())); i++) {
      for (int j = round(floor(this.yi())); j < round(ceil(this.yf())); j++) {
        squares_on.add(new IntegerCoordinate(i, j));
      }
    }
    return squares_on;
  }

   public abstract PImage getImage();

   public abstract void update(int timeElapsed);

   public void mouseMove(float mX, float mY) {
    if (mX >= this.xi() && mY >= this.yi() && mX <= this.xf() && mY <= this.yf()) {
      this.hovered = true;
    }
    else {
      this.hovered = false;
    }
  }

   public abstract boolean targetable(Unit u);

   public abstract String fileString();
   public String objectFileString() {
    return "\nlocation: " + this.x + ", " + this.y + ", " + this.curr_height +
      "\ncurr_height: " + this.curr_height + "\nremove: " + this.remove;
  }

   public abstract void addData(String datakey, String data);
   public boolean addObjectData(String datakey, String data) {
    switch(datakey) {
      case "location":
        String[] locationdata = split(data, ',');
        if (locationdata.length < 3) {
          global.errorMessage("ERROR: Location data for object too short: " + data + ".");
          return false;
        }
        this.x = toFloat(trim(locationdata[0]));
        this.y = toFloat(trim(locationdata[1]));
        this.curr_height = toInt(trim(locationdata[2]));
        return true;
      case "curr_height":
        this.curr_height = toInt(data);
        return true;
      case "remove":
        this.remove = toBoolean(data);
        return true;
      case "description":
        this.setDescription(data);
        return true;
    }
    return false;
  }
}
enum MinigameName {
  CHESS, EPIC_FOOLS, ZAMBOS, BENDOUR,
  ;

  private static final List<MinigameName> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String displayName() {
    return MinigameName.displayName(this);
  }
  public static String displayName(MinigameName code) {
    switch(code) {
      case CHESS:
        return "Chess";
      case EPIC_FOOLS:
        return "Epic Fools";
      case ZAMBOS:
        return "Zambos";
      case BENDOUR:
        return "Bendour";
      default:
        return "-- Error --";
    }
  }

  public String fileName() {
    return MinigameName.fileName(this);
  }
  public static String fileName(MinigameName code) {
    switch(code) {
      case CHESS:
        return "CHESS";
      case EPIC_FOOLS:
        return "EPIC_FOOLS";
      case ZAMBOS:
        return "ZAMBOS";
      case BENDOUR:
        return "BENDOUR";
      default:
        return "ERROR";
    }
  }

  public static MinigameName minigameName(String display_name) {
    for (MinigameName code : MinigameName.VALUES) {
      if (MinigameName.displayName(code).equals(display_name) ||
        MinigameName.fileName(code).equals(display_name)) {
        return code;
      }
    }
    return null;
  }

  public String imagePath() {
    return MinigameName.imagePath(this);
  }
  public static String imagePath(MinigameName code) {
    switch(code) {
      case CHESS:
        return "minigames/chess/logo.png";
      default:
        return "minigames/default.png";
    }
  }
}


abstract class Minigame {
  protected boolean completed = false;
  protected MinigameName name;

  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;

  protected int color_background = color(60);

  Minigame(MinigameName name) {
    this.name = name;
  }

   public String displayName() {
    return this.name.displayName();
  }
   public abstract void drawBottomPanel(int time_elapsed);
   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.setDependencyLocations(xi, yi, xf, yf);
  }
   public abstract void setDependencyLocations(float xi, float yi, float xf, float yf);
   public void refreshLocation() {
    this.setLocation(this.xi, this.yi, this.xf, this.yf);
  }
   public abstract void restartTimers();
   public abstract void displayNerdStats();
   public abstract boolean leftPanelElementsHovered();
   public abstract FormLNZ getEscForm();

   public abstract void update(int time_elapsed);
   public abstract void mouseMove(float mX, float mY);
   public abstract void mousePress();
   public abstract void mouseRelease(float mX, float mY);
   public abstract void scroll(int amount);
   public abstract void keyPress();
   public abstract void keyRelease();

   public abstract void loseFocus();
   public abstract void gainFocus();
}
enum MinigameStatus {
  INITIAL, LAUNCHING, PLAYING;
}

class MinigameInterface extends InterfaceLNZ {

  abstract class MinigameButton extends RectangleButton {
    MinigameButton() {
      super(width - Constants.mapEditor_buttonGapSize - Constants.
        minigames_minigameButtonWidth, 0, width - Constants.mapEditor_buttonGapSize, 0);
      this.raised_border = true;
      this.roundness = 0;
      this.setColors(color(170), color(90, 140, 155), color(110, 170, 195), color(80, 130, 150), color(0));
      this.show_message = true;
    }
     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn2");
    }
     public void dehover() {}
     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick1");
    }
  }

  class MinigameButton1 extends MinigameButton {
    MinigameButton1() {
      super();
      this.message = "Main\nMenu";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      MinigameInterface.this.form = new GoToMainMenuForm();
    }
  }


  class GoToMainMenuForm extends ConfirmForm {
    GoToMainMenuForm() {
      super("Main Menu", "Are you sure you want to exit to the main menu?");
    }
     public void submit() {
      this.canceled = true;
      MinigameInterface.this.saveAndExitToMainMenu();
    }
  }


  class MinigameChooser {
    class MinigameChooserButton extends ImageButton {
      private MinigameName minigame;

      MinigameChooserButton(MinigameName minigame) {
        super(global.images.getImage(minigame.imagePath()), 0, 0, 0, 0);
        this.minigame = minigame;
        this.use_time_elapsed = true;
        this.show_message = true;
        this.message = minigame.displayName();
        this.text_size = 22;
        this.color_text = color(255);
      }

      @Override public 
      void drawButton() {
        super.drawButton();
        rectMode(CORNERS);
        strokeWeight(0.01f);
        if (this.clicked) {
          fill(200, 100);
          stroke(200, 100);
          rect(this.xi, this.yi, this.xf, this.yf);
        }
        else if (this.hovered) {
          fill(200, 200);
          stroke(200, 200);
          rect(this.xi, this.yi, this.xf, this.yf);
        }
      }

       public void hover() {
        MinigameChooser.this.hovered(this.minigame);
      }
       public void dehover() {
        MinigameChooser.this.dehovered(this.minigame);
      }
       public void click() {}
       public void release() {
        if (this.hovered) {
          MinigameChooser.this.chooseMinigame(this.minigame);
        }
      }
    }

    private ArrayList<MinigameChooserButton> buttons = new ArrayList<MinigameChooserButton>();
    private ScrollBar scrollbar = new ScrollBar(0, 0, 0, 0, false);
    private MinigameName minigame_hovered = null;

    private float xi = 0;
    private float yi = 0;
    private float xf = 0;
    private float yf = 0;

    private boolean hovered = false;

    MinigameChooser() {
      this.scrollbar.setButtonColors(color(170), color(90, 140, 155),
        color(110, 170, 195), color(80, 130, 150), color(0));
      this.scrollbar.useElapsedTime();
      for (MinigameName minigame : global.profile.minigames) {
        this.buttons.add(new MinigameChooserButton(minigame));
      }
    }

     public void hovered(MinigameName minigame) {
      this.minigame_hovered = minigame;
    }

     public void dehovered(MinigameName minigame) {
      if (minigame == this.minigame_hovered) {
        this.minigame_hovered = null;
      }
    }

     public void chooseMinigame(MinigameName minigame) {
      MinigameInterface.this.launchMinigame(minigame);
    }

     public void setLocation(float xi, float yi, float xf, float yf) {
      this.xi = xi;
      this.yi = yi;
      this.xf = xf;
      this.yf = yf;
      float button_width = this.yf - this.yi - 3 * Constants.minigames_edgeGap - Constants.minigames_scrollbarWidth;
      for (MinigameChooserButton button : this.buttons) {
        button.setLocation(0, 0, button_width, button_width);
      }
      this.scrollbar.setLocation(this.xi + Constants.minigames_edgeGap, this.yf -
        Constants.minigames_edgeGap - Constants.minigames_scrollbarWidth, this.xf -
        Constants.minigames_edgeGap, this.yf - Constants.minigames_edgeGap);
      float all_buttons_width = this.buttons.size() * (button_width + Constants.
        minigames_buttonGap) - Constants.minigames_buttonGap;
      float excess_width = max(0, all_buttons_width - (this.xf - this.xi - 2 * Constants.minigames_edgeGap));
      this.scrollbar.updateMaxValue(round(ceil(excess_width / (button_width + Constants.minigames_edgeGap))));
    }

     public void update(int time_elapsed) {
      this.scrollbar.update(time_elapsed);
      translate(0, this.yi + Constants.minigames_edgeGap);
      float x_translate = this.xi + Constants.minigames_edgeGap;
      for (int i = round(this.scrollbar.value); i < this.buttons.size(); i++) {
        if (x_translate + this.buttons.get(i).button_width() > this.xf) {
          break;
        }
        translate(x_translate, 0);
        this.buttons.get(i).update(time_elapsed);
        translate(-x_translate, 0);
        x_translate += this.buttons.get(i).button_width() + Constants.minigames_buttonGap;
      }
      translate(0, -this.yi - Constants.minigames_edgeGap);
    }

     public void mouseMove(float mX, float mY) {
      this.scrollbar.mouseMove(mX, mY);
      if (mX > this.xi && mX < this.xf && mY > this.yi && mY < this.yf) {
        this.hovered = true;
      }
      else {
        this.hovered = false;
      }
      float x_translate = this.xi + Constants.minigames_edgeGap;
      for (int i = round(this.scrollbar.value); i < this.buttons.size(); i++) {
        if (x_translate + this.buttons.get(i).button_width() > this.xf) {
          break;
        }
        this.buttons.get(i).mouseMove(mX - x_translate, mY - this.yi - Constants.minigames_edgeGap);
        x_translate += this.buttons.get(i).button_width() + Constants.minigames_buttonGap;
      }
    }

     public void mousePress() {
      this.scrollbar.mousePress();
      float x_translate = this.xi + Constants.minigames_edgeGap;
      for (int i = round(this.scrollbar.value); i < this.buttons.size(); i++) {
        if (x_translate + this.buttons.get(i).button_width() > this.xf) {
          break;
        }
        this.buttons.get(i).mousePress();
        x_translate += this.buttons.get(i).button_width() + Constants.minigames_buttonGap;
      }
    }

     public void mouseRelease(float mX, float mY) {
      this.scrollbar.mouseRelease(mX, mY);
      float x_translate = this.xi + Constants.minigames_edgeGap;
      for (int i = round(this.scrollbar.value); i < this.buttons.size(); i++) {
        if (x_translate + this.buttons.get(i).button_width() > this.xf) {
          break;
        }
        this.buttons.get(i).mouseRelease(mX - x_translate, mY - this.yi - Constants.minigames_edgeGap);
        x_translate += this.buttons.get(i).button_width() + Constants.minigames_buttonGap;
      }
    }

     public void scroll(int amount) {
      if (this.hovered) {
        this.scrollbar.increaseValue(amount);
      }
    }
  }


  class InitializeMinigameThread extends Thread {
    private MinigameName name;
    private Minigame minigame;
    InitializeMinigameThread(MinigameName name) {
      super("InitializeMinigameThread");
      this.name = name;
    }
    @Override public 
    void run() {
      this.minigame = MinigameInterface.this.initializeMinigame(this.name);
      global.images.loadMinigameImages(this.name);
    }
  }


  class MouseMoveThread extends Thread {
    private float mX = 0;
    private float mY = 0;
    private boolean start_again = false;
    private float next_mX = 0;
    private float next_mY = 0;
    MouseMoveThread(float mX, float mY) {
      super("MouseMoveThread");
      this.mX = mX;
      this.mY = mY;
    }
     public void startAgain(float mX, float mY) {
      this.start_again = true;
      this.next_mX = mX;
      this.next_mY = mY;
    }
    @Override public 
    void run() {
      while(true) {
        boolean refreshMapLocation = false;
        if (MinigameInterface.this.status == MinigameStatus.INITIAL) {
          MinigameInterface.this.minigame_chooser.mouseMove(this.mX, this.mY);
        }
        // minigame mouse move
        if (MinigameInterface.this.minigame != null) {
          MinigameInterface.this.minigame.mouseMove(this.mX, this.mY);
          if (MinigameInterface.this.bottomPanel.clicked) {
            refreshMapLocation = true;
          }
        }
        // right panel mouse move
        MinigameInterface.this.bottomPanel.mouseMove(this.mX, this.mY);
        if (MinigameInterface.this.bottomPanel.open && !MinigameInterface.this.bottomPanel.collapsing) {
          for (MinigameButton button : MinigameInterface.this.buttons) {
            button.mouseMove(this.mX, this.mY);
          }
        }
        // refresh minigame location
        if (refreshMapLocation) {
          if (MinigameInterface.this.minigame != null) {
            MinigameInterface.this.minigame.setLocation(0, 0, width, height - MinigameInterface.this.bottomPanel.size);
          }
        }
        // cursor icon resolution
        if (MinigameInterface.this.bottomPanel.clicked) {
          MinigameInterface.this.resizeButtons();
          global.setCursor("icons/cursor_resizeh_white.png");
        }
        else if (MinigameInterface.this.bottomPanel.hovered) {
          global.setCursor("icons/cursor_resizeh.png");
        }
        else {
          global.defaultCursor("icons/cursor_resizeh_white.png", "icons/cursor_resizeh.png");
        }
        if (this.start_again) {
          this.mX = this.next_mX;
          this.mY = this.next_mY;
          this.start_again = false;
          continue;
        }
        break;
      }
    }
  }


  private MinigameButton[] buttons = new MinigameButton[1];
  private Panel bottomPanel = new Panel(DOWN, Constants.minigames_panelWidth);
  private MinigameChooser minigame_chooser = new MinigameChooser();
  private InitializeMinigameThread initialize_minigame_thread = null;
  private MouseMoveThread mouse_move_thread = null;

  private Minigame minigame = null;
  private MinigameStatus status = MinigameStatus.INITIAL;
  private boolean return_to_playing = false;
  private int last_update_time = millis();


  MinigameInterface() {
    this.buttons[0] = new MinigameButton1();
    this.bottomPanel.removeButton();
    this.bottomPanel.cant_resize = true;
    this.bottomPanel.color_background = color(50, 80, 100, 150);
    this.resizeButtons();
  }


   public void resizeButtons() {
    float buttonSize = (this.bottomPanel.size_curr - 5 * Constants.mapEditor_buttonGapSize) / 2.0f;
    float yf = height - Constants.mapEditor_buttonGapSize;
    this.buttons[0].setYLocation(yf - buttonSize, yf);
    yf -= buttonSize + Constants.mapEditor_buttonGapSize;
    this.minigame_chooser.setLocation(5, height + 5 - this.bottomPanel.size, this.buttons[0].xi - 5, height - 5);
  }


   public Minigame initializeMinigame(MinigameName code) {
    switch(code) {
      case CHESS:
        return new Chess();
      default:
        return null;
    }
  }


   public void launchMinigame(MinigameName name) {
    if (this.minigame != null || this.status != MinigameStatus.INITIAL) {
      global.errorMessage("ERROR: Can't launch minigame when playing one.");
      return;
    }
    this.status = MinigameStatus.LAUNCHING;
    this.initialize_minigame_thread = new InitializeMinigameThread(name);
    this.initialize_minigame_thread.start();
  }

   public void completedMinigame() {
    if (this.minigame == null || this.status != MinigameStatus.PLAYING) {
      global.errorMessage("ERROR: Can't complete minigame when not playing one.");
      return;
    }
    global.log("Completed minigame " + this.minigame.displayName() + ".");
    if (this.return_to_playing) {
      global.state = ProgramState.ENTERING_PLAYING;
    }
    this.status = MinigameStatus.INITIAL;
    this.minigame = null;
  }


   public Hero getCurrentHeroIfExists() {
    return null;
  }

   public void saveAndExitToMainMenu() {
    this.minigame = null;
    this.status = MinigameStatus.INITIAL;
    global.state = ProgramState.ENTERING_MAINMENU;
  }

   public void loseFocus() {
    if (this.minigame != null) {
      this.minigame.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.minigame != null) {
      this.minigame.gainFocus();
    }
  }

   public void restartTimers() {
    if (this.minigame != null) {
      this.minigame.restartTimers();
    }
  }

   public void update(int millis) {
    int time_elapsed = millis - this.last_update_time;
    boolean refreshMinigameLocation = false;
    switch(this.status) {
      case INITIAL:
        rectMode(CORNERS);
        stroke(60);
        fill(60);
        rect(0, 0, width, height - this.bottomPanel.size);
        this.minigame_chooser.update(time_elapsed);
        if (this.minigame_chooser.minigame_hovered != null) {
          imageMode(CENTER);
          image(global.images.getImage(this.minigame_chooser.minigame_hovered.
            imagePath()), 0.5f * width, 0.5f * (height - this.bottomPanel.size),
            0.4f * (height - this.bottomPanel.size), 0.4f * (height - this.bottomPanel.size));
          fill(255);
          textSize(50);
          textAlign(CENTER, TOP);
          text(this.minigame_chooser.minigame_hovered.displayName(), 0.5f * width, 5);
        }
        break;
      case LAUNCHING:
        rectMode(CORNERS);
        stroke(60);
        fill(60);
        rect(0, 0, width, height - this.bottomPanel.size);
        if (this.initialize_minigame_thread == null) {
          this.status = MinigameStatus.INITIAL;
          break;
        }
        if (this.initialize_minigame_thread.isAlive()) {
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
          break;
        }
        if (this.initialize_minigame_thread.minigame == null) {
          this.status = MinigameStatus.INITIAL;
          this.initialize_minigame_thread = null;
          break;
        }
        this.minigame = this.initialize_minigame_thread.minigame;
        this.status = MinigameStatus.PLAYING;
        this.minigame.setLocation(0, 0, width, height - this.bottomPanel.size);
        this.initialize_minigame_thread = null;
        break;
      case PLAYING:
        if (this.minigame != null) {
          rectMode(CORNERS);
          stroke(this.minigame.color_background);
          fill(this.minigame.color_background);
          rect(0, 0, width, height - this.bottomPanel.size);
          this.minigame.update(time_elapsed);
          if (this.bottomPanel.collapsing) {
            refreshMinigameLocation = true;
          }
          if (this.minigame.completed) {
            this.completedMinigame();
          }
        }
        else {
          rectMode(CORNERS);
          stroke(60);
          fill(60);
          rect(0, 0, width, height - this.bottomPanel.size);
          global.errorMessage("ERROR: In playing status but no level to update.");
          this.status = MinigameStatus.INITIAL;
        }
        break;
      default:
        global.errorMessage("ERROR: Minigame status " + this.status + " not recognized.");
        break;
    }
    this.bottomPanel.update(millis);
    if (this.bottomPanel.open && !this.bottomPanel.collapsing) {
      for (MinigameButton button : this.buttons) {
        button.update(millis);
      }
      if (this.minigame != null) {
        this.minigame.drawBottomPanel(time_elapsed);
      }
    }
    if (refreshMinigameLocation) {
      if (this.minigame != null) {
        this.minigame.setLocation(0, 0, width, height - this.bottomPanel.size);
      }
    }
    this.last_update_time = millis;
  }

   public void showNerdStats() {
    if (this.minigame != null) {
      this.minigame.displayNerdStats();
    }
    else {
      fill(255);
      textSize(14);
      textAlign(LEFT, TOP);
      float y_stats = 1;
      float line_height = textAscent() + textDescent() + 2;
      text("FPS: " + PApplet.parseInt(global.lastFPS), 1, y_stats);
    }
  }

   public void mouseMove(float mX, float mY) {
    if (this.mouse_move_thread != null && this.mouse_move_thread.isAlive()) {
      this.mouse_move_thread.startAgain(mX, mY);
    }
    this.mouse_move_thread = new MouseMoveThread(mX, mY);
    this.mouse_move_thread.start();
  }

   public void mousePress() {
    if (this.minigame != null) {
      this.minigame.mousePress();
    }
    if (this.status == MinigameStatus.INITIAL) {
      this.minigame_chooser.mousePress();
    }
    this.bottomPanel.mousePress();
    if (this.bottomPanel.clicked) {
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png");
    }
    if (this.bottomPanel.open && !this.bottomPanel.collapsing) {
      for (MinigameButton button : this.buttons) {
        button.mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.minigame != null) {
      this.minigame.mouseRelease(mX, mY);
    }
    if (this.status == MinigameStatus.INITIAL) {
      this.minigame_chooser.mouseRelease(mX, mY);
    }
    this.bottomPanel.mouseRelease(mX, mY);
    if (this.bottomPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh.png", "icons/cursor_resizeh_white.png");
    }
    if (this.bottomPanel.open && !this.bottomPanel.collapsing) {
      for (MinigameButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
    }
  }

   public void scroll(int amount) {
    if (this.minigame != null) {
      this.minigame.scroll(amount);
    }
    if (this.status == MinigameStatus.INITIAL) {
      this.minigame_chooser.scroll(amount);
    }
  }

   public void keyPress() {
    if (this.minigame != null) {
      this.minigame.keyPress();
    }
  }

   public void openEscForm() {
    if (this.minigame != null) {
      this.form = this.minigame.getEscForm();
    }
  }

   public void keyRelease() {
    if (this.minigame != null) {
      this.minigame.keyRelease();
    }
  }
}
enum ChessState {
  ANALYSIS, HUMAN_VS_HUMAN, HUMAN_VS_COMPUTER, COMPUTER_VS_COMPUTER;
  public boolean playingGame() {
    switch(this) {
      case HUMAN_VS_HUMAN:
      case HUMAN_VS_COMPUTER:
      case COMPUTER_VS_COMPUTER:
        return true;
      default:
        return false;
    }
  }
  public String titleString() {
    switch(this) {
      case ANALYSIS:
        return "Analysis";
      case HUMAN_VS_HUMAN:
        return "Human vs. Human";
      case HUMAN_VS_COMPUTER:
        return "Human vs. AI";
      case COMPUTER_VS_COMPUTER:
        return "AI vs. AI";
      default:
        return "";
    }
  }
}

class Chess extends Minigame {
  abstract class MoveBoxButton extends ImageButton {
    protected float width_ratio = 0.85f; // ratio of width to height
    protected boolean show_hover_message = false;

    MoveBoxButton(String icon_name) {
      super(global.images.getImage("icons/" + icon_name + ".png"), 0, 0, 0, 0);
      this.use_time_elapsed = true;
      this.overshadow_colors = true;
      this.setColors(color(170, 170), color(1, 0), color(100, 80), color(200, 160), color(0));
    }

    @Override public 
    void drawButton() {
      super.drawButton();
      if (this.show_hover_message) {
        // show hover message
      }
    }

     public void hover() {
      this.show_hover_message = true;
    }
     public void dehover() {
      this.show_hover_message = false;
    }
     public void click() {}
     public void release() {
      if (this.hovered) {
        this.buttonFunction();
      }
    }

     public abstract void buttonFunction();
  }

  class SpacerButton extends MoveBoxButton {
    SpacerButton(float width_ratio) {
      super("first");
      this.img = global.images.getTransparentPixel();
      this.width_ratio = width_ratio;
      this.overshadow_colors = false;
    }
     public void buttonFunction() {}
  }

  class ViewFirstButton extends MoveBoxButton {
    ViewFirstButton() {
      super("first");
      this.width_ratio = 1.0f;
    }
     public void buttonFunction() {
      Chess.this.viewFirst();
    }
  }

  class ViewLastButton extends MoveBoxButton {
    ViewLastButton() {
      super("last");
      this.width_ratio = 1.0f;
    }
     public void buttonFunction() {
      Chess.this.viewLast();
    }
  }

  class ViewPreviousButton extends MoveBoxButton {
    ViewPreviousButton() {
      super("previous");
      this.width_ratio = 1.4f;
    }
     public void buttonFunction() {
      Chess.this.viewPrevious();
    }
  }

  class ViewNextButton extends MoveBoxButton {
    ViewNextButton() {
      super("next");
      this.width_ratio = 1.4f;
    }
     public void buttonFunction() {
      Chess.this.viewNext();
    }
  }

  class RotateBoardButton extends MoveBoxButton {
    RotateBoardButton() {
      super("flip");
    }
     public void buttonFunction() {
      Chess.this.flipBoard();
    }
  }

  class ResetButton extends MoveBoxButton {
    ResetButton() {
      super("reset");
    }
     public void buttonFunction() {
      Chess.this.resetAnalysisBoard();
    }
  }

  class OfferDrawButton extends MoveBoxButton {
    OfferDrawButton() {
      super("draw");
    }
     public void buttonFunction() {
      Chess.this.offerDraw();
    }
  }

  class ResignButton extends MoveBoxButton {
    ResignButton() {
      super("resign");
    }
     public void buttonFunction() {
      Chess.this.resign();
    }
  }

  class StopGameButton extends MoveBoxButton {
    StopGameButton() {
      super("hand_stop");
    }
     public void buttonFunction() {
      Chess.this.stopGame();
    }
  }

  class MenuButton extends MoveBoxButton {
    MenuButton() {
      super("menu");
    }
     public void buttonFunction() {
      Chess.this.toggleMenuForm();
    }
  }

  class RestartGameButton extends MoveBoxButton {
    protected ChessState state;
    RestartGameButton(ChessState state) {
      super("reset");
      this.state = state;
      switch(state) {
        case HUMAN_VS_HUMAN:
          this.img = global.images.getImage("icons/human.png");
          break;
        case HUMAN_VS_COMPUTER:
          this.img = global.images.getImage("icons/human_ai.png");
          break;
        case COMPUTER_VS_COMPUTER:
          this.img = global.images.getImage("icons/ai.png");
          break;
      }
    }
     public void buttonFunction() {
      switch(this.state) {
        case HUMAN_VS_HUMAN:
          Chess.this.startHumanVsHumanGame();
          break;
        case HUMAN_VS_COMPUTER:
          Chess.this.startGameVsComputer(true);
          break;
        case COMPUTER_VS_COMPUTER:
          Chess.this.startComputerVsComputerGame();
          break;
      }
    }
  }


  abstract class MoveBox {
    class MoveContainer extends ListTextBox {
      MoveContainer() {
        super();
        this.useElapsedTime();
        this.color_background = color(40);
        this.color_header = color(80);
        this.color_stroke = color(20);
        this.color_text = color(245);
        this.color_title = color(255);
        this.scrollbar_max_width = 35;
        this.scrollbar.setButtonColors(color(170), color(60), color(100), color(20), color(0));
        this.scrollbar.button_upspace.setColors(color(170), color(0), color(0), color(200), color(0));
        this.scrollbar.button_downspace.setColors(color(170), color(0), color(0), color(200), color(0));
        this.hover_color = color(200, 200, 100, 60);
        this.highlight_color = color(240, 240, 60, 120);
        this.can_unclick_outside_box = false;
      }

      @Override public 
      void update(int time_elapsed) {
        int last_line_clicked = this.line_clicked;
        this.line_clicked = Chess.this.current_view - 1;
        if (this.line_clicked != last_line_clicked) {
          this.jump_to_line();
        }
        super.update(time_elapsed);
      }

      @Override public 
      void jump_to_line(boolean hard_jump) {
        if (hard_jump || this.line_clicked < PApplet.parseInt(floor(this.scrollbar.value))) {
          this.scrollbar.updateValue(this.line_clicked);
          return;
        }
        int lines_shown = this.text_lines.size() - PApplet.parseInt(this.scrollbar.maxValue);
        if (this.line_clicked >= PApplet.parseInt(this.scrollbar.value) + lines_shown) {
          this.scrollbar.increaseValue(2 + this.line_clicked - PApplet.parseInt(this.scrollbar.value) - lines_shown);
        }
        else if (this.line_clicked < PApplet.parseInt(this.scrollbar.value)) {
          this.scrollbar.decreaseValue(PApplet.parseInt(this.scrollbar.value) - this.line_clicked);
        }
      }

       public void click() {
        Chess.this.setCurrentView(this.line_clicked + 1);
      }

       public void doubleclick() {
      }
    }


    class MenuForm extends Form {
      private boolean hidden = true;
      private boolean canceled = false;

      MenuForm() {
        super();
        this.color_background = color(210);
        this.color_header = color(170);
        this.color_title = color(0);
        this.color_stroke = color(20);
        this.setTitleText("Create Game");
      }

       public void toggle(ChessState state) {
        this.hidden = !this.hidden;
        if (this.hidden) {
          this.clearFields();
          return;
        }
        this.canceled = false;
        switch(state) {
          case ANALYSIS:
            ArrayList<ToggleFormFieldInput> toggle_input = new ArrayList<ToggleFormFieldInput>();
            toggle_input.add(new ToggleFormFieldInput("  vs Human", global.images.getImage("icons/human.png")));
            toggle_input.add(new ToggleFormFieldInput("  vs AI", global.images.getImage("icons/human_ai.png")));
            toggle_input.add(new ToggleFormFieldInput("  AI vs AI", global.images.getImage("icons/ai.png")));
            ToggleFormField toggle = new ToggleFormField(toggle_input);
            toggle.setTextSize(36);
            SubmitCancelFormField submit_cancel = new SubmitCancelFormField("Play", "Cancel");

            this.addField(new SpacerFormField(60));
            this.addField(toggle);
            this.addField(submit_cancel);
            break;
          default:
            this.hidden = true;
            this.clearFields();
            break;
        }
      }

       public void submit() {
        switch(this.fields.get(1).getValue()) {
          case "0":
            Chess.this.startHumanVsHumanGame();
            break;
          case "1":
            Chess.this.startGameVsComputer();
            break;
          case "2":
            Chess.this.startComputerVsComputerGame();
            break;
          default:
            break;
        }
        this.cancel();
      }

       public void cancel() {
        this.canceled = true;
      }

       public void buttonPress(int index) {
      }

     @Override public 
      void update(int time_elapsed) {
        if (this.hidden) {
          return;
        }
        super.update(time_elapsed);
        if (this.canceled) {
          Chess.this.toggleMenuForm();
          this.canceled = false;
        }
      }

     @Override public 
      void mouseMove(float mX, float mY) {
        if (this.hidden) {
          return;
        }
        super.mouseMove(mX, mY);
      }

     @Override public 
      void mousePress() {
        if (this.hidden) {
          return;
        }
        super.mousePress();
      }

     @Override public 
      void mouseRelease(float mX, float mY) {
        if (this.hidden) {
          return;
        }
        super.mouseRelease(mX, mY);
      }
    }


    protected MoveContainer moves = new MoveContainer();
    protected MenuForm menu_form = new MenuForm();
    protected ArrayList<MoveBoxButton> buttons = new ArrayList<MoveBoxButton>();
    protected float button_min_size = 50;
    protected float button_gap = 5;

    protected float xi = 0;
    protected float yi = 0;
    protected float xf = 0;
    protected float yf = 0;

    MoveBox() {
      this.addButtons();
      this.moves.setTitleText(Chess.this.state.titleString());
    }

     public abstract void addButtons();

     public void refreshLocation() {
      this.setLocation(this.xi, this.yi, this.xf, this.yf);
    }
     public void setLocation(float xi, float yi, float xf, float yf) {
      this.xi = xi;
      this.yi = yi;
      this.xf = xf;
      this.yf = yf;
      float button_weight = 0;
      for (MoveBoxButton button : this.buttons) {
        button_weight += button.width_ratio;
      }
      float button_height = 0;
      if (button_weight != 0) {
        button_height = min(this.button_min_size, (xf - xi - (this.buttons.size() - 1) * this.button_gap) / button_weight);
      }
      this.moves.setLocation(xi + this.button_gap, yi + this.button_gap,
        xf - this.button_gap, yf - 2 * this.button_gap - button_height);
      this.menu_form.setLocation(xi + this.button_gap, yi + this.button_gap,
        xf - this.button_gap, yf - 2 * this.button_gap - button_height);
      float x_curr = xi;
      for (MoveBoxButton button : this.buttons) {
        float button_width = button.width_ratio * button_height;
        button.setLocation(x_curr, yf - this.button_gap - button_height,
          x_curr + button_width, yf - this.button_gap);
        x_curr += button_width + this.button_gap;
      }
    }

     public void addMove(ChessMove move, ChessColor in_check) {
      String moveString = move.pgnString();
      if (in_check != null) {
        moveString += "+";
      }
      if (move.source_color == ChessColor.WHITE) {
        moveString = Integer.toString(1 + Chess.this.chessboard.moves.size() / 2) +
          ". " + moveString + " ...";
      }
      else {
        moveString = "       ... " + moveString;
      }
      this.moves.addLine(moveString);
    }

     public void gameEnded(GameEnds ends) {
      this.moves.addLine(ends.displayName());
      this.adjustButtonsForGameEnd();
      this.refreshLocation();
    }
     public abstract void adjustButtonsForGameEnd();

     public void update(int time_elapsed) {
      if (this.menu_form.hidden) {
        this.moves.update(time_elapsed);
      }
      else {
        this.menu_form.update(time_elapsed);
      }
      for (MoveBoxButton button : this.buttons) {
        button.update(time_elapsed);
      }
    }

     public void mouseMove(float mX, float mY) {
      if (this.menu_form.hidden) {
        this.moves.mouseMove(mX, mY);
      }
      else {
        this.menu_form.mouseMove(mX, mY);
      }
      for (MoveBoxButton button : this.buttons) {
        button.mouseMove(mX, mY);
      }
    }

     public void mousePress() {
      if (this.menu_form.hidden) {
        this.moves.mousePress();
      }
      else {
        this.menu_form.mousePress();
      }
      for (MoveBoxButton button : this.buttons) {
        button.mousePress();
      }
    }

     public void mouseRelease(float mX, float mY) {
      if (this.menu_form.hidden) {
        this.moves.mouseRelease(mX, mY);
      }
      else {
        this.menu_form.mouseRelease(mX, mY);
      }
      for (MoveBoxButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
    }

     public void scroll(int amount) {
      this.moves.scroll(amount);
    }

     public void keyPress() {
      this.moves.keyPress();
    }

     public void keyRelease() {
    }
  }


  class AnalysisMoveBox extends MoveBox {
    AnalysisMoveBox() {
      super();
    }

     public void addButtons() {
      this.buttons.add(new RotateBoardButton());
      this.buttons.add(new SpacerButton(0.3f));
      this.buttons.add(new ViewFirstButton());
      this.buttons.add(new ViewPreviousButton());
      this.buttons.add(new ViewNextButton());
      this.buttons.add(new ViewLastButton());
      this.buttons.add(new SpacerButton(0.3f));
      this.buttons.add(new ResetButton());
      this.buttons.add(new MenuButton());
    }

     public void adjustButtonsForGameEnd() {
    }
  }


  class PlayingMoveBox extends MoveBox {
    PlayingMoveBox() {
      super();
    }

     public void addButtons() {
      this.buttons.add(new RotateBoardButton());
      this.buttons.add(new SpacerButton(0.3f));
      this.buttons.add(new ViewFirstButton());
      this.buttons.add(new ViewPreviousButton());
      this.buttons.add(new ViewNextButton());
      this.buttons.add(new ViewLastButton());
      this.buttons.add(new SpacerButton(0.3f));
      switch(Chess.this.state) {
        case HUMAN_VS_HUMAN:
        case HUMAN_VS_COMPUTER:
          this.buttons.add(new OfferDrawButton());
          this.buttons.add(new ResignButton());
          break;
        case COMPUTER_VS_COMPUTER:
          this.buttons.add(new SpacerButton(0.85f));
          this.buttons.add(new StopGameButton());
          break;
        default:
          break;
      }
    }

     public void adjustButtonsForGameEnd() {
      this.buttons.set(7, new RestartGameButton(Chess.this.state));
      this.buttons.set(8, new MenuButton());
    }
  }

  private ChessBoard chessboard = new ChessBoard();
  private ArrayList<ChessBoard> chessboard_views = new ArrayList<ChessBoard>();
  private int current_view = 0;
  private ChessState state = ChessState.ANALYSIS;
  private boolean game_ended = false;
  private MoveBox move_box = new AnalysisMoveBox();

  private ChessAI chess_ai = new ChessAI();
  private ChessAI opposing_chess_ai = null;
  private boolean computers_turn = false;
  private int computers_time_left = 0;

  Chess() {
    super(MinigameName.CHESS);
    this.color_background = color(90);
    this.chessboard.setupBoard();
    this.initialChessboardView();
  }

   public ChessBoard chessboardView() {
    if (this.current_view >= this.chessboard_views.size()) {
      return null;
    }
    return this.chessboard_views.get(this.current_view);
  }

   public void initialChessboardView() {
    ChessBoard copied_board = new ChessBoard(this.chessboard);
    copied_board.toggle_human_controllable = true;
    this.chessboard_views.clear();
    this.chessboard_views.add(copied_board);
    this.current_view = 0;
    this.chessboard.toggle_human_controllable = false;
  }

   public void updateView(ChessMove move) {
    ChessBoard copied_board = new ChessBoard(this.chessboard_views.get(this.chessboard_views.size() - 1));
    copied_board.makeMove(move, false);
    copied_board.toggle_human_controllable = true;
    this.chessboard_views.add(copied_board);
    this.current_view = this.chessboard_views.size() - 1;
    this.chessboard.toggle_human_controllable = false;
  }

   public void setCurrentView(int new_view) {
    this.current_view = new_view;
    if (this.current_view < 0) {
      this.current_view = 0;
    }
    else if (this.current_view > this.chessboard_views.size() - 1) {
      this.current_view = this.chessboard_views.size() - 1;
    }
    if (this.current_view == this.chessboard_views.size() - 1) {
      this.chessboard.toggle_human_controllable = true;
    }
    else {
      this.chessboard.toggle_human_controllable = false;
    }
    this.refreshChessboardViewLocation();
  }

   public void viewFirst() {
    this.current_view = 0;
    if (this.chessboard_views.size() > 1) {
      this.chessboard.toggle_human_controllable = true;
    }
    this.refreshChessboardViewLocation();
  }

   public void viewLast() {
    this.current_view = this.chessboard_views.size() - 1;
    this.chessboard.toggle_human_controllable = false;
    this.refreshChessboardViewLocation();
  }

   public void viewPrevious() {
    if (this.current_view > 0) {
      this.current_view--;
      this.chessboard.toggle_human_controllable = true;
    }
    this.refreshChessboardViewLocation();
  }

   public void viewNext() {
    if (this.current_view < this.chessboard_views.size() - 1) {
      this.current_view++;
      if (this.current_view == this.chessboard_views.size() - 1) {
        this.chessboard.toggle_human_controllable = false;
      }
    }
    this.refreshChessboardViewLocation();
  }

   public void flipBoard() {
    switch(this.chessboard.orientation) {
      case RIGHT:
        this.chessboard.orientation = BoardOrientation.LEFT;
        break;
      case LEFT:
        this.chessboard.orientation = BoardOrientation.RIGHT;
        break;
    }
    this.chessboardView().orientation = this.chessboard.orientation;
  }

   public void resetAnalysisBoard() {
    if (this.state != ChessState.ANALYSIS) {
      global.errorMessage("ERROR: Can't reset analyis when not in analysis.");
      return;
    }
    this.chessboard.resetAnalysis();
    this.initialChessboardView();
    this.chess_ai.reset();
    this.move_box = new AnalysisMoveBox();
    this.refreshLocation();
  }

   public void toggleMenuForm() {
    if (this.state == ChessState.ANALYSIS || this.chessboard.game_ended != null) {
      this.move_box.menu_form.toggle(ChessState.ANALYSIS);
    }
    else {
      this.move_box.menu_form.toggle(this.state);
    }
  }

   public void startGameVsComputer() {
    this.startGameVsComputer(false);
  }
   public void startGameVsComputer(boolean restarted) {
    if (this.state.playingGame() && this.chessboard.game_ended == null) {
      global.errorMessage("ERROR: Can't start game vs computer while in game.");
      return;
    }
    this.state = ChessState.HUMAN_VS_COMPUTER;
    this.move_box = new PlayingMoveBox();
    this.chessboard.setupBoard();
    this.initialChessboardView();
    this.chess_ai.reset();
    this.opposing_chess_ai = null;
    if (restarted && this.chessboard.human_controlled == HumanMovable.WHITE) {
      this.chessboard.human_controlled = HumanMovable.BLACK;
      this.chessboard.orientation = BoardOrientation.LEFT;
      this.chess_ai.decision_algorithm = DecisionAlgorithm.BEST_MOVE_WHITE;
      this.startComputersTurn();
    }
    else if ((restarted && this.chessboard.human_controlled == HumanMovable.BLACK) || randomChance(0.5f)) {
      this.chessboard.human_controlled = HumanMovable.WHITE;
      this.chessboard.orientation = BoardOrientation.RIGHT;
      this.chess_ai.decision_algorithm = DecisionAlgorithm.BEST_MOVE_BLACK;
    }
    else {
      this.chessboard.human_controlled = HumanMovable.BLACK;
      this.chessboard.orientation = BoardOrientation.LEFT;
      this.chess_ai.decision_algorithm = DecisionAlgorithm.BEST_MOVE_WHITE;
      this.startComputersTurn();
    }
    this.refreshLocation();
  }

   public void startComputerVsComputerGame() {
    if (this.state.playingGame() && this.chessboard.game_ended == null) {
      global.errorMessage("ERROR: Can't start computer vs computer during a game.");
      return;
    }
    this.state = ChessState.COMPUTER_VS_COMPUTER;
    this.move_box = new PlayingMoveBox();
    this.chessboard.setupBoard();
    this.initialChessboardView();
    this.chess_ai.reset(); // white
    this.opposing_chess_ai = new ChessAI(); // black
    this.chessboard.human_controlled = HumanMovable.NONE;
    this.chessboard.orientation = BoardOrientation.RIGHT;
    this.startComputersTurn();
    this.refreshLocation();
  }

   public void startHumanVsHumanGame() {
    if (this.state.playingGame() && this.chessboard.game_ended == null) {
      global.errorMessage("ERROR: Can't start computer vs computer during a game.");
      return;
    }
    this.state = ChessState.HUMAN_VS_HUMAN;
    this.move_box = new PlayingMoveBox();
    this.chessboard.setupBoard();
    this.initialChessboardView();
    this.chess_ai.reset(); // white
    this.opposing_chess_ai = null;
    this.chessboard.human_controlled = HumanMovable.BOTH;
    this.chessboard.orientation = BoardOrientation.RIGHT;
    this.refreshLocation();
  }

   public void offerDraw() {
    if (!this.state.playingGame() || this.chessboard.game_ended != null) {
      global.errorMessage("ERROR: Can't offer draw not during a game.");
      return;
    }
    if (this.chessboard.humanCanMakeMove()) {
      this.chessboard.offerDraw();
      if (this.chessboard.game_ended != null) {
        this.move_box.gameEnded(this.chessboard.game_ended);
      }
    }
  }

   public void resign() {
    if (!this.state.playingGame() || this.chessboard.game_ended != null) {
      global.errorMessage("ERROR: Can't resign not during a game.");
      return;
    }
    if (this.chessboard.humanCanMakeMove()) {
      this.chessboard.resign();
      if (this.chessboard.game_ended != null) {
        this.move_box.gameEnded(this.chessboard.game_ended);
      }
    }
  }

   public void stopGame() {
    this.chessboard.human_controlled = HumanMovable.BOTH;
    this.move_box.adjustButtonsForGameEnd();
  }

   public void drawBottomPanel(int time_elapsed) {}
   public void setDependencyLocations(float xi, float yi, float xf, float yf) {
    this.chessboard.setLocation(xi + Constants.minigames_chessPanelsSize +
      Constants.minigames_edgeGap, yi + Constants.minigames_edgeGap, xf -
      Constants.minigames_chessPanelsSize - Constants.minigames_edgeGap, yf -
      Constants.minigames_edgeGap);
    this.refreshChessboardViewLocation();
    this.move_box.setLocation(xf - Constants.minigames_chessPanelsSize, yi, xf, yf);
  }
   public void refreshChessboardViewLocation() {
    if (this.chessboardView() == null) {
      return;
    }
    this.chessboardView().setLocation(this.xi + Constants.minigames_chessPanelsSize +
      Constants.minigames_edgeGap, this.yi + Constants.minigames_edgeGap, this.xf -
      Constants.minigames_chessPanelsSize - Constants.minigames_edgeGap, this.yf -
      Constants.minigames_edgeGap);
    this.chessboardView().orientation = this.chessboard.orientation;
  }
   public void restartTimers() {}
   public void displayNerdStats() {
    fill(255);
    textSize(14);
    textAlign(LEFT, TOP);
    float y_stats = 1;
    float line_height = textAscent() + textDescent() + 2;
    text("FPS: " + PApplet.parseInt(global.lastFPS), 1, y_stats);
  }
   public boolean leftPanelElementsHovered() {
    return false;
  }
   public FormLNZ getEscForm() {
    return null;
  }

   public void startComputersTurn() {
    this.computers_turn = true;
    this.computers_time_left = 100;
  }

   public void update(int time_elapsed) {
    if (this.current_view < this.chessboard_views.size() - 1) {
      this.chessboardView().update(time_elapsed);
      this.chessboard.updateWithoutDisplay(time_elapsed);
    }
    else {
      this.chessboard.update(time_elapsed);
    }
    if (this.computers_turn) {
      this.computers_time_left -= time_elapsed;
      if (this.computers_time_left < 0) {
        this.computers_turn = false;
        ChessMove computers_move = this.chess_ai.getMove();
        if (computers_move == null) {
          if (this.chessboard.game_ended == null) {
            global.errorMessage("ERROR: Chess AI returned null move when game not over.");
            this.chessboard.makeRandomMove();
          }
        }
        else if (chessboard.valid_moves.contains(computers_move)) {
          this.chessboard.makeMove(computers_move);
        }
        else {
          String move_string = "Null";
          if (computers_move != null) {
            move_string = computers_move.pgnString();
          }
          String valid_moves = "";
          for (ChessMove move : this.chessboard.valid_moves) {
            valid_moves += "\n" + move.pgnString();
          }
          global.errorMessage("ERROR: Chess AI returned invalid move:\n" + move_string +
            "\n\nValid moves are:" + valid_moves);
          this.chessboard.makeRandomMove();
        }
      }
    }
    while (this.chessboard.move_queue.peek() != null) {
      ChessMove move = this.chessboard.move_queue.poll();
      this.chess_ai.addMove(move);
      this.updateView(move);
      this.move_box.addMove(move, this.chessboard_views.get(this.chessboard_views.size() - 1).in_check);
      if (this.chessboard.game_ended != null) {
        this.move_box.gameEnded(this.chessboard.game_ended);
      }
      else if (this.chessboard.computersTurn()) {
        this.startComputersTurn();
      }
    }
    this.move_box.update(time_elapsed);
    this.chess_ai.update(time_elapsed);
    fill(ccolor(255));
    textSize(20);
    textAlign(RIGHT, TOP);
    float curr_x = 26;
    text(this.chess_ai.head_node.evaluation.displayString(), this.chessboard.xi - 4, curr_x);
    if (this.chess_ai.thread == null) {
      return;
    }
    curr_x += 26;
    textSize(18);
    text("at depth: " + this.chess_ai.thread.current_depth, this.chessboard.xi - 4, curr_x);
    curr_x += 22;
    text("nodes: " + this.chess_ai.thread.nodes_evaluated, this.chessboard.xi - 4, curr_x);
    curr_x += 22;
    text("nodes / s: " + this.chess_ai.thread.nodes_per_second, this.chessboard.xi - 4, curr_x);
  }
   public void mouseMove(float mX, float mY) {
    this.chessboard.mouseMove(mX, mY);
    this.move_box.mouseMove(mX, mY);
  }
   public void mousePress() {
    this.chessboard.mousePress();
    this.move_box.mousePress();
  }
   public void mouseRelease(float mX, float mY) {
    this.chessboard.mouseRelease(mX, mY);
    this.move_box.mouseRelease(mX, mY);
  }
   public void scroll(int amount) {
    this.move_box.scroll(amount);
  }
   public void keyPress() {
    this.move_box.keyPress();
  }
   public void keyRelease() {
    this.move_box.keyRelease();
  }

   public void loseFocus() {}
   public void gainFocus() {}
}
enum DecisionAlgorithm {
  RANDOM, BEST_MOVE_WHITE, BEST_MOVE_BLACK; // weighted best move, play for draw, play to win, balanced, human-like?
}


class ChessAI {
  class EvaluationThread extends Thread {
    private Queue<ChessNode> nodes_to_evaluate = new ArrayDeque<ChessNode>();
    private boolean kill_thread = false;
    private int current_depth = 0;
    private int nodes_evaluated = 0;
    private int nodes_evaluated_this_second = 0;
    private int time_left = 1000;
    private int nodes_per_second = 0;

    EvaluationThread() {
      super("EvaluationThread");
      this.setDaemon(true);
    }

     public void update(int time_elapsed) {
      this.time_left -= time_elapsed;
      if (this.time_left <= 0) {
        this.time_left += 1000;
        this.nodes_per_second = this.nodes_evaluated_this_second;
        this.nodes_evaluated_this_second = 0;
      }
    }

    @Override public 
    void run() {
      this.nodes_to_evaluate.add(ChessAI.this.head_node);
      while(!this.nodes_to_evaluate.isEmpty()) {
        if (this.kill_thread) {
          return;
        }
        ChessNode next_node = this.nodes_to_evaluate.poll();
        if (next_node == null) {
          continue;
        }
        next_node.evaluate(EvaluationAlgorithm.MATERIAL, true);
        next_node.makeDaughters();
        this.current_depth = next_node.tree_depth;
        for (ChessNode daughter : next_node.daughters.values()) {
          this.nodes_to_evaluate.add(daughter);
        }
        this.nodes_evaluated++;
        this.nodes_evaluated_this_second++;
      }
    }
  }


  private ChessNode head_node;
  private DecisionAlgorithm decision_algorithm = DecisionAlgorithm.RANDOM;
  private EvaluationThread thread = null;

  ChessAI() {
    this.reset();
  }

   public void update(int time_elapsed) {
    if (this.thread != null) {
      this.thread.update(time_elapsed);
    }
  }

   public void reset() {
    this.head_node = new ChessNode(new ChessBoard(), null, null);
    this.head_node.board.setupBoard();
    this.thread = new EvaluationThread();
    this.thread.start();
  }

   public void addMove(ChessMove move) {
    ChessNode daughter = this.head_node.getDaughter(move);
    if (daughter == null) {
      global.errorMessage("ERROR: GameTree corrupted; can't find appropriate daughter node.");
      return;
    }
    this.head_node = daughter;
    this.head_node.parent = null;
    this.head_node.source_move = null;
    this.restartThread();
  }

   public void restartThread() {
    if (this.thread.isAlive()) {
      this.thread.kill_thread = true;
    }
    this.thread = new EvaluationThread();
    this.thread.start();
  }

   public ChessMove getMove() {
    ArrayList<ChessMove> possible_moves = new ArrayList<ChessMove>(this.head_node.board.valid_moves);
    if (possible_moves.size() == 0) {
      return null;
    }
    DecisionAlgorithm algorithm = this.decision_algorithm;
    if (!this.head_node.made_daughters) {
      algorithm = DecisionAlgorithm.RANDOM;
    }
    ChessMove best_move = null;
    switch(algorithm) {
      case BEST_MOVE_WHITE:
        if (this.head_node.board.turn != ChessColor.WHITE) {
          global.log("WARNING: Using BEST_MOVE_WHITE but not white's turn.");
        }
        best_move = possible_moves.get(0);
        for (ChessMove move : possible_moves) {
          ChessNode daughter = this.head_node.getDaughter(move);
          if (daughter == null) {
            continue;
          }
          if (daughter.evaluation.betterForWhite(this.head_node.daughters.get(best_move).evaluation)) {
            best_move = move;
          }
        }
        return best_move;
      case BEST_MOVE_BLACK:
        if (this.head_node.board.turn != ChessColor.WHITE) {
          global.log("WARNING: Using BEST_MOVE_BLACK but not black's turn.");
        }
        best_move = possible_moves.get(0);
        if (this.head_node.getDaughter(best_move) == null) {
          break;
        }
        for (ChessMove move : possible_moves) {
          ChessNode daughter = this.head_node.getDaughter(move);
          if (daughter == null) {
            continue;
          }
          if (daughter.evaluation.betterForBlack(this.head_node.daughters.get(best_move).evaluation)) {
            best_move = move;
          }
        }
        return best_move;
      case RANDOM:
      default:
        break;
    }
    Collections.shuffle(possible_moves);
    return possible_moves.get(0);
  }
}


enum EvaluationAlgorithm {
  NONE, MATERIAL, CHECKMATE, MATERIAL_CHECKMATE;
}


class ChessEvaluation {
  private float evaluation = 0;
  private boolean game_ended = false;
  private int game_ended_result = 0;

   public ChessEvaluation copy() {
    ChessEvaluation copied = new ChessEvaluation();
    copied.evaluation = this.evaluation;
    copied.game_ended = this.game_ended;
    copied.game_ended_result = this.game_ended_result;
    return copied;
  }

   public String displayString() {
    if (this.game_ended) {
      if (game_ended_result > 0) {
        return "White Wins";
      }
      if (game_ended_result < 0) {
        return "Black Wins";
      }
      return "Draw";
    }
    return Float.toString(round(10.0f * evaluation) / 10.0f);
  }

   public boolean betterForWhite(ChessEvaluation evaluation) {
    // white wins
    if (this.game_ended && this.game_ended_result > 0 && (!evaluation.game_ended || evaluation.game_ended_result <= 0)) {
      return true;
    }
    // white prevents black win
    if (evaluation.game_ended && evaluation.game_ended_result < 0 && (!this.game_ended || this.game_ended_result >= 0)) {
      return true;
    }
    // white better
    if (this.evaluation > evaluation.evaluation) {
      return true;
    }
    // else
    return false;
  }

   public boolean betterForBlack(ChessEvaluation evaluation) {
    // black wins
    if (this.game_ended && this.game_ended_result < 0 && (!evaluation.game_ended || evaluation.game_ended_result >= 0)) {
      return true;
    }
    // black prevents white win
    if (evaluation.game_ended && evaluation.game_ended_result > 0 && (!this.game_ended || this.game_ended_result <= 0)) {
      return true;
    }
    // black better
    if (this.evaluation < evaluation.evaluation) {
      return true;
    }
    // else
    return false;
  }
}


class ChessNode {
  private ChessNode parent = null;
  private int tree_depth = 0;
  private ChessMove source_move = null;
  private ChessBoard board;
  private HashMap<ChessMove, ChessNode> daughters = new HashMap<ChessMove, ChessNode>();
  private boolean made_daughters = false;
  private boolean evaluated = false;
  private ChessEvaluation base_evaluation = new ChessEvaluation(); // from this node only
  private ChessEvaluation evaluation = new ChessEvaluation(); // from daughter nodes

  ChessNode(ChessBoard board, ChessNode parent, ChessMove source_move) {
    this.board = board;
    this.parent = parent;
    this.source_move = source_move;
  }

   public ChessNode getDaughter(ChessMove move) {
    if (!this.made_daughters) {
      if (this.board.valid_moves.contains(move)) {
        ChessBoard copied = new ChessBoard(this.board);
        copied.makeMove(move, false);
        return new ChessNode(copied, this, move);
      }
      else {
        return null;
      }
    }
    ChessNode daughter = this.daughters.get(move);
    if (daughter == null) { // race condition
      if (this.board.valid_moves.contains(move)) {
        ChessBoard copied = new ChessBoard(this.board);
        copied.makeMove(move, false);
        return new ChessNode(copied, this, move);
      }
      else {
        return null;
      }
    }
    return daughter;
  }

   public void makeDaughters() {
    if (this.parent == null) {
      this.tree_depth = 0;
    }
    else {
      this.tree_depth = this.parent.tree_depth + 1;
    }
    if (this.made_daughters) {
      return;
    }
    if (!this.evaluated) {
      this.evaluate(EvaluationAlgorithm.NONE, true);
    }
    this.made_daughters = true;
    for (ChessMove move : this.board.valid_moves) {
      ChessBoard copied = new ChessBoard(this.board);
      copied.makeMove(move, false);
      this.daughters.put(move, new ChessNode(copied, this, move));
    }
  }

   public void evaluate(EvaluationAlgorithm algorithm, boolean my_turn) {
    if (this.evaluated) {
      return;
    }
    this.evaluated = true;
    switch(algorithm) {
      case MATERIAL:
        this.base_evaluation.evaluation = this.board.materialDifference();
        break;
      case CHECKMATE:
        if (this.board.game_ended == null) {
          break;
        }
        this.base_evaluation.game_ended = true;
        this.base_evaluation.game_ended_result = this.board.game_ended.points();
        break;
      case MATERIAL_CHECKMATE:
        this.base_evaluation.evaluation = this.board.materialDifference();
        if (this.board.game_ended == null) {
          break;
        }
        this.base_evaluation.game_ended = true;
        this.base_evaluation.game_ended_result = this.board.game_ended.points();
        break;
      case NONE:
      default:
        break;
    }
    this.evaluation.evaluation = this.base_evaluation.evaluation;
    this.evaluation.game_ended = this.base_evaluation.game_ended;
    this.evaluation.game_ended_result = this.base_evaluation.game_ended_result;
    if (this.parent != null) {
      this.parent.daughterEvaluation(this.base_evaluation);
    }
  }

   public void daughterEvaluation(ChessEvaluation evaluation) {
    if (this.board.turn == ChessColor.WHITE && evaluation.betterForWhite(this.evaluation)) {
      this.evaluation = evaluation.copy();
      if (this.parent != null) {
        this.parent.daughterEvaluation(evaluation);
      }
    }
    else if (this.board.turn == ChessColor.BLACK && evaluation.betterForBlack(this.evaluation)) {
      this.evaluation = evaluation.copy();
      if (this.parent != null) {
        this.parent.daughterEvaluation(evaluation);
      }
    }
  }
}
enum ChessSetup {
  STANDARD;
}

enum HumanMovable {
  NONE, WHITE, BLACK, BOTH;
}

enum GameEnds {
  WHITE_CHECKMATES, BLACK_CHECKMATES, STALEMATE, REPETITION, FIFTY_MOVE,
  WHITE_TIME, BLACK_TIME, WHITE_RESIGNS, BLACK_RESIGNS, DRAW_AGREED; // abandonment, insufficient material

  public String displayName() {
    return GameEnds.displayName(this);
  }
  public static String displayName(GameEnds end) {
    switch(end) {
      case WHITE_CHECKMATES:
        return "Checkmate - White is Victorious";
      case BLACK_CHECKMATES:
        return "Checkmate - Black is Victorious";
      case STALEMATE:
        return "Stalemate - Draw";
      case REPETITION:
        return "Repetition - Draw";
      case FIFTY_MOVE:
        return "Fifty Move rule - Draw";
      case WHITE_TIME:
        return "White time out - Black is Victorious";
      case BLACK_TIME:
        return "Black time out - White is Victorious";
      case WHITE_RESIGNS:
        return "White resigns - Black is Victorious";
      case BLACK_RESIGNS:
        return "Black resigns - White is Victorious";
      case DRAW_AGREED:
        return "Draw agreed - Draw";
      default:
        return "Error";
    }
  }

  public int points() {
    return GameEnds.points(this);
  }
  public static int points(GameEnds end) {
    switch(end) {
      case WHITE_CHECKMATES:
        return 1;
      case BLACK_CHECKMATES:
        return -1;
      case STALEMATE:
        return 0;
      case REPETITION:
        return 0;
      case FIFTY_MOVE:
        return 0;
      case WHITE_TIME:
        return -1;
      case BLACK_TIME:
        return 1;
      case WHITE_RESIGNS:
        return -1;
      case BLACK_RESIGNS:
        return 1;
      case DRAW_AGREED:
        return 0;
      default:
        return 0;
    }
  }
}

class ChessBoard extends GridBoard {
  class ChessSquare extends BoardSquare {
    protected ChessColor square_color;
    protected boolean clicked = false;
    protected boolean can_move_to = false;
    protected boolean last_move_square = false;

    ChessSquare(IntegerCoordinate coordinate) {
      super(coordinate);
      this.square_color = ChessColor.colorFromSquare(coordinate);
    }
     public ChessSquare copy() {
      ChessSquare square = new ChessSquare(this.coordinate.copy());
      square.square_color = this.square_color;
      square.clicked = this.clicked;
      square.can_move_to = this.can_move_to;
      square.last_move_square = this.last_move_square;
      return square;
    }

     public void initializePieceMap() {
      this.pieces = new HashMap<Integer, GamePiece>();
    }

     public void movingFrom() {
      this.clearSquare();
      this.last_move_square = true;
    }

     public void movingTo(ChessPiece piece) {
      this.addPiece(piece);
      this.last_move_square = true;
    }

    @Override public 
    boolean empty() {
      for (GamePiece piece : this.pieces.values()) {
        if (piece == null || piece.remove) {
          continue;
        }
        return false;
      }
      return true;
    }

     public ChessPiece getPiece() {
      for (GamePiece piece : this.pieces.values()) {
        if (piece == null || piece.remove) {
          continue;
        }
        return (ChessPiece)piece;
      }
      return null;
    }

     public boolean canTakePiece(GamePiece piece) {
      if (piece == null || piece.remove || !ChessPiece.class.isInstance(piece)) {
        return false;
      }
      if (this.empty()) {
        return true;
      }
      return false;
    }

     public void drawSquare() {
      rectMode(CORNERS);
      stroke(Constants.color_transparent);
      strokeWeight(0.01f);
      if (this.last_move_square) {
        fill(ChessBoard.this.moveColor());
      }
      else {
        fill(ChessBoard.this.squareColor(this.square_color));
      }
      rect(this.button.xi, this.button.yi, this.button.xf, this.button.yf);
      imageMode(CORNERS);
      for (GamePiece piece : this.pieces.values()) {
        if (piece == null || piece.remove) {
          continue;
        }
        ChessPiece chess_piece = (ChessPiece)piece;
        if (chess_piece.type == ChessPieceType.KING && ChessBoard.this.in_check == chess_piece.piece_color) {
          image(global.images.getImage("minigames/chess/check.png"), this.button.xi, this.button.yi, this.button.xf, this.button.yf);
        }
        image(chess_piece.getImage(), this.button.xi, this.button.yi, this.button.xf, this.button.yf);
      }
      if (this.can_move_to) {
        ellipseMode(CENTER);
        if (this.empty()) {
          fill(ChessBoard.this.clickColor());
          stroke(ChessBoard.this.clickColor());
          strokeWeight(0.01f);
          circle(this.button.xCenter(), this.button.yCenter(), 0.3f * this.button.button_width());
        }
        else {
          fill(Constants.color_transparent);
          stroke(ChessBoard.this.clickColor());
          strokeWeight(6);
          circle(this.button.xCenter(), this.button.yCenter(), this.button.button_width() - 3);
        }
      }
      if ((this.clicked || this.button.clicked) && !this.empty()) {
        fill(ChessBoard.this.clickColor());
        stroke(ChessBoard.this.clickColor());
        strokeWeight(0.01f);
        rect(this.button.xi, this.button.yi, this.button.xf, this.button.yf);
      }
      else if (this.button.hovered) {
        fill(ChessBoard.this.hoverColor());
        stroke(ChessBoard.this.hoverColor());
        strokeWeight(0.01f);
        rect(this.button.xi, this.button.yi, this.button.xf, this.button.yf);
      }
    }

     public void clicked() {
      ChessBoard.this.clicked(this.coordinate);
    }

     public void released() {
      ChessBoard.this.released(this.coordinate);
    }
  }


  abstract class ChessMarking {
    protected IntegerCoordinate coordinate; // for translating into right place
    protected boolean smaller = false; // for current marking
    ChessMarking(IntegerCoordinate coordinate) {
      this.coordinate = coordinate;
    }
     public abstract void setFill();
     public abstract void drawMarking(float button_width);
     public void draw(float button_width) {
      if (this.coordinate == null) {
        return;
      }
      this.setFill();
      this.drawMarking(button_width);
    }
  }
  class CircleMark extends ChessMarking {
    CircleMark(IntegerCoordinate coordinate) {
      super(coordinate);
    }
     public void setFill() {
      fill(Constants.color_transparent);
      stroke(ChessBoard.this.markingColor());
      if (this.smaller) {
        strokeWeight(4);
      }
      else {
        strokeWeight(6);
      }
      ellipseMode(CENTER);
    }
     public void drawMarking(float button_width) {
      circle(0, 0, button_width - 3);
    }
    @Override
    public int hashCode() {
      return Objects.hash(this.coordinate.x, this.coordinate.y);
    }
    @Override
    public boolean equals(Object circle_mark_object) {
      if (this == circle_mark_object) {
        return true;
      }
      if (circle_mark_object == null || this.getClass() != circle_mark_object.getClass()) {
        return false;
      }
      CircleMark circle_mark = (CircleMark)circle_mark_object;
      if (this.coordinate.equals(circle_mark.coordinate)) {
        return true;
      }
      return false;
    }
  }
  class ArrowMark extends ChessMarking {
    protected IntegerCoordinate head;
    ArrowMark(IntegerCoordinate tail, IntegerCoordinate head) {
      super(tail);
      this.head = head;
    }
     public void setFill() {
      fill(ChessBoard.this.markingColor());
      stroke(ChessBoard.this.markingColor());
    }
     public void drawMarking(float button_width) {
      float ratio = 0.3f;
      if (this.smaller) {
        strokeWeight(0.14f * button_width);
        ratio = 0.2f;
      }
      else {
        strokeWeight(0.2f * button_width);
      }
      if (this.head == null) {
        return;
      }
      float x_head = button_width * (this.head.x - this.coordinate.x);
      float y_head = button_width * (this.head.y - this.coordinate.y);
      if (this.head.x > this.coordinate.x) {
        x_head -= ratio * button_width;
      }
      else if (this.coordinate.x > this.head.x) {
        x_head += ratio * button_width;
      }
      if (this.head.y > this.coordinate.y) {
        y_head -= ratio * button_width;
      }
      else if (this.coordinate.y > this.head.y) {
        y_head += ratio * button_width;
      }
      float dist = sqrt(x_head * x_head + y_head * y_head);
      if (dist == 0) {
        return;
      }
      line(0, 0, x_head, y_head);
      strokeWeight(0.01f);
      translate(x_head, y_head);
      triangle(ratio * button_width * y_head / dist, -ratio * button_width * x_head / dist,
        -ratio * button_width * y_head / dist, ratio * button_width * x_head / dist,
        1.3f * ratio * button_width * x_head / dist, 1.3f * ratio * button_width * y_head / dist);
      translate(-x_head, -y_head);
    }
    @Override
    public int hashCode() {
      return Objects.hash(this.coordinate.x, this.coordinate.y, this.head.x, this.head.y);
    }
    @Override
    public boolean equals(Object arrow_mark_object) {
      if (this == arrow_mark_object) {
        return true;
      }
      if (arrow_mark_object == null || this.getClass() != arrow_mark_object.getClass()) {
        return false;
      }
      ArrowMark arrow_mark = (ArrowMark)arrow_mark_object;
      if (this.coordinate.equals(arrow_mark.coordinate) && this.head.equals(arrow_mark.head)) {
        return true;
      }
      return false;
    }
  }


  class PawnPromotionChooser {
    class PawnPromotionChooserButton extends ImageButton {
      protected ChessPieceType type;
      PawnPromotionChooserButton(ChessPieceType type, ChessColor piece_color) {
        super(global.images.getImage("minigames/chess/" + piece_color.fileName() +
          "_" + type.fileName() + ".png"), 0, 0, 0, 0);
        this.type = type;
        this.use_time_elapsed = true;
        this.overshadow_colors = true;
        this.setColors(ccolor(170, 170), ccolor(1, 0), ccolor(100, 80), ccolor(200, 160), ccolor(0));
      }

      @Override public 
      void drawButton() {
        rectMode(CORNERS);
        fill(ccolor(20, 120, 60));
        stroke(ccolor(120, 120, 60));
        strokeWeight(0.01f);
        rect(this.xi, this.yi, this.xf, this.yf);
        super.drawButton();
      }

       public void hover() {}
       public void dehover() {}
       public void click() {}
       public void release() {
        PawnPromotionChooser.this.promote_to = this.type;
        PawnPromotionChooser.this.move.pawn_promotion = this.type;
      }
    }

    private boolean remove = false;
    private ChessMove move;
    private PawnPromotionChooserButton[] buttons = new PawnPromotionChooserButton[4];
    private ChessPieceType promote_to = null;
    private int fade_in_timer = 200;
    private boolean button_pressed = false;

    PawnPromotionChooser(ChessMove move) {
      this.move = move;
      this.buttons[0] = new PawnPromotionChooserButton(ChessPieceType.QUEEN, move.source_color);
      this.buttons[1] = new PawnPromotionChooserButton(ChessPieceType.KNIGHT, move.source_color);
      this.buttons[2] = new PawnPromotionChooserButton(ChessPieceType.ROOK, move.source_color);
      this.buttons[3] = new PawnPromotionChooserButton(ChessPieceType.BISHOP, move.source_color);
      if (move == null) {
        this.remove = true;
        return;
      }
      this.updateLocations();
    }

     public void updateLocations() {
      float x_button = ChessBoard.this.squareCenterX(this.move.target) - 0.5f * ChessBoard.this.square_length;
      float y_center = ChessBoard.this.squareCenterY(this.move.target);
      boolean increase = (y_center > 0.5f * height);
      float y_curr = y_center - 0.5f * ChessBoard.this.square_length;
      for (PawnPromotionChooserButton button : this.buttons) {
        button.setLocation(x_button, y_curr, x_button + ChessBoard.this.square_length, y_curr + ChessBoard.this.square_length);
        if (increase) {
          y_curr -= ChessBoard.this.square_length;
        }
        else {
          y_curr += ChessBoard.this.square_length;
        }
      }
    }

     public void update(int time_elapsed) {
      this.fade_in_timer -= time_elapsed;
      if (this.promote_to != null) {
        this.remove = true;
      }
      for (PawnPromotionChooserButton button : this.buttons) {
        button.update(time_elapsed);
      }
    }

     public void mouseMove(float mX, float mY) {
      if (this.promote_to != null) {
        this.remove = true;
        return;
      }
      for (PawnPromotionChooserButton button : this.buttons) {
        button.mouseMove(mX, mY);
      }
    }

     public void mousePress() {
      if (this.promote_to != null) {
        this.remove = true;
        return;
      }
      this.button_pressed = false;
      for (PawnPromotionChooserButton button : this.buttons) {
        button.mousePress();
        if (button.clicked) {
          this.button_pressed = true;
        }
      }
    }

     public void mouseRelease(float mX, float mY) {
      if (this.fade_in_timer < 0 && !this.button_pressed) {
        this.remove = true;
      }
      if (this.promote_to != null) {
        return;
      }
      for (PawnPromotionChooserButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
    }
  }


  protected ChessSetup setup = null;
  protected HumanMovable human_controlled = HumanMovable.BOTH;
  protected boolean toggle_human_controllable = false;
  protected ArrayList<ChessPiece> white_pieces = new ArrayList<ChessPiece>();
  protected ArrayList<ChessPiece> black_pieces = new ArrayList<ChessPiece>();

  protected ChessColor turn = ChessColor.WHITE;
  protected HashSet<ChessMove> valid_moves = new HashSet<ChessMove>();
  protected PawnPromotionChooser pawn_promotion_chooser = null;
  protected HashSet<ChessMove> return_moves = new HashSet<ChessMove>();
  protected boolean calculate_return_moves = true;

  protected ChessColor in_check = null;
  protected ArrayList<ChessMove> moves = new ArrayList<ChessMove>();
  protected int fifty_move_counter = 0;
  protected Queue<ChessMove> move_queue = new ArrayDeque<ChessMove>();
  protected HashMap<ChessPosition, Integer> all_positions = new HashMap<ChessPosition, Integer>();
  protected GameEnds game_ended = null; // null until game ends

  protected IntegerCoordinate coordinate_dragging = null;
  protected IntegerCoordinate coordinate_clicked = null;
  protected IntegerCoordinate coordinate_marking = null;
  protected HashSet<ChessMarking> markings = new HashSet<ChessMarking>();

  ChessBoard() {
    super(8, 8);
    this.orientation = BoardOrientation.RIGHT;
  }
  ChessBoard(ChessBoard board) {
    super(8, 8);
    this.orientation = board.orientation;
    this.next_piece_key = board.next_piece_key;
    this.setup = board.setup;
    this.turn = board.turn;
    this.calculate_return_moves = board.calculate_return_moves;
    this.in_check = board.in_check;
    if (board.coordinate_dragging == null) {
      this.coordinate_dragging = null;
    }
    else {
      this.coordinate_dragging = board.coordinate_dragging.copy();
    }
    if (board.coordinate_clicked == null) {
      this.coordinate_clicked = null;
    }
    else {
      this.coordinate_clicked = board.coordinate_clicked.copy();
    }
    if (board.coordinate_marking == null) {
      this.coordinate_marking = null;
    }
    else {
      this.coordinate_marking = board.coordinate_marking.copy();
    }
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j] = ((ChessSquare)board.squares[i][j]).copy();
      }
    }
    for (GamePiece piece : board.pieces.values()) {
      ChessPiece copied_piece = ((ChessPiece)piece).copy();
      this.addPiece(copied_piece, piece.coordinate.x, piece.coordinate.y, piece.board_key);
    }
    for (ChessMove move : board.valid_moves) {
      this.valid_moves.add(move.copy());
    }
    for (ChessMove move : board.return_moves) {
      this.return_moves.add(move.copy());
    }
    for (ChessMove move : board.moves) {
      this.moves.add(move.copy());
    }
    this.removeSquareMarkings();
  }

   public void initializePieceMap() {
    this.pieces = new HashMap<Integer, GamePiece>();
  }

   public void initializeSquares() {
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j] = new ChessSquare(new IntegerCoordinate(i, j));
      }
    }
  }

   public void removeSquareMarkings() {
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        ChessSquare square = (ChessSquare)this.squares[i][j];
        square.clicked = false;
        square.can_move_to = false;
        square.last_move_square = false;
      }
    }
  }

   public void resetAnalysis() {
    this.human_controlled = HumanMovable.BOTH;
    this.orientation = BoardOrientation.RIGHT;
    this.setupBoard();
  }

   public void setupBoard() {
    this.setupBoard(ChessSetup.STANDARD);
  }
   public void setupBoard(ChessSetup setup) {
    this.setup = setup;
    this.clearBoard();
    for (ChessPiece piece : this.white_pieces) {
      piece.remove = true;
    }
    for (ChessPiece piece : this.black_pieces) {
      piece.remove = true;
    }
    this.removeSquareMarkings();
    this.valid_moves.clear();
    this.return_moves.clear();
    this.markings.clear();
    this.moves.clear();
    this.fifty_move_counter = 0;
    this.move_queue.clear();
    this.all_positions.clear();
    this.game_ended = null;
    this.turn = ChessColor.WHITE;
    // White back-rank
    ChessPiece white_rook1 = new ChessPiece(ChessPieceType.ROOK, ChessColor.WHITE);
    this.addPiece(white_rook1, 0, 0);
    ChessPiece white_knight1 = new ChessPiece(ChessPieceType.KNIGHT, ChessColor.WHITE);
    this.addPiece(white_knight1, 0, 1);
    ChessPiece white_bishop1 = new ChessPiece(ChessPieceType.BISHOP, ChessColor.WHITE);
    this.addPiece(white_bishop1, 0, 2);
    ChessPiece white_queen1 = new ChessPiece(ChessPieceType.QUEEN, ChessColor.WHITE);
    this.addPiece(white_queen1, 0, 3);
    ChessPiece white_king1 = new ChessPiece(ChessPieceType.KING, ChessColor.WHITE);
    this.addPiece(white_king1, 0, 4);
    ChessPiece white_bishop2 = new ChessPiece(ChessPieceType.BISHOP, ChessColor.WHITE);
    this.addPiece(white_bishop2, 0, 5);
    ChessPiece white_knight2 = new ChessPiece(ChessPieceType.KNIGHT, ChessColor.WHITE);
    this.addPiece(white_knight2, 0, 6);
    ChessPiece white_rook2 = new ChessPiece(ChessPieceType.ROOK, ChessColor.WHITE);
    this.addPiece(white_rook2, 0, 7);
    // White pawns
    ChessPiece white_pawn1 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn1, 1, 0);
    ChessPiece white_pawn2 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn2, 1, 1);
    ChessPiece white_pawn3 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn3, 1, 2);
    ChessPiece white_pawn4 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn4, 1, 3);
    ChessPiece white_pawn5 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn5, 1, 4);
    ChessPiece white_pawn6 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn6, 1, 5);
    ChessPiece white_pawn7 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn7, 1, 6);
    ChessPiece white_pawn8 = new ChessPiece(ChessPieceType.PAWN, ChessColor.WHITE);
    this.addPiece(white_pawn8, 1, 7);
    // Black back-rank
    ChessPiece black_rook1 = new ChessPiece(ChessPieceType.ROOK, ChessColor.BLACK);
    this.addPiece(black_rook1, 7, 0);
    ChessPiece black_knight1 = new ChessPiece(ChessPieceType.KNIGHT, ChessColor.BLACK);
    this.addPiece(black_knight1, 7, 1);
    ChessPiece black_bishop1 = new ChessPiece(ChessPieceType.BISHOP, ChessColor.BLACK);
    this.addPiece(black_bishop1, 7, 2);
    ChessPiece black_queen1 = new ChessPiece(ChessPieceType.QUEEN, ChessColor.BLACK);
    this.addPiece(black_queen1, 7, 3);
    ChessPiece black_king1 = new ChessPiece(ChessPieceType.KING, ChessColor.BLACK);
    this.addPiece(black_king1, 7, 4);
    ChessPiece black_bishop2 = new ChessPiece(ChessPieceType.BISHOP, ChessColor.BLACK);
    this.addPiece(black_bishop2, 7, 5);
    ChessPiece black_knight2 = new ChessPiece(ChessPieceType.KNIGHT, ChessColor.BLACK);
    this.addPiece(black_knight2, 7, 6);
    ChessPiece black_rook2 = new ChessPiece(ChessPieceType.ROOK, ChessColor.BLACK);
    this.addPiece(black_rook2, 7, 7);
    // Black pawns
    ChessPiece black_pawn1 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn1, 6, 0);
    ChessPiece black_pawn2 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn2, 6, 1);
    ChessPiece black_pawn3 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn3, 6, 2);
    ChessPiece black_pawn4 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn4, 6, 3);
    ChessPiece black_pawn5 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn5, 6, 4);
    ChessPiece black_pawn6 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn6, 6, 5);
    ChessPiece black_pawn7 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn7, 6, 6);
    ChessPiece black_pawn8 = new ChessPiece(ChessPieceType.PAWN, ChessColor.BLACK);
    this.addPiece(black_pawn8, 6, 7);
    // calculate move
    this.startTurn(ChessColor.WHITE);
  }

   public int materialDifference() {
    return this.whiteMaterial() - this.blackMaterial();
  }

   public int whiteMaterial() {
    int material = 0;
    for (ChessPiece piece : this.white_pieces) {
      if (piece == null || piece.remove) {
        continue;
      }
      material += piece.type.material();
    }
    return material;
  }

   public int blackMaterial() {
    int material = 0;
    for (ChessPiece piece : this.black_pieces) {
      if (piece == null || piece.remove) {
        continue;
      }
      material += piece.type.material();
    }
    return material;
  }

   public void nextTurn() {
    switch(this.turn) {
      case WHITE:
        this.startTurn(ChessColor.BLACK);
        break;
      case BLACK:
        this.startTurn(ChessColor.WHITE);
        break;
    }
  }
   public void startTurn(ChessColor chess_color) {
    this.valid_moves.clear();
    this.return_moves.clear();
    if (this.game_ended != null) {
      return;
    }
    this.turn = chess_color;
    this.in_check = null;
    switch(chess_color) {
      case WHITE:
        for (ChessPiece piece : this.black_pieces) {
          if (piece.remove) {
            continue;
          }
          if (this.calculate_return_moves) {
            piece.updateValidMoves(this, true);
            this.return_moves.addAll(piece.valid_moves);
          }
          piece.valid_moves.clear();
        }
        if (this.inCheck()) {
          this.in_check = chess_color;
        }
        for (ChessPiece piece : this.white_pieces) {
          if (piece.remove) {
            continue;
          }
          piece.updateValidMoves(this, !this.calculate_return_moves);
          this.valid_moves.addAll(piece.valid_moves);
        }
        break;
      case BLACK:
        for (ChessPiece piece : this.white_pieces) {
          if (piece.remove) {
            continue;
          }
          if (this.calculate_return_moves) {
            piece.updateValidMoves(this, true);
            this.return_moves.addAll(piece.valid_moves);
          }
          piece.valid_moves.clear();
        }
        if (this.inCheck()) {
          this.in_check = chess_color;
        }
        for (ChessPiece piece : this.black_pieces) {
          if (piece.remove) {
            continue;
          }
          piece.updateValidMoves(this, !this.calculate_return_moves);
          this.valid_moves.addAll(piece.valid_moves);
        }
        break;
    }
    if (this.valid_moves.size() == 0) { // game over
      switch(this.in_check) {
        case WHITE:
          this.game_ended = GameEnds.BLACK_CHECKMATES;
          break;
        case BLACK:
          this.game_ended = GameEnds.WHITE_CHECKMATES;
          break;
        default:
          this.game_ended = GameEnds.STALEMATE;
          break;
      }
    }
  }

   public boolean inCheck() {
    for (ChessMove move : this.return_moves) {
      if (move.capture && this.pieceAt(move.target) != null &&
        this.pieceAt(move.target).type == ChessPieceType.KING) {
        return true;
      }
    }
    return false;
  }

   public boolean canTakeKing() {
    for (ChessMove move : this.valid_moves) {
      if (move.capture && this.pieceAt(move.target) != null &&
        this.pieceAt(move.target).type == ChessPieceType.KING) {
        return true;
      }
    }
    return false;
  }

   public boolean humanCanMakeMove() {
    if (this.toggle_human_controllable || this.game_ended != null) {
      return false;
    }
    switch(this.human_controlled) {
      case NONE:
        return false;
      case WHITE:
        return this.turn == ChessColor.WHITE;
      case BLACK:
        return this.turn == ChessColor.BLACK;
      case BOTH:
        return true;
    }
    return false;
  }

   public void offerDraw() {
    this.offerDraw(this.turn);
  }
   public void offerDraw(ChessColor offering_player) {
    if (this.game_ended != null) {
      return;
    }
    // offering player offers draw
  }

   public void resign() {
    if (this.game_ended != null) {
      return;
    }
    switch(this.turn) {
      case WHITE:
        this.game_ended = GameEnds.WHITE_RESIGNS;
        break;
      case BLACK:
        this.game_ended = GameEnds.BLACK_RESIGNS;
        break;
    }
  }

   public boolean computersTurn() {
    if (this.valid_moves.size() == 0) {
      return false;
    }
    switch(this.human_controlled) {
      case NONE:
        return true;
      case WHITE:
        return this.turn != ChessColor.WHITE;
      case BLACK:
        return this.turn != ChessColor.BLACK;
      case BOTH:
        return false;
    }
    return false;
  }

   public void addedPiece(GamePiece piece) {
    if (!ChessPiece.class.isInstance(piece)) {
      global.errorMessage("ERROR: Piece with class " + piece.getClass() + " not a chess piece.");
      return;
    }
    ChessPiece chess_piece = (ChessPiece)piece;
    switch(chess_piece.piece_color) {
      case WHITE:
        this.white_pieces.add(chess_piece);
        break;
      case BLACK:
        this.black_pieces.add(chess_piece);
        break;
      default:
        global.errorMessage("ERROR: Chess piece color " + chess_piece.piece_color + " not recognized.");
        break;
    }
  }

   public void afterUpdate() {
    for (int i = 0; i < this.white_pieces.size(); i++) {
      if (this.white_pieces.get(i).remove) {
        this.white_pieces.remove(i);
        i--;
      }
    }
    for (int i = 0; i < this.black_pieces.size(); i++) {
      if (this.black_pieces.get(i).remove) {
        this.black_pieces.remove(i);
        i--;
      }
    }
    float marking_rotate = 0;
    switch(this.orientation) {
      case LEFT:
        marking_rotate = 0.5f * PI;
        break;
      case RIGHT:
        marking_rotate = -0.5f * PI;
        break;
    }
    for (ChessMarking marking : this.markings) {
      float translate_x = this.squareCenterX(marking.coordinate);
      float translate_y = this.squareCenterY(marking.coordinate);
      translate(translate_x, translate_y);
      rotate(marking_rotate);
      marking.draw(this.square_length);
      rotate(-marking_rotate);
      translate(-translate_x, -translate_y);
    }
    if (this.coordinate_marking != null) {
      ChessMarking marking;
      if (this.coordinate_marking.equals(this.coordinate_hovered)) {
        marking = new CircleMark(this.coordinate_marking);
      }
      else if (this.coordinate_hovered != null) {
        marking = new ArrowMark(this.coordinate_marking, this.coordinate_hovered);
      }
      else {
        return;
      }
      marking.smaller = true;
      float translate_x = this.squareCenterX(marking.coordinate);
      float translate_y = this.squareCenterY(marking.coordinate);
      translate(translate_x, translate_y);
      rotate(marking_rotate);
      marking.draw(this.square_length);
      rotate(-marking_rotate);
      translate(-translate_x, -translate_y);
    }
  }

  @Override public 
  void update(int time_elapsed) {
    super.update(time_elapsed);
    if (this.pawn_promotion_chooser != null) {
      this.pawn_promotion_chooser.update(time_elapsed);
      if (this.pawn_promotion_chooser.promote_to != null) {
        this.tryMakeMove(this.pawn_promotion_chooser.move);
      }
      if (this.pawn_promotion_chooser.remove) {
        this.pawn_promotion_chooser = null;
      }
    }
  }

  @Override public 
  void mouseMove(float mX, float mY) {
    super.mouseMove(mX, mY);
    if (this.pawn_promotion_chooser != null) {
      this.pawn_promotion_chooser.mouseMove(mX, mY);
    }
  }

  @Override public 
  void mousePress() {
    if (this.pawn_promotion_chooser != null) {
      this.pawn_promotion_chooser.mousePress();
    }
    super.mousePress();
  }

  @Override public 
  void mouseRelease(float mX, float mY) {
    super.mouseRelease(mX, mY);
    if (this.pawn_promotion_chooser != null) {
      this.pawn_promotion_chooser.mouseRelease(mX, mY);
    }
  }

   public int squareColor(ChessColor square_color) {
    switch(square_color) {
      case WHITE:
        return ccolor(248, 240, 227);
      case BLACK:
        return ccolor(165, 42, 42);
    }
    return ccolor(1, 0);
  }

   public int hoverColor() {
    return ccolor(120, 80);
  }

   public int clickColor() {
    return ccolor(200, 160);
  }

   public int moveColor() {
    return ccolor(190, 190, 50);
  }

   public int markingColor() {
    return ccolor(180, 100, 90, 170);
  }

   public void clicked(IntegerCoordinate coordinate) {
    if (coordinate == null) {
      this.markings.clear();
      return;
    }
    switch(mouseButton) {
      case LEFT:
        this.markings.clear();
        if (!this.humanCanMakeMove()) {
          break;
        }
        if (this.pieceAt(coordinate) != null) {
          this.coordinate_dragging = coordinate;
          //((ChessSquare)this.squareAt(coordinate)).clicked = true;
        }
        break;
      case RIGHT:
        this.coordinate_marking = coordinate;
        break;
      default:
        this.markings.clear();
        break;
    }
  }

   public void released(IntegerCoordinate coordinate) {
    if (coordinate == null) {
      this.markings.clear();
      return;
    }
    switch(mouseButton) {
      case LEFT:
        this.markings.clear();
        if (!this.humanCanMakeMove()) {
          break;
        }
        ChessPiece piece = this.pieceAt(coordinate);
        if (this.coordinate_clicked == null && piece != null && piece.piece_color == this.turn) {
          ChessSquare square = ((ChessSquare)this.squareAt(coordinate));
          if (square.button.hovered) {
            this.coordinate_clicked = coordinate;
            square.clicked = true;
          }
          else {
            // use dragged
          }
        }
        else if (piece != null && piece.piece_color == this.turn) {
          ChessSquare square = ((ChessSquare)this.squareAt(coordinate));
          if (square.button.hovered) {
            ((ChessSquare)this.squareAt(this.coordinate_clicked)).clicked = false;
            this.coordinate_clicked = coordinate;
            square.clicked = true;
          }
          else {
            // use dragged
          }
        }
        else if (this.coordinate_clicked != null) {
          this.tryMovePiece(this.coordinate_clicked, coordinate);
          ((ChessSquare)this.squareAt(this.coordinate_clicked)).clicked = false;
          this.coordinate_clicked = null;
        }
        this.updateSquaresMarked();
        break;
      case RIGHT:
        if (this.coordinate_marking == null) {
          return;
        }
        else if (this.coordinate_marking.equals(this.coordinate_hovered)) {
          this.addMarking(new CircleMark(coordinate));
        }
        else {
          this.addMarking(new ArrowMark(this.coordinate_marking, this.coordinate_hovered));
        }
        this.coordinate_marking = null;
        break;
      default:
        break;
    }
  }

   public void addMarking(ChessMarking chess_marking) {
    if (chess_marking == null) {
      return;
    }
    if (this.markings.contains(chess_marking)) {
      this.markings.remove(chess_marking);
    }
    else {
      this.markings.add(chess_marking);
    }
  }

   public void updateSquaresMarked() {
    boolean all_false = false;
    ChessPiece piece = this.pieceAt(this.coordinate_clicked);
    if (piece == null) {
      all_false = true;
    }
    for (BoardSquare[] squares_row : this.squares) {
      for (BoardSquare board_square : squares_row) {
        ChessSquare square = (ChessSquare)board_square;
        if (all_false) {
          square.can_move_to = false;
          continue;
        }
        square.can_move_to = piece.canMoveTo(square.coordinate);
      }
    }
  }

  // For when human tries to make a move
   public void tryMovePiece(IntegerCoordinate source, IntegerCoordinate target) {
    if (!this.humanCanMakeMove()) {
      return;
    }
    ChessPiece source_piece = this.pieceAt(source);
    if (source_piece == null) {
      return;
    }
    ChessPiece target_piece = this.pieceAt(target);
    if (target_piece != null && target_piece.piece_color == source_piece.piece_color) {
      return;
    }
    if (target_piece == null) { // check for en passant
      if (source_piece.type == ChessPieceType.PAWN && source.y != target.y) {
        target_piece = this.pieceAt(new IntegerCoordinate(source.x, target.y));
      }
    }
    ChessMove potential_move = new ChessMove(source, target, target_piece != null,
      source_piece.piece_color, source_piece.type);
    if (source_piece.type == ChessPieceType.PAWN && (target.x == 0 || target.x == this.boardHeight() - 1)) {
      this.pawnPromotionChooser(potential_move);
      return;
    }
    if (!this.valid_moves.contains(potential_move)) {
      return;
    }
    this.makeMove(potential_move);
  }

   public void tryMakeMove(ChessMove move) {
    if (!this.humanCanMakeMove()) {
      return;
    }
    if (!this.valid_moves.contains(move)) {
      return;
    }
    if (move.pawn_promotion == null && move.source_type == ChessPieceType.PAWN &&
      (move.target.x == 0 || move.target.x == this.boardHeight() - 1)) {
      this.pawnPromotionChooser(move);
      return;
    }
    this.makeMove(move);
  }

   public void pawnPromotionChooser(ChessMove move) {
    if (!this.humanCanMakeMove()) {
      return;
    }
    if (move.source_type != ChessPieceType.PAWN || (move.target.x > 0 && move.target.x < this.boardHeight() - 1)) {
      return;
    }
    this.pawn_promotion_chooser = new PawnPromotionChooser(move);
  }

   public void makeRandomMove() {
    ArrayList<ChessMove> possible_moves = new ArrayList<ChessMove>(this.valid_moves);
    Collections.shuffle(possible_moves);
    this.makeMove(possible_moves.get(0), false);
  }

   public void makeMove(ChessMove move) {
    this.makeMove(move, true);
  }
   public void makeMove(ChessMove move, boolean play_sound) {
    ChessPiece source_piece = this.pieceAt(move.source);
    if (source_piece == null) {
      return;
    }
    ChessPiece target_piece = this.pieceAt(move.target);
    if (target_piece != null && target_piece.piece_color == source_piece.piece_color) {
      return;
    }
    for (ChessPiece piece : this.white_pieces) {
      piece.moved_last_turn = false;
    }
    for (ChessPiece piece : this.black_pieces) {
      piece.moved_last_turn = false;
    }
    if (target_piece == null) { // check for en passant
      if (source_piece.type == ChessPieceType.PAWN && move.source.y != move.target.y) {
        target_piece = this.pieceAt(new IntegerCoordinate(move.source.x, move.target.y));
      }
    }
    if (target_piece != null) {
      target_piece.remove = true;
      if (play_sound) {
        global.sounds.trigger_player("minigames/chess/capture");
      }
    }
    else {
      if (move.castlingMove()) { // check for castling
        IntegerCoordinate rook_source = move.castlingMoveRookSource(this);
        ChessPiece rook = this.pieceAt(rook_source);
        if (rook == null || rook.remove || rook.piece_color != source_piece.piece_color ||
          rook.type != ChessPieceType.ROOK || rook.has_moved) {
          global.errorMessage("ERROR: Can't castle with invalid rook.");
          return;
        }
        IntegerCoordinate rook_target = move.castlingMoveRookTarget();
        BoardSquare rook_target_square = this.squareAt(rook_target);
        if (rook_source == null || rook_target == null || !rook_target_square.empty()) {
          global.errorMessage("ERROR: Can't castle with invalid rook squares.");
          return;
        }
        rook.last_coordinate = rook.coordinate.copy();
        rook.has_moved = true;
        rook.moved_last_turn = true;
        this.squareAt(rook_source).clearSquare();
        rook_target_square.addPiece(rook);
      }
      if (play_sound) {
        global.sounds.trigger_player("minigames/chess/move");
      }
    }
    source_piece.last_coordinate = source_piece.coordinate.copy();
    source_piece.has_moved = true;
    source_piece.moved_last_turn = true;
    if (move.pawn_promotion != null) {
      if (source_piece.type == ChessPieceType.PAWN && (move.target.x == 0 || move.target.x == this.boardHeight() - 1)) {
        source_piece.type = move.pawn_promotion;
      }
      else {
        global.errorMessage("ERROR: Invalid pawn promotion move.");
        return;
      }
    }
    if (this.moves.size() > 0) {
      ChessMove last_move = this.moves.get(this.moves.size() - 1);
      ((ChessSquare)this.squareAt(last_move.source)).last_move_square = false;
      ((ChessSquare)this.squareAt(last_move.target)).last_move_square = false;
    }
    ((ChessSquare)this.squareAt(move.source)).movingFrom();
    ((ChessSquare)this.squareAt(move.target)).movingTo(source_piece);
    this.moves.add(move);
    this.move_queue.add(move);
    this.markings.clear();
    ChessPosition new_position = new ChessPosition(this);
    if (this.all_positions.containsKey(new_position)) {
      this.all_positions.put(new_position, 1 + this.all_positions.get(new_position));
      if (this.all_positions.get(new_position) >= 3) {
        this.game_ended = GameEnds.REPETITION;
      }
    }
    else {
      this.all_positions.put(new_position, 1);
    }
    if (move.fiftyMoveResetMove()) {
      this.fifty_move_counter = 0;
    }
    else {
      this.fifty_move_counter++;
      if (this.fifty_move_counter >= 50) {
        this.game_ended = GameEnds.FIFTY_MOVE;
      }
    }
    this.nextTurn();
  }

   public ChessPiece pieceAt(IntegerCoordinate coordinate) {
    BoardSquare square = this.squareAt(coordinate);
    if (square == null) {
      return null;
    }
    if (square.empty()) {
      return null;
    }
    ChessPiece piece = ((ChessSquare)square).getPiece();
    if (piece != null && piece.remove) {
      piece = null;
    }
    return piece;
  }
}


enum ChessPieceType {
  KING, QUEEN, ROOK, BISHOP, KNIGHT, PAWN;

  public String fileName() {
    return ChessPieceType.fileName(this);
  }
  public static String fileName(ChessPieceType type) {
    switch(type) {
      case KING:
        return "king";
      case QUEEN:
        return "queen";
      case ROOK:
        return "rook";
      case BISHOP:
        return "bishop";
      case KNIGHT:
        return "knight";
      case PAWN:
        return "pawn";
      default:
        return "";
    }
  }

  public String characterString() {
    return this.characterString(false);
  }
  public String characterString(boolean show_pawn) {
    return ChessPieceType.characterString(this, show_pawn);
  }
  public static String characterString(ChessPieceType type, boolean show_pawn) {
    switch(type) {
      case KING:
        return "K";
      case QUEEN:
        return "Q";
      case ROOK:
        return "R";
      case BISHOP:
        return "B";
      case KNIGHT:
        return "N";
      case PAWN:
        if (show_pawn) {
          return "P";
        }
        else {
          return "";
        }
      default:
        return "";
    }
  }

  public int material() {
    return ChessPieceType.material(this);
  }
  public static int material(ChessPieceType type) {
    switch(type) {
      case KING:
        return 0;
      case QUEEN:
        return 8;
      case ROOK:
        return 5;
      case BISHOP:
        return 3;
      case KNIGHT:
        return 3;
      case PAWN:
        return 1;
      default:
        return 0;
    }
  }
}

enum ChessColor {
  WHITE, BLACK;

  public String fileName() {
    return ChessColor.fileName(this);
  }
  public static String fileName(ChessColor type) {
    switch(type) {
      case WHITE:
        return "white";
      case BLACK:
        return "black";
      default:
        return "";
    }
  }

  public static ChessColor colorFromSquare(IntegerCoordinate coordinate) {
    if ((coordinate.x + coordinate.y) % 2 == 0) {
      return ChessColor.BLACK;
    }
    return ChessColor.WHITE;
  }
}

class ChessPiece extends GamePiece {
  protected ChessPieceType type;
  protected ChessColor piece_color;
  protected HashSet<ChessMove> valid_moves = new HashSet<ChessMove>();
  protected boolean has_moved = false;
  protected boolean moved_last_turn = false;
  protected IntegerCoordinate last_coordinate = null;

  ChessPiece(ChessPieceType type, ChessColor piece_color) {
    super();
    this.type = type;
    this.piece_color = piece_color;
  }
   public ChessPiece copy() {
    ChessPiece piece = new ChessPiece(this.type, this.piece_color);
    piece.board_key = this.board_key;
    piece.remove = this.remove;
    piece.coordinate = this.coordinate.copy();
    piece.has_moved = this.has_moved;
    piece.moved_last_turn = this.moved_last_turn;
    if (this.last_coordinate == null) {
      piece.last_coordinate = null;
    }
    else {
      piece.last_coordinate = this.last_coordinate.copy();
    }
    for (ChessMove move : this.valid_moves) {
      piece.valid_moves.add(move.copy());
    }
    return piece;
  }

   public PImage getImage() {
    return global.images.getImage("minigames/chess/" + this.piece_color.fileName() +
      "_" + this.type.fileName() + ".png");
  }

   public boolean canMoveTo(IntegerCoordinate coordinate) {
    for (ChessMove move : this.valid_moves) {
      if (move.target.equals(coordinate)) {
        return true;
      }
    }
    return false;
  }

   public void updateValidMoves(ChessBoard board) {
    this.updateValidMoves(board, false);
  }
   public void updateValidMoves(ChessBoard board, boolean ignore_check) {
    this.valid_moves.clear();
    if (this.remove) {
      return;
    }
    switch(this.type) {
      case KING:
        for (IntegerCoordinate target : this.coordinate.adjacentAndCornerCoordinates()) {
          if (!board.contains(target)) {
            continue;
          }
          ChessPiece target_piece = board.pieceAt(target);
          if (target_piece != null && target_piece.piece_color == this.piece_color) {
            continue;
          }
          this.valid_moves.add(new ChessMove(this.coordinate, target,
            target_piece != null, this.piece_color, this.type));
        }
        this.addCastlingMoves(board);
        break;
      case QUEEN:
        this.addBishopMoves(board);
        this.addRookMoves(board);
        break;
      case ROOK:
        this.addRookMoves(board);
        break;
      case BISHOP:
        this.addBishopMoves(board);
        break;
      case KNIGHT:
        for (IntegerCoordinate target : this.coordinate.knightMoves()) {
          if (!board.contains(target)) {
            continue;
          }
          ChessPiece target_piece = board.pieceAt(target);
          if (target_piece != null && target_piece.piece_color == this.piece_color) {
            continue;
          }
          this.valid_moves.add(new ChessMove(this.coordinate, target,
            target_piece != null, this.piece_color, this.type));
        }
        break;
      case PAWN:
        IntegerCoordinate move1 = null;
        IntegerCoordinate capture_left = null;
        IntegerCoordinate capture_right = null;
        IntegerCoordinate capture_left_en_passant = null;
        IntegerCoordinate capture_right_en_passant = null;
        IntegerCoordinate move2 = null;
        switch(this.piece_color) {
          case WHITE:
            move1 = new IntegerCoordinate(this.coordinate.x + 1, this.coordinate.y);
            capture_left = new IntegerCoordinate(this.coordinate.x + 1, this.coordinate.y + 1);
            capture_left_en_passant = new IntegerCoordinate(this.coordinate.x, this.coordinate.y + 1);
            capture_right = new IntegerCoordinate(this.coordinate.x + 1, this.coordinate.y - 1);
            capture_right_en_passant = new IntegerCoordinate(this.coordinate.x, this.coordinate.y - 1);
            if (!this.has_moved) {
              move2 = new IntegerCoordinate(this.coordinate.x + 2, this.coordinate.y);
            }
            break;
          case BLACK:
            move1 = new IntegerCoordinate(this.coordinate.x - 1, this.coordinate.y);
            capture_left = new IntegerCoordinate(this.coordinate.x - 1, this.coordinate.y + 1);
            capture_left_en_passant = new IntegerCoordinate(this.coordinate.x, this.coordinate.y + 1);
            capture_right = new IntegerCoordinate(this.coordinate.x - 1, this.coordinate.y - 1);
            capture_right_en_passant = new IntegerCoordinate(this.coordinate.x, this.coordinate.y - 1);
            if (!this.has_moved) {
              move2 = new IntegerCoordinate(this.coordinate.x - 2, this.coordinate.y);
            }
            break;
        }
        boolean move1_valid = false;
        if (move1 != null) {
          ChessPiece target_piece = board.pieceAt(move1);
          if (board.contains(move1) && (target_piece == null || target_piece.remove)) {
            this.valid_moves.add(new ChessMove(this.coordinate, move1, false,
              this.piece_color, this.type));
            move1_valid = true;
          }
        }
        if (capture_left != null) {
          ChessPiece target_piece = board.pieceAt(capture_left);
          if (target_piece == null || target_piece.remove) {
            ChessPiece maybe_target_piece = board.pieceAt(capture_left_en_passant);
            if (maybe_target_piece != null && maybe_target_piece.type == ChessPieceType.
              PAWN && maybe_target_piece.moved_last_turn && abs(maybe_target_piece.
              coordinate.x - maybe_target_piece.last_coordinate.x) == 2) {
              target_piece = maybe_target_piece;
            }
          }
          if (board.contains(capture_left) && target_piece != null && target_piece.piece_color != this.piece_color) {
            this.valid_moves.add(new ChessMove(this.coordinate, capture_left, true,
              this.piece_color, this.type));
          }
        }
        if (capture_right != null) {
          ChessPiece target_piece = board.pieceAt(capture_right);
          if (target_piece == null || target_piece.remove) {
            ChessPiece maybe_target_piece = board.pieceAt(capture_right_en_passant);
            if (maybe_target_piece != null && maybe_target_piece.type == ChessPieceType.
              PAWN && maybe_target_piece.moved_last_turn && abs(maybe_target_piece.
              coordinate.x - maybe_target_piece.last_coordinate.x) == 2) {
              target_piece = maybe_target_piece;
            }
          }
          if (board.contains(capture_right) && target_piece != null && target_piece.piece_color != this.piece_color) {
            this.valid_moves.add(new ChessMove(this.coordinate, capture_right, true,
              this.piece_color, this.type));
          }
        }
        if (move2 != null && move1_valid) {
          ChessPiece target_piece = board.pieceAt(move2);
          if (board.contains(move2) && (target_piece == null || target_piece.remove)) {
            this.valid_moves.add(new ChessMove(this.coordinate, move2, false,
              this.piece_color, this.type));
          }
        }
        ArrayList<ChessMove> new_moves_to_add = new ArrayList<ChessMove>();
        for (ChessMove move : this.valid_moves) {
          if (move.target.x > 0 && move.target.x < board.boardHeight() - 1) {
            continue;
          }
          move.pawn_promotion = ChessPieceType.QUEEN;
          ChessMove copied_move = move.copy();
          copied_move.pawn_promotion = ChessPieceType.ROOK;
          new_moves_to_add.add(copied_move);
          copied_move = move.copy();
          copied_move.pawn_promotion = ChessPieceType.BISHOP;
          new_moves_to_add.add(copied_move);
          copied_move = move.copy();
          copied_move.pawn_promotion = ChessPieceType.KNIGHT;
          new_moves_to_add.add(copied_move);
        }
        for (ChessMove move : new_moves_to_add) {
          this.valid_moves.add(move);
        }
        break;
      default:
        break;
    }
    if (ignore_check) {
      return;
    }
    for (Iterator<ChessMove> i = this.valid_moves.iterator(); i.hasNext();) {
      ChessMove move = i.next();
      ChessBoard copied_board = new ChessBoard(board);
      copied_board.calculate_return_moves = false;
      copied_board.makeMove(move, false);
      if (copied_board.canTakeKing()) {
        i.remove();
      }
    }
  }

   public void addCastlingMoves(ChessBoard board) {
    if (this.has_moved) {
      return;
    }
    ChessPiece[] rooks = new ChessPiece[2];
    rooks[0] = board.pieceAt(new IntegerCoordinate(this.coordinate.x, 0));
    rooks[1] = board.pieceAt(new IntegerCoordinate(this.coordinate.x, board.boardHeight() - 1));
    for (ChessPiece rook : rooks) {
      if (rook == null || rook.remove || rook.piece_color != this.piece_color ||
        rook.type != ChessPieceType.ROOK || rook.has_moved) {
        continue;
      }
      if (board.in_check == this.piece_color) {
        continue;
      }
      int direction = 1;
      if (rook.coordinate.y < this.coordinate.y) {
        direction = -1;
      }
      boolean blocking = false;
      for (int i = this.coordinate.y + direction; (i > 0 && i < board.boardHeight() - 1); i += direction) {
        ChessPiece piece = board.pieceAt(new IntegerCoordinate(this.coordinate.x, i));
        if (piece == null || piece.remove) {
          continue;
        }
        blocking = true;
        break;
      }
      if (blocking) {
        continue;
      }
      ChessMove through_check_check = new ChessMove(this.coordinate, new IntegerCoordinate(
        this.coordinate.x, this.coordinate.y + direction), false, this.piece_color, this.type);
      ChessBoard copied_board = new ChessBoard(board);
      copied_board.calculate_return_moves = false;
      copied_board.makeMove(through_check_check, false);
      if (copied_board.canTakeKing()) {
        continue;
      }
      this.valid_moves.add(new ChessMove(this.coordinate, new IntegerCoordinate(
        this.coordinate.x, this.coordinate.y + 2 * direction), false, this.piece_color, this.type));
    }
  }

   public void addBishopMoves(ChessBoard board) {
    for (int x = this.coordinate.x + 1, y = this.coordinate.y + 1; (x <
      board.boardWidth() && y < board.boardHeight()); x++, y++) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x + 1, y = this.coordinate.y - 1; x <
      board.boardWidth() && y >= 0; x++, y--) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x - 1, y = this.coordinate.y + 1; x
      >= 0 && y < board.boardHeight(); x--, y++) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x - 1, y = this.coordinate.y - 1; x >= 0 && y >= 0; x--, y--) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
  }

   public void addRookMoves(ChessBoard board) {
    for (int x = this.coordinate.x + 1, y = this.coordinate.y; x < board.boardWidth(); x++) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x, y = this.coordinate.y + 1; y < board.boardHeight(); y++) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x - 1, y = this.coordinate.y; x >= 0; x--) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
    for (int x = this.coordinate.x, y = this.coordinate.y - 1; y >= 0; y--) {
      IntegerCoordinate target = new IntegerCoordinate(x, y);
      ChessPiece target_piece = board.pieceAt(target);
      if (target_piece == null || target_piece.remove || target_piece.piece_color != this.piece_color) {
        this.valid_moves.add(new ChessMove(this.coordinate, target,
          (target_piece != null && !target_piece.remove), this.piece_color, this.type));
      }
      if (target_piece != null && !target_piece.remove) {
        break;
      }
    }
  }
}


 public String chessBoardNotation(IntegerCoordinate coordinate) {
  return Character.toString('a' + coordinate.y) + Integer.toString(coordinate.x + 1);
}


class ChessMove {
  private IntegerCoordinate source;
  private IntegerCoordinate target;
  private boolean capture;
  private ChessColor source_color;
  private ChessPieceType source_type;
  private ChessPieceType pawn_promotion = null;

  ChessMove(IntegerCoordinate source, IntegerCoordinate target, boolean capture,
    ChessColor source_color, ChessPieceType source_type) {
    this(source, target, capture, source_color, source_type, null);
  }
  ChessMove(IntegerCoordinate source, IntegerCoordinate target, boolean capture,
    ChessColor source_color, ChessPieceType source_type, ChessPieceType pawn_promotion) {
    this.source = source;
    this.target = target;
    this.capture = capture;
    this.source_color = source_color;
    this.source_type = source_type;
    this.pawn_promotion = pawn_promotion;
  }
   public ChessMove copy() {
    return new ChessMove(this.source.copy(), this.target.copy(), this.capture,
      this.source_color, this.source_type, this.pawn_promotion);
  }

   public String pgnString() {
    String source_string = chessBoardNotation(this.source);
    String target_string = chessBoardNotation(this.target);
    String piece_string = this.source_type.characterString();
    if (this.capture) {
      target_string = "x" + target_string;
    }
    if (this.pawn_promotion != null) {
      target_string += "=" + this.pawn_promotion.characterString();
    }
    return piece_string + source_string + target_string;
  }

  @Override
  public int hashCode() {
    return Objects.hash(this.source.x, this.source.y, this.target.x, this.target.y, this.capture, this.source_color, this.source_type);
  }

  @Override
  public boolean equals(Object chessmove_object) {
    if (this == chessmove_object) {
      return true;
    }
    if (chessmove_object == null || this.getClass() != chessmove_object.getClass()) {
      return false;
    }
    ChessMove chessmove = (ChessMove)chessmove_object;
    if (this.source.equals(chessmove.source) && this.target.equals(chessmove.target) &&
      this.capture == chessmove.capture && this.source_color == chessmove.source_color &&
      this.source_type == chessmove.source_type && this.pawn_promotion == chessmove.pawn_promotion) {
      return true;
    }
    return false;
  }

   public boolean castlingMove() {
    return (this.source.x == this.target.x && abs(this.source.y - this.target.y) == 2 &&
      !this.capture && this.source_type == ChessPieceType.KING);
  }

   public boolean fiftyMoveResetMove() {
    return (this.capture || this.source_type == ChessPieceType.PAWN);
  }

   public IntegerCoordinate castlingMoveRookSource(ChessBoard board) {
    if (!this.castlingMove()) {
      return null;
    }
    if (this.source.y < this.target.y) {
      return new IntegerCoordinate(this.source.x, board.boardHeight() - 1);
    }
    else {
      return new IntegerCoordinate(this.source.x, 0);
    }
  }

   public IntegerCoordinate castlingMoveRookTarget() {
    if (!this.castlingMove()) {
      return null;
    }
    if (this.source.y < this.target.y) {
      return new IntegerCoordinate(this.source.x, this.source.y + 1);
    }
    else {
      return new IntegerCoordinate(this.source.x, this.source.y - 1);
    }
  }
}


class ChessPosition {
  private String[][] square_strings;
  private int hash_code = 0;
  ChessPosition(ChessBoard board) {
    this.square_strings = new String[board.boardWidth()][board.boardHeight()];
    String hash_string = "";
    for (int i = 0; i < board.squares.length; i++) {
      for (int j = 0; j < board.squares[i].length; j++) {
        ChessPiece piece = (ChessPiece)board.squares[i][j].getPiece();
        if (piece == null || piece.remove) {
          square_strings[i][j] = "-";
          hash_string += "-";
        }
        else {
          square_strings[i][j] = piece.type.characterString(true);
          hash_string += piece.type.characterString(true);
        }
      }
    }
    this.hash_code = hash_string.hashCode();
  }
  @Override
  public int hashCode() {
    return this.hash_code;
  }
  @Override
  public boolean equals(Object chess_position_object) {
    if (this == chess_position_object) {
      return true;
    }
    if (chess_position_object == null || this.getClass() != chess_position_object.getClass()) {
      return false;
    }
    ChessPosition chess_position = (ChessPosition)chess_position_object;
    for (int i = 0; i < this.square_strings.length; i++) {
      for (int j = 0; j < this.square_strings[i].length; j++) {
        try {
          if (this.square_strings[i][j].equals(chess_position.square_strings[i][j])) {
            continue;
          }
        } catch (ArrayIndexOutOfBoundsException e) {}
        return false;
      }
    }
    return true;
  }
}
class EpicFools extends Minigame {

  EpicFools() {
    super(MinigameName.EPIC_FOOLS);
  }

   public String displayName() {
    return "Epic Fools";
  }
   public void drawBottomPanel(int time_elapsed) {}
   public void setDependencyLocations(float xi, float yi, float xf, float yf) {}
   public void restartTimers() {}
   public void displayNerdStats() {}
   public boolean leftPanelElementsHovered() {
    return false;
  }
   public FormLNZ getEscForm() {
    return null;
  }

   public void update(int time_elapsed) {}
   public void mouseMove(float mX, float mY) {}
   public void mousePress() {}
   public void mouseRelease(float mX, float mY) {}
   public void scroll(int amount) {}
   public void keyPress() {}
   public void keyRelease() {}

   public void loseFocus() {}
   public void gainFocus() {}
}
class Zambos extends Minigame {

  Zambos() {
    super(MinigameName.ZAMBOS);
  }

   public String displayName() {
    return "Zambos";
  }
   public void drawBottomPanel(int time_elapsed) {}
   public void setDependencyLocations(float xi, float yi, float xf, float yf) {}
   public void restartTimers() {}
   public void displayNerdStats() {}
   public boolean leftPanelElementsHovered() {
    return false;
  }
   public FormLNZ getEscForm() {
    return null;
  }

   public void update(int time_elapsed) {}
   public void mouseMove(float mX, float mY) {}
   public void mousePress() {}
   public void mouseRelease(float mX, float mY) {}
   public void scroll(int amount) {}
   public void keyPress() {}
   public void keyRelease() {}

   public void loseFocus() {}
   public void gainFocus() {}
}
enum BoardOrientation {
  STANDARD, LEFT, RIGHT;
}

abstract class GridBoard {
  abstract class BoardSquare {
    class SquareButton extends RectangleButton {
      protected boolean no_draw_button = false;

      SquareButton() {
        super(0, 0, 0, 0);
        this.use_time_elapsed = true;
        this.force_left_button = false;
        this.roundness = 0;
        this.setColors(Constants.color_transparent, Constants.color_transparent,
          Constants.color_transparent, Constants.color_transparent, Constants.color_transparent);
      }

       public void turnOffDrawing() {
        this.no_draw_button = true;
      }
       public void turnOnDrawing() {
        this.no_draw_button = false;
      }

      @Override public 
      void drawButton() {
        if (this.no_draw_button) {
          return;
        }
        super.drawButton();
      }

       public void dehover() {}
       public void hover() {}
       public void click() {
        BoardSquare.this.clicked();
      }
       public void release() {
        BoardSquare.this.released();
      }
    }

    protected IntegerCoordinate coordinate;
    protected HashMap<Integer, GamePiece> pieces;
    protected SquareButton button = new SquareButton();

    BoardSquare(IntegerCoordinate coordinate) {
      this.coordinate = coordinate;
      this.initializePieceMap();
    }

     public abstract void initializePieceMap();

     public void clearSquare() {
      this.pieces.clear();
    }

     public void addPiece(GamePiece piece) {
      if (this.pieces.containsKey(piece.board_key)) {
        global.errorMessage("ERROR: Can't add piece with key " + piece.board_key +
          " to square " + this.coordinate.x + ", " + this.coordinate.y + ".");
        return;
      }
      this.pieces.put(piece.board_key, piece);
      piece.coordinate = new IntegerCoordinate(this.coordinate.x, this.coordinate.y);
    }

     public abstract boolean canTakePiece(GamePiece piece);
     public abstract GamePiece getPiece();

     public boolean empty() {
      return this.pieces.isEmpty();
    }

     public void setSize(float size) {
      this.button.setLocation(0, 0, size, size);
    }

     public void update(int time_elapsed) {
      this.updateWithoutDisplay(time_elapsed);
      this.drawSquare();
    }
     public void updateWithoutDisplay(int time_elapsed) {
      this.button.turnOffDrawing();
      this.button.update(time_elapsed);
      this.button.turnOnDrawing();
      Iterator iterator = this.pieces.entrySet().iterator();
      while(iterator.hasNext()) {
        Map.Entry<Integer, GamePiece> entry = (Map.Entry<Integer, GamePiece>)iterator.next();
        if (entry.getValue().remove) {
          iterator.remove();
        }
      }
    }
     public abstract void drawSquare();

     public void mouseMove(float mX, float mY) {
      this.button.mouseMove(mX, mY);
    }

     public void mousePress() {
      this.button.mousePress();
    }

     public void mouseRelease(float mX, float mY) {
      this.button.mouseRelease(mX, mY);
    }

     public abstract void clicked();
     public abstract void released();
  }


  protected BoardSquare[][] squares;
  protected BoardOrientation orientation = BoardOrientation.STANDARD;
  protected HashMap<Integer, GamePiece> pieces;
  protected int next_piece_key = 1;

  protected float xi = 0;
  protected float yi = 0;
  protected float xf = 0;
  protected float yf = 0;
  protected float xi_draw = 0;
  protected float yi_draw = 0;
  protected float square_length = 0;

  protected IntegerCoordinate coordinate_hovered = null;

  GridBoard(int w, int h) {
    this.squares = new BoardSquare[w][h];
    this.initializeSquares();
    this.initializePieceMap();
  }

   public void setOrientation(BoardOrientation orientation) {
    if (this.boardWidth() != this.boardHeight()) {
      return;
    }
    this.orientation = orientation;
  }

   public int boardWidth() {
    return this.squares.length;
  }
   public int boardHeight() {
    if (this.squares.length > 0) {
      return this.squares[0].length;
    }
    return 0;
  }

   public boolean contains(IntegerCoordinate coordinate) {
    return this.squareAt(coordinate) != null;
  }

   public abstract void initializePieceMap();
   public abstract void initializeSquares();

   public void clearBoard() {
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j].clearSquare();
      }
    }
  }

   public BoardSquare squareAt(IntegerCoordinate coordinate) {
    if (coordinate == null) {
      return null;
    }
    try {
      return this.squares[coordinate.x][coordinate.y];
    } catch(ArrayIndexOutOfBoundsException e) {
      return null;
    }
  }

   public void addPiece(GamePiece piece, IntegerCoordinate coordinate) {
    this.addPiece(piece, coordinate.x, coordinate.y);
  }
   public void addPiece(GamePiece piece, int x, int y) {
    if (x < 0 || y < 0 || x >= this.boardWidth() || y >= this.boardHeight()) {
      global.errorMessage("ERROR: Can't add piece to square " + x + ", " + y +
        " since that square is not on the board.");
      return;
    }
    if (!this.squares[x][y].canTakePiece(piece)) {
      global.errorMessage("ERROR: Can't add piece with key " + piece.board_key +
        " to square " + x + ", " + y + " since it won't take it.");
      return;
    }
    this.addPiece(piece, x, y, this.next_piece_key);
    this.next_piece_key++;
  }
   public void addPiece(GamePiece piece, int x, int y, int board_key) {
    piece.board_key = board_key;
    this.pieces.put(board_key, piece);
    this.squares[x][y].addPiece(piece);
    this.addedPiece(piece);
  }

   public abstract void addedPiece(GamePiece piece);

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    if (this.boardWidth() == 0 || this.boardHeight() == 0) {
      return;
    }

    float square_length_from_width = (xf - xi) / this.boardWidth();
    float square_length_from_height = (yf - yi) / this.boardHeight();
    this.square_length = min(square_length_from_width, square_length_from_height);
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j].setSize(this.square_length);
      }
    }
    this.xi_draw = xi + 0.5f * (xf - xi - this.boardWidth() * this.square_length);
    this.yi_draw = yi + 0.5f * (yf - yi - this.boardHeight() * this.square_length);
  }

   public float squareCenterX(IntegerCoordinate coordinate) {
    if (coordinate == null) {
      return 0;
    }
    float x_curr = this.xi_draw;
    switch(this.orientation) {
      case STANDARD:
        x_curr += coordinate.x * this.square_length;
        break;
      case LEFT:
        x_curr += (this.squares[0].length - 1 - coordinate.y) * this.square_length;
        break;
      case RIGHT:
        x_curr += coordinate.y * this.square_length;
        break;
    }
    return x_curr + 0.5f * this.square_length;
  }

   public float squareCenterY(IntegerCoordinate coordinate) {
    if (coordinate == null) {
      return 0;
    }
    float y_curr = this.yi_draw;
    switch(this.orientation) {
      case STANDARD:
        y_curr += coordinate.y * this.square_length;
        break;
      case LEFT:
        y_curr += coordinate.x * this.square_length;
        break;
      case RIGHT:
        y_curr += (this.squares.length - 1 - coordinate.x) * this.square_length;
        break;
    }
    return y_curr + 0.5f * this.square_length;
  }

   public void update(int time_elapsed) {
    float x_curr = this.xi_draw;
    float y_curr = this.yi_draw;
    switch(this.orientation) {
      case STANDARD:
        for (int i = 0; i < this.squares.length; i++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int j = 0; j < this.squares[i].length; j++, y_curr += this.square_length) {
            translate(x_curr, y_curr);
            this.squares[i][j].update(time_elapsed);
            translate(-x_curr, -y_curr);
          }
        }
        break;
      case LEFT:
        for (int j = this.squares[0].length - 1; j >= 0; j--, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = 0; i < this.squares.length; i++, y_curr += this.square_length) {
            translate(x_curr, y_curr);
            this.squares[i][j].update(time_elapsed);
            translate(-x_curr, -y_curr);
          }
        }
        break;
      case RIGHT:
        for (int j = 0; j < this.squares[0].length; j++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = this.squares.length - 1; i >= 0; i--, y_curr += this.square_length) {
            translate(x_curr, y_curr);
            this.squares[i][j].update(time_elapsed);
            translate(-x_curr, -y_curr);
          }
        }
        break;
    }
    this.removePieces();
    this.afterUpdate();
  }
   public void updateWithoutDisplay(int time_elapsed) {
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j].updateWithoutDisplay(time_elapsed);
      }
    }
    this.removePieces();
  }
   public void removePieces() {
    Iterator iterator = this.pieces.entrySet().iterator();
    while(iterator.hasNext()) {
      Map.Entry<Integer, GamePiece> entry = (Map.Entry<Integer, GamePiece>)iterator.next();
      if (entry.getValue().remove) {
        iterator.remove();
      }
    }
  }
   public abstract void afterUpdate();

   public void mouseMove(float mX, float mY) {
    this.coordinate_hovered = null;
    float x_curr = this.xi_draw;
    float y_curr = this.yi_draw;
    switch(this.orientation) {
      case STANDARD:
        for (int i = 0; i < this.squares.length; i++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int j = 0; j < this.squares[i].length; j++, y_curr += this.square_length) {
            this.squares[i][j].mouseMove(mX - x_curr, mY - y_curr);
            if (this.squares[i][j].button.hovered) {
              this.coordinate_hovered = this.squares[i][j].coordinate;
            }
          }
        }
        break;
      case LEFT:
        for (int j = this.squares[0].length - 1; j >= 0; j--, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = 0; i < this.squares.length; i++, y_curr += this.square_length) {
            this.squares[i][j].mouseMove(mX - x_curr, mY - y_curr);
            if (this.squares[i][j].button.hovered) {
              this.coordinate_hovered = this.squares[i][j].coordinate;
            }
          }
        }
        break;
      case RIGHT:
        for (int j = 0; j < this.squares[0].length; j++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = this.squares.length - 1; i >= 0; i--, y_curr += this.square_length) {
            this.squares[i][j].mouseMove(mX - x_curr, mY - y_curr);
            if (this.squares[i][j].button.hovered) {
              this.coordinate_hovered = this.squares[i][j].coordinate;
            }
          }
        }
        break;
    }
  }

   public void mousePress() {
    for (int i = 0; i < this.squares.length; i++) {
      for (int j = 0; j < this.squares[i].length; j++) {
        this.squares[i][j].mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    float x_curr = this.xi_draw;
    float y_curr = this.yi_draw;
    switch(this.orientation) {
      case STANDARD:
        for (int i = 0; i < this.squares.length; i++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int j = 0; j < this.squares[i].length; j++, y_curr += this.square_length) {
            this.squares[i][j].mouseRelease(mX - x_curr, mY - y_curr);
          }
        }
        break;
      case LEFT:
        for (int j = this.squares[0].length - 1; j >= 0; j--, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = 0; i < this.squares.length; i++, y_curr += this.square_length) {
            this.squares[i][j].mouseRelease(mX - x_curr, mY - y_curr);
          }
        }
        break;
      case RIGHT:
        for (int j = 0; j < this.squares[0].length; j++, x_curr += this.square_length) {
          y_curr = this.yi_draw;
          for (int i = this.squares.length - 1; i >= 0; i--, y_curr += this.square_length) {
            this.squares[i][j].mouseRelease(mX - x_curr, mY - y_curr);
          }
        }
        break;
    }
  }
}


abstract class GamePiece {
  protected int board_key = -1;
  protected boolean remove = false;
  protected IntegerCoordinate coordinate = new IntegerCoordinate(0, 0);

  GamePiece() {
  }

   public abstract PImage getImage();
}
// Java mod with negative numbers
 public float negMod(float a, float b) {
  return (a % b + b) % b;
}

// Element to color
 public int elementalColor(Element e) {
  switch(e) {
    case GRAY:
      return ccolor(170);
    case BLUE:
      return ccolor(0, 0, 255);
    case RED:
      return ccolor(255, 0, 0);
    case CYAN:
      return ccolor(0, 255, 255);
    case ORANGE:
      return ccolor(255, 165, 0);
    case BROWN:
      return ccolor(51, 45, 26);
    case PURPLE:
      return ccolor(125, 0, 125);
    case YELLOW:
      return ccolor(255, 255, 0);
    case MAGENTA:
      return ccolor(255, 0, 255);
    default:
      global.errorMessage("ERROR: Element " + e.element_name() + " doesn't have a color.");
      return ccolor(0);
  }
}
 public int elementalColorDark(Element e) {
  switch(e) {
    case GRAY:
      return ccolor(145);
    case BLUE:
      return ccolor(0, 0, 200);
    case RED:
      return ccolor(200, 0, 0);
    case CYAN:
      return ccolor(0, 200, 200);
    case ORANGE:
      return ccolor(200, 140, 0);
    case BROWN:
      return ccolor(20, 15, 10);
    case PURPLE:
      return ccolor(100, 0, 100);
    case YELLOW:
      return ccolor(200, 200, 0);
    case MAGENTA:
      return ccolor(200, 0, 200);
    default:
      global.errorMessage("ERROR: Element " + e.element_name() + " doesn't have a color.");
      return ccolor(0);
  }
}
 public int elementalColorLight(Element e) {
  switch(e) {
    case GRAY:
      return ccolor(195);
    case BLUE:
      return ccolor(25, 25, 255);
    case RED:
      return ccolor(255, 25, 25);
    case CYAN:
      return ccolor(25, 255, 255);
    case ORANGE:
      return ccolor(255, 190, 25);
    case BROWN:
      return ccolor(70, 65, 45);
    case PURPLE:
      return ccolor(150, 0, 150);
    case YELLOW:
      return ccolor(255, 255, 40);
    case MAGENTA:
      return ccolor(255, 40, 255);
    default:
      global.errorMessage("ERROR: Element " + e.element_name() + " doesn't have a color.");
      return ccolor(0);
  }
}
 public int elementalColorText(Element e) {
  switch(e) {
    case GRAY:
    case BLUE:
    case RED:
    case CYAN:
    case ORANGE:
    case PURPLE:
    case YELLOW:
    case MAGENTA:
      return ccolor(0);
    case BROWN:
      return ccolor(255);
    default:
      global.errorMessage("ERROR: Element " + e.element_name() + " doesn't have a color.");
      return ccolor(0);
  }
}
 public int elementalColorLocked(Element e) {
  switch(e) {
    case GRAY:
      return ccolor(120);
    case BLUE:
      return ccolor(100, 100, 150);
    case RED:
      return ccolor(150, 100, 100);
    case CYAN:
      return ccolor(100, 150, 150);
    case ORANGE:
      return ccolor(160, 120, 100);
    case BROWN:
      return ccolor(80, 75, 70);
    case PURPLE:
      return ccolor(90, 50, 90);
    case YELLOW:
      return ccolor(150, 150, 100);
    case MAGENTA:
      return ccolor(150, 100, 150);
    default:
      global.errorMessage("ERROR: Element " + e.element_name() + " doesn't have a color.");
      return ccolor(0);
  }
}

// Random events
 public boolean randomChance(float percent) {
  if (random(1) < percent) {
    return true;
  }
  return false;
}
 public int randomInt(int min, int max) {
  if (max < min) {
    return randomInt(max, min);
  }
  return min + PApplet.parseInt(floor(random(1 + max - min)));
}
 public float randomFloat(float min, float max) {
  if (max < min) {
    return randomFloat(max, min);
  }
  return min + random(max - min);
}

// String to primitive casts
 public boolean isInt(String str) {
  try {
    int i = Integer.parseInt(str);
    return true;
  } catch(NumberFormatException e) {
    return false;
  }
}
 public int toInt(String str) {
  int i = -1;
  try {
    i = Integer.parseInt(str);
  } catch(NumberFormatException e) {}
  return i;
}

 public boolean isFloat(String str) {
  try {
    float i = Float.parseFloat(str);
    return true;
  } catch(NumberFormatException e) {
    return false;
  }
}
 public float toFloat(String str) {
  float i = -1;
  try {
    i = Float.parseFloat(str);
  } catch(NumberFormatException e) {}
  return i;
}

 public boolean isBoolean(String str) {
  if (str.equals(Boolean.toString(true)) || str.equals(Boolean.toString(false))) {
    return true;
  }
  else {
    return false;
  }
}
 public boolean toBoolean(String str) {
  if (str.equals(Boolean.toString(true))) {
    return true;
  }
  else {
    return false;
  }
}


// color functions
 public int brighten(int c) {
  return adjust_color_brightness(c, 1.05f);
}
 public int darken(int c) {
  return adjust_color_brightness(c, 0.95f);
}
 public int adjust_color_brightness(int c, float factor) {
  float r = constrain(factor * (c >> 16 & 0xFF), 0, 255);
  float g = constrain(factor * (c >> 8 & 0xFF), 0, 255);
  float b = constrain(factor * (c & 0xFF), 0, 255);
  return ccolor(r, g, b, alpha(c));
}
abstract class NotificationLNZ {
  protected boolean sliding_in = true;
  protected boolean sliding_out = false;
  protected boolean finished = false;
  protected boolean hovered = false;
  protected float time_left = Constants.notification_slide_time;

  NotificationLNZ() {
  }

   public void update(int time_elapsed) {
    if (this.finished) {
      return;
    }
    this.drawNotification();
    this.time_left -= time_elapsed;
    if (this.time_left < 0) {
      if (this.sliding_in) {
        this.sliding_in = false;
        this.time_left = Constants.notification_display_time;
      }
      else if (this.sliding_out) {
        this.finished = true;
      }
      else {
        this.sliding_out = true;
        this.time_left = Constants.notification_slide_time;
      }
    }
  }

   public abstract void drawNotification();

   public void mouseMove(float mX, float mY) {
    if (!this.sliding_in && !this.sliding_out && this.hovered(mX, mY)) {
      this.time_left = Constants.notification_display_time;
      this.hovered = true;
    }
    else {
      this.hovered = false;
    }
  }

   public abstract boolean hovered(float mX, float mY);

   public void mousePress() {
    if (this.hovered) {
      this.finished = true;
    }
  }
}


abstract class BottomRightNotification extends NotificationLNZ {
  private String header;
  private String content;
  private int color_background;
  private int color_text;

  BottomRightNotification(String header, String content, int color_background, int color_text) {
    super();
    this.header = header;
    this.content = content;
    this.color_background = color_background;
    this.color_text = color_text;
  }

   public void drawNotification() {
    fill(this.color_background);
    noStroke();
    rectMode(CORNERS);
    if (this.sliding_in) {
      float curr_height = Constants.notification_achievement_height *
        (1 - this.time_left / Constants.notification_slide_time);
      rect(width - Constants.notification_achievement_width, height - curr_height, width, height);
    }
    else if (this.sliding_out) {
      float curr_height = Constants.notification_achievement_height *
        this.time_left / Constants.notification_slide_time;
      rect(width - Constants.notification_achievement_width, height - curr_height, width, height);
    }
    else {
      rect(width - Constants.notification_achievement_width, height -
        Constants.notification_achievement_height, width, height);
      fill(this.color_text);
      textSize(18);
      textAlign(CENTER, TOP);
      text(this.header, width - 0.5f * Constants.notification_achievement_width,
        height - Constants.notification_achievement_height - 1);
      float offset = textAscent() + textDescent() + 2;
      stroke(this.color_text);
      strokeWeight(2);
      line(width - Constants.notification_achievement_width + 3, height -
        Constants.notification_achievement_height + offset, width - 3, height -
        Constants.notification_achievement_height + offset);
      textSize(16);
      textAlign(CENTER, CENTER);
      text(this.content, width - 0.5f * Constants.notification_achievement_width,
        height - 0.5f * (Constants.notification_achievement_height - offset));
    }
  }

   public boolean hovered(float mX, float mY) {
    if (width - mX < Constants.notification_achievement_width && height - mY <
      Constants.notification_achievement_height && mX < width && mY < height) {
      return true;
    }
    return false;
  }
}


class AchievementNotification extends BottomRightNotification {
  AchievementNotification(AchievementCode code) {
    super("Achievement Complete!", code.display_name(), color(160, 155, 88, 200), color(0));
  }
}


class AreaUnlockNotification extends BottomRightNotification {
  AreaUnlockNotification(Location location) {
    super("Area Unlocked!", location.display_name(), color(177, 156, 217, 200), color(0));
  }
}


class HeroUnlockNotification extends BottomRightNotification {
  HeroUnlockNotification(HeroCode code) {
    super("Hero Unlocked!", code.display_name(), color(255, 127, 127, 200), color(0));
  }
}


class MinigameUnlockNotification extends BottomRightNotification {
  MinigameUnlockNotification(MinigameName name) {
    super("Minigame Unlocked!", name.displayName(), color(100, 255, 255, 200), color(0));
  }
}
enum PlayingStatus {
  INITIAL, STARTING_NEW, LOADING_SAVED, PLAYING;
}


class PlayingInterface extends InterfaceLNZ {

  abstract class PlayingButton extends RectangleButton {
    PlayingButton() {
      super(0, 0.94f * height, 0, height - Constants.mapEditor_buttonGapSize);
      this.raised_border = true;
      this.roundness = 0;
      this.setColors(color(170), color(222, 184, 135), color(244, 164, 96), color(205, 133, 63), color(0));
      this.show_message = true;
    }
     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn2");
    }
     public void dehover() {}
     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick1");
    }
  }

  class PlayingButton1 extends PlayingButton {
    PlayingButton1() {
      super();
      this.message = "";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      Hero h = PlayingInterface.this.getCurrentHeroIfExists();
      if (h != null) {
        if (PlayingInterface.this.form != null || PlayingInterface.this.status != PlayingStatus.PLAYING) {
          return;
        }
        if (this.message.contains("Abandon")) {
          PlayingInterface.this.form = new AbandonLevelWhilePlayingForm(h);
        }
        else {
          PlayingInterface.this.form = new EnterNewCampaignForm(h);
        }
      }
    }
  }

  class PlayingButton2 extends PlayingButton {
    PlayingButton2() {
      super();
      this.message = "Options";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      PlayingInterface.this.form = new OptionsForm();
    }
  }

  class PlayingButton3 extends PlayingButton {
    PlayingButton3() {
      super();
      this.message = "Heroes";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      PlayingInterface.this.form = new HeroesForm();
    }
  }

  class PlayingButton4 extends PlayingButton {
    PlayingButton4() {
      super();
      this.message = "Main\nMenu";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      PlayingInterface.this.form = new GoToMainMenuForm();
    }
  }


  class GoToMainMenuForm extends ConfirmForm {
    GoToMainMenuForm() {
      super("Main Menu", "Are you sure you want to save and exit to the main menu?");
    }
     public void submit() {
      this.canceled = true;
      PlayingInterface.this.saveAndExitToMainMenu();
    }
  }


  abstract class PlayingForm extends FormLNZ {
    PlayingForm(String title, float formWidth, float formHeight) {
      super(0.5f * (width - formWidth), 0.5f * (height - formHeight),
        0.5f * (width + formWidth), 0.5f * (height + formHeight));
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
    }
  }


  class ConfirmStartLevelForm extends PlayingForm {
    protected Hero hero = null;
    ConfirmStartLevelForm(Hero hero) {
      super("Start Level: " + hero.location.display_name(), 550, 390);
      this.hero = hero;

      MessageFormField message1 = new MessageFormField("Begin the following level?");
      if (hero.location.isArea()) {
        message1.setValue("Begin playing in the following area?");
      }
      MessageFormField message2 = new MessageFormField("Hero: " + hero.display_name());
      message2.text_color = color(120, 30, 120);
      message2.setTextSize(18);
      MessageFormField message3 = new MessageFormField("Location: " + hero.location.display_name());
      message3.text_color = color(120, 30, 120);
      message3.setTextSize(18);
      MessageFormField message4 = new MessageFormField("");
      message4.text_color = color(150, 20, 20);
      message4.setTextSize(18);
      SubmitCancelFormField submit = new SubmitCancelFormField("Begin Level", "Abandon Level");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      if (hero.location.isArea()) {
        submit.button1.message = "Enter Area";
        submit.button2.message = "";
        submit.button2.disabled = true;
      }
      ButtonFormField switch_hero = new ButtonFormField("Switch Hero");
      switch_hero.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(10));
      this.addField(message1);
      this.addField(message2);
      this.addField(message3);
      this.addField(new SpacerFormField(10));
      this.addField(message4);
      this.addField(new SpacerFormField(10));
      this.addField(submit);
      this.addField(switch_hero);
    }

    @Override public 
    void cancel() {
      if (this.hero.location.isArea()) {
        this.fields.get(5).setValue("You can't abandon an area.");
        return;
      }
      Location area_location = this.hero.location.areaLocation();
      if (global.profile.areas.containsKey(area_location) && global.profile.areas.get(area_location) == Boolean.TRUE) {
        PlayingInterface.this.form = new ConfirmAbandonForm();
        this.canceled = true;
      }
      else {
        this.fields.get(5).setValue("You can't abandon this level as you haven't explored the surrounding area.");
      }
    }

     public void submit() {
      PlayingInterface.this.startLevel();
      this.canceled = true;
    }

    @Override public 
    void buttonPress(int i) {
      switch(i) {
        case 8: // switch hero
          PlayingInterface.this.heroesForm();
          break;
        default:
          global.errorMessage("ERROR: Button press code " + i + " not recognized in ConfirmStartLevelForm.");
          break;
      }
    }
  }


  class ConfirmContinueLevelForm extends PlayingForm {
    protected Hero hero = null;
    ConfirmContinueLevelForm(Hero hero) {
      super("Continue Level: " + hero.location.display_name(), 550, 440);
      this.hero = hero;

      MessageFormField message1 = new MessageFormField("Continue the following level?");
      if (hero.location.isArea()) {
        message1.setValue("Continue playing in the following area?");
      }
      MessageFormField message2 = new MessageFormField("Hero: " + hero.display_name());
      message2.text_color = color(120, 30, 120);
      message2.setTextSize(18);
      MessageFormField message3 = new MessageFormField("Location: " + hero.location.display_name());
      message3.text_color = color(120, 30, 120);
      message3.setTextSize(18);
      MessageFormField message4 = new MessageFormField("");
      message4.text_color = color(150, 20, 20);
      message4.setTextSize(18);
      SubmitCancelFormField submit = new SubmitCancelFormField("Continue Level", "Abandon Level");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      if (hero.location.isArea()) {
        submit.button1.message = "Continue";
        submit.button2.message = "";
        submit.button2.disabled = true;
      }
      ButtonFormField switch_hero = new ButtonFormField("Switch Hero");
      switch_hero.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      ButtonFormField restart_level = new ButtonFormField("Restart Level");
      restart_level.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(10));
      this.addField(message1);
      this.addField(message2);
      this.addField(message3);
      this.addField(new SpacerFormField(10));
      this.addField(message4);
      this.addField(new SpacerFormField(10));
      this.addField(submit);
      this.addField(switch_hero);
      if (!hero.location.isArea()) {
        this.addField(restart_level);
      }
    }

    @Override public 
    void cancel() {
      if (this.hero.location.isArea()) {
        this.fields.get(5).setValue("You can't abandon an area.");
        return;
      }
      Location area_location = this.hero.location.areaLocation();
      if (global.profile.areas.containsKey(area_location) && global.profile.areas.get(area_location) == Boolean.TRUE) {
        PlayingInterface.this.form = new ConfirmAbandonForm();
        this.canceled = true;
      }
      else {
        this.fields.get(5).setValue("You can't abandon this level as you haven't explored the surrounding area.");
      }
    }

     public void submit() {
      PlayingInterface.this.continueLevel();
      this.canceled = true;
    }

    @Override public 
    void buttonPress(int i) {
      switch(i) {
        case 8: // switch hero
          PlayingInterface.this.heroesForm();
          break;
        case 9: // restart level
          if (this.hero.location.isArea()) {
            this.fields.get(5).setValue("You can't restart an area.");
            return;
          }
          PlayingInterface.this.form = new ConfirmRestartForm();
          this.canceled = true;
          break;
        default:
          global.errorMessage("ERROR: Button press code " + i + " not recognized in ConfirmContinueLevelForm.");
          break;
      }
    }
  }


  class AbandonLevelWhilePlayingForm extends PlayingForm {
    protected Hero hero = null;
    AbandonLevelWhilePlayingForm(Hero hero) {
      super("Abandon Level: " + hero.location.display_name(), 550, 440);
      this.hero = hero;
      this.cancel = null;

      MessageFormField message1 = new MessageFormField("Abandon the following level?");
      MessageFormField message2 = new MessageFormField("Hero: " + hero.display_name());
      message2.text_color = color(120, 30, 120);
      message2.setTextSize(18);
      MessageFormField message3 = new MessageFormField("Location: " + hero.location.display_name());
      message3.text_color = color(120, 30, 120);
      if (hero.location.isArea()) {
        message1.setValue("You can't abandon an area."); // basic instruction on how to start next level
      }
      message3.setTextSize(18);
      MessageFormField message4 = new MessageFormField("");
      message4.text_color = color(150, 20, 20);
      message4.setTextSize(18);
      SubmitCancelFormField submit = new SubmitCancelFormField("Abandon Level", "Restart Level");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      if (hero.location.isArea()) {
        submit.button1.message = "Continue";
        submit.button2.message = "";
        submit.button2.disabled = true;
      }
      ButtonFormField switch_hero = new ButtonFormField("Switch Hero");
      switch_hero.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      ButtonFormField continue_level = new ButtonFormField("Continue Level");
      continue_level.button.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(10));
      this.addField(message1);
      this.addField(message2);
      this.addField(message3);
      this.addField(new SpacerFormField(10));
      this.addField(message4);
      this.addField(new SpacerFormField(10));
      this.addField(submit);
      this.addField(switch_hero);
      this.addField(continue_level);
    }

    @Override public 
    void cancel() {
      if (this.hero.location.isArea()) {
        this.fields.get(5).setValue("You can't restart an area.");
        return;
      }
      PlayingInterface.this.form = new ConfirmRestartForm();
      this.canceled = true;
    }

     public void submit() {
      if (this.hero.location.isArea()) {
        this.fields.get(5).setValue("You can't abandon an area.");
        return;
      }
      Location area_location = this.hero.location.areaLocation();
      if (global.profile.areas.containsKey(area_location) && global.profile.areas.get(area_location) == Boolean.TRUE) {
        PlayingInterface.this.form = new ConfirmAbandonForm();
        this.canceled = true;
      }
      else {
        this.fields.get(5).setValue("You can't abandon this level as you haven't explored the surrounding area.");
      }
    }

    @Override public 
    void buttonPress(int i) {
      switch(i) {
        case 8: // switch hero
          PlayingInterface.this.heroesForm();
          break;
        case 9: // continue level
          this.canceled = true;
          break;
        default:
          global.errorMessage("ERROR: Button press code " + i + " not recognized in AbandonLevelWhilePlayingForm.");
          break;
      }
    }
  }


  abstract class ConfirmActionForm extends FormLNZ {
    ConfirmActionForm(String title, String message) {
      super(0.5f * width - 120, 0.5f * height - 120, 0.5f * width + 120, 0.5f * height + 120);
      this.setTitleText(title);
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));

      SubmitCancelFormField submit = new SubmitCancelFormField("  Ok  ", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      TextBoxFormField textbox = new TextBoxFormField(message, 120);
      textbox.textbox.scrollbar.setButtonColors(color(170), color(190, 255, 190),
        color(220, 255, 220), color(160, 220, 160), color(0));

      this.addField(new SpacerFormField(0));
      this.addField(textbox);
      this.addField(submit);
    }

     public void submit() {
      this.canceled = true;
      this.doAction();
    }

     public abstract void doAction();
  }


  class ConfirmAbandonForm extends ConfirmActionForm {
    ConfirmAbandonForm() {
      super("Abandon Level", "Are you sure you want to abandon the level?");
    }
     public void doAction() {
      if (PlayingInterface.this.status == PlayingStatus.PLAYING) {
        PlayingInterface.this.saveAndReturnToInitialState();
      }
      PlayingInterface.this.abandonLevel();
    }
  }


  class ConfirmRestartForm extends ConfirmActionForm {
    ConfirmRestartForm() {
      super("Restart Level", "Are you sure you want to restart the level?");
    }
     public void doAction() {
      if (PlayingInterface.this.status == PlayingStatus.PLAYING) {
        PlayingInterface.this.saveAndReturnToInitialState();
      }
      PlayingInterface.this.restartLevel();
    }
  }


  class ConfirmLaunchCampaign extends ConfirmActionForm {
    protected Location location = Location.ERROR;
    ConfirmLaunchCampaign(Location location) {
      super("Launch Campaign", "Are you sure you want to launch a new campaign?");
      this.location = location;
    }
     public void doAction() {
      PlayingInterface.this.saveAndReturnToInitialState();
      PlayingInterface.this.launchCampaign(this.location);
    }
  }


  class EnterNewCampaignForm extends FormLNZ {
    protected Hero hero = null;
    protected DropDownList list = null;

    EnterNewCampaignForm(Hero hero) {
      super(0.5f * (width - 300), 0.5f * (height - 400),
        0.5f * (width + 300), 0.5f * (height + 400));
      this.setTitleText("Enter New Campaign");
      this.setTitleSize(18);
      this.color_background = color(180, 250, 180);
      this.color_header = color(30, 170, 30);
      this.hero = hero;

      TextBoxFormField list_field = new TextBoxFormField("", 100);
      this.list = new DropDownList();
      this.list.setLocation(0, 0, 0, 100);
      this.list.hint_text = "Select Campaign to Launch";
      boolean first = true;
      for (Location a : hero.location.locationsFromArea()) {
        if (first) {
          first = false;
          this.list.setText(a.display_name());
        }
        else {
          this.list.addLine(a.display_name());
        }
      }
      list_field.textbox = this.list;
      SubmitCancelFormField submit = new SubmitCancelFormField("Launch Campaign", "Cancel");
      submit.button1.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));
      submit.button2.setColors(color(220), color(190, 240, 190),
        color(140, 190, 140), color(90, 140, 90), color(0));

      this.addField(new SpacerFormField(0));
      this.addField(list_field);
      this.addField(submit);
    }

     public void submit() {
      String location_name = this.list.highlightedLine();
      if (location_name == null) {
        return;
      }
      Location new_location = Location.location(location_name);
      if (new_location == null || new_location == Location.ERROR) {
        global.errorMessage("ERROR: The location name " + location_name +
          " gave an invalid location.");
        return;
      }
      if (!new_location.isCampaignStart()) {
        global.errorMessage("ERROR: The location " + new_location.display_name() +
          " is not the start of any campaign.");
        return;
      }
      for (Map.Entry<HeroCode, Hero> entry : global.profile.heroes.entrySet()) {
        // can't enter campaign another hero is in
        if (entry.getValue().location.getCampaignStart() == new_location) {
          return;
        }
      }
      PlayingInterface.this.form = new ConfirmLaunchCampaign(new_location);
      this.canceled = true;
    }
  }


  class OpenNewLevelThread extends Thread {
    private Level level = null;
    private Hero hero = null;
    private String curr_status = "";
    private boolean running = true;

    OpenNewLevelThread(Hero hero) {
      super("OpenNewLevelThread");
      this.hero = hero;
    }

     public void stopThread() {
      this.running = false;
      deleteFolder(PlayingInterface.this.savePath + this.hero.location.file_name());
    }

    @Override public 
    void run() {
      while(this.running) {
        this.curr_status += "Gathering Level Data";
        if (this.hero == null) {
          this.curr_status += " -> No hero found.";
          delay(2500);
          return;
        }
        if (this.hero.location == null || this.hero.location == Location.ERROR) {
          this.curr_status += " -> No hero location found.";
          delay(2500);
          return;
        }
        this.level = new Level("data/locations", this.hero.location);
        if (this.level.nullify) {
          this.curr_status += " -> " + global.lastErrorMessage();
          delay(2500);
          return;
        }
        this.curr_status += "\nCopying Data";
        mkdir(PlayingInterface.this.savePath);
        String destination_folder = PlayingInterface.this.savePath + this.hero.location.file_name();
        deleteFolder(destination_folder);
        copyFolder("data/locations/" + this.hero.location.file_name(), destination_folder);
        this.level.folderPath = PlayingInterface.this.savePath;
        this.level.save();
        if (!this.hero.location.isArea()) {
          PrintWriter hero_file = createWriter(destination_folder + "/old_hero.lnz");
          hero_file.println(this.hero.fileString());
          hero_file.flush();
          hero_file.close();
        }
        if (this.level.nullify) {
          this.curr_status += " -> " + global.lastErrorMessage();
          delay(2500);
          return;
        }
        this.curr_status += "\nOpening Map";
        this.level.setPlayer(this.hero);
        if (this.level.nullify) {
          this.curr_status += " -> " + global.lastErrorMessage();
          delay(2500);
          return;
        }
        if (!global.images.loaded_map_gifs) {
          this.curr_status += "\nLoading Animations";
          global.images.loadMapGifs();
        }
        break;
      }
    }
  }


  class OpenSavedLevelThread extends Thread {
    private Level level = null;
    private Hero hero = null;
    private String curr_status = "";
    private boolean running = true;

    OpenSavedLevelThread(Hero hero) {
      super("OpenSavedLevelThread");
      this.hero = hero;
    }

     public void stopThread() {
      this.running = false;
    }

    @Override public 
    void run() {
      while(this.running) {
        this.curr_status += "Opening Saved Level";
        if (this.hero == null) {
          this.curr_status += " -> No hero found.";
          delay(2500);
          return;
        }
        if (this.hero.location == null || this.hero.location == Location.ERROR) {
          this.curr_status += " -> No hero location found.";
          delay(2500);
          return;
        }
        String destination_folder = "data/profiles/" + global.profile.display_name.toLowerCase() + "/locations/";
        this.level = new Level(destination_folder, this.hero.location);
        if (this.level.nullify) {
          this.curr_status += " -> " + global.lastErrorMessage();
          delay(2500);
          return;
        }
        curr_status += "\nOpening Map";
        this.level.openCurrMap();
        this.level.addPlayer(this.hero);
        if (this.level.nullify) {
          this.curr_status += " -> " + global.lastErrorMessage();
          delay(2500);
          return;
        }
        if (!global.images.loaded_map_gifs) {
          this.curr_status += "\nLoading Animations";
          global.images.loadMapGifs();
        }
        break;
      }
    }
  }


  private PlayingButton[] buttons = new PlayingButton[4];
  private Panel leftPanel = new Panel(LEFT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);
  private Panel rightPanel = new Panel(RIGHT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);

  private String savePath = "data/profiles/" + global.profile.display_name.toLowerCase() + "/locations/";
  private Level level = null;
  private PlayingStatus status = PlayingStatus.INITIAL;

  private OpenNewLevelThread newLevelThread = null;
  private OpenSavedLevelThread savedLevelThread = null;

  private boolean return_to_confirmStartLevelForm = false;
  private boolean return_to_confirmContinueLevelForm = false;
  private boolean return_to_confirmAbandonLevelForm = false;


  PlayingInterface() {
    this.buttons[0] = new PlayingButton1();
    this.buttons[1] = new PlayingButton2();
    this.buttons[2] = new PlayingButton3();
    this.buttons[3] = new PlayingButton4();
    this.leftPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.rightPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.leftPanel.color_background = global.color_panelBackground;
    this.rightPanel.color_background = global.color_panelBackground;
    this.resizeButtons();
  }


   public void resizeButtons() {
    float buttonSize = (this.rightPanel.size_curr - 5 * Constants.mapEditor_buttonGapSize) / 4.0f;
    float xi = width - this.rightPanel.size_curr + Constants.mapEditor_buttonGapSize;
    this.buttons[0].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[1].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[2].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[3].setXLocation(xi, xi + buttonSize);
  }


   public void checkLevelSave() {
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    if (folderExists(this.savePath + curr_hero.location.file_name())) {
      this.form = new ConfirmContinueLevelForm(curr_hero);
    }
    else {
      this.form = new ConfirmStartLevelForm(curr_hero);
    }
  }

   public void startLevel() {
    if (this.level != null) {
      global.errorMessage("ERROR: Trying to open level save when current level not null.");
      return;
    }
    if (this.status != PlayingStatus.INITIAL) {
      global.errorMessage("ERROR: Trying to open level save when current status is " + this.status + ".");
      return;
    }
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    this.status = PlayingStatus.STARTING_NEW;
    this.newLevelThread = new OpenNewLevelThread(curr_hero);
    this.newLevelThread.start();
  }

   public void continueLevel() {
    if (this.level != null) {
      global.errorMessage("ERROR: Trying to open level save when current level not null.");
      return;
    }
    if (this.status != PlayingStatus.INITIAL) {
      global.errorMessage("ERROR: Trying to open level save when current status is " + this.status + ".");
      return;
    }
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    if (!folderExists(this.savePath + curr_hero.location.file_name())) {
      global.errorMessage("ERROR: No save folder at " + (this.savePath + curr_hero.location.file_name()) + ".");
      return;
    }
    this.status = PlayingStatus.LOADING_SAVED;
    this.savedLevelThread = new OpenSavedLevelThread(curr_hero);
    this.savedLevelThread.start();
  }

   public void restartLevel() {
    if (this.level != null) {
      global.errorMessage("ERROR: Trying to restart level when current level not null.");
      return;
    }
    if (this.status != PlayingStatus.INITIAL) {
      global.errorMessage("ERROR: Trying to restart level save when current status is " + this.status + ".");
      return;
    }
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    if (!folderExists(this.savePath + curr_hero.location.file_name())) {
      global.errorMessage("ERROR: No save folder at " + (this.savePath + curr_hero.location.file_name()) + ".");
      return;
    }
    if (curr_hero.location.isArea()) {
      global.errorMessage("ERROR: Can't restart " + curr_hero.location.display_name() + " since it's an area.");
      return;
    }
    Hero hero = readHeroFile(this.savePath + curr_hero.location.file_name() + "/old_hero.lnz");
    if (hero == null || hero.code == HeroCode.ERROR || hero.code != curr_hero.code || hero.location != curr_hero.location) {
      global.errorMessage("ERROR: Can't restart " + curr_hero.location.display_name() + " since old hero data corrupted.");
      return;
    }
    deleteFolder(this.savePath + curr_hero.location.file_name());
    global.profile.heroes.put(hero.code, hero);
    this.status = PlayingStatus.STARTING_NEW;
    this.newLevelThread = new OpenNewLevelThread(hero);
    this.newLevelThread.start();
  }

   public void abandonLevel() {
    if (this.level != null) {
      global.errorMessage("ERROR: Trying to restart level when current level not null.");
      return;
    }
    if (this.status != PlayingStatus.INITIAL) {
      global.errorMessage("ERROR: Trying to restart level save when current status is " + this.status + ".");
      return;
    }
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    if (curr_hero.location.isArea()) {
      global.errorMessage("ERROR: Can't abandon " + curr_hero.location.display_name() + " since it's an area.");
      return;
    }
    Location area_location = curr_hero.location.areaLocation();
    if (!global.profile.areas.containsKey(area_location) || global.profile.areas.get(area_location) == Boolean.FALSE) {
      global.errorMessage("ERROR: Can't abandon " + curr_hero.location.display_name() + " since its area isn't unlocked.");
      return;
    }
    if (folderExists(this.savePath + curr_hero.location.file_name())) {
      Hero hero = readHeroFile(this.savePath + curr_hero.location.file_name() + "/old_hero.lnz");
      if (hero == null || hero.code == HeroCode.ERROR || hero.code != curr_hero.code || hero.location != curr_hero.location) {
        global.errorMessage("ERROR: Can't restart " + curr_hero.location.display_name() + " since old hero data corrupted.");
        return;
      }
      deleteFolder(this.savePath + curr_hero.location.file_name());
      hero.location = area_location;
      global.profile.heroes.put(hero.code, hero);
      this.status = PlayingStatus.LOADING_SAVED;
      this.savedLevelThread = new OpenSavedLevelThread(hero);
      this.savedLevelThread.start();
    }
    else {
      curr_hero.location = area_location;
      this.status = PlayingStatus.STARTING_NEW;
      this.newLevelThread = new OpenNewLevelThread(curr_hero);
      this.newLevelThread.start();
    }
  }

   public void launchCampaign(Location new_location) {
    if (this.level != null) {
      global.errorMessage("ERROR: Trying to launch new campaign when current level not null.");
      return;
    }
    if (this.status != PlayingStatus.INITIAL) {
      global.errorMessage("ERROR: Trying to launch new campaign save when current status is " + this.status + ".");
      return;
    }
    if (global.profile.curr_hero == null || global.profile.curr_hero == HeroCode.ERROR) {
      global.errorMessage("ERROR: Profile has no current hero.");
      return;
    }
    Hero curr_hero = global.profile.heroes.get(global.profile.curr_hero);
    if (curr_hero == null) {
      global.errorMessage("ERROR: Profile missing curr hero " + global.profile.curr_hero + ".");
      return;
    }
    if (curr_hero.location == null || curr_hero.location == Location.ERROR) {
      global.errorMessage("ERROR: Hero " + curr_hero.display_name() + " missing location data.");
      return;
    }
    if (!curr_hero.location.isArea()) {
      global.errorMessage("ERROR: Can't launch new campaign since hero in " +
        curr_hero.location.display_name() + " which is not an area.");
      return;
    }
    if (new_location == null || new_location == Location.ERROR) {
      global.errorMessage("ERROR: New location does not exist.");
      return;
    }
    ArrayList<Location> campaign_locations = curr_hero.location.locationsFromArea();
    boolean valid_new_location = false;
    for (Location a : campaign_locations) {
      if (a == new_location) {
        valid_new_location = true;
        break;
      }
    }
    if (!valid_new_location) {
      global.errorMessage("ERROR: New location " + new_location.display_name() +
        " is not accessible from hero's current location " + curr_hero.location.display_name());
      return;
    }
    if (!new_location.isCampaignStart()) {
      global.errorMessage("ERROR: New location " + new_location.display_name() +
        " is not a campaign start point.");
      return;
    }
    for (Map.Entry<HeroCode, Hero> entry : global.profile.heroes.entrySet()) {
      // can't enter campaign another hero is in
      if (entry.getValue().location.getCampaignStart() == new_location) {
        global.errorMessage("ERROR: New location " + new_location.display_name() +
          " is being played by " + entry.getValue().display_name() + " already.");
        return;
      }
    }
    curr_hero.location = new_location;
    this.status = PlayingStatus.STARTING_NEW;
    this.newLevelThread = new OpenNewLevelThread(curr_hero);
    this.newLevelThread.start();
  }

   public void switchHero(Hero hero) {
    if (hero == null || hero.code == null || hero.code == HeroCode.ERROR) {
      global.errorMessage("ERROR: Can't switch to a hero code that doesn't exist.");
      return;
    }
    if (!global.profile.heroes.containsKey(hero.code)) {
      global.errorMessage("ERROR: Can't switch to a hero that hasn't been unlocked.");
      return;
    }
    if (global.profile.curr_hero == hero.code) {
      return;
    }
    switch(this.status) {
      case INITIAL:
        break;
      case STARTING_NEW:
        if (this.newLevelThread == null) {
          global.errorMessage("ERROR: No thread in new level status.");
          break;
        }
        this.newLevelThread.stopThread();
        this.newLevelThread = null;
        break;
      case LOADING_SAVED:
        if (this.savedLevelThread == null) {
          global.errorMessage("ERROR: No thread in open level status.");
          break;
        }
        this.savedLevelThread.stopThread();
        this.savedLevelThread = null;
        break;
      case PLAYING:
        if (this.level == null) {
          global.errorMessage("ERROR: No level in playing status.");
          break;
        }
        this.level.save();
        this.level = null;
        break;
      default:
        global.errorMessage("ERROR: Playing status " + this.status + " not recognized.");
        break;
    }
    global.profile.saveHeroesFile();
    global.profile.curr_hero = hero.code;
    this.status = PlayingStatus.INITIAL;
  }


   public void completedLevel(int completion_code) {
    if (this.level == null || this.status != PlayingStatus.PLAYING) {
      global.errorMessage("ERROR: Can't complete level when not playing one.");
      return;
    }
    if (this.level.player == null || this.level.player.code == null || this.level.player.code == HeroCode.ERROR) {
      global.errorMessage("ERROR: Can't complete level without a player object.");
      return;
    }
    global.log("Completed level " + this.level.location.display_name() + " with code " + completion_code + ".");
    Location next_location = Location.nextLocation(this.level.location, completion_code);
    if (next_location == Location.ERROR) {
      global.errorMessage("ERROR: Completion code " + completion_code +
        " not recognized for location " + this.level.location.display_name() + ".");
    }
    this.level.player.stopAction();
    this.level.player.statuses.clear();
    this.level.player.restartAbilityTimers();
    deleteFolder(this.savePath + this.level.player.location.file_name());
    this.level.player.location = next_location;
    global.profile.saveHeroesFile();
    if (next_location.isArea()) {
      global.profile.unlockArea(next_location);
    }
    this.status = PlayingStatus.INITIAL;
    this.level = null;
  }


   public Hero getCurrentHeroIfExists() {
    if (this.level != null) {
      return this.level.player;
    }
    return null;
  }

   public void saveLevel() {
    if (this.level == null) {
      return;
    }
    this.level.save();
    global.profile.saveHeroesFile();
  }

   public void saveAndExitToMainMenu() {
    this.saveLevel();
    this.level = null;
    this.status = PlayingStatus.INITIAL;
    global.state = ProgramState.ENTERING_MAINMENU;
  }

   public void saveAndReturnToInitialState() {
    this.saveLevel();
    this.status = PlayingStatus.INITIAL;
    this.level = null;
  }

   public void loseFocus() {
    if (this.level != null) {
      this.level.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.level != null) {
      this.level.gainFocus();
    }
  }

   public void restartTimers() {
    if (this.level != null) {
      this.level.restartTimers();
    }
  }

   public void update(int millis) {
    boolean refreshLevelLocation = false;
    switch(this.status) {
      case INITIAL:
        rectMode(CORNERS);
        noStroke();
        fill(60);
        rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
        break;
      case STARTING_NEW:
        if (this.newLevelThread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.newLevelThread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.newLevelThread.level == null || this.newLevelThread.level.nullify) {
            this.level = null;
            this.status = PlayingStatus.INITIAL;
          }
          else {
            this.level = this.newLevelThread.level;
            this.level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.level.restartTimers();
            if (this.level.album_name != null) {
              global.sounds.play_background(this.level.album_name);
            }
            this.status = PlayingStatus.PLAYING;
            if (this.level.location.isArea()) {
              this.buttons[0].message = "Launch\nCampaign";
            }
            else {
              this.buttons[0].message = "Abandon\nLevel";
            }
          }
          this.newLevelThread = null;
          return;
        }
        break;
      case LOADING_SAVED:
        if (this.savedLevelThread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.savedLevelThread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.savedLevelThread.level == null || this.savedLevelThread.level.nullify ||
            this.savedLevelThread.level.currMap == null || this.savedLevelThread.level.currMap.nullify) {
            this.level = null;
            this.status = PlayingStatus.INITIAL;
          }
          else {
            this.level = this.savedLevelThread.level;
            this.level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.level.restartTimers();
            if (this.level.album_name != null) {
              global.sounds.play_background(this.level.album_name);
            }
            this.level.currMap.addHeaderMessage(GameMapCode.display_name(this.level.currMap.code));
            this.status = PlayingStatus.PLAYING;
            if (this.level.location.isArea()) {
              this.buttons[0].message = "Launch\nCampaign";
            }
            else {
              this.buttons[0].message = "Abandon\nLevel";
            }
          }
          this.savedLevelThread = null;
          return;
        }
        break;
      case PLAYING:
        if (this.level != null) {
          this.level.update(millis);
          if (this.leftPanel.collapsing || this.rightPanel.collapsing) {
            refreshLevelLocation = true;
          }
          if (this.level.completed) {
            this.completedLevel(this.level.completion_code);
          }
        }
        else {
          global.errorMessage("ERROR: In playing status but no level to update.");
          this.status = PlayingStatus.INITIAL;
        }
        break;
      default:
        global.errorMessage("ERROR: Playing status " + this.status + " not recognized.");
        break;
    }
    this.leftPanel.update(millis);
    this.rightPanel.update(millis);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (PlayingButton button : this.buttons) {
        button.update(millis);
      }
      if (this.level != null) {
        this.level.drawRightPanel(millis);
      }
    }
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.level != null) {
        this.level.drawLeftPanel(millis);
      }
    }
    if (refreshLevelLocation) {
      if (this.level != null) {
        this.level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
    if (this.status == PlayingStatus.INITIAL) {
      this.checkLevelSave();
    }
  }

   public void showNerdStats() {
    if (this.level != null) {
      this.level.displayNerdStats();
    }
    else {
      fill(255);
      textSize(14);
      textAlign(LEFT, TOP);
      float y_stats = 1;
      float line_height = textAscent() + textDescent() + 2;
      text("FPS: " + PApplet.parseInt(global.lastFPS), 1, y_stats);
    }
  }

   public void mouseMove(float mX, float mY) {
    boolean refreshMapLocation = false;
    // level mouse move
    if (this.level != null) {
      this.level.mouseMove(mX, mY);
      if (this.leftPanel.clicked || this.rightPanel.clicked) {
        refreshMapLocation = true;
      }
    }
    // left panel mouse move
    this.leftPanel.mouseMove(mX, mY);
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.level != null) {
        if (this.level.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
    }
    // right panel mouse move
    this.rightPanel.mouseMove(mX, mY);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (PlayingButton button : this.buttons) {
        button.mouseMove(mX, mY);
      }
    }
    // refresh map location
    if (refreshMapLocation) {
      if (this.level != null) {
        this.level.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
    // cursor icon resolution
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      this.resizeButtons();
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png", "icons/cursor_resizeh.png");
    }
  }

   public void mousePress() {
    if (this.level != null) {
      this.level.mousePress();
    }
    this.leftPanel.mousePress();
    this.rightPanel.mousePress();
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (PlayingButton button : this.buttons) {
        button.mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.level != null) {
      this.level.mouseRelease(mX, mY);
    }
    this.leftPanel.mouseRelease(mX, mY);
    this.rightPanel.mouseRelease(mX, mY);
    if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh.png", "icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (PlayingButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
    }
  }

   public void scroll(int amount) {
    if (this.level != null) {
      this.level.scroll(amount);
    }
  }

   public void keyPress() {
    if (this.level != null) {
      this.level.keyPress();
    }
  }

   public void openEscForm() {
    this.form = new EscForm();
  }

   public void keyRelease() {
    if (this.level != null) {
      this.level.keyRelease();
    }
  }
}
enum PlayerTreeCode {
  CAN_PLAY;
  private static final List<PlayerTreeCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  public String message() {
    switch(this) {
      case CAN_PLAY:
        return "Can launch game";
      default:
        return "";
    }
  }

  public String display_name() {
    switch(this) {
      case CAN_PLAY:
        return "Launch Game";
      default:
        return "";
    }
  }

  public String file_name() {
    switch(this) {
      case CAN_PLAY:
        return "Launch_Game";
      default:
        return "";
    }
  }

  public String description() {
    switch(this) {
      case CAN_PLAY:
        return "Unlocking this perk allows you to start the storyline.";
      default:
        return "";
    }
  }

  public int cost() {
    switch(this) {
      case CAN_PLAY:
        return 1;
      default:
        return 0;
    }
  }

  public static PlayerTreeCode code(String display_name) {
    for (PlayerTreeCode code : PlayerTreeCode.VALUES) {
      if (code.display_name().equals(display_name) ||
        code.file_name().equals(display_name)) {
        return code;
      }
    }
    return null;
  }
}



class Profile {
  class Options {
    private float volume_master;
    private boolean volume_master_muted;
    private float volume_music;
    private boolean volume_music_muted;
    private float volume_interface;
    private boolean volume_interface_muted;
    private float volume_environment;
    private boolean volume_environment_muted;
    private float volume_units;
    private boolean volume_units_muted;
    private float volume_player;
    private boolean volume_player_muted;

    private float map_viewMoveSpeedFactor;
    private float inventory_bar_size;
    private boolean inventory_bar_hidden;
    private int terrain_resolution;
    private float fog_update_time;
    private boolean lock_screen;

    Options() {
      this.profileUpdated();
    }

     public void profileUpdated() {
      this.defaults();
      this.read();
      this.change();
    }

     public void defaults() {
      this.volume_master = Constants.options_defaultVolume;
      this.volume_master_muted = false;
      this.volume_music = Constants.options_defaultMusicVolume;
      this.volume_music_muted = false;
      this.volume_interface = Constants.options_defaultVolume;
      this.volume_interface_muted = false;
      this.volume_environment = Constants.options_defaultVolume;
      this.volume_environment_muted = false;
      this.volume_units = Constants.options_defaultVolume;
      this.volume_units_muted = false;
      this.volume_player = Constants.options_defaultVolume;
      this.volume_player_muted = false;
      this.map_viewMoveSpeedFactor = Constants.map_defaultCameraSpeed;
      this.inventory_bar_size = Constants.hero_defaultInventoryBarHeight;
      this.inventory_bar_hidden = false;
      this.terrain_resolution = Constants.map_terrainResolutionDefault;
      this.fog_update_time = Constants.map_timer_refresh_fog_default;
      this.lock_screen = true;
    }

     public void setVolumes() {
      float master_volume_multiplier = this.volume_master / (Constants.options_volumeMax - Constants.options_volumeMin);

      global.sounds.setBackgroundVolume(Constants.options_volumeGainMultiplier *
        log(master_volume_multiplier * this.volume_music / (Constants.
        options_volumeMax - Constants.options_volumeMin)), this.volume_master_muted
        || this.volume_music_muted);

      if (this.volume_master_muted || this.volume_interface_muted) {
        global.sounds.out_interface.mute();
      }
      else {
        global.sounds.out_interface.unmute();
      }
      global.sounds.out_interface.setGain(Constants.options_volumeGainMultiplier *
        log(master_volume_multiplier * this.volume_interface / (Constants.
        options_volumeMax - Constants.options_volumeMin)));

      if (this.volume_master_muted || this.volume_environment_muted) {
        global.sounds.out_environment.mute();
      }
      else {
        global.sounds.out_environment.unmute();
      }
      global.sounds.out_environment.setGain(Constants.options_volumeGainMultiplier *
        log(master_volume_multiplier * this.volume_environment / (Constants.
        options_volumeMax - Constants.options_volumeMin)));

      if (this.volume_master_muted || this.volume_units_muted) {
        global.sounds.out_units.mute();
      }
      else {
        global.sounds.out_units.unmute();
      }
      global.sounds.out_units.setGain(Constants.options_volumeGainMultiplier *
        log(master_volume_multiplier * this.volume_units / (Constants.
        options_volumeMax - Constants.options_volumeMin)));

      if (this.volume_master_muted || this.volume_player_muted) {
        global.sounds.out_player.mute();
      }
      else {
        global.sounds.out_player.unmute();
      }
      global.sounds.out_player.setGain(Constants.options_volumeGainMultiplier *
        log(master_volume_multiplier * this.volume_player / (Constants.
        options_volumeMax - Constants.options_volumeMin)));
    }

     public void change() {
      if (Profile.this.invalidProfile()) {
        return;
      }

      this.setVolumes();

      Hero h = global.menu.getCurrentHeroIfExists();
      if (h != null) {
        h.inventory_bar.setHeight(this.inventory_bar_size);
      }
    }

     public void read() {
      if (Profile.this.invalidProfile()) {
        return;
      }
      String[] lines = loadStrings(sketchPath("data/profiles/" + Profile.this.display_name.toLowerCase() + "/options.lnz"));
      if (lines == null) {
        this.save(); // save defaults if no options exists
        return;
      }
      for (String line : lines) {
        String[] data = split(line, ':');
        if (data.length < 2) {
          continue;
        }
        switch(data[0]) {
          case "volume_master":
            this.volume_master = toFloat(trim(data[1]));
            break;
          case "volume_master_muted":
            this.volume_master_muted = toBoolean(trim(data[1]));
            break;
          case "volume_music":
            this.volume_music = toFloat(trim(data[1]));
            break;
          case "volume_music_muted":
            this.volume_music_muted = toBoolean(trim(data[1]));
            break;
          case "volume_interface":
            this.volume_interface = toFloat(trim(data[1]));
            break;
          case "volume_interface_muted":
            this.volume_interface_muted = toBoolean(trim(data[1]));
            break;
          case "volume_environment":
            this.volume_environment = toFloat(trim(data[1]));
            break;
          case "volume_environment_muted":
            this.volume_environment_muted = toBoolean(trim(data[1]));
            break;
          case "volume_units":
            this.volume_units = toFloat(trim(data[1]));
            break;
          case "volume_units_muted":
            this.volume_units_muted = toBoolean(trim(data[1]));
            break;
          case "volume_player":
            this.volume_player = toFloat(trim(data[1]));
            break;
          case "volume_player_muted":
            this.volume_player_muted = toBoolean(trim(data[1]));
            break;
          case "map_viewMoveSpeedFactor":
            this.map_viewMoveSpeedFactor = toFloat(trim(data[1]));
            break;
          case "inventory_bar_size":
            this.inventory_bar_size = toFloat(trim(data[1]));
            break;
          case "inventory_bar_hidden":
            this.inventory_bar_hidden = toBoolean(trim(data[1]));
            break;
          case "lock_screen":
            this.lock_screen = toBoolean(trim(data[1]));
            break;
          default:
            break;
        }
      }
    }

     public void save() {
      if (Profile.this.invalidProfile()) {
        return;
      }
      PrintWriter file = createWriter(sketchPath("data/profiles/" + Profile.this.display_name.toLowerCase() + "/options.lnz"));
      file.println("volume_master: " + this.volume_master);
      file.println("volume_master_muted: " + this.volume_master_muted);
      file.println("volume_music: " + this.volume_music);
      file.println("volume_music_muted: " + this.volume_music_muted);
      file.println("volume_interface: " + this.volume_interface);
      file.println("volume_interface_muted: " + this.volume_interface_muted);
      file.println("volume_environment: " + this.volume_environment);
      file.println("volume_environment_muted: " + this.volume_environment_muted);
      file.println("volume_units: " + this.volume_units);
      file.println("volume_units_muted: " + this.volume_units_muted);
      file.println("volume_player: " + this.volume_player);
      file.println("volume_player_muted: " + this.volume_player_muted);
      file.println("map_viewMoveSpeedFactor: " + this.map_viewMoveSpeedFactor);
      file.println("inventory_bar_size: " + this.inventory_bar_size);
      file.println("inventory_bar_hidden: " + this.inventory_bar_hidden);
      file.println("lock_screen: " + this.lock_screen);
      file.flush();
      file.close();
    }
  }



  class PlayerTree {
    class PlayerTreeNode {
      class PlayerTreeNodeButton1 extends RectangleButton {
        protected int start_time = 0;
        protected float last_mX = 0;
        protected float last_mY = 0;

        PlayerTreeNodeButton1(float xi, float yi, float button_height) {
          super(xi, yi, xi + 4 * button_height, yi + button_height);
          this.show_message = false;
          this.text_size = 18;
          this.message = PlayerTreeNode.this.code.display_name();
        }

        @Override public 
        void drawButton() {
          super.drawButton();
          if (this.hovered && millis() - this.start_time > 1000) {
            fill(global.color_nameDisplayed_background);
            noStroke();
            rectMode(CORNER);
            textSize(16);
            String hover_message = "Press for details";
            float message_width = textWidth(hover_message);
            float message_height = textAscent() + textDescent() + 2;
            textAlign(LEFT, BOTTOM);
            if (this.last_mX < this.xi + 0.5f * this.button_height()) {
              rect(this.last_mX - message_width - 2, this.last_mY - message_height - 2, message_width, message_height);
              fill(255);
              text(hover_message, this.last_mX - message_width - 1, this.last_mY - 1);
            }
            else {
              rect(this.last_mX + 2, this.last_mY - message_height - 2, message_width, message_height);
              fill(255);
              text(hover_message, this.last_mX + 1, this.last_mY - 1);
            }
          }
        }

        @Override public 
        void mouseMove(float mX, float mY) {
          super.mouseMove(mX, mY);
          this.last_mX = mX;
          this.last_mY = mY;
        }

         public void hover() {
          if (PlayerTreeNode.this.visible) {
            this.start_time = millis();
            this.message = PlayerTreeNode.this.code.message();
          }
        }
         public void dehover() {
          if (PlayerTreeNode.this.visible) {
            this.message = PlayerTreeNode.this.code.display_name();
          }
        }
         public void click() {}
         public void release() {
          if (this.hovered) {
            if (PlayerTreeNode.this.unlocked || PlayerTreeNode.this.visible) {
              PlayerTreeNode.this.showDetails();
            }
          }
        }
      }

      class PlayerTreeNodeButton2 extends CircleButton {
        PlayerTreeNodeButton2(float xi, float yi, float button_height) {
          super(xi + 0.5f * button_height, yi + 0.5f * button_height, 0.5f * button_height);
          this.show_message = false;
          this.text_size = 16;
          this.message = PlayerTreeNode.this.code.cost() + " 〶";
        }

         public void hover() {
          if (PlayerTreeNode.this.visible && !PlayerTreeNode.this.unlocked) {
            this.message = PlayerTreeNode.this.code.cost() + " 〶\nBuy";
          }
        }
         public void dehover() {
          if (PlayerTreeNode.this.visible && !PlayerTreeNode.this.unlocked) {
            this.message = PlayerTreeNode.this.code.cost() + " 〶";
          }
        }
         public void click() {
          if (!PlayerTreeNode.this.visible || PlayerTreeNode.this.unlocked) {
            this.clicked = false;
          }
        }
         public void release() {
          if (this.hovered) {
            if (PlayerTreeNode.this.visible && !PlayerTreeNode.this.unlocked) {
              PlayerTreeNode.this.tryUnlock();
            }
          }
        }
      }

      protected PlayerTreeCode code;
      protected ArrayList<PlayerTreeCode> dependencies = new ArrayList<PlayerTreeCode>();
      protected boolean in_view = false;
      protected boolean visible = false;
      protected boolean unlocked = false;
      protected PlayerTreeNodeButton1 button1;
      protected PlayerTreeNodeButton2 button2;

      PlayerTreeNode(PlayerTreeCode code, float xi, float yi, float button_height) {
        this.code = code;
        this.button1 = new PlayerTreeNodeButton1(xi, yi, button_height);
        this.button2 = new PlayerTreeNodeButton2(xi, yi, button_height);
      }

       public void showDetails() {
        PlayerTree.this.showDetails(this.code);
      }

       public void setDependencies() {
        switch(this.code) {
          case CAN_PLAY:
            break;
          default:
            global.errorMessage("ERROR: PlayerTreeCode " + this.code + " not recognized.");
            break;
        }
      }

       public void visible() {
        this.visible = true;
        this.button1.show_message = true;
        this.button2.show_message = true;
        this.button1.setColors(global.color_perkTreeLockedColor,
          global.color_perkTreeDarkColor, global.color_perkTreeBaseColor,
          global.color_perkTreeBrightColor, color(255));
        this.button1.setStroke(global.color_perkTreeBrightColor, 2);
        this.button2.setColors(global.color_perkTreeLockedColor,
          global.color_perkTreeDarkColor, global.color_perkTreeBaseColor,
          global.color_perkTreeBrightColor, color(255));
        this.button1.setStroke(global.color_perkTreeBrightColor, 1);
      }

       public void unlock() {
        this.unlocked = true;
        this.button2.message = "Unlocked";
        this.button1.setColors(global.color_perkTreeLockedColor,
          global.color_perkTreeBrightColor, global.color_perkTreeBrightColor,
          global.color_perkTreeBrightColor, color(255));
        this.button1.setStroke(global.color_perkTreeBrightColor, 3);
        this.button2.setColors(global.color_perkTreeLockedColor,
          global.color_perkTreeBrightColor, global.color_perkTreeBrightColor,
          global.color_perkTreeBrightColor, color(255));
        this.button1.setStroke(global.color_perkTreeBrightColor, 1);
      }

       public void tryUnlock() {
        PlayerTree.this.unlockNode(this.code);
      }


       public void update(int millis) {
        this.button1.update(millis);
        this.button2.update(millis);
      }

       public void mouseMove(float mX, float mY) {
        this.button1.mouseMove(mX, mY);
        this.button2.mouseMove(mX, mY);
        if (this.button2.hovered) {
          this.button1.hovered = false;
          this.button1.dehover();
        }
      }

       public boolean hovered() {
        return this.button1.hovered || this.button2.hovered;
      }

       public void mousePress() {
        this.button1.mousePress();
        this.button2.mousePress();
      }

       public void mouseRelease(float mX, float mY) {
        this.button1.mouseRelease(mX, mY);
        this.button2.mouseRelease(mX, mY);
        if (this.button2.hovered) {
          this.button1.hovered = false;
          this.button1.dehover();
        }
      }
    }


    class NodeDetailsForm extends Form {
      protected boolean canceled = false;
      protected PlayerTreeNode node;
      protected float shadow_distance = 10;
      protected PImage img;

      NodeDetailsForm(PlayerTreeNode node) {
        super(0.5f * (width - Constants.profile_treeForm_width), 0.5f * (height - Constants.profile_treeForm_height),
          0.5f * (width + Constants.profile_treeForm_width), 0.5f * (height + Constants.profile_treeForm_height));
        this.img = getCurrImage();
        this.cancelButton();
        this.draggable = false;
        this.node = node;
        this.setTitleText(node.code.display_name());
        this.setTitleSize(20);
        this.setFieldCushion(0);
        this.color_background = global.color_perkTreeLockedColor;
        this.color_header = global.color_perkTreeBrightColor;
        this.color_stroke = global.color_perkTreeDarkColor;
        this.color_title = color(255);

        this.addField(new SpacerFormField(20));
        this.addField(new TextBoxFormField(node.code.description(), 200));
        this.addField(new SpacerFormField(20));
        boolean has_enough = Profile.this.achievement_tokens >= node.code.cost();
        SubmitCancelFormField buttons = new SubmitCancelFormField(Profile.this.
          achievement_tokens + "/" + node.code.cost(), "Cancel");
        if (has_enough && node.visible && !node.unlocked) {
        }
        else {
          buttons.button1.disabled = true;
          if (node.unlocked) {
            buttons.button1.message = "Unlocked";
          }
        }
        this.addField(buttons);
      }

      @Override public 
      void update(int millis) {
        rectMode(CORNERS);
        fill(0);
        imageMode(CORNER);
        image(this.img, 0, 0);
        fill(0, 150);
        stroke(0, 1);
        translate(shadow_distance, shadow_distance);
        rect(this.xi, this.yi, this.xf, this.yf);
        translate(-shadow_distance, -shadow_distance);
        super.update(millis);
      }

       public void cancel() {
        this.canceled = true;
      }

       public void submit() {
        PlayerTree.this.unlockNode(this.node.code);
        this.canceled = true;
      }

       public void buttonPress(int index) {}
    }


    class BackButton extends RectangleButton {
      BackButton() {
        super(0, 0, 0, 0);
        this.setColors(color(170), color(1, 0), color(40, 120), color(20, 150), color(255));
        this.noStroke();
        this.show_message = true;
        this.message = "Back";
        this.text_size = 18;
        this.adjust_for_text_descent = true;
      }

       public void hover() {}
       public void dehover() {}
       public void click() {}
       public void release() {
        if (this.hovered) {
          PlayerTree.this.curr_viewing = false;
        }
      }
    }


    protected float xi = 0;
    protected float yi = 0;
    protected float xf = 0;
    protected float yf = 0;
    protected float xCenter = 0.5f * width;
    protected float yCenter = 0.5f * height;

    protected float tree_xi = 0;
    protected float tree_yi = 0;
    protected float tree_xf = 0;
    protected float tree_yf = 0;
    protected float translateX = 0;
    protected float translateY = 0;

    protected float viewX = 0;
    protected float viewY = 0;
    protected float zoom = 1.0f;
    protected float inverse_zoom = 1.0f;
    protected boolean curr_viewing = false;

    protected boolean dragging = false;
    protected float last_mX = mouseX;
    protected float last_mY = mouseY;
    protected boolean hovered = false;

    protected float lowestX = 0;
    protected float lowestY = 0;
    protected float highestX = 0;
    protected float highestY = 0;

    protected int color_background = color(30);
    protected int color_connectorStroke_locked = global.color_perkTreeDarkColor;
    protected int color_connectorStroke_visible = global.color_perkTreeBaseColor;
    protected int color_connectorStroke_unlocked = global.color_perkTreeBrightColor;
    protected int color_connectorFill_locked = global.color_perkTreeLockedColor;
    protected int color_connectorFill_visible = global.color_perkTreeDarkColor;
    protected int color_connectorFill_unlocked = global.color_perkTreeBaseColor;

    protected HashMap<PlayerTreeCode, PlayerTreeNode> nodes = new HashMap<PlayerTreeCode, PlayerTreeNode>();
    protected NodeDetailsForm node_details = null;
    protected BackButton back_button = new BackButton();


    PlayerTree() {
      this.initializeNodes();
      this.updateDependencies();
      this.setView(0, 0);
    }


     public void showDetails(PlayerTreeCode code) {
      if (!this.nodes.containsKey(code)) {
        return;
      }
      this.node_details = new NodeDetailsForm(this.nodes.get(code));
    }

     public void unlockNode(PlayerTreeCode code) {
      this.unlockNode(code, false);
    }
     public void unlockNode(PlayerTreeCode code, boolean from_save) {
      if (!this.nodes.containsKey(code)) {
        return;
      }
      if (this.nodes.get(code).unlocked || (!this.nodes.get(code).visible && !from_save)) {
        return;
      }
      if (!from_save && Profile.this.achievement_tokens < code.cost()) {
        return;
      }
      if (!from_save) {
        Profile.this.achievement_tokens -= code.cost();
      }
      this.nodes.get(code).unlock();
      this.updateDependencies();
      Profile.this.upgrade(code, from_save);
    }

     public ArrayList<PlayerTreeCode> unlockedCodes() {
      ArrayList<PlayerTreeCode> codes = new ArrayList<PlayerTreeCode>();
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().unlocked) {
          codes.add(entry.getKey());
        }
      }
      return codes;
    }


     public void initializeNodes() {
      for (PlayerTreeCode code : PlayerTreeCode.VALUES) {
        float xi = 0;
        float yi = 0;
        float h = Constants.profile_tree_nodeHeight;
        switch(code) {
          case CAN_PLAY:
            break;
          default:
            global.errorMessage("ERROR: PlayerTreeCode " + code + " not recognized.");
            break;
        }
        this.nodes.put(code, new PlayerTreeNode(code, xi, yi, h));
        if (xi < this.lowestX) {
          this.lowestX = xi;
        }
        else if (xi + 4 * h > this.highestX) {
          this.highestX = xi + 4 * h;
        }
        if (yi < this.lowestY) {
          this.lowestY = yi;
        }
        else if (yi + h > this.highestY) {
          this.highestY = yi + h;
        }
      }
    }


     public void updateDependencies() {
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().visible) {
          continue;
        }
        boolean visible = true;
        for (PlayerTreeCode code : entry.getValue().dependencies) {
          if (!this.nodes.get(code).unlocked) {
            visible = false;
            break;
          }
        }
        if (visible) {
          entry.getValue().visible();
        }
      }
    }


     public void setLocation(float xi, float yi, float xf, float yf) {
      this.xi = xi;
      this.yi = yi;
      this.xf = xf;
      this.yf = yf;
      this.setView(this.viewX, this.viewY);
      this.back_button.setLocation(xf - 120, yf - 70, xf - 30, yf - 30);
    }

     public void moveView(float moveX, float moveY) {
      this.setView(this.viewX + moveX, this.viewY + moveY);
    }
     public void setView(float viewX, float viewY) {
      if (viewX < this.lowestX) {
        viewX = this.lowestX;
      }
      else if (viewX > this.highestX) {
        viewX = this.highestX;
      }
      if (viewY < this.lowestY) {
        viewY = this.lowestY;
      }
      else if (viewY > this.highestY) {
        viewY = this.highestY;
      }
      this.viewX = viewX;
      this.viewY = viewY;
      this.tree_xi = viewX - this.inverse_zoom * (this.xCenter - this.xi);
      this.tree_yi = viewY - this.inverse_zoom * (this.yCenter - this.yi);
      this.tree_xf = viewX - this.inverse_zoom * (this.xCenter - this.xf);
      this.tree_yf = viewY - this.inverse_zoom * (this.yCenter - this.yf);
      this.translateX = this.xCenter - this.zoom * viewX;
      this.translateY = this.yCenter - this.zoom * viewY;
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().button1.xi > this.tree_xi && entry.getValue().button1.yi > this.tree_yi &&
          entry.getValue().button1.xf < this.tree_xf && entry.getValue().button1.yf < this.tree_yf) {
          entry.getValue().in_view = true;
        }
        else {
          entry.getValue().in_view = false;
        }
      }
    }


     public void update(int millis) {
      if (this.node_details != null) {
        this.node_details.update(millis);
        if (this.node_details.canceled) {
          this.node_details = null;
        }
        return;
      }
      rectMode(CORNERS);
      fill(this.color_background);
      noStroke();
      rect(this.xi, this.yi, this.xf, this.yf);
      translate(this.translateX, this.translateY);
      scale(this.zoom, this.zoom);
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        rectMode(CORNERS);
        translate(entry.getValue().button1.xCenter(), entry.getValue().button1.yCenter());
        for (PlayerTreeCode dependency : entry.getValue().dependencies) {
          PlayerTreeNode dependent = this.nodes.get(dependency);
          strokeWeight(2);
          float connector_width = 6;
          if (entry.getValue().unlocked) {
            fill(this.color_connectorFill_unlocked);
            stroke(this.color_connectorStroke_unlocked);
            strokeWeight(4);
            connector_width = 10;
          }
          else if (entry.getValue().visible || dependent.unlocked) {
            fill(this.color_connectorFill_visible);
            stroke(this.color_connectorStroke_visible);
            strokeWeight(3);
            connector_width = 8;
          }
          else {
            fill(this.color_connectorFill_locked);
            stroke(this.color_connectorStroke_locked);
          }
          float xDif = dependent.button1.xCenter() - entry.getValue().button1.xCenter();
          float yDif = dependent.button1.yCenter() - entry.getValue().button1.yCenter();
          float rotation = (float)Math.atan2(yDif, xDif);
          float distance = sqrt(xDif * xDif + yDif * yDif);
          rotate(rotation);
          rect(0, -connector_width, distance, connector_width);
          rotate(-rotation);
        }
        translate(-entry.getValue().button1.xCenter(), -entry.getValue().button1.yCenter());
      }
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().update(millis);
        }
      }
      scale(this.inverse_zoom, this.inverse_zoom);
      translate(-this.translateX, -this.translateY);
      this.back_button.update(millis);
      fill(255);
      textAlign(CENTER, TOP);
      textSize(30);
      text("Perk Tree", this.xCenter, this.yi + 5);
      text("Achievement Tokens: " + Profile.this.achievement_tokens + " 〶", this.xCenter, textAscent() + textDescent() + 10);
    }

     public void mouseMove(float mX, float mY) {
      if (this.node_details != null) {
        this.node_details.mouseMove(mX, mY);
        return;
      }
      this.back_button.mouseMove(mX, mY);
      if (this.dragging) {
        this.moveView(this.inverse_zoom * (this.last_mX - mX), this.inverse_zoom * (this.last_mY - mY));
      }
      this.last_mX = mX;
      this.last_mY = mY;
      if (mX > this.xi && mY > this.yi && mX < this.xf && mY < this.yf) {
        this.hovered = true;
      }
      else {
        this.hovered = false;
      }
      mX -= this.translateX;
      mY -= this.translateY;
      mX *= this.inverse_zoom;
      mY *= this.inverse_zoom;
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mouseMove(mX, mY);
        }
      }
    }

     public void mousePress() {
      if (this.node_details != null) {
        this.node_details.mousePress();
        return;
      }
      this.back_button.mousePress();
      boolean button_hovered = false;
      if (this.back_button.hovered) {
        button_hovered = true;
      }
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mousePress();
          if (entry.getValue().hovered()) {
            button_hovered = true;
          }
        }
      }
      if (!button_hovered && mouseButton == LEFT && this.hovered) {
        this.dragging = true;
      }
    }

     public void mouseRelease(float mX, float mY) {
      if (this.node_details != null) {
        this.node_details.mouseRelease(mX, mY);
        return;
      }
      this.back_button.mouseRelease(mX, mY);
      if (mouseButton == LEFT) {
        this.dragging = false;
      }
      mX -= this.translateX;
      mY -= this.translateY;
      for (Map.Entry<PlayerTreeCode, PlayerTreeNode> entry : this.nodes.entrySet()) {
        if (entry.getValue().in_view) {
          entry.getValue().mouseRelease(mX, mY);
        }
      }
    }

     public void scroll(int amount) {
      if (this.node_details != null) {
        this.node_details.scroll(amount);
        return;
      }
      this.zoom -= amount * 0.01f;
      if (this.zoom < 0.5f) {
        this.zoom = 0.5f;
      }
      if (this.zoom > 1.5f) {
        this.zoom = 1.5f;
      }
      this.inverse_zoom = 1 / this.zoom;
      this.setView(this.viewX, this.viewY);
    }

     public void keyPress() {
      if (this.node_details != null) {
        this.node_details.keyPress();
        return;
      }
      if (key == ESC || (key == 'p' && global.holding_ctrl)) {
        this.curr_viewing = false;
      }
    }

     public void keyRelease() {
      if (this.node_details != null) {
        this.node_details.keyRelease();
        return;
      }
    }
  }



  private String display_name = "";

  private HashSet<MinigameName> minigames = new HashSet<MinigameName>();
  private HashMap<AchievementCode, Boolean> achievements = new HashMap<AchievementCode, Boolean>();
  private int achievement_tokens = 0;
  private boolean ben_has_eyes = true;
  private PlayerTree player_tree = new PlayerTree();
  private Options options;

  private HashMap<HeroCode, Hero> heroes = new HashMap<HeroCode, Hero>();
  private HeroCode curr_hero = HeroCode.ERROR; // hero the player is playing as
  private HashMap<Location, Boolean> areas = new HashMap<Location, Boolean>();

  private EnderChestInventory ender_chest = new EnderChestInventory();
  private Set<Integer> chuck_quizmo_answers = new HashSet<Integer>();
  private float money = 0;

  Profile() {
    this("");
  }
  Profile(String s) {
    this.display_name = s;
    for (AchievementCode code : AchievementCode.VALUES) {
      this.achievements.put(code, false);
    }
    for (Location location : Location.VALUES) {
      if (location.isArea()) {
        this.areas.put(location, false);
      }
    }
    this.options = new Options();
  }

   public boolean invalidProfile() {
    String name = this.display_name.toLowerCase();
    return name == null || name.equals("") || !folderExists("data/profiles/" + name);
  }

   public void profileUpdated() {
    this.options.profileUpdated();
    this.save();
  }

   public void addInitialHero() {
    if (this.heroes.size() > 0) {
      global.errorMessage("ERROR: Cannot add initial hero when heroes already in profile.");
      return;
    }
    this.addHero(HeroCode.BEN);
    this.curr_hero = HeroCode.BEN;
    this.saveProfileFile();
  }

   public void addHero(HeroCode code) {
    if (this.heroes.containsKey(code)) {
      return;
    }
    Hero h = new Hero(code);
    switch(code) {
      case BEN:
        h.location = Location.FRANCISCAN_FRANCIS;
        break;
      case DAN:
      default:
        global.errorMessage("ERROR: HeroCode " + code.display_name() + " not " +
          "recognized when being added to profile.");
        break;
    }
    this.heroes.put(code, h);
    this.saveHeroesFile();
    global.notification.add(new HeroUnlockNotification(code));
    global.log("Added Hero: " + code.display_name());
  }

   public void achievement(AchievementCode code) {
    if (code == null) {
      return;
    }
    if (this.achievements.get(code).equals(Boolean.FALSE)) {
      this.achievements.put(code, Boolean.TRUE);
      this.achievement_tokens += code.tokens();
      this.saveProfileFile();
      global.notification.add(new AchievementNotification(code));
      global.log("Completed achievement: " + code.display_name());
    }
  }

   public boolean answeredChuckQuizmo(int code) {
    return this.chuck_quizmo_answers.add(code);
  }

   public boolean achievementUnlocked(AchievementCode code) {
    if (code == null || !this.achievements.containsKey(code)) {
      return false;
    }
    return this.achievements.get(code).equals(Boolean.TRUE);
  }

   public void unlockArea(Location location) {
    if (location == null || !this.areas.containsKey(location)) {
      global.errorMessage("ERROR: Trying to unlock area that doesn't exist.");
      return;
    }
    if (this.areas.get(location).equals(Boolean.FALSE)) {
      this.areas.put(location, Boolean.TRUE);
      this.saveProfileFile();
      global.notification.add(new AreaUnlockNotification(location));
      global.log("Unlocked area: " + location.display_name());
    }
  }

   public void upgrade(PlayerTreeCode code, boolean from_save) {
    switch(code) {
      case CAN_PLAY:
        if (!from_save) {
          this.addInitialHero();
        }
        break;
      default:
        break;
    }
    if (!from_save) {
      this.saveProfileFile();
      global.log("Unlocked perk: " + code.display_name());
    }
  }

   public boolean upgraded(PlayerTreeCode code) {
    if (code == null || !this.player_tree.nodes.containsKey(code)) {
      return false;
    }
    return this.player_tree.nodes.get(code).unlocked;
  }

   public boolean unlockedMinigame(MinigameName name) {
    if (name == null) {
      return false;
    }
    return this.minigames.contains(name);
  }

   public void unlockMinigame(MinigameName name) {
    if (name == null || this.minigames.contains(name)) {
      return;
    }
    this.minigames.add(name);
    this.saveProfileFile();
    global.notification.add(new MinigameUnlockNotification(name));
    global.log("Unlocked minigame: " + name.displayName());
  }

   public void saveProfileFile() {
    if (this.display_name.equals("")) {
      return;
    }
    PrintWriter file = createWriter(sketchPath("data/profiles/" + this.display_name.toLowerCase() + "/profile.lnz"));
    file.println("display_name: " + this.display_name);
    file.println("ben_has_eyes: " + this.ben_has_eyes);
    for (AchievementCode code : AchievementCode.VALUES) {
      if (this.achievements.get(code).equals(Boolean.TRUE)) {
        file.println("achievement: " + code.file_name());
      }
    }
    for (MinigameName minigame : this.minigames) {
      file.println("minigame: " + minigame.fileName());
    }
    for (Map.Entry<Location, Boolean> entry : this.areas.entrySet()) {
      if (entry.getValue().equals(Boolean.TRUE)) {
        file.println("areaUnlocked: " + entry.getKey().file_name());
      }
    }
    file.println("achievement_tokens: " + this.achievement_tokens);
    for (PlayerTreeCode code : this.player_tree.unlockedCodes()) {
      file.println("perk: " + code.file_name());
    }
    for (Integer i : this.chuck_quizmo_answers) {
      file.println("chuck_quizmo_answer: " + i);
    }
    file.println("curr_hero: " + this.curr_hero.file_name());
    file.println("money: " + this.money);
    file.println(this.ender_chest.internalFileString());
    file.flush();
    file.close();
  }

   public void saveHeroesFile() {
    if (this.display_name.equals("")) {
      return;
    }
    PrintWriter heroes_file = createWriter(sketchPath("data/profiles/" + this.display_name.toLowerCase() + "/heroes.lnz"));
    for (Map.Entry<HeroCode, Hero> entry : this.heroes.entrySet()) {
      heroes_file.println(entry.getValue().fileString());
      heroes_file.println("");
    }
    heroes_file.flush();
    heroes_file.close();
  }

   public void save() {
    if (this.display_name.equals("")) {
      return;
    }
    this.saveProfileFile();
    this.saveHeroesFile();
    this.options.save();
  }
}


 public Profile readProfile(String folder_path) {
  String[] lines = loadStrings(folder_path + "/profile.lnz");
  Profile p = new Profile();
  Item curr_item = null;
  boolean in_item = false;
  if (lines == null) {
    global.errorMessage("ERROR: Reading profile file but path " + (folder_path + "/profile.lnz") + " doesn't exist.");
    return p;
  }
  for (String line : lines) {
    String[] data = split(line, ':');
    if (data.length < 2) {
      continue;
    }
    switch(data[0]) {
      case "display_name":
        p.display_name = trim(data[1]);
        break;
      case "achievement":
        AchievementCode code = AchievementCode.achievementCode(trim(data[1]));
        if (code != null && p.achievements.containsKey(code)) {
          p.achievements.put(code, Boolean.TRUE);
        }
        else if (code == null) {
          global.errorMessage("ERROR: Unknown achievement " + trim(data[1]) + " in profile data.");
        }
        else {
          global.errorMessage("ERROR: Unknown achievement " + code.display_name() + " in profile data.");
        }
        break;
      case "minigame":
        MinigameName name = MinigameName.minigameName(trim(data[1]));
        if (name != null) {
          p.minigames.add(name);
        }
        else {
          global.errorMessage("ERROR: Unknown minigame " + trim(data[1]) + " in profile data.");
        }
        break;
      case "areaUnlocked":
        Location location = Location.location(trim(data[1]));
        if (location != null && p.areas.containsKey(location)) {
          p.areas.put(location, Boolean.TRUE);
        }
        else {
          global.errorMessage("ERROR: Unknown location " + location.display_name() + " in profile data.");
        }
        break;
      case "ben_has_eyes":
        p.ben_has_eyes = toBoolean(trim(data[1]));
        break;
      case "chuck_quizmo_answer":
        p.answeredChuckQuizmo(toInt(trim(data[1])));
        break;
      case "perk":
        PlayerTreeCode tree_code = PlayerTreeCode.code(trim(data[1]));
        if (tree_code != null) {
          p.player_tree.unlockNode(tree_code, true);
        }
        break;
      case "achievement_tokens":
        if (isInt(trim(data[1]))) {
          p.achievement_tokens = toInt(trim(data[1]));
        }
        break;
      case "curr_hero":
        p.curr_hero = HeroCode.heroCode(trim(data[1]));
        break;
      case "money":
        if (isFloat(trim(data[1]))) {
          p.money = toFloat(trim(data[1]));
        }
        break;
      case "new":
        switch(trim(data[1])) {
          case "Item":
            if (data.length < 3) {
              global.errorMessage("ERROR: Item ID missing in Item constructor.");
              break;
            }
            if (curr_item != null) {
              global.errorMessage("ERROR: Can't create a new Item inside an Item.");
              break;
            }
            curr_item = new Item(toInt(trim(data[2])));
            in_item = true;
            break;
          default:
            global.errorMessage("ERROR: Trying to create a new " + trim(data[1]) +
              " which is invalid for profile data.");
            break;
        }
        break;
      case "end":
        switch(trim(data[1])) {
          case "Item":
            if (curr_item == null) {
              global.errorMessage("ERROR: Can't end a null Item.");
              break;
            }
            if (data.length < 3) {
              global.errorMessage("ERROR: No positional information for ender chest item.");
              break;
            }
            int index = toInt(trim(data[2]));
            Item i = p.ender_chest.placeAt(curr_item, index, true);
            if (i != null) {
              global.errorMessage("ERROR: Item already exists at position " + index + ".");
              break;
            }
            curr_item = null;
            in_item = false;
            break;
          default:
            global.errorMessage("ERROR: Trying to create a new " + trim(data[1]) +
              " which is invalid for profile data.");
            break;
        }
        break;
      default:
        if (in_item) {
          curr_item.addData(trim(data[0]), trim(data[1]));
          continue;
        }
        break;
    }
  }
  lines = loadStrings(folder_path + "/heroes.lnz");
  if (lines == null) {
    global.errorMessage("ERROR: Reading heroes file but file " + (folder_path + "/heroes.lnz") + " doesn't exist.");
    return p;
  }
  Stack<ReadFileObject> object_queue = new Stack<ReadFileObject>();
  Hero curr_hero = null;
  StatusEffectCode curr_status_code = StatusEffectCode.ERROR;
  StatusEffect curr_status = null;
  Ability curr_ability = null;
  for (String line : lines) {
    String[] parameters = split(line, ':');
    if (parameters.length < 2) {
      continue;
    }
    String dataname = trim(parameters[0]);
    String data = trim(parameters[1]);
    for (int i = 2; i < parameters.length; i++) {
      data += ":" + parameters[i];
    }
    if (dataname.equals("new")) {
      ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
      switch(type) {
        case HERO:
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Unit ID missing in Hero constructor.");
            break;
          }
          object_queue.push(type);
          curr_hero = new Hero(toInt(trim(parameters[2])));
          curr_hero.abilities.clear();
          break;
        case INVENTORY:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to start an inventory in a null hero.");
          }
          object_queue.push(type);
          break;
        case ITEM:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to start an item in a null hero.");
          }
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Item ID missing in Item constructor.");
            break;
          }
          object_queue.push(type);
          curr_item = new Item(toInt(trim(parameters[2])));
          break;
        case STATUS_EFFECT:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to start a status effect in a null hero.");
          }
          object_queue.push(type);
          curr_status = new StatusEffect();
          break;
        case ABILITY:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to start an ability in a null hero.");
          }
          if (parameters.length < 3) {
            global.errorMessage("ERROR: Ability ID missing in Projectile constructor.");
            break;
          }
          object_queue.push(type);
          curr_ability = new Ability(toInt(trim(parameters[2])));
          break;
        default:
          global.errorMessage("ERROR: Can't add a " + type + " type to Heroes data.");
          break;
      }
    }
    else if (dataname.equals("end")) {
      ReadFileObject type = ReadFileObject.objectType(trim(parameters[1]));
      if (object_queue.empty()) {
        global.errorMessage("ERROR: Tring to end a " + type.name + " object but not inside any object.");
      }
      else if (type.name.equals(object_queue.peek().name)) {
        switch(object_queue.pop()) {
          case HERO:
            if (curr_hero == null) {
              global.errorMessage("ERROR: Trying to end a null hero.");
              break;
            }
            if (!object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end a hero but inside another object.");
              break;
            }
            if (p.heroes.containsKey(curr_hero.code)) {
              global.errorMessage("ERROR: Trying to end hero " + curr_hero.code + " this profile already has.");
              break;
            }
            if (curr_hero.code == HeroCode.ERROR) {
              global.errorMessage("ERROR: Trying to end hero with errored code.");
              break;
            }
            p.heroes.put(curr_hero.code, curr_hero);
            curr_hero = null;
            break;
          case INVENTORY:
            if (curr_hero == null) {
              global.errorMessage("ERROR: Trying to end an inventory in a null hero.");
              break;
            }
            break;
          case ITEM:
            if (curr_item == null) {
              global.errorMessage("ERROR: Trying to end a null item.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end an item not inside any other object.");
              break;
            }
            if (object_queue.peek() != ReadFileObject.HERO) {
              global.errorMessage("ERROR: Trying to end an ability not inside a hero.");
              break;
            }
            switch(object_queue.peek()) {
              case HERO:
                if (parameters.length < 3) {
                  global.errorMessage("ERROR: GearSlot code missing in Item constructor.");
                  break;
                }
                GearSlot code = GearSlot.gearSlot(trim(parameters[2]));
                if (curr_hero == null) {
                  global.errorMessage("ERROR: Trying to add gear to null hero.");
                  break;
                }
                curr_hero.gear.put(code, curr_item);
                break;
              case INVENTORY:
                if (parameters.length < 3) {
                  global.errorMessage("ERROR: No positional information for inventory item.");
                  break;
                }
                int index = toInt(trim(parameters[2]));
                if (curr_hero == null) {
                  global.errorMessage("ERROR: Trying to add inventory item to null hero.");
                  break;
                }
                Item i = curr_hero.inventory.placeAt(curr_item, index, true);
                if (i != null) {
                  global.errorMessage("ERROR: Item already exists at position " + index + ".");
                  break;
                }
                break;
              default:
                global.errorMessage("ERROR: Trying to end an item inside a " + object_queue.peek().name + ".");
                break;
            }
            curr_item = null;
            break;
          case STATUS_EFFECT:
            if (curr_status == null) {
              global.errorMessage("ERROR: Trying to end a null status effect.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end a status effect not inside any other object.");
              break;
            }
            if (object_queue.peek() != ReadFileObject.HERO) {
              global.errorMessage("ERROR: Trying to end a status effect not inside a hero.");
              break;
            }
            if (curr_hero == null) {
              global.errorMessage("ERROR: Trying to end a status effect inside a null hero.");
              break;
            }
            curr_hero.statuses.put(curr_status_code, curr_status);
            curr_status = null;
            break;
          case ABILITY:
            if (curr_ability == null) {
              global.errorMessage("ERROR: Trying to end a null ability.");
              break;
            }
            if (object_queue.empty()) {
              global.errorMessage("ERROR: Trying to end an ability not inside any other object.");
              break;
            }
            if (object_queue.peek() != ReadFileObject.HERO) {
              global.errorMessage("ERROR: Trying to end an ability not inside a hero.");
              break;
            }
            if (curr_hero == null) {
              global.errorMessage("ERROR: Trying to end an ability inside a null hero.");
              break;
            }
            curr_hero.abilities.add(curr_ability);
            curr_ability = null;
            break;
        }
      }
      else {
        global.errorMessage("ERROR: Tring to end a " + type.name + " object but current object is a " + object_queue.peek().name + ".");
      }
    }
    else {
      switch(object_queue.peek()) {
        case HERO:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to add unit data to a null hero.");
            break;
          }
          if (dataname.equals("next_status_code")) {
            curr_status_code = StatusEffectCode.code(data);
          }
          else {
            curr_hero.addData(dataname, data);
          }
          break;
        case INVENTORY:
          if (curr_hero == null) {
            global.errorMessage("ERROR: Trying to add hero inventory data to a null hero.");
            break;
          }
          curr_hero.inventory.addData(dataname, data);
          break;
        case ITEM:
          if (curr_item == null) {
            global.errorMessage("ERROR: Trying to add item data to a null item.");
            break;
          }
          curr_item.addData(dataname, data);
          break;
        case STATUS_EFFECT:
          if (curr_status == null) {
            global.errorMessage("ERROR: Trying to add status effect data to a null status effect.");
            break;
          }
          curr_status.addData(dataname, data);
          break;
        case ABILITY:
          if (curr_ability == null) {
            global.errorMessage("ERROR: Trying to add ability data to a null ability.");
            break;
          }
          curr_ability.addData(dataname, data);
          break;
        default:
          break;
      }
    }
  }
  p.profileUpdated();
  return p;
}


 public int isValidProfileName(String s) {
  if (s == null) {
    return 1;
  }
  else if (s.equals("")) {
    return 1;
  }
  for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);
    if (i == 0 && !Character.isLetter(c)) {
      return 2;
    }
    else if (!Character.isLetterOrDigit(c)) {
      return 3;
    }
  }
  for (Path p : listEntries(sketchPath("data/profiles/"))) {
    String filename = p.getFileName().toString().toLowerCase();
    if (filename.equals(s.toLowerCase())) {
      return 4;
    }
  }
  return 0;
}
class Projectile extends MapObject {
  protected float size = Constants.projectile_defaultSize; // radius

  protected int source_key;
  protected float facingX = 1;
  protected float facingY = 0;
  protected float facingA = 0;
  protected Alliance alliance = Alliance.NONE;

  protected float power = 0;
  protected float piercing = 0;
  protected float penetration = 0;
  protected Element element = Element.GRAY;
  protected DamageType damageType = DamageType.PHYSICAL;
  protected boolean toggled = false; // various uses

  protected float speed = 0;
  protected float decay = 0;
  protected float range_left = 0;
  protected boolean friendly_fire = false;
  protected boolean waiting_to_explode = false;

  Projectile(int ID) {
    super(ID);
    this.setID();
  }
  Projectile(int ID, Unit u) {
    this(ID, u, 0);
  }
  Projectile(int ID, Unit u, float inaccuracy) {
    super(ID);
    this.source_key = u.map_key;
    this.setID();
    if (u != null) {
      this.x = u.frontX();
      this.y = u.frontY();
      this.curr_height = u.zHalf();
      this.facingX = u.facingX;
      this.facingY = u.facingY;
      this.facingA = u.facingA;
      this.alliance = u.alliance;
      switch(ID) {
        case 3001: // mighty Pen
          if (u.holding(2911, 2912)) {
            this.power = Constants.ability_102_powerBasePen + u.power(Constants.
              ability_102_powerRatioPen, Constants.ability_102_powerRatioPen);
            u.pickup(null);
          }
          else {
            this.power = Constants.ability_102_powerBase + u.power(Constants.
              ability_102_powerRatio, Constants.ability_102_powerRatio);
          }
          this.damageType = DamageType.MIXED;
          break;
        case 3002: // Mighty Pen II
          if (u.holding(2911, 2912)) {
            this.power = Constants.ability_107_powerBasePen + u.power(Constants.
              ability_107_powerRatioPen, Constants.ability_107_powerRatioPen);
            u.pickup(null);
          }
          else {
            this.power = Constants.ability_107_powerBase + u.power(Constants.
              ability_107_powerRatio, Constants.ability_107_powerRatio);
          }
          this.damageType = DamageType.MIXED;
          break;
        case 3003: // Condom Throw
          this.power = Constants.ability_1002_basePower + u.power(0, Constants.ability_1002_magicRatio);
          this.damageType = DamageType.MAGICAL;
          break;
        case 3118: // Chicken Egg (thrown)
          if (u.holding(2118)) {
            this.toggled = u.weapon().toggled;
          }
          this.power = u.attack();
          break;
        case 3372: // Ray Gun
        case 3392: // Porter's X2 Ray Gun
          this.power = u.attack() + u.magic();
          this.damageType = DamageType.MIXED;
          break;
        default:
          this.power = u.attack();
          if (u.aposematicCamouflage()) {
            this.power *= Constants.ability_111_powerBuff;
            u.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGE);
          }
          if (u.aposematicCamouflageII()) {
            this.power *= Constants.ability_116_powerBuff;
            u.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGEII);
          }
          break;
      }
      this.piercing = u.piercing();
      this.penetration = u.penetration();
      this.turn(inaccuracy - 2 * random(inaccuracy));
      this.range_left = 1.1f * u.attackRange();
      switch(ID) {
        case 3001: // Mighty Pen
          this.range_left = Constants.ability_102_distance;
          break;
        case 3002: // Mighty Pen II
          this.range_left = Constants.ability_107_distance;
          break;
        case 3003: // Condom Throw
          this.range_left = Constants.ability_1002_range;
          break;
        default:
          this.range_left = 1.1f * u.attackRange();
          break;
      }
    }
  }

   public void setID() {
    switch(ID) {
      // abilities
      case 3001: // Mighty Pen
        this.speed = 9;
        this.decay = 0;
        break;
      case 3002: // Mighty Pen II
        this.speed = 9;
        this.decay = 0;
        break;
      case 3003: // Condom Throw
        this.speed = 5;
        this.decay = 0;
        break;
      // Items
      case 3118: // Chicken Egg (thrown)
        this.speed = 5;
        this.decay = 0.25f;
        break;
      case 3301: // Slingshot
        this.speed = 8;
        this.decay = 0.4267f;
        break;
      case 3311: // Bow
        this.speed = 12;
        this.decay = 0.3656f;
        break;
      case 3312: // M1911
        this.speed = 90;
        this.decay = 0;
        break;
      case 3321: // War Machine
        this.speed = 18;
        this.decay = 0;
        break;
      case 3322: // Five-Seven
        this.speed = 90;
        this.decay = 1.709f;
        break;
      case 3323: // Type25
        this.speed = 90;
        this.decay = 1.157f;
        break;
      case 3331: // Mustang and Sally
        this.speed = 60;
        this.decay = 0;
        break;
      case 3332: // FAL
        this.speed = 100;
        this.decay = 0.6797f;
        break;
      case 3333: // Python
        this.speed = 100;
        this.decay = 2.6f;
        break;
      case 3341: // RPG
        this.speed = 30;
        this.decay = 0;
        break;
      case 3342: // Dystopic Demolisher
        this.speed = 30;
        this.decay = 0;
        break;
      case 3343: // Ultra
        this.speed = 90;
        this.decay = 1.5f;
        break;
      case 3344: // Strain25
        this.speed = 90;
        this.decay = 0.9888f;
        break;
      case 3345: // Executioner
        this.speed = 90;
        this.decay = 4.6251f;
        break;
      case 3351: // Galil
        this.speed = 90;
        this.decay = 1.0417f;
        break;
      case 3352: // WN
        this.speed = 100;
        this.decay = 0.7954f;
        break;
      case 3353: // Ballistic Knife
        this.speed = 40;
        this.decay = 0;
        break;
      case 3354: // Cobra
        this.speed = 100;
        this.decay = 1.8286f;
        break;
      case 3355: // MTAR
        this.speed = 90;
        this.decay = 0.8345f;
        break;
      case 3361: // RPD
        this.speed = 90;
        this.decay = 0.8905f;
        break;
      case 3362: // Rocket-Propelled Grievance
        this.speed = 90;
        this.decay = 0;
        break;
      case 3363: // DSR-50
        this.speed = 90;
        this.decay = 0.6592f;
        break;
      case 3364: // Voice of Justice
        this.speed = 90;
        this.decay = 3.9339f;
        break;
      case 3371: // HAMR
        this.speed = 90;
        this.decay = 1.2022f;
        break;
      case 3372: // Ray Gun
        this.speed = 90;
        this.decay = 0;
        break;
      case 3373: // Lamentation
        this.speed = 90;
        this.decay = 0.973f;
        break;
      case 3374: // The Krauss Refibrillator
        this.speed = 90;
        this.decay = 0;
        break;
      case 3375: // Malevolent Taxonomic Anodized Redeemer
        this.speed = 90;
        this.decay = 0.8163f;
        break;
      case 3381: // Relativistic Punishment Device
        this.speed = 90;
        this.decay = 0.6584f;
        break;
      case 3382: // Dead Specimen Reactor 5000
        this.speed = 90;
        this.decay = 0;
        break;
      case 3391: // SLDG HAMR
        this.speed = 90;
        this.decay = 0.768f;
        break;
      case 3392: // Porter's X2 Ray Gun
        this.speed = 90;
        this.decay = 0;
        break;
      case 3924: // Glass Bottle (thrown)
        this.speed = 4;
        this.decay = 0.3f;
        break;
      case 3931: // Rock (thrown)
        this.speed = 5;
        this.decay = 0.3f;
        break;
      case 3932: // Arrow (thrown)
        this.speed = 4;
        this.decay = 0.3f;
        break;
      case 3933: // Pebble (thrown)
        this.speed = 5;
        this.decay = 0.3f;
        break;
      case 3944: // Grenade (thrown)
        this.speed = 6;
        this.decay = 0.3f;
        break;
      default:
        global.errorMessage("ERROR: Projectile ID " + ID + " not found.");
        break;
    }
  }

   public void setPower(int source_key, float power, float piercing, float penetration) {
    this.power = power;
    this.piercing = piercing;
    this.penetration = penetration;
  }

   public void setFacing(float facingX, float facingY) {
    this.facingX = facingX;
    this.facingY = facingY;
    this.facingA = (float)Math.atan2(this.facingY, this.facingX);
  }

   public void turn(float angle_change) {
    this.turnTo(this.facingA + angle_change);
  }
   public void turnTo(float facingA) {
    this.facingA = facingA;
    this.facingX = cos(this.facingA);
    this.facingY = sin(this.facingA);
  }

   public void refreshFacing() {
    this.facingA = (float)Math.atan2(this.facingY, this.facingX);
  }

   public String display_name() {
    return this.display_name;
  }
   public String type() {
    return this.type;
  }
   public String description() {
    return this.description;
  }
   public String selectedObjectTextboxText() {
    String text = "-- " + this.type() + " --";
    return text + "\n\n" + this.description();
  }

   public void setLocation(float x, float y) {
    this.x = x;
    this.y = y;
  }

   public float xi() {
    return this.x - this.size;
  }
   public float yi() {
    return this.y - this.size;
  }
   public float xf() {
    return this.x + this.size;
  }
   public float yf() {
    return this.y + this.size;
  }
   public float xCenter() {
    return this.x;
  }
   public float yCenter() {
    return this.y;
  }
   public float width() {
    return 2 * this.size;
  }
   public float height() {
    return 2 * this.size;
  }
   public float xRadius() {
    return this.size;
  }
   public float yRadius() {
    return this.size;
  }

  @Override public 
  float distance(MapObject object) {
    float xDistance = max(0, abs(this.xCenter() - object.xCenter()) - object.xRadius());
    float yDistance = max(0, abs(this.yCenter() - object.yCenter()) - object.yRadius());
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }

  @Override public 
  boolean touching(MapObject object) {
    if ( ((abs(this.xCenter() - object.xCenter()) - object.xRadius()) <= 0) ||
      ((abs(this.yCenter() - object.yCenter()) - object.yRadius()) <= 0) ) {
        return true;
    }
    return false;
  }

   public PImage getImage() {
    String path = "projectiles/";
    switch(this.ID) {
      case 3001:
      case 3002:
        path += "pen.png";
        break;
      case 3003:
        path += "condom.png";
        break;
      case 3118:
        path += "chicken_egg.png";
        break;
      case 3301:
        path += "rock.png";
        break;
      case 3311:
        path += "arrow.png";
        break;
      case 3312:
        path += "45_acp.png";
        break;
      case 3321:
        path += "grenade.png";
        break;
      case 3322:
        path += "fn_57_28mm.png";
        break;
      case 3323:
        path += "556_45mm.png";
        break;
      case 3331:
        path += "grenade.png";
        break;
      case 3332:
        path += "762_39mm.png";
        break;
      case 3333:
        path += "357_magnum.png";
        break;
      case 3341:
        path += "grenade.png";
        break;
      case 3342:
        path += "grenade.png";
        break;
      case 3343:
        path += "fn_57_28mm.png";
        break;
      case 3344:
        path += "556_45mm.png";
        break;
      case 3345:
        path += "28_gauge.png";
        break;
      case 3351:
        path += "556_45mm.png";
        break;
      case 3352:
        path += "762_39mm.png";
        break;
      case 3353:
        path += "ballistic_knife.png";
        break;
      case 3354:
        path += "357_magnum.png";
        break;
      case 3355:
        path += "556_45mm.png";
        break;
      case 3361:
        path += "762_39mm.png";
        break;
      case 3362:
        path += "grenade.png";
        break;
      case 3363:
        path += "50_bmg.png";
        break;
      case 3364:
        path += "28_gauge.png";
        break;
      case 3371:
        path += "762_39mm.png";
        break;
      case 3372:
        path += "ray.png";
        break;
      case 3373:
        path += "762_39mm.png";
        break;
      case 3374:
        path += "ballistic_knife.png";
        break;
      case 3375:
        path += "762_39mm.png";
        break;
      case 3381:
        path += "762_39mm.png";
        break;
      case 3382:
        path += "50_bmg.png";
        break;
      case 3391:
        path += "762_39mm.png";
        break;
      case 3392:
        path += "ray.png";
        break;
      case 3924:
        path += "glass_bottle.png";
        break;
      case 3931:
        path += "rock.png";
        break;
      case 3932:
        path += "arrow.png";
        break;
      case 3933:
        path += "pebble.png";
        break;
      case 3944:
        path += "grenade.png";
        break;
      default:
        global.errorMessage("ERROR: Projectile ID " + ID + " not found.");
        path += "default.png";
        break;
    }
    return global.images.getImage(path);
  }


   public boolean targetable(Unit u) {
    return false;
  }


   public void update(int timeElapsed, AbstractGameMap map) {
    if (this.remove) {
      return;
    }
    this.update(timeElapsed);
    if (this.waiting_to_explode) {
      this.range_left -= timeElapsed;
      if (this.range_left < 0) {
        this.explode(map);
      }
      return;
    }
    float distance_moved = this.speed * timeElapsed / 1000.0f;
    float tryMoveX = distance_moved * this.facingX;
    float tryMoveY = distance_moved * this.facingY;
    // move in x direction
    if (!this.moveX(tryMoveX, map)) {
      // move in y direction
      this.moveY(tryMoveY, map);
    }
    // decay
    float decay_percentage = 1 - this.decay * timeElapsed / 1000.0f;
    if (decay_percentage < 0) {
      this.speed = 0;
      this.power = 0;
      this.piercing = 0;
      this.penetration = 0;
    }
    else {
      this.speed *= decay_percentage;
      this.power *= decay_percentage;
      this.piercing *= decay_percentage;
      this.penetration *= decay_percentage;
    }
    if (speed < Constants.projectile_threshholdSpeed) {
      this.dropOnGround(map);
      this.dropSound(map);
    }
    this.range_left -= distance_moved;
    if (this.range_left < 0) {
      this.dropOnGround(map);
      this.dropSound(map);
    }
  }


   public void update(int timeElapsed) {}


  // returns true if collision occurs
   public boolean moveX(float tryMoveX, AbstractGameMap map) {
    while(abs(tryMoveX) > Constants.map_moveLogicCap) {
      if (tryMoveX > 0) {
        if (this.collisionLogicX(Constants.map_moveLogicCap, map)) {
          return true;
        }
        tryMoveX -= Constants.map_moveLogicCap;
      }
      else {
        if (this.collisionLogicX(-Constants.map_moveLogicCap, map)) {
          return true;
        }
        tryMoveX += Constants.map_moveLogicCap;
      }
    }
    if (this.collisionLogicX(tryMoveX, map)) {
      return true;
    }
    return false;
  }

  // returns true if collision occurs
   public boolean moveY(float tryMoveY, AbstractGameMap map) {
    while(abs(tryMoveY) > Constants.map_moveLogicCap) {
      if (tryMoveY > 0) {
        if (this.collisionLogicY(Constants.map_moveLogicCap, map)) {
          return true;
        }
        tryMoveY -= Constants.map_moveLogicCap;
      }
      else {
        if (this.collisionLogicY(-Constants.map_moveLogicCap, map)) {
          return true;
        }
        tryMoveY += Constants.map_moveLogicCap;
      }
    }
    if (this.collisionLogicY(tryMoveY, map)) {
      return true;
    }
    return false;
  }

  // returns true if collision occurs
   public boolean collisionLogicX(float tryMoveX, AbstractGameMap map) {
    float startX = this.x;
    this.x += tryMoveX;
    // map collisions
    if (!this.inMapX(map.mapXI(), map.mapXF())) {
      this.remove = true;
      return true;
    }
    // terrain collisions
    try {
      if (map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y)).elevation(true) > this.curr_height) {
        this.x = startX;
        this.dropOnGround(map);
        this.collideSound(map);
        return true;
      }
    } catch(Exception e) {}
    // unit collisions
    for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
      if (entry.getKey() == this.source_key) {
        continue;
      }
      Unit u = entry.getValue();
      if (u.alliance == this.alliance && this.alliance != Alliance.NONE && !this.friendly_fire) {
        continue;
      }
      if (this.curr_height < u.zi() && this.curr_height > u.zi()) {
        continue;
      }
      float distance_to = this.distance(u);
      if (distance_to > 0) {
        continue;
      }
      if ( (this.x > u.x && this.facingX > 0) || (this.x < u.x && this.facingX < 0) ) {
        continue;
      }
      this.x = startX;
      this.collideWithUnit(map, u);
      this.collideSound(map);
      return true;
    }
    return false;
  }

  // returns true if collision occurs
   public boolean collisionLogicY(float tryMoveY, AbstractGameMap map) {
    float startY = this.y;
    this.y += tryMoveY;
    // map collisions
    if (!this.inMapY(map.mapYI(), map.mapYF())) {
      this.remove = true;
      return true;
    }
    // terrain collisions
    try {
      if (map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y)).elevation(true) > this.curr_height) {
        this.y = startY;
        this.dropOnGround(map);
        this.collideSound(map);
        return true;
      }
    } catch(Exception e) {}
    // unit collisions
    for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
      if (entry.getKey() == this.source_key) {
        continue;
      }
      Unit u = entry.getValue();
      if (u.alliance == this.alliance && this.alliance != Alliance.NONE && !this.friendly_fire) {
        continue;
      }
      if (this.curr_height < u.zi() && this.curr_height > u.zi()) {
        continue;
      }
      float distance_to = this.distance(u);
      if (distance_to > 0) {
        continue;
      }
      if ( (this.y > u.y && this.facingY > 0) || (this.y < u.y && this.facingY < 0) ) {
        continue;
      }
      this.y = startY;
      this.collideWithUnit(map, u);
      this.collideSound(map);
      return true;
    }
    return false;
  }

   public ArrayList<Item> droppedItems(boolean hitUnit) {
    ArrayList<Item> droppedItems = new ArrayList<Item>();
    switch(this.ID) {
      case 3001: // Mighty Pen
      case 3002: // Mighty Pen II
        droppedItems.add(new Item(2911));
        break;
      case 3301: // Slingshot
      case 3931: // Rock
        droppedItems.add(new Item(2931));
        break;
      case 3311: // Recurve Bow
      case 3932: // Arrow
        droppedItems.add(new Item(2932));
        break;
      case 3353: // Ballistic Knife
      case 3374: // The Krauss Refibrillator
        droppedItems.add(new Item(2203));
        break;
      case 3924: // Glass Bottle
        droppedItems.add(new Item(2805));
        break;
      case 3933: // Pebble
        droppedItems.add(new Item(2933));
        break;
      default:
        break;
    }
    return droppedItems;
  }

   public void dropItems(AbstractGameMap map) {
    for (Item i : this.droppedItems(false)) {
      map.addItem(i, this.x, this.y);
    }
    switch(this.ID) {
      case 3118: // Chicken Egg (thrown)
        if (this.toggled) {
          Unit u = new Unit(1003);
          u.setLocation(this.x - this.facingX * u.size - Constants.small_number,
            this.y - this.facingY * u.size - Constants.small_number);
          u.curr_height = this.curr_height;
          map.addUnit(u);
        }
        break;
      default:
        break;
    }
  }

   public void dropOnGround(AbstractGameMap map) {
    this.dropItems(map);
    if (this.waitsToExplode()) {
      this.startExplodeTimer(map);
    }
    else if (this.explodesOnImpact()) {
      this.explode(map);
    }
    else {
      this.remove = true;
    }
  }

   public void collideWithUnit(AbstractGameMap map, Unit u) {
    this.dropItems(map);
    float damage = u.calculateDamageFrom(this.collidePower(), this.damageType,
      this.element, this.piercing, this.penetration);
    u.damage(map.units.get(this.source_key), damage);
    switch(this.ID) {
      case 3001: // Mighty Pen
        u.heal(Constants.ability_102_healRatio * damage);
        break;
      case 3002: // Mighty Pen II
        u.heal(Constants.ability_107_healRatio * damage);
        break;
      default:
        break;
    }
    if (this.waitsToExplode()) {
      this.startExplodeTimer(map);
    }
    else if (this.explodesOnImpact()) {
      this.explode(map);
    }
    else {
      this.remove = true;
    }
  }


   public void dropSound(AbstractGameMap map) {
    switch(this.ID) {
      case 3118: // Chicken Egg
        global.sounds.trigger_units("items/egg_crack", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3924: // Glass Bottle
        global.sounds.trigger_units("items/glass_bottle_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      default:
      // default drop sound
        break;
    }
  }


   public void collideSound(AbstractGameMap map) {
    switch(this.ID) {
      case 3118: // Chicken Egg
        global.sounds.trigger_units("items/egg_crack", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3311: // Recurve Bow
      case 3932: // Arrow
        global.sounds.trigger_units("items/recurve_bow_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3001: // Mighty Pen
      case 3002: // Mighty Pen II
      case 3312: // M1911
      case 3322: // Five-Seven
      case 3323: // Type25
      case 3332: // FAL
      case 3333: // Python
      case 3343: // Ultra
      case 3344: // Strain25
      case 3345: // Executioner
      case 3351: // Galil
      case 3352: // WN
      case 3354: // Cobra
      case 3355: // MTAR
      case 3361: // RPD
      case 3363: // DSR-50
      case 3364: // Voice of Justice
      case 3371: // HAMR
      case 3373: // Lamentation
      case 3375: // Malevolent Taxonomic Anodized Redeemer
      case 3381: // Relativistic Punishment Device
      case 3382: // Dead Specimen Reactor 5000
      case 3391: // SLDG HAMR
        global.sounds.trigger_units("items/bullet_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3353: // Ballistic Knife
      case 3374: // The Krauss Refibrillator
        global.sounds.trigger_units("items/ballistic_knife_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3301: // Slingshot
      case 3321: // War Machine
      case 3931: // Rock
      case 3933: // Pebble
      case 3944: // Grenade
        global.sounds.trigger_units("items/rock_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3924: // Glass Bottle
        global.sounds.trigger_units("items/glass_bottle_hit", this.x - map.viewX, this.y - map.viewY);
        break;
      default:
        break;
    }
  }


   public float collidePower() {
    switch(this.ID) {
      case 3321: // War Machine
        return 10;
      case 3331: // Mustang and Sally
        return 18;
      case 3341: // RPG
        return 20;
      case 3342: // Dystopic Demolisher
        return 12;
      case 3362: // Rocket-Propelled Grievance
        return 24;
      case 3372: // Ray Gun
        return 1000;
      case 3392: // Porter's X2 Ray Gun
        return 1000;
      case 3944: // Grenade
        return 4;
      default:
        return this.power;
    }
  }


   public boolean waitsToExplode() {
    switch(this.ID) {
      case 3321: // War Machine
      case 3944: // Grenade
        return true;
      default:
        return false;
    }
  }

   public void startExplodeTimer(AbstractGameMap map) {
    this.waiting_to_explode = true;
    switch(this.ID) {
      case 3321: // War Machine
        this.range_left = 1980;
        global.sounds.trigger_units("items/grenade_ticking", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3944: // Grenade
        this.range_left = 1980;
        global.sounds.trigger_units("items/grenade_ticking", this.x - map.viewX, this.y - map.viewY);
        break;
      default:
        global.errorMessage("ERROR: Projectile ID " + this.ID + " doesn't wait to explode.");
        this.waiting_to_explode = false;
        return;
    }
  }

   public boolean explodesOnImpact() {
    switch(this.ID) {
      case 3331: // Mustang and Sally
      case 3341: // RPG
      case 3342: // Dystopic Demolisher
      case 3362: // Rocket-Propelled Grievance
      case 3372: // Ray Gun
      case 3392: // Porter's X2 Ray Gun
        return true;
      default:
        return false;
    }
  }

   public void explode(AbstractGameMap map) {
    float explode_x = this.x;
    float explode_y = this.y;
    float explode_range = 0;
    float explode_maxPower = 0;
    float explode_minPower = 0;
    switch(this.ID) { // set values and add visual effects
      case 3321: // War Machine
        explode_range = Constants.projectile_grenadeExplosionRadius;
        explode_minPower = 125;
        explode_maxPower = 450;
        map.addVisualEffect(4010, this.x, this.y);
        global.sounds.trigger_units("items/grenade", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3331: // Mustang and Sally
        explode_range = Constants.projectile_grenadeExplosionRadius;
        explode_minPower = 75;
        explode_maxPower = 1200;
        map.addVisualEffect(4011, this.x, this.y);
        global.sounds.trigger_units("items/grenade", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3341: // RPG
        explode_range = Constants.projectile_rpgExplosionRadius;
        explode_minPower = 100;
        explode_maxPower = 500;
        map.addVisualEffect(4012, this.x, this.y);
        global.sounds.trigger_units("items/grenade_RPG", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3342: // Dystopic Demolisher
        explode_range = Constants.projectile_grenadeExplosionRadius;
        explode_minPower = 125;
        explode_maxPower = 900;
        map.addVisualEffect(4013, this.x, this.y);
        global.sounds.trigger_units("items/grenade", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3362: // Rocket-Propelled Grievance
        explode_range = Constants.projectile_rpgIIExplosionRadius;
        explode_minPower = 100;
        explode_maxPower = 600;
        map.addVisualEffect(4014, this.x, this.y);
        global.sounds.trigger_units("items/grenade_RPG", this.x - map.viewX, this.y - map.viewY);
        break;
      case 3372: // Ray Gun
        explode_range = Constants.projectile_rayGunExplosionRadius;
        explode_minPower = 300;
        explode_maxPower = 1500;
        map.addVisualEffect(4015, this.x, this.y - 0.5f * Constants.projectile_rayGunExplosionRadius);
        break;
      case 3392: // Porter's X2 Ray Gun
        explode_range = Constants.projectile_rayGunIIExplosionRadius;
        explode_minPower = 300;
        explode_maxPower = 2000;
        map.addVisualEffect(4016, this.x, this.y - 0.5f * Constants.projectile_rayGunIIExplosionRadius);
        break;
      case 3944: // Grenade
        explode_range = Constants.projectile_grenadeExplosionRadius;
        explode_minPower = 100;
        explode_maxPower = 400;
        map.addVisualEffect(4017, this.x, this.y);
        global.sounds.trigger_units("items/grenade", this.x - map.viewX, this.y - map.viewY);
        break;
      default:
        global.errorMessage("ERROR: Projectile ID " + this.ID + " doesn't explode.");
        break;
    }
    map.splashDamage(explode_x, explode_y, explode_range, explode_maxPower,
      explode_minPower, this.source_key, this.damageType, this.element,
      this.piercing, this.penetration, true);
    this.remove = true;
  }


   public String fileString() {
    String fileString = "\nnew: Projectile: " + this.ID;
    fileString += this.objectFileString();
    fileString += "\nsize: " + this.size;
    fileString += "\nsource_key: " + this.source_key;
    fileString += "\nfacingX: " + this.facingX;
    fileString += "\nfacingY: " + this.facingY;
    fileString += "\nalliance: " + this.alliance.alliance_name();
    fileString += "\nelement: " + this.element.element_name();
    fileString += "\npower: " + this.power;
    fileString += "\npiercing: " + this.piercing;
    fileString += "\npenetration: " + this.penetration;
    fileString += "\nrangeLeft: " + this.range_left;
    fileString += "\nwaitingToExplode: " + this.waiting_to_explode;
    fileString += "\nend: Projectile\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    if (this.addObjectData(datakey, data)) {
      return;
    }
    switch(datakey) {
      case "size":
        this.size = toFloat(data);
        break;
      case "source_key":
        this.source_key = toInt(data);
        break;
      case "facingX":
        this.facingX = toFloat(data);
        break;
      case "facingY":
        this.facingY = toFloat(data);
        break;
      case "alliance":
        this.alliance = Alliance.alliance(data);
        break;
      case "element":
        this.element = Element.element(data);
        break;
      case "power":
        this.power = toFloat(data);
        break;
      case "piercing":
        this.piercing = toFloat(data);
        break;
      case "penetration":
        this.penetration = toFloat(data);
        break;
      case "rangeLeft":
        this.range_left = toFloat(data);
        break;
      case "waitingToExplode":
        this.waiting_to_explode = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for projectile data.");
        break;
    }
  }
}
class Quest {
  protected int ID = 0;
  protected boolean met = false;
  protected int blink_time_left = Constants.level_questBlinkTime;
  protected int blinks_left = Constants.level_questBlinks;
  protected boolean blinking = false;

  Quest(int id) {
    this.ID = id;
  }

   public void meet(Hero h) {
    if (this.met) {
      return;
    }
    this.met = true;
    global.sounds.trigger_player("player/quest");
    this.blink_time_left = Constants.level_questBlinkTime;
    this.blinks_left = Constants.level_questBlinks;
    this.blinking = false;
    switch(this.ID) {
      // Francis Hall
      case 21: // find molly
        break;
      case 22: // find the thing
        break;
      case 23: // find bens coat
        break;
      case 24: // find bens backpack
        break;
      default:
        break;
    }
  }

   public void update(Level level, int timeElapsed) {
    if (this.blink_time_left > 0) {
      this.blink_time_left -= timeElapsed;
      if (this.blink_time_left <= 0) {
        if (this.blinking) {
          this.blinking = false;
          this.blink_time_left = Constants.level_questBlinkTime;
        }
        else if (this.blinks_left > 0) {
          this.blinking = true;
          this.blinks_left--;
          this.blink_time_left = Constants.level_questBlinkTime;
        }
      }
    }
    if (this.met) {
      return;
    }
    switch(this.ID) {
      // Tutorial
      case 1: // select ben
        break;
      case 2: // move toward arrow
        break;
      case 3: // go to room
        break;
      case 4: // kill chicken
        break;
      case 5: // unlock inventory
        break;
      case 6: // use backpack
        if (level.player != null && level.player.inventory.slots.size() > 2) {
          this.meet(level.player);
        }
        break;
      case 7: // damage john rankin
        break;
      case 8: // drink water
        break;
      case 9: // eat food
        break;
      case 10: // sleep
        break;
      case 11: // die
        break;
      case 12: // enter common room
        break;
      // Francis Hall
      case 21: // find molly
        break;
      case 22: // find the thing
        if (level.player != null && level.player.holding(2211)) {
          this.meet(level.player);
        }
        break;
      case 23: // find bens coat
        if (level.player != null && level.player.holding(2512)) {
          this.meet(level.player);
        }
        break;
      case 24: // find bens backpack
        if (level.player != null && level.player.holding(2922)) {
          this.meet(level.player);
        }
        break;
      case 25: // go to room
        break;
      // Frontdoor
      case 31: // get off campus
        break;
      // Ahimdoor
      case 41:
        break;
      // Brothersdoor
      case 51:
        break;
      // Chapeldoor
      case 61:
        break;
      // Custodialdoor
      case 71:
        break;
      default:
        global.errorMessage("ERROR: Quest ID " + this.ID + " not recognized.");
        break;
    }
  }

   public String name() {
    switch(this.ID) {
      // Tutorial
      case 1: // select ben
        return "Select Ben Nelson";
      case 2: // move toward arrow
        return "Move Ben Nelson toward the arrow";
      case 3: // go to room
        return "Go to your room";
      case 4: // kill chicken
        return "Kill the chicken";
      case 5: // unlock inventory
        return "Unlock your inventory";
      case 6: // use backpack
        return "Use your backpack";
      case 7: // damage john rankin
        return "Chase away John Rankin";
      case 8: // drink water
        return "Drink water";
      case 9: // eat food
        return "Eat food";
      case 10: // sleep
        return "Go to sleep";
      case 11: // die
        return "Die";
      case 12: // enter common room
        return "Enter the common room";
      // Francis Hall
      case 21: // find molly
        return "Find Molly";
      case 22: // find the thing
        return "Find The Thing";
      case 23: // find bens coat
        return "Find Ben's Coat";
      case 24: // find bens backpack
        return "Find Ben's Backpack";
      case 25: // go to room
        return "Go to your room";
      // Frontdoor
      case 31: // get off campus
        return "Get off campus";
      // Ahimdoor
      case 41:
        return "";
      // Brothersdoor
      case 51:
        return "";
      // Chapeldoor
      case 61:
        return "";
      // Custodialdoor
      case 71:
        return "";
      default:
        return "";
    }
  }

   public String shortDescription() {
    switch(this.ID) {
      // Tutorial
      case 1: // select ben
        return "Select Ben Nelson by left-clicking him.";
      case 2: // move toward arrow
        return "Move Ben Nelson toward the arrow by right-clicking near the arrow.";
      case 3: // go to room
        return "Your room is on the second floor of Francis Hall.";
      case 4: // kill chicken
        return "Attack the chicken by right-clicking it.";
      case 5: // unlock inventory
        return "Unlock your inventory in the HeroTree, which you can open with 'ctrl-t'.";
      case 6: // use backpack
        return "Use your backpack by placing it in your primary hand and pressing 'r'.";
      case 7: // damage john rankin
        return "Chase away John Rankin by damaging him. Your base attack won't be enough.";
      case 8: // drink water
        return "Drink water by right-clicking the water fountain outside your room.";
      case 9: // eat food
        return "There's food in your fridge that will quell your hunger.";
      case 10: // sleep
        return "Go to sleep by right-clicking your bed at night-time.";
      case 11: // die
        return "Die by walking in lava; you will respawn at your bed.";
      case 12: // enter common room
        return "The lava won't damage you while your ultimate is activated.";
      // Francis Hall
      case 21: // find molly
        return "Find Molly and bring her back to Mike Schmiesing.";
      case 22: // find the thing
        return "Find The Thing before Connor Smith finds out you lost it.";
      case 23: // find bens coat
        return "Find Ben's Coat; it's got to be somewhere on Soldier's wing...";
      case 24: // find bens backpack
        return "Find Ben's Backpack; he remembers putting it in storage somewhere.";
      case 25: // go to room
        return "Somehow the door is locked again";
      // Frontdoor
      case 31: // get off campus
        return "Find a place more remote, preferrably before night-fall";
      // Ahimdoor
      case 41:
        return "";
      // Brothersdoor
      case 51:
        return "";
      // Chapeldoor
      case 61:
        return "";
      // Custodialdoor
      case 71:
        return "";
      default:
        return "";
    }
  }
}
class Rectangle {
  private String mapName = "";
  private float xi = 0;
  private float yi = 0;
  private float xf = 0;
  private float yf = 0;

  Rectangle() {}
  Rectangle(String mapName, float xi, float yi, float xf, float yf) {
    this.mapName = mapName;
    if (xf < xi) {
      this.xi = xf;
      this.xf = xi;
    }
    else {
      this.xi = xi;
      this.xf = xf;
    }
    if (yf < yi) {
      this.yi = yf;
      this.yf = yi;
    }
    else {
      this.yi = yi;
      this.yf = yf;
    }
  }
  Rectangle(String mapName, MapObject object) {
    this.mapName = mapName;
    this.setLocation(object);
  }

   public float centerX() {
    return this.xi + 0.5f * (this.xf - this.xi);
  }
   public float centerY() {
    return this.yi + 0.5f * (this.yf - this.yi);
  }

   public boolean touching(MapObject object, String object_map_name) {
    if (!this.mapName.equals(object_map_name)) {
      return false;
    }
    if (object.xf() >= this.xi && object.yf() >= this.yi &&
      object.xi() <= this.xf && object.yi() <= this.yf) {
      return true;
    }
    return false;
  }
   public boolean touching(MapObject object) {
    if (object.xf() >= this.xi && object.yf() >= this.yi &&
      object.xi() <= this.xf && object.yi() <= this.yf) {
      return true;
    }
    return false;
  }

   public boolean contains(MapObject object, String object_map_name) {
    if (!this.mapName.equals(object_map_name)) {
      return false;
    }
    if (object.xi() >= this.xi && object.yi() >= this.yi &&
      object.xf() <= this.xf && object.yf() <= this.yf) {
      return true;
    }
    return false;
  }
   public boolean contains(MapObject object) {
    if (object.xi() >= this.xi && object.yi() >= this.yi &&
      object.xf() <= this.xf && object.yf() <= this.yf) {
      return true;
    }
    return false;
  }

   public void setLocation(MapObject object) {
    this.xi = object.xi();
    this.yi = object.yi();
    this.xf = object.xf();
    this.yf = object.yf();
  }

   public String fileString() {
    return this.mapName + ", " + this.xi + ", " + this.yi + ", " + this.xf + ", " + this.yf;
  }

   public void addData(String fileString) {
    String[] data = split(fileString, ',');
    if (data.length < 5) {
      global.errorMessage("ERROR: Data dimensions not sufficient for Rectangle data.");
      return;
    }
    this.mapName = trim(data[0]);
    this.xi = toFloat(trim(data[1]));
    this.yi = toFloat(trim(data[2]));
    this.xf = toFloat(trim(data[3]));
    this.yf = toFloat(trim(data[4]));
  }
}
class Sounds {
  private Minim minim;

  private AudioPlayer background_track;
  private float volume_background = 0;
  private boolean muted_background = false;
  private boolean playing_background = false;
  private boolean loop_background = true;
  private String album_name = "";
  private int track_number = 1;

  private AudioOutput out_interface;
  private HashMap<String, Sampler> sounds_interface = new HashMap<String, Sampler>();
  private AudioOutput out_environment;
  private HashMap<String, Sampler> sounds_environment = new HashMap<String, Sampler>();
  private AudioOutput out_units;
  private HashMap<String, Sampler> sounds_units = new HashMap<String, Sampler>();
  private AudioOutput out_player;
  private HashMap<String, Sampler> sounds_player = new HashMap<String, Sampler>();

  private String basePath = sketchPath("data/sounds/");

  Sounds(LNZ thisInstance) {
    this.minim = new Minim(thisInstance);
    this.out_interface = this.minim.getLineOut();
    this.out_environment = this.minim.getLineOut();
    this.out_units = this.minim.getLineOut();
    this.out_player = this.minim.getLineOut();
  }

   public void play_background(String album_name) {
    this.play_background(album_name, true);
  }
   public void play_background(String album_name, boolean loop_background) {
    if (this.album_name.equals(album_name)) {
      return;
    }
    this.stop_background();
    this.album_name = album_name;
    if (album_name == null || album_name.equals("none")) {
      return;
    }
    this.playing_background = true;
    this.loop_background = loop_background;
    this.track_number = 0;
  }

   public void stop_background() {
    if (this.background_track != null) {
      this.background_track.pause();
      this.background_track.close();
    }
  }

   public void pause_background() {
    if (this.background_track != null) {
      this.background_track.pause();
    }
  }

   public void resume_background() {
    if (this.background_track != null) {
      this.background_track.play();
    }
  }

   public void setBackgroundVolume(float volume, boolean muted) {
    this.volume_background = volume;
    this.muted_background = muted;
    if (this.background_track != null) {
      this.background_track.setGain(volume);
      if (this.muted_background) {
        this.background_track.mute();
      }
      else {
        this.background_track.unmute();
      }
    }
  }

   public void update() {
    if (this.playing_background) {
      if (this.background_track == null || !this.background_track.isPlaying()) {
        this.track_number++;
        String track_path = "data/sounds/background/" + this.album_name + this.track_number + ".wav";
        if (fileExists(track_path)) {
          this.background_track = minim.loadFile(track_path);
          this.background_track.play();
          this.setBackgroundVolume(this.volume_background, this.muted_background);
        }
        else if (this.loop_background) {
          this.track_number = 0;
        }
        else {
          this.playing_background = false;
        }
      }
    }
  }

   public void trigger_interface(String soundPath) {
    if (this.sounds_interface.containsKey(soundPath)) {
      this.sounds_interface.get(soundPath).trigger();
    }
    else {
      String filePath = this.basePath + soundPath + ".wav";
      File f = new File(filePath);
      if (f.exists()) {
        Sampler s = new Sampler(filePath, 2, this.minim);
        s.patch(this.out_interface);
        this.sounds_interface.put(soundPath, s);
        s.trigger();
      }
      else {
        global.log("Sounds: Missing interface sound " + filePath + ".");
      }
    }
  }
   public void silence_interface(String soundPath) {
    if (this.sounds_interface.containsKey(soundPath)) {
      this.sounds_interface.get(soundPath).stop();
    }
  }

   public void trigger_environment(String soundPath) {
    this.trigger_environment(soundPath, 0, 0);
  }
   public void trigger_environment(String soundPath, float xDif, float yDif) {
    float distance = sqrt(xDif * xDif + yDif * yDif);
    if (distance > Constants.map_defaultMaxSoundDistance) {
      return;
    }
    if (this.sounds_environment.containsKey(soundPath)) {
      this.sounds_environment.get(soundPath).trigger();
    }
    else {
      String filePath = this.basePath + soundPath + ".wav";
      File f = new File(filePath);
      if (f.exists()) {
        Sampler s = new Sampler(filePath, 2, this.minim);
        s.patch(this.out_environment);
        this.sounds_environment.put(soundPath, s);
        s.trigger();
      }
      else {
        global.log("Sounds: Missing environment sound " + filePath + ".");
      }
    }
  }
   public void silence_environment(String soundPath) {
    if (this.sounds_environment.containsKey(soundPath)) {
      this.sounds_environment.get(soundPath).stop();
    }
  }

   public void trigger_units(String soundPath) {
    this.trigger_units(soundPath, 0, 0);
  }
   public void trigger_units(String soundPath, float xDif, float yDif) {
    float distance = sqrt(xDif * xDif + yDif * yDif);
    if (distance > Constants.map_defaultMaxSoundDistance) {
      return;
    }
    if (this.sounds_units.containsKey(soundPath)) {
      this.sounds_units.get(soundPath).trigger();
    }
    else {
      String filePath = this.basePath + soundPath + ".wav";
      File f = new File(filePath);
      if (f.exists()) {
        Sampler s = new Sampler(filePath, 2, this.minim);
        s.patch(this.out_units);
        this.sounds_units.put(soundPath, s);
        s.trigger();
      }
      else {
        global.log("Sounds: Missing units sound " + filePath + ".");
      }
    }
  }
   public void silence_units(String soundPath) {
    if (this.sounds_units.containsKey(soundPath)) {
      this.sounds_units.get(soundPath).stop();
    }
  }

   public void trigger_player(String soundPath) {
    this.trigger_player(soundPath, 0, 0);
  }
   public void trigger_player(String soundPath, float xDif, float yDif) {
    float distance = sqrt(xDif * xDif + yDif * yDif);
    if (distance > Constants.map_defaultMaxSoundDistance) {
      return;
    }
    if (this.sounds_player.containsKey(soundPath)) {
      this.sounds_player.get(soundPath).trigger();
    }
    else {
      String filePath = this.basePath + soundPath + ".wav";
      File f = new File(filePath);
      if (f.exists()) {
        Sampler s = new Sampler(filePath, 2, this.minim);
        s.patch(this.out_player);
        this.sounds_player.put(soundPath, s);
        s.trigger();
      }
      else {
        global.log("Sounds: Missing player sound " + filePath + ".");
      }
    }
  }
   public void silence_player(String soundPath) {
    if (this.sounds_player.containsKey(soundPath)) {
      this.sounds_player.get(soundPath).stop();
    }
  }
}
enum StatusEffectCode {
  ERROR("Error"), HUNGRY("Hungry"), WEAK("Weak"), THIRSTY("Thirsty"), WOOZY("Woozy"),
  CONFUSED("Confused"), INVULNERABLE("Invulnerable"), UNKILLABLE("Unkillable"),
  BLEEDING("Bleeding"), HEMORRHAGING("Hemorrhaging"), WILTED("Wilted"), WITHERED("Withered"),
  VISIBLE("Visible"), SUPPRESSED("Suppressed"), UNTARGETABLE("Untargetable"),
  STUNNED("Stunned"), INVISIBLE("Invisible"), UNCOLLIDABLE("Uncollidable"),
  RUNNING("Running"), FERTILIZED("Fertilized"), SNEAKING("Sneaking"), RELAXED("Relaxed"),
  GHOSTING("Ghosting"), SILENCED("Silenced"), SLOWED("Slowed"),

  DRENCHED("Drenched"), DROWNING("Drowning"), BURNT("Burning"), CHARRED("Charred"),
  CHILLED("Chilled"), FROZEN("Frozen"), SICK("Sick"), DISEASED("Diseased"), ROTTING("Rotting"),
  DECAYED("Decayed"), SHAKEN("Shaken"), FALLEN("Fallen"), SHOCKED("Shocked"),
  PARALYZED("Paralyzed"), UNSTABLE("Unstable"), RADIOACTIVE("Radioactive"),

  NELSON_GLARE("Nelson Glared"), NELSON_GLAREII("Nelson Glared"), SENSELESS_GRIT(
  "Senseless Grit"), SENSELESS_GRITII("Senseless Grit"), RAGE_OF_THE_BEN(
  "Rage of the Ben"), RAGE_OF_THE_BENII("Rage of the Ben"),

  APOSEMATIC_CAMOUFLAGE("Camouflaged"), APOSEMATIC_CAMOUFLAGEII("Camouflaged"),
  TONGUE_LASH("Slowed"), ALKALOID_SECRETION("Secreting Alkaloids"), ALKALOID_SECRETIONII(
  "Secreting Alkaloids"),
  ;

  private static final List<StatusEffectCode> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String code_name;
  private StatusEffectCode(String code_name) {
    this.code_name = code_name;
  }
  public String code_name() {
    return this.code_name;
  }
  public static String code_name(StatusEffectCode code) {
    return code.code_name();
  }

  public static StatusEffectCode code(String code_name) {
    for (StatusEffectCode code : StatusEffectCode.VALUES) {
      if (code == StatusEffectCode.ERROR) {
        continue;
      }
      if (code.code_name().equals(code_name)) {
        return code;
      }
    }
    return StatusEffectCode.ERROR;
  }

  public boolean negative() {
    return StatusEffectCode.negative(this);
  }
  public static boolean negative(StatusEffectCode code) {
    switch(code) {
      case INVULNERABLE:
      case UNKILLABLE:
      case UNTARGETABLE:
      case INVISIBLE:
      case UNCOLLIDABLE:
      case RUNNING:
      case FERTILIZED:
      case SNEAKING:
      case RELAXED:
      case GHOSTING:
      case SENSELESS_GRIT:
      case SENSELESS_GRITII:
      case RAGE_OF_THE_BEN:
      case RAGE_OF_THE_BENII:
      case APOSEMATIC_CAMOUFLAGE:
      case APOSEMATIC_CAMOUFLAGEII:
      case ALKALOID_SECRETION:
      case ALKALOID_SECRETIONII:
        return false;
      default:
        return true;
    }
  }

  public Element element() {
    return StatusEffectCode.element(this);
  }
  public static Element element(StatusEffectCode code) {
    switch(code) {
      case DRENCHED:
      case DROWNING:
        return Element.BLUE;
      case BURNT:
      case CHARRED:
        return Element.RED;
      case CHILLED:
      case FROZEN:
        return Element.CYAN;
      case SICK:
      case DISEASED:
        return Element.ORANGE;
      case ROTTING:
      case DECAYED:
      case APOSEMATIC_CAMOUFLAGE:
      case APOSEMATIC_CAMOUFLAGEII:
      case TONGUE_LASH:
      case ALKALOID_SECRETION:
      case ALKALOID_SECRETIONII:
        return Element.BROWN;
      case SHAKEN:
      case FALLEN:
        return Element.PURPLE;
      case SHOCKED:
      case PARALYZED:
        return Element.YELLOW;
      case UNSTABLE:
      case RADIOACTIVE:
        return Element.MAGENTA;
      default:
        return Element.GRAY;
    }
  }

  public String getImageString() {
    String image_path = "statuses/";
    switch(this) {
      case INVULNERABLE:
        image_path += "invulnerable.png";
        break;
      case UNKILLABLE:
        image_path += "unkillable.png";
        break;
      case HUNGRY:
        image_path += "hungry.png";
        break;
      case WEAK:
        image_path += "weak.png";
        break;
      case THIRSTY:
        image_path += "thirsty.png";
        break;
      case WOOZY:
        image_path += "woozy.png";
        break;
      case CONFUSED:
        image_path += "confused.png";
        break;
      case BLEEDING:
        image_path += "bleeding.png";
        break;
      case HEMORRHAGING:
        image_path += "hemorrhaging.png";
        break;
      case WILTED:
        image_path += "wilted.png";
        break;
      case WITHERED:
        image_path += "withered.png";
        break;
      case VISIBLE:
        image_path += "visible.png";
        break;
      case SUPPRESSED:
        image_path += "suppressed.png";
        break;
      case UNTARGETABLE:
        image_path += "untargetable.png";
        break;
      case STUNNED:
        image_path += "stunned.png";
        break;
      case INVISIBLE:
        image_path += "invisible.png";
        break;
      case UNCOLLIDABLE:
        image_path += "uncollidable.png";
        break;
      case RUNNING:
        image_path += "running.png";
        break;
      case FERTILIZED:
        image_path += "fertilized.png";
        break;
      case SNEAKING:
        image_path += "sneaking.png";
        break;
      case RELAXED:
        image_path += "relaxed.png";
        break;
      case GHOSTING:
        image_path += "ghosting.png";
        break;
      case SILENCED:
        image_path += "silenced.png";
        break;
      case DRENCHED:
        image_path += "drenched.png";
        break;
      case DROWNING:
        image_path += "drowning.png";
        break;
      case BURNT:
        image_path += "burning.png";
        break;
      case CHARRED:
        image_path += "charred.png";
        break;
      case CHILLED:
        image_path += "chilled.png";
        break;
      case FROZEN:
        image_path += "frozen.jpg";
        break;
      case SICK:
        image_path += "sick.png";
        break;
      case DISEASED:
        image_path += "diseased.png";
        break;
      case ROTTING:
        image_path += "rotting.png";
        break;
      case DECAYED:
        image_path += "decayed.png";
        break;
      case SHAKEN:
        image_path += "shaken.png";
        break;
      case FALLEN:
        image_path += "fallen.png";
        break;
      case SHOCKED:
        image_path += "shocked.png";
        break;
      case PARALYZED:
        image_path += "paralyzed.png";
        break;
      case UNSTABLE:
        image_path += "unstable.png";
        break;
      case RADIOACTIVE:
        image_path += "radioactive.png";
        break;
      case NELSON_GLARE:
      case NELSON_GLAREII:
        image_path += "nelson_glare.png";
        break;
      case SENSELESS_GRIT:
      case SENSELESS_GRITII:
        image_path += "senseless_grit.png";
        break;
      case RAGE_OF_THE_BEN:
      case RAGE_OF_THE_BENII:
        image_path += "rage_of_the_ben.png";
        break;
      case APOSEMATIC_CAMOUFLAGE:
      case APOSEMATIC_CAMOUFLAGEII:
        image_path += "camouflaged.jpg";
        break;
      case SLOWED:
      case TONGUE_LASH:
        image_path += "slowed.png";
        break;
      case ALKALOID_SECRETION:
      case ALKALOID_SECRETIONII:
        image_path += "alkaloid_secretion.png";
        break;
      default:
        image_path += "default.png";
        break;
    }
    return image_path;
  }

  public String description() {
    switch(this) {
      case INVULNERABLE:
        return "This unit does not take damage from any source.";
      case UNKILLABLE:
        return "This unit cannot be killed.";
      case HUNGRY:
        return "This unit is hungry and will slowly take damage to " + round(100.0f *
          Constants.status_hunger_damageLimit) + "% max health.\nHunger can " +
          "also lead to weakness.";
      case WEAK:
        return "This unit is weak and has " + round(100.0f * Constants.
          status_weak_multiplier) + "% combat stats (attack, defense, etc.).";
      case THIRSTY:
        return "This unit is thirsty and will slowly take damage to " + round(100.0f *
          Constants.status_thirst_damageLimit) + "% max health.\nThirst can " +
          "also lead to becoming woozy or confused.";
      case WOOZY:
        return "This unit is woozy and will randomly stop what they are " +
          "doing and turn another direction.";
      case CONFUSED:
        return "This unit is confused and will randomly stop what they are " +
          "doing and move in a random direction.";
      case BLEEDING:
        return "This unit is bleeding and will take damage to " + round(100.0f *
          Constants.status_bleed_damageLimit) + "% max health.\nBleeding can " +
          "also lead to hemorrhaging";
      case HEMORRHAGING:
        return "This unit is hemorraghing and will quickly die if it is not stopped.";
      case WILTED:
        return "This unit is wilted and has " + round(100.0f * Constants.
          status_wilted_multiplier) + "% combat stats (attack, defense, etc.).";
      case WITHERED:
        return "This unit is withered and has " + round(100.0f * Constants.
          status_withered_multiplier) + "% combat stats (attack, defense, etc.).";
      case VISIBLE:
        return "This unit is visible and can be seen by enemies.";
      case SUPPRESSED:
        return "This unit is suppressed and cannot perform any action";
      case UNTARGETABLE:
        return "This unit is untargetable and cannot be targeted by attacks, abilities, or spells.";
      case STUNNED:
        return "This unit is stunned and cannot move, attack, use abilities, or cast spells.";
      case INVISIBLE:
        return "This unit is invisible and cannot be seen.";
      case UNCOLLIDABLE:
        return "This unit is uncollidable and cannot be collided with.";
      case RUNNING:
        return "This unit is running and moves " + round(100.0f * (Constants.
          status_running_multiplier - 1.0f)) + "% faster.";
      case FERTILIZED:
        return "This unit is fertilized.";
      case SNEAKING:
        return "This unit is sneaking and will move slowly and not make walking sound.";
      case RELAXED:
        return "This unit is relaxed and has " + round(100.0f * Constants.
          status_relaxed_multiplier) + "% combat stats (attack, defense, etc.), " +
          " move speed, and tenacity, but " + round(1000.0f * Constants.
          status_relaxed_healMultiplier) / 10.0f + "% increased passive healing.";
      case GHOSTING:
        return "This unit is ghosting and can move through walls and other units.";
      case SILENCED:
        return "This unit is silenced and cannot cast spells.";
      case SLOWED:
        return "This unit is slowed and moves " + round(100.0f * (1.0f - Constants.
          status_slowed_multiplier)) + "% slower.";
      case DRENCHED:
        return "This unit is drenched so will take more damage from blue sources." +
          "\nIf this unit is red it will also slowly take damage to " + round(100.0f *
          Constants.status_drenched_damageLimit) + "% max health.";
      case DROWNING:
        return "This unit is drowning and will quickly take damage to their death." +
          "\nDrowning will also make the unit drenched." +
          "\nIf this unit is blue it will only take damage to " + round(100.0f *
          Constants.status_drowning_damageLimitBlue) + "% max health.";
      case BURNT:
        return "This unit is burning and will take damage to its death." +
          "\nBurning also has chance to make this unit charred." +
          "\nIf this unit is red it will only take damage to " + round(100.0f *
          Constants.status_burnt_damageLimitRed) + "% max health.";
      case CHARRED:
        return "This unit is charred and will quickly take damage to its death." +
          "\nIf this unit is red it will only take damage to " + round(100.0f *
          Constants.status_charred_damageLimitRed) + "% max health.";
      case CHILLED:
        return "This unit is chilled and has " + round(100.0f * Constants.
          status_chilled_speedMultiplier) + "% movement and attack speed." +
          "\nIf this unit is cyan it has " + round(100.0f * Constants.
            status_chilled_speedMultiplierCyan) + "% movement and attack speed.";
      case FROZEN:
        return "This unit is frozen and cannot move or attack." +
          "\nIf this unit is orange they will take small damage to " + round(100.0f *
          Constants.status_frozen_damageLimit) + "% max health.";
      case SICK:
        return "This unit is sick and cannot defend themselves. They will take " +
          round(100.0f * (Constants.status_sick_damageMultiplier - 1)) + "% more " +
          "damage from all sources and have their defensive stats reduced by " +
          round(100.0f * (1 - Constants.status_sick_defenseMultiplier)) + "%.";
      case DISEASED:
        return "This unit is diseased and cannot defend themselves. They will take " +
          round(100.0f * (Constants.status_diseased_damageMultiplier - 1)) + "% more " +
          "damage from all sources and have their defensive stats reduced by " +
          round(100.0f * (1 - Constants.status_diseased_defenseMultiplier)) + "%.";
      case ROTTING:
        return "This unit is rotting and will take damage to " + round(100.0f *
          Constants.status_rotting_damageLimit) + "% max health.\nIf this " +
          "unit is blue they can die from rotting; if this unit is brown they " +
          "will only take damage to " + round(100.0f * Constants.
          status_rotting_damageLimitBrown) + "% max health.";
      case DECAYED:
        return "This unit is decayed and will take damage to their death.\nIf " +
        "this unit is brown they will only take damage to " + round(100.0f *
        Constants.status_decayed_damageLimitBrown) + "% max health.";
      case SHAKEN:
        return "This unit is shaken.";
      case FALLEN:
        return "This unit is fallen.";
      case SHOCKED:
        return "This unit is shocked.";
      case PARALYZED:
        return "This unit is paralyzed.";
      case UNSTABLE:
        return "This unit is unstable.";
      case RADIOACTIVE:
        return "This unit is radioactive.";
      case NELSON_GLARE:
        return "This unit is Nelson glared and has " + round(100.0f * (1 - Constants.
          ability_103_debuff)) + "% reduced attack and speed.";
      case NELSON_GLAREII:
        return "This unit is Nelson glared and has " + round(100.0f * (1 - Constants.
          ability_108_debuff)) + "% reduced attack and speed.";
      case SENSELESS_GRIT:
        return "This unit has senseless grit and has " + round(100.0f * (Constants.
          ability_104_speedBuff - 1)) + "% more move speed when targeting enemies.";
      case SENSELESS_GRITII:
        return "This unit has senseless grit and has " + round(100.0f * (Constants.
          ability_109_speedBuff - 1)) + "% more move speed when targeting enemies.";
      case RAGE_OF_THE_BEN:
        return "This unit has the rage of the Ben and has " + round(100.0f * (Constants.
          ability_105_buffAmount - 1)) + "% increased attack and incrased rage gains.";
      case RAGE_OF_THE_BENII:
        return "This unit has the rage of the Ben and has " + round(100.0f * (Constants.
          ability_110_buffAmount - 1)) + "% increased attack and incrased rage gains.";
      case APOSEMATIC_CAMOUFLAGE:
        return "This unit is camouflaged and cannot be seen by enemies.\nThis " +
        "unit will also have a " + round(100.0f * (Constants.ability_111_powerBuff -
        1)) + "% bonus power the first attack they deliver while camouflaged.";
      case APOSEMATIC_CAMOUFLAGEII:
        return "This unit is camouflaged and cannot be seen by enemies.\nThis " +
        "unit will also have a " + round(100.0f * (Constants.ability_116_powerBuff -
        1)) + "% bonus power the first attack they deliver while camouflaged.";
      case TONGUE_LASH:
        return "This unit has been tongue lashed and is slowed by " + round(100.0f *
          (1 - Constants.ability_112_slowAmount)) + "%.";
      case ALKALOID_SECRETION:
      case ALKALOID_SECRETIONII:
        return "This unit is secreting alkaloids and damaging nearby enemy units " +
        "every " + Constants.ability_114_tickTime + "ms while also making them rot.";
      default:
        return "";
    }
  }
}


class StatusEffect {
  private boolean permanent = false;
  private float timer_gone_start = 0;
  private float timer_gone = 0;
  private float number = 0; // usually a timer for DoTs

  StatusEffect() {}
  StatusEffect(StatusEffectCode code, float timer) {
    this(code, timer, false);
  }
  StatusEffect(StatusEffectCode code, boolean permanent) {
    this(code, 0, permanent);
  }
  StatusEffect(StatusEffectCode code, float timer, boolean permanent) {
    this.timer_gone_start = timer;
    this.timer_gone = timer;
    this.permanent = permanent;
    switch(code) {
      case HUNGRY:
        this.number = random(Constants.status_hunger_tickTimer);
        break;
      case THIRSTY:
        this.number = random(Constants.status_thirst_tickTimer);
        break;
      case WOOZY:
        this.number = random(Constants.status_woozy_tickMaxTimer);
        break;
      case CONFUSED:
        this.number = random(Constants.status_confused_tickMaxTimer);
        break;
      case BLEEDING:
        this.number = random(Constants.status_bleed_tickTimer);
        break;
      case HEMORRHAGING:
        this.number = random(Constants.status_hemorrhage_tickTimer);
        break;
      case UNKILLABLE:
        this.number = 1;
        break;
      default:
        break;
    }
  }

   public void update(int millis) {
    if (!this.permanent) {
      this.timer_gone -= millis;
    }
  }

   public void startTimer(float timer) {
    this.permanent = false;
    this.timer_gone_start = timer;
    this.timer_gone = timer;
  }

   public void addTime(float extra_time) {
    this.timer_gone_start += extra_time;
    this.timer_gone += extra_time;
  }

   public void refreshTime(float time) {
    this.timer_gone = max(this.timer_gone, time);
    this.timer_gone_start = this.timer_gone;
  }

   public String fileString() {
    String fileString = "\nnew: StatusEffect";
    fileString += "\npermanent: " + this.permanent;
    fileString += "\ntimer_gone_start: " + this.timer_gone_start;
    fileString += "\ntimer_gone: " + this.timer_gone;
    fileString += "\nnumber: " + this.number;
    fileString += "\nend: StatusEffect";
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "permanent":
        this.permanent = toBoolean(data);
        break;
      case "timer_gone_start":
        this.timer_gone_start = toFloat(data);
        break;
      case "timer_gone":
        this.timer_gone = toFloat(data);
        break;
      case "number":
        this.number = toFloat(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for StatusEffect data.");
        break;
    }
  }
}
class Trigger {
  private String triggerName = "";
  private int triggerID = -1; // level id

  private boolean active = false;
  private boolean looping = false;
  private boolean amalgam = true; // all conditions must be met (&& vs || condition list)

  private ArrayList<Condition> conditions = new ArrayList<Condition>();
  private ArrayList<Effect> effects = new ArrayList<Effect>();

  Trigger() {}
  Trigger(String triggerName) {
    this.triggerName = triggerName;
  }

   public void update(int timeElapsed, Level level) {
    if (!this.active) {
      return;
    }
    boolean actuate = false;
    if (amalgam) {
      actuate = true;
    }
    for (Condition condition : this.conditions) {
      if (condition.update(timeElapsed, level)) {
        if (!amalgam) {
          actuate = true;
        }
      }
      else if (amalgam) {
        actuate = false;
      }
    }
    if (this.conditions.size() == 0 && !this.amalgam) {
      actuate = true;
    }
    if (actuate) {
      this.actuate(level);
    }
    else if (this.amalgam) {
      for (Condition condition : this.conditions) {
        condition.met = false;
      }
    }
  }

   public void actuate(Level level) {
    for (Effect effect : this.effects) {
      effect.actuate(level);
    }
    for (Condition condition : this.conditions) {
      condition.reset();
    }
    if (!this.looping) {
      this.active = false;
    }
  }

   public String fileString() {
    String fileString = "\nnew: Trigger";
    fileString += "\ntriggerName: " + this.triggerName;
    fileString += "\nactive: " + this.active;
    fileString += "\nlooping: " + this.looping;
    fileString += "\namalgam: " + this.amalgam;
    for (Condition condition : this.conditions) {
      fileString += condition.fileString();
    }
    for (Effect effect : this.effects) {
      fileString += effect.fileString();
    }
    fileString += "\nend: Trigger\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "triggerName":
        this.triggerName = data;
        break;
      case "active":
        this.active = toBoolean(data);
        break;
      case "looping":
        this.looping = toBoolean(data);
        break;
      case "amalgam":
        this.amalgam = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for Trigger object.");
        break;
    }
  }
}




class Condition {
  private int ID = 0;
  private String display_name = "Condition";

  private int number1 = 0;
  private int number2 = 0;
  private Rectangle rectangle = new Rectangle();

  private boolean not_condition = false;
  private boolean met = false;

  Condition() {}

   public void setID(int ID) {
    this.ID = ID;
    switch(ID) {
      case 0: // nothing
      case 1: // timer
      case 2: // selected specific unit
      case 3: // selected specific item
      case 4: // selected unit
      case 5: // selected item
      case 6: // player in rectangle
      case 7: // unit exists
      case 8: // has hero upgrade
      case 9: // unit in rectangle
      case 10: // unit health
      case 11: // holding item
      case 12: // player hunger
      case 13: // player thirst
      case 14: // player mana
      case 15: // time after
      case 16: // player respawning
      case 17: // item id in rectangle
        break;
      default:
        global.errorMessage("ERROR: Condition ID " + ID + " not recognized.");
        break;
    }
    this.setName();
  }

   public void setName() {
    switch(this.ID) {
      case 1: // timer
        if (number1 < 1000) {
          this.display_name = "Timer (" + this.number1 + " ms)";
        }
        else {
          this.display_name = "Timer (" + round(this.number1/100.0f)/10.0f + " s)";
        }
        break;
      case 2: // selected specific unit
        this.display_name = "Select Specific Unit (" + this.number1 + ")";
        break;
      case 3: // selected specific item
        this.display_name = "Select Specific Item (" + this.number1 + ")";
        break;
      case 4: // selected unit id
        this.display_name = "Select Unit (" + this.number1 + ")";
        break;
      case 5: // selected item id
        this.display_name = "Select Item (" + this.number1 + ")";
        break;
      case 6: // player in rectangle
        this.display_name = "Player In: " + this.rectangle.fileString();
        break;
      case 7: // unit exists
        this.display_name = "Unit Exists (" + this.number1 + ")";
        break;
      case 8: // has hero upgrade
        this.display_name = "Has Hero Upgrade (" + HeroTreeCode.codeFromId(this.number1) + ")";
        break;
      case 9: // unit in rectangle
        this.display_name = "Unit (" + this.number1 + ") In: " + this.rectangle.fileString();
        break;
      case 10: // unit health
        this.display_name = "Unit (" + this.number1 + ") Health above (" + this.number2 + ")";
        break;
      case 11: // holding item
        this.display_name = "Player Holding Item (" + this.number1 + ")";
        break;
      case 12: // player hunger
        this.display_name = "Player Hunger Above (" + this.number1 + ")";
        break;
      case 13: // player thirst
        this.display_name = "Player Thirst Above (" + this.number1 + ")";
        break;
      case 14: // player mana
        this.display_name = "Player Mana Above (" + this.number1 + ")";
        break;
      case 15: // time after
        this.display_name = "Time after (" + this.number1 + ")";
        break;
      case 16: // player respawning
        this.display_name = "Player Respawning";
        break;
      case 17: // item id in rectangle
        this.display_name = "Item ID (" + this.number1 + ") In: " + this.rectangle.fileString();
        break;
      default:
        this.display_name = "Condition";
        break;
    }
    if (this.not_condition) {
      this.display_name = "NOT " + this.display_name;
    }
  }

   public boolean update(int timeElapsed, Level level) {
    switch(this.ID) {
      case 0: // nothing
        break;
      case 1: // timer
        if (!this.met) {
          this.number2 -= timeElapsed;
          if (this.number2 < 0) {
            this.met = true;
          }
        }
        break;
      case 2: // selected specific unit
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (Unit.class.isInstance(level.currMap.selected_object)) {
          Unit u = (Unit)level.currMap.selected_object;
          if (u.map_key == this.number1) {
            this.met = true;
          }
        }
        break;
      case 3: // selected specific item
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (Item.class.isInstance(level.currMap.selected_object)) {
          Item i = (Item)level.currMap.selected_object;
          if (i.map_key == this.number1) {
            this.met = true;
          }
        }
        break;
      case 4: // selected unit
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (Unit.class.isInstance(level.currMap.selected_object)) {
          Unit u = (Unit)level.currMap.selected_object;
          if (u.ID == this.number1) {
            this.met = true;
          }
        }
        break;
      case 5: // selected item
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (Item.class.isInstance(level.currMap.selected_object)) {
          Item i = (Item)level.currMap.selected_object;
          if (i.ID == this.number1) {
            this.met = true;
          }
        }
        break;
      case 6: // player in rectangle
        if (this.met) {
          break;
        }
        if (level.respawning) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.currMapName == null) {
          break;
        }
        if (this.rectangle.contains(level.player, level.currMapName)) {
          this.met = true;
        }
        break;
      case 7: // unit exists
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number1)) {
          this.met = true;
        }
        break;
      case 8: // has hero upgrade
        if (this.met) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.player.heroTree.nodes.get(HeroTreeCode.codeFromId(this.number1)).unlocked) {
          this.met = true;
        }
        break;
      case 9: // unit in rectangle
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (!level.currMap.units.containsKey(this.number1)) {
          break;
        }
        if (this.rectangle.contains(level.currMap.units.get(this.number1), level.currMapName)) {
          this.met = true;
        }
        break;
      case 10: // unit health
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (!level.currMap.units.containsKey(this.number1)) {
          break;
        }
        if (level.currMap.units.get(this.number1).curr_health > this.number2) {
          this.met = true;
        }
        break;
      case 11: // holding item
        if (this.met) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.player.holding(this.number1)) {
          this.met = true;
        }
        break;
      case 12: // player hunger
        if (this.met) {
          break;
        }
        if (level.respawning) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.player.hunger > this.number1) {
          this.met = true;
        }
        break;
      case 13: // player thirst
        if (this.met) {
          break;
        }
        if (level.respawning) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.player.thirst > this.number1) {
          this.met = true;
        }
        break;
      case 14: // player mana
        if (this.met) {
          break;
        }
        if (level.respawning) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (level.player.curr_mana > this.number1) {
          this.met = true;
        }
        break;
      case 15: // time after
        if (this.met) {
          break;
        }
        if (level.time.value >= this.number1) {
          this.met = true;
        }
        break;
      case 16: // player respawning
        if (this.met) {
          break;
        }
        this.met = level.respawning;
        break;
      case 17: // item id in rectangle
        if (this.met) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        for (Item i : level.currMap.items.values()) {
          if (i.remove || i.ID != this.number1) {
            continue;
          }
          if (this.rectangle.contains(i, level.currMapName)) {
            this.met = true;
          }
        }
        break;
      default:
        global.errorMessage("ERROR: Condition ID " + ID + " not recognized.");
        return false;
    }
    if (this.not_condition) {
      this.met = !this.met;
    }
    return this.met;
  }

   public void reset() {
    this.met = false;
    switch(this.ID) {
      case 0: // nothing
        break;
      case 1: // timer
        this.number2 = this.number1;
        break;
      case 2: // selected specific unit
        break;
      case 3: // selected specific item
        break;
      case 4: // selected unit
        break;
      case 5: // selected item
        break;
      case 6: // player in rectangle
        break;
      case 7: // unit exists
        break;
      case 8: // has hero upgrade
        break;
      case 9: // unit in rectangle
        break;
      case 10: // unit health
        break;
      case 11: // holding item
        break;
      case 12: // player hunger
        break;
      case 13: // player thirst
        break;
      case 14: // player mana
        break;
      case 15: // time after
        break;
      case 16: // player respawning
        break;
      case 17: // item id in rectangle
        break;
      default:
        global.errorMessage("ERROR: Condition ID " + ID + " not recognized.");
        break;
    }
  }

   public String fileString() {
    String fileString = "\nnew: Condition";
    fileString += "\nID: " + this.ID;
    fileString += "\nnumber1: " + this.number1;
    fileString += "\nnumber2: " + this.number2;
    fileString += "\nrectangle: " + this.rectangle.fileString();
    fileString += "\nmet: " + this.met;
    fileString += "\nnot_condition: " + this.not_condition;
    fileString += "\nend: Condition\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "ID":
        this.setID(toInt(data));
        break;
      case "number1":
        this.number1 = toInt(data);
        break;
      case "number2":
        this.number2 = toInt(data);
        break;
      case "rectangle":
        this.rectangle.addData(data);
        break;
      case "met":
        this.met = toBoolean(data);
        break;
      case "not_condition":
        this.not_condition = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for Condition object.");
        break;
    }
  }
}




class Effect {
  private int ID = 0;
  private String display_name = "Effect";

  private String message = "";
  private int number = 0;
  private float decimal1 = 0;
  private float decimal2 = 0;
  private Rectangle rectangle = new Rectangle();

  Effect() {}

   public void setID(int ID) {
    this.ID = ID;
    switch(ID) {
      case 0: // nothing
      case 1: // console log
      case 2: // LNZ log
      case 3: // timestamp log
      case 4: // header messae
      case 5: // level chat
      case 6: // win level
      case 7: // activate trigger
      case 8: // deactivate trigger
      case 9: // add quest
      case 10: // remove quest
      case 11: // lose control
      case 12: // gain control
      case 13: // move view
      case 14: // tint map
      case 15: // stop tinting map
      case 16: // show blinking arrow
      case 17: // complete quest
      case 18: // add visual effect
      case 19: // move view to player
      case 20: // unit chats
      case 21: // stop unit
      case 22: // stop player
      case 23: // stop units in rectangle
      case 24: // move unit
      case 25: // move player
      case 26: // move units in rectangle
      case 27: // face unit
      case 28: // face player
      case 29: // face units in rectangle
      case 30: // teleport unit
      case 31: // teleport player
      case 32: // teleport units in rectangle
      case 33: // change player hunger
      case 34: // change player thirst
      case 35: // change player mana
      case 36: // set player hunger
      case 37: // set player thirst
      case 38: // set player mana
      case 39: // change unit health
      case 40: // set unit health
      case 41: // change time
      case 42: // set time
      case 43: // add item to player inventory
      case 44: // clear player inventory
      case 45: // create unit
      case 46: // clear level chat
      case 47: // grant hero tree upgrade
      case 48: // refresh cooldown on ability
      case 49: // change terrain in rectangle
      case 50: // add feature
      case 51: // remove features in rectangle
      case 52: // unlock achievement
      case 53: // give unit status effect
      case 54: // give player status effect
      case 55: // give units in rectangle status effect
      case 56: // explore rectangle
      case 57: // decision form
      case 58: // set background music
      case 59: // trigger sleeping
      case 60: // set background volume
      case 61: // trigger player sound
      case 62: // silence player sound
      case 63: // take bens eyes
      case 64: // equip item to unit
      case 65: // toggle unit ai_toggle
      case 66: // reset unit
        break;
      default:
        global.errorMessage("ERROR: Effect ID " + ID + " not recognized.");
        break;
    }
    this.setName();
  }

   public void setName() {
    switch(this.ID) {
      case 1: // console log
        this.display_name = "Console Log";
        break;
      case 2: // LNZ log
        this.display_name = "LNZ Log";
        break;
      case 3: // timestamp log
        this.display_name = "Timestamp Log";
        break;
      case 4: // header messae
        this.display_name = "Header Message (" + this.number + ")";
        break;
      case 5: // level chat
        this.display_name = "Level Chat";
        break;
      case 6: // win level
        this.display_name = "Win Level (" + this.number + ")";
        break;
      case 7: // activate trigger
        this.display_name = "Activate Trigger (" + this.number + ")";
        break;
      case 8: // deactivate trigger
        this.display_name = "Deactivate Trigger (" + this.number + ")";
        break;
      case 9: // add quest
        this.display_name = "Add Quest (" + this.number + ")";
        break;
      case 10: // remove quest
        this.display_name = "Remove Quest (" + this.number + ")";
        break;
      case 11: // lose control
        this.display_name = "Lose Control";
        break;
      case 12: // gain control
        this.display_name = "Gain Control";
        break;
      case 13: // move view
        this.display_name = "Move View";
        break;
      case 14: // tint map
        this.display_name = "Tint Map (" + this.number + ")";
        break;
      case 15: // stop tinting map
        this.display_name = "Remove Map Tint";
        break;
      case 16: // show blinking arrow
        this.display_name = "Blinking Arrow (" + this.number + ")";
        break;
      case 17: // complete quest
        this.display_name = "Complete Quest (" + this.number + ")";
        break;
      case 18: // add visual effect
        this.display_name = "Add Visual Effect (" + this.number + ")";
        break;
      case 19: // move view to player
        this.display_name = "Move View to Player";
        break;
      case 20: // unit chats
        this.display_name = "Unit Chats (" + this.number + ")";
        break;
      case 21: // stop unit
        this.display_name = "Stop Unit (" + this.number + ")";
        break;
      case 22: // stop player
        this.display_name = "Stop Player";
        break;
      case 23: // stop units in rectangle
        this.display_name = "Stop Units in Rectangle";
        break;
      case 24: // move unit
        this.display_name = "Move Unit (" + this.number + ")";
        break;
      case 25: // move player
        this.display_name = "Move Player";
        break;
      case 26: // move units rectangle
        this.display_name = "Move Units in Rectangle";
        break;
      case 27: // face unit
        this.display_name = "Face Unit (" + this.number + ")";
        break;
      case 28: // face player
        this.display_name = "Face Player";
        break;
      case 29: // face units in rectangle
        this.display_name = "Face Units in Rectangle";
        break;
      case 30: // teleport unit
        this.display_name = "Teleport Unit (" + this.number + ")";
        break;
      case 31: // teleport player
        this.display_name = "Teleport Player";
        break;
      case 32: // teleport units in rectangle
        this.display_name = "Teleport Units in Rectangle";
        break;
      case 33: // change player hunger
        this.display_name = "Change Player Hunger (" + this.number + ")";
        break;
      case 34: // change player thirst
        this.display_name = "Change Player Thirst (" + this.number + ")";
        break;
      case 35: // change player mana
        this.display_name = "Change Player Mana (" + this.number + ")";
        break;
      case 36: // set player hunger
        this.display_name = "Set Player Hunger (" + this.number + ")";
        break;
      case 37: // set player thirst
        this.display_name = "Set Player Thirst (" + this.number + ")";
        break;
      case 38: // set player mana
        this.display_name = "Set Player Mana (" + this.number + ")";
        break;
      case 39: // change unit health
        this.display_name = "Change Unit (" + this.number + ") Health (" + this.decimal1 + ")";
        break;
      case 40: // set unit health
        this.display_name = "Set Unit (" + this.number + ") Health (" + this.decimal1 + ")";
        break;
      case 41: // change time
        this.display_name = "Change Time (" + this.decimal1 + ")";
        break;
      case 42: // set time
        this.display_name = "Set Time (" + this.decimal1 + ")";
        break;
      case 43: // add item to player inventory
        this.display_name = "Add Item to Inventory (" + this.number + ")";
        break;
      case 44: // clear player inventory
        this.display_name = "Clear Player Inventory";
        break;
      case 45: // create unit
        this.display_name = "Create Unit (" + this.number + ")";
        break;
      case 46: // clear level chat
        this.display_name = "Clear Level Chat";
        break;
      case 47: // grant hero tree upgrade
        this.display_name = "Give Player Upgrade (" + HeroTreeCode.codeFromId(this.number) + ")";
        break;
      case 48: // refresh cooldown on ability
        this.display_name = "Refresh Ability (" + this.number + ")";
        break;
      case 49: // change terrain in rectangle
        this.display_name = "Change Terrain to (" + this.number + ")";
        break;
      case 50: // add feature
        this.display_name = "Add Feature (" + this.number + ")";
        break;
      case 51: // remove features in rectangle
        this.display_name = "Remove Features from rectangle";
        break;
      case 52: // unlock achievement
        this.display_name = "Unlock Achievement (" + this.number + ")";
        break;
      case 53: // give unit status effect
        this.display_name = "Give Unit (" + this.number + ") Status Effect " + this.message;
        break;
      case 54: // give player status effect
        this.display_name = "Give Player Status Effect " + this.message;
        break;
      case 55: // give units in rectangle status effect
        this.display_name = "Give Units in Rectangle Status Effect " + this.message;
        break;
      case 56: // explore rectangle
        this.display_name = "Explore Rectangle: " + this.rectangle.fileString();
        break;
      case 57: // decision form
        this.display_name = "Decision Form (" + this.number + ")";
        break;
      case 58: // set background music
        this.display_name = "Play Background Music (" + this.message + ")";
        break;
      case 59: // trigger sleeping
        this.display_name = "Trigger Sleeping";
        break;
      case 60: // set background volume
        if (this.number > 0) {
          this.display_name = "Set Background Volume (" + this.decimal1 + ")";
        }
        else {
          this.display_name = "Mute Background Volume";
        }
        break;
      case 61: // trigger player sound
        this.display_name = "Trigger Player Sound (" + this.message + ")";
        break;
      case 62: // silence player sound
        this.display_name = "Silence Player Sound (" + this.message + ")";
        break;
      case 63: // take bens eyes
        this.display_name = "Remove Ben's Eyes";
        break;
      case 64: // equip item to unit
        this.display_name = "Equip Item (" + round(this.decimal1) + ") to Unit (" + this.number + ")";
        break;
      case 65: // toggle ai toggle
        if (this.decimal1 > 0) {
          this.display_name = "AI Toggle (true) to Unit (" + this.number + ")";
        }
        else if (this.decimal1 < 0) {
          this.display_name = "AI Toggle (false) to Unit (" + this.number + ")";
        }
        else {
          this.display_name = "AI Toggle (toggle) to Unit (" + this.number + ")";
        }
        break;
      case 66: // reset unit
        this.display_name = "Reset Unit (" + this.number + ")";
        break;
      default:
        this.display_name = "Effect";
        break;
    }
  }

   public void actuate(Level level) {
    StatusEffectCode code = null;
    switch(this.ID) {
      case 0: // nothing
        break;
      case 1: // console log
        println(this.message);
        break;
      case 2: // LNZ log
        global.log(this.message);
        break;
      case 3: // Timestamp log
        global.log(millis() + this.message);
        break;
      case 4: // header message
        if (level.currMap != null) {
          level.currMap.addHeaderMessage(this.message, this.number);
        }
        break;
      case 5: // level chat
        level.chat(this.message);
        break;
      case 6: // win level
        level.complete(this.number);
        break;
      case 7: // activate trigger
        if (level.triggers.containsKey(this.number)) {
          level.triggers.get(this.number).active = true;
        }
        break;
      case 8: // deactivate trigger
        if (level.triggers.containsKey(this.number)) {
          level.triggers.get(this.number).active = false;
        }
        break;
      case 9: // add quest
        level.addQuest(this.number);
        break;
      case 10: // remove quest
        level.removeQuest(this.number);
        break;
      case 11: // Lose control
        level.loseControl();
        break;
      case 12: // gain control
        level.gainControl();
        break;
      case 13: // move view
        if (level.currMap != null) {
          level.currMap.setViewLocation(this.rectangle.centerX(), this.rectangle.centerY());
        }
        break;
      case 14: // tint map
        if (level.currMap != null) {
          level.currMap.show_tint = true;
          if (this.number == 0) { // default to brown with transparency 100
            level.currMap.color_tint = 1681075482;
          }
          else {
            level.currMap.color_tint = this.number;
          }
        }
        break;
      case 15: // stop tinting map
        if (level.currMap != null) {
          level.currMap.show_tint = false;
        }
        break;
      case 16: // show blinking arrow
        int frame = PApplet.parseInt(floor(Constants.gif_arrow_frames * (PApplet.parseFloat(millis() %
          Constants.gif_arrow_time) / (1 + Constants.gif_arrow_time))));
        float translate_x = 0;
        switch(this.number) {
          case 1: // toward buttons
            translate_x = level.xf - 80;
            translate(translate_x, 0.9f * height);
            rotate(0.1f * PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-0.1f * PI);
            translate(-translate_x, -0.9f * height);
            break;
          case 2: // panel collapse buttons
            translate_x = level.xf - 80;
            translate(translate_x, 0.05f * height);
            rotate(-0.2f * PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(0.2f * PI);
            translate(-translate_x, -0.05f * height);
            translate_x = level.xi + 80;
            translate(translate_x, 0.05f * height);
            rotate(-0.8f * PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(0.8f * PI);
            translate(-translate_x, -0.05f * height);
            break;
          case 3: // inventory bar
            translate_x = 0.5f * width;
            float translate_y = level.player.inventory_bar.yi - 70;
            translate(translate_x, translate_y);
            rotate(0.5f * PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-0.5f * PI);
            translate(-translate_x, -translate_y);
            break;
          case 4: // player left panel form
            translate_x = level.xi + 65;
            translate(translate_x, 0.55f * height);
            rotate(PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-PI);
            translate(-translate_x, -0.55f * height);
            break;
          case 5: // chatbox
            translate_x = level.xf - 65;
            translate(translate_x, 0.3f * height);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            translate(-translate_x, -0.3f * height);
            break;
          case 6: // questbox
            translate_x = level.xf - 65;
            translate(translate_x, 0.08f * height);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            translate(-translate_x, -0.08f * height);
            break;
          case 7: // selected object
            translate_x = level.xi + 65;
            translate(translate_x, 0.1f * height);
            rotate(PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-PI);
            translate(-translate_x, -0.1f * height);
            break;
          case 8: // move toward arrow
            translate_x = 0.5f * width;
            translate(translate_x, 0.5f * height + 300);
            rotate(0.5f * PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-0.5f * PI);
            translate(-translate_x, -0.5f * height - 300);
            break;
          case 9: // xp/level
            translate_x = level.xi + 65;
            translate(translate_x, 0.65f * height);
            rotate(PI);
            imageMode(CENTER);
            image(global.images.getImage("gifs/arrow/" + frame + ".png"), 0, 0, 130, 130);
            rotate(-PI);
            translate(-translate_x, -0.65f * height);
            break;
          default:
            global.errorMessage("ERROR: Blinking arrow ID " + this.number + " not recognized.");
            break;
        }
        break;
      case 17: // complete quest
        if (level.player == null) {
          break;
        }
        if (level.quests.containsKey(this.number)) {
          level.quests.get(this.number).meet(level.player);
        }
        break;
      case 18: // add visual effect
        if (level.currMap != null) {
          level.currMap.addVisualEffect(this.number, this.rectangle.centerX(), this.rectangle.centerY());
        }
        break;
      case 19: // move view to player
        if (level.currMap != null) {
          if (level.player != null) {
            level.currMap.setViewLocation(level.player.x, level.player.y);
          }
        }
        break;
      case 20: // unit chats
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.chat(level.currMap.units.get(this.number).display_name() + ": " + this.message);
          level.currMap.addVisualEffect(4009, level.currMap.units.get(this.number).x + 0.6f, level.currMap.units.get(this.number).y - 0.4f);
          level.currMap.selected_object = level.currMap.units.get(this.number);
        }
        break;
      case 21: // stop unit
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).stopAction();
        }
        break;
      case 22: // stop player
        if (level.player != null) {
          level.player.stopAction();
        }
        break;
      case 23: // stop units in rectangle
        if (level.currMap == null) {
          break;
        }
        for (Map.Entry<Integer, Unit> entry : level.currMap.units.entrySet()) {
          if (this.rectangle.contains(entry.getValue())) {
            entry.getValue().stopAction();
          }
        }
        break;
      case 24: // move unit
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).moveTo(this.rectangle.centerX(), this.rectangle.centerY(), level.currMap);
        }
        break;
      case 25: // move player
        if (level.currMap == null) {
          break;
        }
        if (level.player != null) {
          level.player.moveTo(this.rectangle.centerX(), this.rectangle.centerY(), level.currMap);
        }
        break;
      case 26: // move units in rectangle
        if (level.currMap == null) {
          break;
        }
        for (Map.Entry<Integer, Unit> entry : level.currMap.units.entrySet()) {
          if (this.rectangle.contains(entry.getValue())) {
            entry.getValue().moveTo(this.decimal1, this.decimal2, level.currMap);
          }
        }
        break;
      case 27: // face unit
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).turnTo(PI * this.decimal1 / 180.0f);
        }
        break;
      case 28: // face player
        if (level.player != null) {
          level.player.turnTo(PI * this.decimal1 / 180.0f);
        }
        break;
      case 29: // face units in rectangle
        if (level.currMap == null) {
          break;
        }
        for (Map.Entry<Integer, Unit> entry : level.currMap.units.entrySet()) {
          if (this.rectangle.contains(entry.getValue())) {
            entry.getValue().turnTo(PI * this.decimal1 / 180.0f);
          }
        }
        break;
      case 30: // teleport unit
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).setLocation(this.rectangle.centerX(), this.rectangle.centerY());
        }
        break;
      case 31: // teleport player
        if (level.player != null) {
          level.player.setLocation(this.rectangle.centerX(), this.rectangle.centerY());
        }
        break;
      case 32: // teleport units in rectangle
        if (level.currMap == null) {
          break;
        }
        for (Map.Entry<Integer, Unit> entry : level.currMap.units.entrySet()) {
          if (this.rectangle.contains(entry.getValue())) {
            entry.getValue().setLocation(this.decimal1, this.decimal2);
          }
        }
        break;
      case 33: // change player hunger
        if (level.player != null) {
          level.player.changeHunger(this.number);
        }
        break;
      case 34: // change player thirst
        if (level.player != null) {
          level.player.changeThirst(this.number);
        }
        break;
      case 35: // change player mana
        if (level.player != null) {
          level.player.changeMana(this.number);
        }
        break;
      case 36: // set player hunger
        if (level.player != null) {
          level.player.setHunger(this.number);
        }
        break;
      case 37: // set player thirst
        if (level.player != null) {
          level.player.setThirst(this.number);
        }
        break;
      case 38: // set player mana
        if (level.player != null) {
          level.player.setMana(this.number);
        }
        break;
      case 39: // change unit health
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).changeHealth(this.decimal1);
        }
        break;
      case 40: // set unit health
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).setHealth(this.decimal1);
        }
        break;
      case 41: // change time
        level.time.add(this.decimal1);
        break;
      case 42: // set time
        level.time.set(this.decimal1);
        break;
      case 43: // add item to player inventory
        if (level.player != null) {
          Item leftover = level.player.inventory.stash(new Item(this.number));
          if (leftover != null && !leftover.remove && level.currMap != null) {
            level.currMap.addItem(leftover, level.player.frontX(), level.player.frontY());
          }
        }
        break;
      case 44: // clear player inventory
        if (level.player != null) {
          level.player.inventory.clear();
        }
        break;
      case 45: // create unit
        if (level.currMap != null) {
          Unit u = new Unit(this.number, this.rectangle.centerX(), this.rectangle.centerY());
          if (this.decimal1 > 0) {
            level.currMap.addUnit(u, PApplet.parseInt(round(this.decimal1)));
          }
          else {
            level.currMap.addUnit(u);
          }
        }
        break;
      case 46: // clear level chat
        if (level.level_chatbox != null) {
          level.level_chatbox.clearText();
        }
        break;
      case 47: // grant hero tree upgrade
        if (level.player != null) {
          level.player.upgrade(HeroTreeCode.codeFromId(this.number));
        }
        break;
      case 48: // refresh cooldown on ability
        if (level.player == null) {
          break;
        }
        if (this.number < 0 || this.number >= level.player.abilities.size()) {
          break;
        }
        if (level.player.abilities.get(this.number) == null) {
          break;
        }
        level.player.abilities.get(this.number).timer_cooldown = 0;
        break;
      case 49: // change terrain in rectangle
        if (level.currMap == null) {
          break;
        }
        for (int i = PApplet.parseInt(round(this.rectangle.xi)); i < PApplet.parseInt(round(this.rectangle.xf)); i++) {
          for (int j = PApplet.parseInt(round(this.rectangle.yi)); j < PApplet.parseInt(round(this.rectangle.yf)); j++) {
            try {
              level.currMap.setTerrain(this.number, i, j, false);
            } catch(Exception e) {}
          }
        }
        level.currMap.refreshDisplayImages();
        break;
      case 50: // add feature
        if (level.currMap != null) {
          Feature f = new Feature(this.number, PApplet.parseInt(floor(this.rectangle.xi)), PApplet.parseInt(floor(this.rectangle.yi)));
          f.number = PApplet.parseInt(round(this.decimal1));
          level.currMap.addFeature(f);
        }
        break;
      case 51: // remove features in rectangle
        if (level.currMap != null) {
          for (Feature f : level.currMap.features()) {
            if (this.rectangle.contains(f)) {
              f.remove = true;
            }
          }
        }
        break;
      case 52: // unlock achievement
        global.profile.achievement(AchievementCode.achievementCode(this.number));
        break;
      case 53: // give unit status effect
        code = StatusEffectCode.code(this.message);
        if (code == null || code == StatusEffectCode.ERROR) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          if (this.decimal1 > 0) {
            level.currMap.units.get(this.number).refreshStatusEffect(code, this.decimal1);
          }
          else {
            level.currMap.units.get(this.number).addStatusEffect(code);
          }
        }
        break;
      case 54: // give player status effect
        code = StatusEffectCode.code(this.message);
        if (code == null || code == StatusEffectCode.ERROR) {
          break;
        }
        if (level.player == null) {
          break;
        }
        if (this.decimal1 > 0) {
          level.player.refreshStatusEffect(code, this.decimal1);
        }
        else {
          level.player.addStatusEffect(code);
        }
        break;
      case 55: // give units in rectangle status effect
        code = StatusEffectCode.code(this.message);
        if (code == null || code == StatusEffectCode.ERROR) {
          break;
        }
        if (level.currMap == null) {
          break;
        }
        for (Map.Entry<Integer, Unit> entry : level.currMap.units.entrySet()) {
          if (this.rectangle.contains(entry.getValue())) {
            if (this.decimal1 > 0) {
              entry.getValue().refreshStatusEffect(code, this.decimal1);
            }
            else {
              entry.getValue().addStatusEffect(code);
            }
          }
        }
        break;
      case 56: // explore rectangle
        if (level.currMap == null) {
          break;
        }
        if (!level.currMapName.equals(this.rectangle.mapName)) {
          break;
        }
        level.currMap.exploreRectangle(this.rectangle);
        break;
      case 57: // decision form
        level.decisionForm(this.number);
        break;
      case 58: // set background music
        global.sounds.play_background(this.message);
        level.album_name = this.message;
        break;
      case 59: // trigger sleeping
        level.sleeping = true;
        level.sleep_timer = Constants.feature_bedSleepTimer;
        level.loseControl();
        if (level.player != null) {
          level.player.stopAction();
        }
        break;
      case 60: // set background volume
        if (this.number > 0) {
          global.profile.options.volume_music = this.decimal1;
          global.profile.options.volume_music_muted = false;
        }
        else {
          global.profile.options.volume_music = this.decimal1;
          global.profile.options.volume_music_muted = true;
        }
        global.profile.options.change();
        break;
      case 61: // trigger player sound
        global.sounds.trigger_player(this.message);
        break;
      case 62: // silence player sound
        global.sounds.silence_player(this.message);
        break;
      case 63: // take bens eyes
        global.profile.ben_has_eyes = false;
        break;
      case 64: // equip item to unit
        if (level.currMap == null) {
          break;
        }
        Item i = new Item(round(this.decimal1));
        if (i == null || i.remove) {
          break;
        }
        if (level.currMap.units.containsKey(this.number)) {
          level.currMap.units.get(this.number).pickup(i);
        }
        break;
      case 65: // toggle ai toggle
        if (level.currMap == null) {
          break;
        }
        if (!level.currMap.units.containsKey(this.number)) {
          break;
        }
        if (this.decimal1 > 0) {
          level.currMap.units.get(this.number).ai_toggle = true;
        }
        else if (this.decimal1 < 0) {
          level.currMap.units.get(this.number).ai_toggle = false;
        }
        else {
          level.currMap.units.get(this.number).ai_toggle = !level.currMap.units.get(this.number).ai_toggle;
        }
        break;
      case 66: // reset unit
        if (level.currMap == null) {
          break;
        }
        if (!level.currMap.units.containsKey(this.number)) {
          break;
        }
        Unit u = level.currMap.units.get(this.number);
        u.statuses.clear();
        u.curr_health = u.health();
        u.stopAction();
        break;
      default:
        global.errorMessage("ERROR: Effect ID " + ID + " not recognized.");
        break;
    }
  }

   public String fileString() {
    String fileString = "\nnew: Effect";
    fileString += "\nID: " + this.ID;
    fileString += "\nmessage: " + this.message;
    fileString += "\nnumber: " + this.number;
    fileString += "\ndecimal1: " + this.decimal1;
    fileString += "\ndecimal2: " + this.decimal2;
    fileString += "\nrectangle: " + this.rectangle.fileString();
    fileString += "\nend: Effect\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    switch(datakey) {
      case "ID":
        this.setID(toInt(data));
        break;
      case "message":
        this.message = data;
        break;
      case "number":
        this.number = toInt(data);
        break;
      case "decimal1":
        this.decimal1 = toFloat(data);
        break;
      case "decimal2":
        this.decimal2 = toFloat(data);
        break;
      case "rectangle":
        this.rectangle.addData(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not recognized for Effect object.");
        break;
    }
  }
}
enum TutorialStatus {
  INITIAL, STARTING_NEW, LOADING_SAVED, PLAYING;
}


class TutorialInterface extends InterfaceLNZ {

  abstract class TutorialButton extends RectangleButton {
    TutorialButton() {
      super(0, 0.94f * height, 0, height - Constants.mapEditor_buttonGapSize);
      this.raised_border = true;
      this.roundness = 0;
      this.setColors(color(170), color(222, 184, 135), color(244, 164, 96), color(205, 133, 63), color(0));
      this.show_message = true;
    }
     public void hover() {
      global.sounds.trigger_interface("interfaces/buttonOn2");
    }
     public void dehover() {}
     public void click() {
      global.sounds.trigger_interface("interfaces/buttonClick1");
    }
  }

  class TutorialButton1 extends TutorialButton {
    TutorialButton1() {
      super();
      this.message = "Restart\nTutorial";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      TutorialInterface.this.form = new RestartTutorialForm();
    }
  }

  class TutorialButton2 extends TutorialButton {
    TutorialButton2() {
      super();
      this.message = "Options";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      TutorialInterface.this.form = new OptionsForm();
    }
  }

  class TutorialButton3 extends TutorialButton {
    TutorialButton3() {
      super();
      this.message = "Heroes";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      TutorialInterface.this.form = new HeroesForm();
    }
  }

  class TutorialButton4 extends TutorialButton {
    TutorialButton4() {
      super();
      this.message = "Main\nMenu";
    }
     public void release() {
      if (!this.hovered) {
        return;
      }
      this.stayDehovered();
      TutorialInterface.this.form = new GoToMainMenuForm();
    }
  }


  class GoToMainMenuForm extends ConfirmForm {
    GoToMainMenuForm() {
      super("Main Menu", "Are you sure you want to save and exit to the main menu?");
    }
     public void submit() {
      this.canceled = true;
      TutorialInterface.this.saveAndExitToMainMenu();
    }
  }

  class RestartTutorialForm extends ConfirmForm {
    RestartTutorialForm() {
      super("Restart Tutorial", "Are you sure you want to restart the tutorial? " +
        "Any current progress will be lost.");
    }
     public void submit() {
      this.canceled = true;
      TutorialInterface.this.startNewTutorial();
    }
  }


  class OpenNewTutorialThread extends Thread {
    private Level level;
    private String curr_status = "";

    OpenNewTutorialThread() {
      super("OpenNewTutorialThread");
    }

    @Override public 
    void run() {
      this.curr_status += "Creating New Tutorial";
      this.level = new Level("data/locations", Location.TUTORIAL);
      if (this.level.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nCopying Data";
      String destination_folder = "data/profiles/" + global.profile.display_name.toLowerCase() + "/locations/";
      if (!folderExists(destination_folder)) {
        mkdir(destination_folder);
      }
      deleteFolder(destination_folder + Location.TUTORIAL.file_name());
      copyFolder("data/locations/" + Location.TUTORIAL.file_name(),
        destination_folder + Location.TUTORIAL.file_name());
      this.level.folderPath = destination_folder;
      this.level.save();
      if (this.level.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nOpening Map";
      this.level.setPlayer(new Hero(HeroCode.BEN));
      if (this.level.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
    }
  }


  class OpenSavedTutorialThread extends Thread {
    private Level level;
    private String curr_status = "";

    OpenSavedTutorialThread() {
      super("OpenSavedTutorialThread");
    }

    @Override public 
    void run() {
      this.curr_status += "Opening Saved Tutorial";
      String destination_folder = "data/profiles/" + global.profile.display_name.toLowerCase() + "/locations/";
      this.level = new Level(destination_folder, Location.TUTORIAL);
      if (this.level.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nOpening Hero";
      Hero hero = readHeroFile(destination_folder + "tutorial/hero.lnz");
      if (!global.lastErrorMessage().equals("None")) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      this.curr_status += "\nOpening Map";
      this.level.openCurrMap();
      this.level.addPlayer(hero);
      if (this.level.nullify) {
        this.curr_status += " -> " + global.lastErrorMessage();
        delay(2500);
        return;
      }
      if (!global.images.loaded_map_gifs) {
        this.curr_status += "\nLoading Animations";
        global.images.loadMapGifs();
      }
    }
  }


  private TutorialButton[] buttons = new TutorialButton[4];
  private Panel leftPanel = new Panel(LEFT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);
  private Panel rightPanel = new Panel(RIGHT, Constants.mapEditor_panelMinWidth,
    Constants.mapEditor_panelMaxWidth, Constants.mapEditor_panelStartWidth);

  private TutorialStatus status = TutorialStatus.INITIAL;
  private Level tutorial = null;

  private OpenNewTutorialThread newTutorialThread = null;
  private OpenSavedTutorialThread savedTutorialThread = null;


  TutorialInterface() {
    this.buttons[0] = new TutorialButton1();
    this.buttons[1] = new TutorialButton2();
    this.buttons[2] = new TutorialButton3();
    this.buttons[3] = new TutorialButton4();
    this.leftPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.rightPanel.addIcon(global.images.getImage("icons/triangle_gray.png"));
    this.leftPanel.color_background = global.color_panelBackground;
    this.rightPanel.color_background = global.color_panelBackground;
    this.resizeButtons();
    this.checkTutorialSave();
  }


   public void resizeButtons() {
    float buttonSize = (this.rightPanel.size_curr - 5 * Constants.mapEditor_buttonGapSize) / 4.0f;
    float xi = width - this.rightPanel.size_curr + Constants.mapEditor_buttonGapSize;
    this.buttons[0].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[1].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[2].setXLocation(xi, xi + buttonSize);
    xi += buttonSize + Constants.mapEditor_buttonGapSize;
    this.buttons[3].setXLocation(xi, xi + buttonSize);
  }


   public void checkTutorialSave() {
    if (folderExists("data/profiles/" + global.profile.display_name.toLowerCase() +
      "/locations/" + Location.TUTORIAL.file_name())) {
      this.status = TutorialStatus.LOADING_SAVED;
      this.tutorial = null;
      this.savedTutorialThread = new OpenSavedTutorialThread();
      this.savedTutorialThread.start();
      return;
    }
    this.startNewTutorial();
  }

   public void startNewTutorial() {
    this.status = TutorialStatus.STARTING_NEW;
    this.tutorial = null;
    this.newTutorialThread = new OpenNewTutorialThread();
    this.newTutorialThread.start();
  }

   public void completedTutorial(int completion_code) {
    global.log("Completed tutorial with code " + completion_code + ".");
    switch(completion_code) {
      case 0: // default
        this.tutorial = null;
        deleteFolder(this.destination_folder() + Location.TUTORIAL.file_name());
        global.profile.achievement(AchievementCode.COMPLETED_TUTORIAL);
        this.saveAndExitToMainMenu();
        break;
      default:
        global.errorMessage("ERROR: Completion code " + completion_code + " not recognized for tutorial.");
        break;
    }
  }


   public Hero getCurrentHeroIfExists() {
    if (this.tutorial != null) {
      return this.tutorial.player;
    }
    return null;
  }

   public String destination_folder() {
    return ("data/profiles/" + global.profile.display_name.toLowerCase() + "/locations/");
  }

   public void saveTutorial() {
    if (this.tutorial == null) {
      return;
    }
    this.tutorial.save();
    if (this.tutorial.player == null) {
      return;
    }
    PrintWriter file = createWriter(this.destination_folder() + Location.TUTORIAL.file_name() + "/hero.lnz");
    file.println(this.tutorial.player.fileString());
    file.flush();
    file.close();
  }

   public void saveAndExitToMainMenu() {
    this.saveTutorial();
    this.tutorial = null;
    global.state = ProgramState.ENTERING_MAINMENU;
  }

   public void loseFocus() {
    if (this.tutorial != null) {
      this.tutorial.loseFocus();
    }
  }

   public void gainFocus() {
    if (this.tutorial != null) {
      this.tutorial.gainFocus();
    }
  }

   public void restartTimers() {
    if (this.tutorial != null) {
      this.tutorial.restartTimers();
    }
  }

   public void update(int millis) {
    boolean refreshLevelLocation = false;
    switch(this.status) {
      case INITIAL:
        rectMode(CORNERS);
        noStroke();
        fill(60);
        rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
        break;
      case STARTING_NEW:
        if (this.newTutorialThread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.newTutorialThread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.newTutorialThread.level == null || this.newTutorialThread.level.nullify) {
            this.tutorial = null;
            this.status = TutorialStatus.INITIAL;
          }
          else {
            this.tutorial = this.newTutorialThread.level;
            this.tutorial.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.tutorial.restartTimers();
            this.status = TutorialStatus.PLAYING;
            this.saveTutorial();
          }
          this.newTutorialThread = null;
          return;
        }
        break;
      case LOADING_SAVED:
        if (this.savedTutorialThread.isAlive()) {
          fill(global.color_mapBorder);
          noStroke();
          rectMode(CORNERS);
          rect(this.leftPanel.size, 0, width - this.rightPanel.size, height);
          fill(global.color_loadingScreenBackground);
          rect(this.leftPanel.size + Constants.map_borderSize, Constants.map_borderSize,
              width - this.rightPanel.size - Constants.map_borderSize, height - Constants.map_borderSize);
          fill(0);
          textSize(24);
          textAlign(LEFT, TOP);
          text(this.savedTutorialThread.curr_status + " ...", this.leftPanel.size +
            Constants.map_borderSize + 30, Constants.map_borderSize + 30);
          imageMode(CENTER);
          int frame = PApplet.parseInt(floor(Constants.gif_loading_frames * (PApplet.parseFloat(millis %
            Constants.gif_loading_time) / (1 + Constants.gif_loading_time))));
          image(global.images.getImage("gifs/loading/" + frame + ".png"), 0.5f * width, 0.5f * height, 250, 250);
        }
        else {
          if (this.savedTutorialThread.level == null || this.savedTutorialThread.level.nullify) {
            this.tutorial = null;
            this.status = TutorialStatus.INITIAL;
          }
          else {
            this.tutorial = this.savedTutorialThread.level;
            this.tutorial.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
            this.status = TutorialStatus.PLAYING;
          }
          this.savedTutorialThread = null;
          return;
        }
        break;
      case PLAYING:
        if (this.tutorial != null) {
          this.tutorial.update(millis);
          if (this.leftPanel.collapsing || this.rightPanel.collapsing) {
            refreshLevelLocation = true;
          }
          if (this.tutorial.completed) {
            this.completedTutorial(this.tutorial.completion_code);
          }
        }
        break;
      default:
        global.errorMessage("Tutorial status " + this.status + " not recognized.");
        break;
    }
    this.leftPanel.update(millis);
    this.rightPanel.update(millis);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (TutorialButton button : this.buttons) {
        button.update(millis);
      }
      if (this.tutorial != null) {
        this.tutorial.drawRightPanel(millis);
      }
    }
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.tutorial != null) {
        this.tutorial.drawLeftPanel(millis);
      }
    }
    if (refreshLevelLocation) {
      if (this.tutorial != null) {
        this.tutorial.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
  }

   public void showNerdStats() {
    if (this.tutorial != null) {
      this.tutorial.displayNerdStats();
    }
    else {
      fill(255);
      textSize(14);
      textAlign(LEFT, TOP);
      float y_stats = 1;
      float line_height = textAscent() + textDescent() + 2;
      text("FPS: " + PApplet.parseInt(global.lastFPS), 1, y_stats);
    }
  }

   public void mouseMove(float mX, float mY) {
    boolean refreshMapLocation = false;
    // level mouse move
    if (this.tutorial != null) {
      this.tutorial.mouseMove(mX, mY);
      if (this.leftPanel.clicked || this.rightPanel.clicked) {
        refreshMapLocation = true;
      }
    }
    // left panel mouse move
    this.leftPanel.mouseMove(mX, mY);
    if (this.leftPanel.open && !this.leftPanel.collapsing) {
      if (this.tutorial != null) {
        if (this.tutorial.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
      else if (this.tutorial != null) {
        if (this.tutorial.leftPanelElementsHovered()) {
          this.leftPanel.hovered = false;
        }
      }
    }
    // right panel mouse move
    this.rightPanel.mouseMove(mX, mY);
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (TutorialButton button : this.buttons) {
        button.mouseMove(mX, mY);
      }
    }
    // refresh map location
    if (refreshMapLocation) {
      if (this.tutorial != null) {
        this.tutorial.setLocation(this.leftPanel.size, 0, width - this.rightPanel.size, height);
      }
    }
    // cursor icon resolution
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      this.resizeButtons();
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png", "icons/cursor_resizeh.png");
    }
  }

   public void mousePress() {
    if (this.tutorial != null) {
      this.tutorial.mousePress();
    }
    this.leftPanel.mousePress();
    this.rightPanel.mousePress();
    if (this.leftPanel.clicked || this.rightPanel.clicked) {
      global.setCursor("icons/cursor_resizeh_white.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (TutorialButton button : this.buttons) {
        button.mousePress();
      }
    }
  }

   public void mouseRelease(float mX, float mY) {
    if (this.tutorial != null) {
      this.tutorial.mouseRelease(mX, mY);
    }
    this.leftPanel.mouseRelease(mX, mY);
    this.rightPanel.mouseRelease(mX, mY);
    if (this.leftPanel.hovered || this.rightPanel.hovered) {
      global.setCursor("icons/cursor_resizeh.png");
    }
    else {
      global.defaultCursor("icons/cursor_resizeh.png", "icons/cursor_resizeh_white.png");
    }
    if (this.rightPanel.open && !this.rightPanel.collapsing) {
      for (TutorialButton button : this.buttons) {
        button.mouseRelease(mX, mY);
      }
    }
  }

   public void scroll(int amount) {
    if (this.tutorial != null) {
      this.tutorial.scroll(amount);
    }
  }

   public void keyPress() {
    if (this.tutorial != null) {
      this.tutorial.keyPress();
    }
  }

   public void openEscForm() {
    this.form = new EscForm();
  }

   public void keyRelease() {
    if (this.tutorial != null) {
      this.tutorial.keyRelease();
    }
  }
}
enum UnitAction {
  NONE, MOVING, TARGETING_FEATURE, TARGETING_UNIT, TARGETING_ITEM, ATTACKING,
  SHOOTING, AIMING, USING_ITEM, FEATURE_INTERACTION, FEATURE_INTERACTION_WITH_ITEM,
  HERO_INTERACTING_WITH_FEATURE, TARGETING_FEATURE_WITH_ITEM,
  HERO_INTERACTING_WITH_FEATURE_WITH_ITEM, MOVING_AND_USING_ITEM, CASTING,
  CAST_WHEN_IN_RANGE,
  ;
}


enum MoveModifier {
  NONE, SNEAK, RECOIL,
  AMPHIBIOUS_LEAP, ANURAN_APPETITE;
}


enum DamageType {
  PHYSICAL, MAGICAL, MIXED, TRUE;
}


enum GearSlot {
  ERROR("Error"), WEAPON("Weapon"), HEAD("Head"), CHEST("Chest"), LEGS("Legs"),
    FEET("Feet"), OFFHAND("Offhand"), BELT_LEFT("Belt (left)"), BELT_RIGHT(
    "Belt (right)"), HAND_THIRD("Third Hand"), HAND_FOURTH("Fourth Hand"),
    FEET_SECOND("Feet (second pair)"), FEET_THIRD("Feet (third pair)");

  private static final List<GearSlot> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String slot_name;
  private GearSlot(String slot_name) {
    this.slot_name = slot_name;
  }
  public String slot_name() {
    return this.slot_name;
  }
  public static String slot_name(GearSlot slot) {
    return slot.slot_name();
  }

  public static GearSlot gearSlot(String slot_name) {
    for (GearSlot slot : GearSlot.VALUES) {
      if (slot == GearSlot.ERROR) {
        continue;
      }
      if (slot.slot_name().equals(slot_name)) {
        return slot;
      }
    }
    return GearSlot.ERROR;
  }
}


enum Alliance {
  NONE("None"), BEN("Ben"), ZOMBIE("Zombie");

  private static final List<Alliance> VALUES = Collections.unmodifiableList(Arrays.asList(values()));

  private String alliance_name;
  private Alliance(String alliance_name) {
    this.alliance_name = alliance_name;
  }
  public String alliance_name() {
    return this.alliance_name;
  }
  public static String alliance_name(Alliance alliance) {
    return alliance.alliance_name();
  }

  public static Alliance alliance(String alliance_name) {
    for (Alliance alliance : Alliance.VALUES) {
      if (alliance.alliance_name().equals(alliance_name)) {
        return alliance;
      }
    }
    return Alliance.NONE;
  }
}



class EditUnitForm extends EditMapObjectForm {
  protected Unit unit;

  EditUnitForm(Unit unit) {
    super(unit);
    this.unit = unit;
    this.addField(new FloatFormField("Base Health: ", "base health", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Attack: ", "base attack", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Magic: ", "base magic", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Defense: ", "base defense", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Resistance: ", "base resistance", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Piercing: ", "base piercing", 0, 1));
    this.addField(new FloatFormField("Base Penetration: ", "base penetration", 0, 1));
    this.addField(new FloatFormField("Base Attack Range: ", "base attack range", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Sight: ", "base sight", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Speed: ", "base speed", 0, Float.MAX_VALUE - 1));
    this.addField(new FloatFormField("Base Tenacity: ", "base tenacity", 0, 1));
    this.addField(new IntegerFormField("Base Agility: ", "base agility", 0, 10));
    this.addField(new CheckboxFormField("AI Toggle:  "));
    this.addField(new SubmitFormField("Finished", false));
    this.updateForm();
  }

   public void updateObject() {
    this.unit.base_health = toFloat(this.fields.get(1).getValue());
    this.unit.base_attack = toFloat(this.fields.get(2).getValue());
    this.unit.base_magic = toFloat(this.fields.get(3).getValue());
    this.unit.base_defense = toFloat(this.fields.get(4).getValue());
    this.unit.base_resistance = toFloat(this.fields.get(5).getValue());
    this.unit.base_piercing = toFloat(this.fields.get(6).getValue());
    this.unit.base_penetration = toFloat(this.fields.get(7).getValue());
    this.unit.base_attackRange = toFloat(this.fields.get(8).getValue());
    this.unit.base_sight = toFloat(this.fields.get(9).getValue());
    this.unit.base_speed = toFloat(this.fields.get(10).getValue());
    this.unit.base_tenacity = toFloat(this.fields.get(11).getValue());
    this.unit.base_agility = toInt(this.fields.get(12).getValue());
    this.unit.ai_toggle = toBoolean(this.fields.get(13).getValue());
  }

   public void updateForm() {
    this.fields.get(1).setValueIfNotFocused(Float.toString(this.unit.base_health));
    this.fields.get(2).setValueIfNotFocused(Float.toString(this.unit.base_attack));
    this.fields.get(3).setValueIfNotFocused(Float.toString(this.unit.base_magic));
    this.fields.get(4).setValueIfNotFocused(Float.toString(this.unit.base_defense));
    this.fields.get(5).setValueIfNotFocused(Float.toString(this.unit.base_resistance));
    this.fields.get(6).setValueIfNotFocused(Float.toString(this.unit.base_piercing));
    this.fields.get(7).setValueIfNotFocused(Float.toString(this.unit.base_penetration));
    this.fields.get(8).setValueIfNotFocused(Float.toString(this.unit.base_attackRange));
    this.fields.get(9).setValueIfNotFocused(Float.toString(this.unit.base_sight));
    this.fields.get(10).setValueIfNotFocused(Float.toString(this.unit.base_speed));
    this.fields.get(11).setValueIfNotFocused(Float.toString(this.unit.base_tenacity));
    this.fields.get(12).setValueIfNotFocused(Integer.toString(this.unit.base_agility));
    this.fields.get(13).setValueIfNotFocused(Boolean.toString(this.unit.ai_toggle));
  }
}



class Unit extends MapObject {
  class PathFindingThread extends Thread {
    class CoordinateValues {
      private int source_height = 0;
      private boolean corner_square = false;
      private int source_x = 0;
      private int source_y = 0;
      private float distance = 0;
      CoordinateValues(int source_height, boolean corner_square, IntegerCoordinate coordinate, float distance) {
        this.source_height = source_height;
        this.corner_square = corner_square;
        this.source_x = coordinate.x;
        this.source_y = coordinate.y;
        this.distance = distance;
      }
      CoordinateValues(CoordinateValues coordinate_values) {
        this.source_height = coordinate_values.source_height;
        this.corner_square = coordinate_values.corner_square;
        this.source_x = coordinate_values.source_x;
        this.source_y = coordinate_values.source_y;
        this.distance = coordinate_values.distance;
      }
    }

    private float goal_x = 0;
    private float goal_y = 0;
    private AbstractGameMap map = null;
    private Stack<FloatCoordinate> move_stack = new Stack<FloatCoordinate>();
    private boolean stop_thread = false;

    PathFindingThread(float goal_x, float goal_y, AbstractGameMap map) {
      super("PathFindingThread");
      this.goal_x = goal_x;
      this.goal_y = goal_y;
      this.map = map;
    }

     public HashMap<IntegerCoordinate, CoordinateValues> next_coordinates(HashMap<IntegerCoordinate, Float> last_coordinates, AbstractGameMap map) {
      HashMap<IntegerCoordinate, CoordinateValues> next_coordinates = new HashMap<IntegerCoordinate, CoordinateValues>();
      for (Map.Entry<IntegerCoordinate, Float> entry : last_coordinates.entrySet()) {
        int source_height = map.heightOfSquare(entry.getKey(), true);
        for (IntegerCoordinate adjacent : entry.getKey().adjacentCoordinates()) {
          if (next_coordinates.containsKey(adjacent) && next_coordinates.get(
            adjacent).distance <= entry.getValue() + 1) {
            continue;
          }
          next_coordinates.put(adjacent, new CoordinateValues(source_height, false,
            entry.getKey(), entry.getValue() + 1));
        }
        for (IntegerCoordinate corner : entry.getKey().cornerCoordinates()) {
          if (next_coordinates.containsKey(corner) && next_coordinates.get(
            corner).distance <= entry.getValue() + Constants.root_two) {
            continue;
          }
          next_coordinates.put(corner, new CoordinateValues(source_height, true,
            entry.getKey(), entry.getValue() + Constants.root_two));
        }
      }
      return next_coordinates;
    }

    @Override public 
    void run() {
      if (this.map == null) {
        return;
      }
      int unit_max_height = Unit.this.curr_height + Unit.this.walkHeight();
      ArrayList<IntegerCoordinate> unit_squares_on = Unit.this.getSquaresOn();
      float unit_current_x = Unit.this.x;
      float unit_current_y = Unit.this.y;
      HashMap<IntegerCoordinate, CoordinateValues> coordinates = new HashMap<IntegerCoordinate, CoordinateValues>(); // value is distance
      IntegerCoordinate goal = new IntegerCoordinate(PApplet.parseInt(this.goal_x), PApplet.parseInt(this.goal_y));
      IntegerCoordinate current = new IntegerCoordinate(PApplet.parseInt(Unit.this.x), PApplet.parseInt(Unit.this.y));
      if (current.equals(goal)) {
        return;
      }
      coordinates.put(current, new CoordinateValues(Unit.this.curr_height, true, current, 0));
      HashMap<IntegerCoordinate, Float> last_coordinates = new HashMap<IntegerCoordinate, Float>();
      last_coordinates.put(current, 0.0f);
      float last_distance = 0;
      maploop:
      while(true) {
        if (this.stop_thread) {
          return;
        }
        boolean break_map_loop = false;
        HashMap<IntegerCoordinate, CoordinateValues> current_coordinates = this.next_coordinates(last_coordinates, map);
        last_coordinates.clear();
        boolean all_dead_ends = true;
        ArrayList<IntegerCoordinate> current_coordinates_keys = new ArrayList<IntegerCoordinate>(current_coordinates.keySet());
        Collections.shuffle(current_coordinates_keys);
        for (IntegerCoordinate coordinate : current_coordinates_keys) {
          if (!map.containsMapSquare(coordinate)) {
            continue;
          }
          int max_height = current_coordinates.get(coordinate).source_height + Unit.this.walkHeight();
          int coordinate_height = map.heightOfSquare(coordinate, true);
          if (coordinate_height > max_height) {
            continue;
          }
          if (current_coordinates.get(coordinate).corner_square) {
            coordinate_height = map.heightOfSquare(new IntegerCoordinate(
              current_coordinates.get(coordinate).source_x, coordinate.y), true);
            if (coordinate_height > max_height) {
              continue;
            }
            coordinate_height = map.heightOfSquare(new IntegerCoordinate(
              coordinate.x, current_coordinates.get(coordinate).source_y), true);
            if (coordinate_height > max_height) {
              continue;
            }
          }
          if (coordinates.containsKey(coordinate) && coordinates.get(
            coordinate).distance <= current_coordinates.get(coordinate).distance) {
            continue;
          }
          coordinates.put(coordinate, new CoordinateValues(current_coordinates.get(coordinate)));
          if (coordinate.equals(goal)) {
            last_distance = current_coordinates.get(coordinate).distance + 1;
            break_map_loop = true;
          }
          last_coordinates.put(coordinate, current_coordinates.get(coordinate).distance);
          all_dead_ends = false;
        }
        if (all_dead_ends) {
          return;
        }
        if (break_map_loop) {
          break maploop;
        }
      }
      boolean x_changed = false;
      boolean y_changed = false;
      boolean x_changed_last_turn = false;
      boolean y_changed_last_turn = false;
      boolean x_not_changed = false;
      boolean y_not_changed = false;
      boolean push_next_goal = false;
      boolean check_next_goal = false;
      int check_next_goal_x = 0;
      int check_next_goal_y = 0;
      if (!coordinates.containsKey(goal)) {
        global.errorMessage("ERROR: Coordinates missing original goal.");
        return;
      }
      pathloop:
      while(true) {
        if (this.stop_thread) {
          return;
        }
        x_not_changed = false;
        y_not_changed = false;
        if (!x_changed) {
          x_not_changed = true;
        }
        if (!y_changed) {
          y_not_changed = true;
        }
        IntegerCoordinate next_goal = null;
        List<IntegerCoordinate> adjacents;
        if (coordinates.get(goal).corner_square) {
          adjacents = Arrays.asList(goal.adjacentAndCornerCoordinates());
        }
        else {
          adjacents = Arrays.asList(goal.adjacentCoordinates());
        }
        Collections.shuffle(adjacents); // to allow random choosing of equivalent paths
        for (IntegerCoordinate adjacent : adjacents) {
          if (!coordinates.containsKey(adjacent)) {
            continue;
          }
          if (coordinates.get(adjacent).distance >= last_distance) {
            continue;
          }
          next_goal = adjacent;
          last_distance = coordinates.get(adjacent).distance;
        }
        if (next_goal == null) {
          global.errorMessage("ERROR: Found path but can't map it.");
          return;
        }
        if (check_next_goal) {
          check_next_goal = false;
          int max_height = coordinates.get(next_goal).source_height + Unit.this.walkHeight();
          if (next_goal.x != goal.x) {
            if (goal.y > check_next_goal_y) {
              int coordinate_height = map.heightOfSquare(next_goal.x, next_goal.y - 1, true);
              if (coordinate_height > max_height) {
                y_changed = true;
              }
            }
            else {
              int coordinate_height = map.heightOfSquare(next_goal.x, next_goal.y + 1, true);
              if (coordinate_height > max_height) {
                y_changed = true;
              }
            }
          }
          if (next_goal.y != goal.y) {
            if (goal.x > check_next_goal_x) {
              int coordinate_height = map.heightOfSquare(next_goal.x - 1, next_goal.y, true);
              if (coordinate_height > max_height) {
                x_changed = true;
              }
            }
            else {
              int coordinate_height = map.heightOfSquare(next_goal.x + 1, next_goal.y, true);
              if (coordinate_height > max_height) {
                x_changed = true;
              }
            }
          }
        }
        if (coordinates.get(goal).corner_square) {
          if (!coordinates.get(next_goal).corner_square) {
            check_next_goal = true;
            check_next_goal_x = goal.x;
            check_next_goal_y = goal.y;
          }
        }
        else {
          boolean keep_x_changed = false;
          boolean keep_y_changed = false;
          if (next_goal.x != goal.x) {
            x_changed = true;
            if (coordinates.get(next_goal).corner_square) {
              int max_height = coordinates.get(goal).source_height + Unit.this.walkHeight();
              if (next_goal.y > coordinates.get(next_goal).source_y) {
                int coordinate_height = map.heightOfSquare(goal.x, goal.y - 1, true);
                if (coordinate_height > max_height) {
                  push_next_goal = true;
                }
              }
              else {
                int coordinate_height = map.heightOfSquare(goal.x, goal.y + 1, true);
                if (coordinate_height > max_height) {
                  push_next_goal = true;
                }
              }
            }
            else if (y_changed_last_turn) {
              keep_x_changed = true; // zig zag
            }
          }
          if (next_goal.y != goal.y) {
            y_changed = true;
            if (coordinates.get(next_goal).corner_square) {
              int max_height = coordinates.get(goal).source_height + Unit.this.walkHeight();
              if (next_goal.x > coordinates.get(next_goal).source_x) {
                int coordinate_height = map.heightOfSquare(goal.x - 1, goal.y, true);
                if (coordinate_height > max_height) {
                  push_next_goal = true;
                }
              }
              else {
                int coordinate_height = map.heightOfSquare(goal.x + 1, goal.y, true);
                if (coordinate_height > max_height) {
                  push_next_goal = true;
                }
              }
            }
            else if (x_changed_last_turn) {
              keep_y_changed = true; // zig zag
            }
          }
          if (x_changed && x_not_changed) {
            x_changed_last_turn = true;
          }
          else {
            x_changed_last_turn = false;
          }
          if (y_changed && y_not_changed) {
            y_changed_last_turn = true;
          }
          else {
            y_changed_last_turn = false;
          }
          if (x_changed && y_changed) {
            if (!keep_x_changed) {
              x_changed = false;
            }
            if (!keep_y_changed) {
              y_changed = false;
            }
            this.move_stack.push(new FloatCoordinate(goal.x + 0.5f, goal.y + 0.5f));
          }
        }
        if (next_goal.equals(current)) {
          break pathloop;
        }
        goal = next_goal;
        if (push_next_goal) {
          push_next_goal = false;
          this.move_stack.push(new FloatCoordinate(goal.x + 0.5f, goal.y + 0.5f));
        }
      }
      float initial_goal_x = this.goal_x;
      float initial_goal_y = this.goal_y;
      if (!this.move_stack.empty()) {
        initial_goal_x = this.move_stack.peek().x;
        initial_goal_y = this.move_stack.peek().y;
      }
      float x_dif = initial_goal_x - unit_current_x;
      float y_dif = initial_goal_y - unit_current_y;
      float dif_distance = sqrt(x_dif * x_dif + y_dif * y_dif);
      if (abs(dif_distance) < 1 || Unit.this.size == 0) {
        return;
      }
      float x_multiplier = x_dif / dif_distance;
      float y_multiplier = y_dif / dif_distance;
      HashSet<IntegerCoordinate> new_squares_on = new HashSet<IntegerCoordinate>();
      int number_sets_to_check = 2;
      for (int n = 0; n < number_sets_to_check; n++) {
        unit_current_x += x_multiplier * Unit.this.size * 0.4f;
        unit_current_y += y_multiplier * Unit.this.size * 0.4f;
        for (int i = round(floor(unit_current_x - Unit.this.size)); i < round(ceil(unit_current_x + Unit.this.size)); i++) {
          for (int j = round(floor(unit_current_y - Unit.this.size)); j < round(ceil(unit_current_y + Unit.this.size)); j++) {
            IntegerCoordinate coordinate = new IntegerCoordinate(i, j);
            if (unit_squares_on.contains(coordinate)) {
              continue;
            }
            new_squares_on.add(coordinate);
          }
        }
      }
      for (IntegerCoordinate coordinate : new_squares_on) {
        int coordinate_height = map.heightOfSquare(coordinate.x, coordinate.y, true);
        if (coordinate_height > unit_max_height) {
          this.move_stack.push(new FloatCoordinate(current.x + 0.5f, current.y + 0.5f));
          break;
        }
      }
    }
  }


  protected float size = Constants.unit_defaultSize; // radius
  protected int sizeZ = Constants.unit_defaultHeight;

  protected int level = 0;
  protected Alliance alliance = Alliance.NONE;
  protected Element element = Element.GRAY;

  protected float facingX = 1;
  protected float facingY = 0;
  protected float facingA = 0; // angle in radians

  protected HashMap<GearSlot, Item> gear = new HashMap<GearSlot, Item>();
  protected ArrayList<Ability> abilities = new ArrayList<Ability>();
  protected ConcurrentHashMap<StatusEffectCode, StatusEffect> statuses = new ConcurrentHashMap<StatusEffectCode, StatusEffect>();

  protected float base_health = 1;
  protected float base_attack = 0;
  protected float base_magic = 0;
  protected float base_defense = 0;
  protected float base_resistance = 0;
  protected float base_piercing = 0; // percentage from 0 - 1
  protected float base_penetration = 0; // percentage from 0 - 1
  protected float base_attackRange = Constants.unit_defaultBaseAttackRange;
  protected float base_attackCooldown = Constants.unit_defaultBaseAttackCooldown;
  protected float base_attackTime = Constants.unit_defaultBaseAttackTime;
  protected float base_sight = Constants.unit_defaultSight;
  protected float base_speed = 0;
  protected float base_tenacity = 0; // percentage from 0 - 1
  protected int base_agility = 1;
  protected float base_lifesteal = 0; // percentage
  protected boolean save_base_stats = false; // toggle on if base stats manually changed

  protected float curr_health = 1;
  protected float timer_attackCooldown = 0;
  protected float timer_actionTime = 0;
  protected float timer_last_damage = 0;

  protected UnitAction curr_action = UnitAction.NONE;
  protected int curr_action_id = 0;
  protected boolean curr_action_unhaltable = false;
  protected boolean curr_action_unstoppable = false;
  protected float curr_action_x = 0;
  protected float curr_action_y = 0;
  protected Stack<FloatCoordinate> move_stack = new Stack<FloatCoordinate>();
  protected boolean using_current_move_stack = false;
  protected boolean waiting_for_pathfinding_thread = false;
  protected PathFindingThread pathfinding_thread = null;
  protected int timer_update_pathfinding = Constants.unit_update_pathfinding_timer;

  protected int map_key = -10;
  protected MapObject object_targeting = null;
  protected MapObject last_damage_from = null;
  protected float last_damage_amount = 0;
  protected float last_move_distance = 0;
  protected int buffer_cast = -1;
  protected boolean last_move_collision = false;
  protected boolean last_move_any_collision = false;
  protected float footgear_durability_distance = Constants.unit_footgearDurabilityDistance;

  protected ArrayList<IntegerCoordinate> curr_squares_on = new ArrayList<IntegerCoordinate>(); // squares unit is on
  protected ArrayList<IntegerCoordinate> curr_squares_sight = new ArrayList<IntegerCoordinate>(); // squares unit can see
  protected int unit_height = 0; // height of unit you are standing on
  protected int floor_height = 0; // height of ground
  protected boolean falling = false;
  protected int fall_amount = 0;
  protected float timer_falling = 0;
  protected int timer_resolve_floor_height = Constants.unit_timer_resolve_floor_height_cooldown;

  protected boolean ai_controlled = true;
  protected int timer_ai_action1 = 0;
  protected int timer_ai_action2 = 0;
  protected int timer_ai_action3 = 0;
  protected boolean ai_toggle = false;

  // graphics
  protected float random_number = random(100);
  protected int timer_talk = Constants.unit_timer_talk + PApplet.parseInt(random(Constants.unit_timer_talk));
  protected int timer_target_sound = 0;
  protected int timer_walk = Constants.unit_timer_walk;

  Unit(int ID) {
    this(ID, 0, 0);
  }
  Unit(int ID, float x, float y) {
    super(ID);
    this.setLocation(x, y);
    this.setUnitID(ID);
  }

   public void setUnitID(int ID) {
    this.ID = ID;
    switch(ID) {
      // Other
      case 1001:
        this.setStrings("Test Dummy", "", "");
        this.addStatusEffect(StatusEffectCode.UNKILLABLE);
        break;
      case 1002:
        this.setStrings("Chicken", "Gaia", "");
        this.baseStats(2.5f, 0, 0, 0, 1.4f);
        this.base_agility = 1;
        this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
        this.timer_ai_action2 = PApplet.parseInt(Constants.ai_chickenTimer2 + random(Constants.ai_chickenTimer2));
        this.setLevel(1);
        this.sizeZ = 2;
        break;
      case 1003:
        this.setStrings("Chick", "Gaia", "");
        this.baseStats(1.5f, 0, 0, 0, 1.1f);
        this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
        this.timer_ai_action2 = PApplet.parseInt(2 * Constants.ai_chickenTimer2 + 2 * random(Constants.ai_chickenTimer2));
        this.setLevel(0);
        this.size = 0.8f * Constants.unit_defaultSize;
        this.sizeZ = 1;
        break;
      case 1004:
        this.setStrings("Rankin", "Human", "");
        this.baseStats(8, 3, 2, 0, 3);
        this.setLevel(5);
        this.size = 0.45f;
        this.sizeZ = 6;
        break;
      case 1005:
        this.setStrings("Rooster", "Gaia", "");
        this.baseStats(2.8f, 1.2f, 0, 0, 1.4f);
        this.base_agility = 1;
        this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
        this.timer_ai_action2 = PApplet.parseInt(Constants.ai_chickenTimer2 + random(Constants.ai_chickenTimer2));
        this.setLevel(2);
        this.sizeZ = 2;
        break;
      case 1006:
        this.setStrings("Father Dom", "Human", "");
        this.baseStats(3.5f, 2, 0, 0, 2);
        this.magicStats(2, 4, 0.05f);
        this.alliance = Alliance.BEN;
        this.setLevel(3);
        this.sizeZ = 4;
        this.gearSlots("Weapon");
        this.pickup(new Item(2928));
        break;
      case 1007:
        this.setStrings("Michael Schmiesing", "Human", "The fat man himself!");
        this.baseStats(15, 4, 3, 0, 1.5f);
        this.alliance = Alliance.BEN;
        this.setLevel(7);
        this.gearSlots("Weapon");
        this.size = 0.55f;
        break;
      case 1008:
        this.setStrings("Molly Schmiesing", "Human", "");
        this.baseStats(9, 4, 1, 0, 1.7f);
        this.alliance = Alliance.BEN;
        this.setLevel(6);
        break;

      // Heroes
      case 1101:
        this.setStrings("Ben Nelson", "Hero", "");
        this.baseStats(4, 1, 0, 0, 1.7f);
        this.setLevel(0);
        this.base_agility = 1;
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        this.element = Element.GRAY;
        break;
      case 1102:
        this.setStrings("Dan Gray", "Hero", "");
        this.baseStats(4, 1, 0, 0, 1.8f);
        this.setLevel(0);
        this.base_agility = 2;
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        this.element = Element.BROWN;
        break;
      case 1103:
        this.setStrings("JIF", "Hero", "");
        this.baseStats(4, 1, 0, 0, 2);
        this.setLevel(0);
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        break;
      case 1104:
        this.setStrings("Mark Spinny", "Hero", "");
        this.baseStats(4, 1, 0, 0, 2);
        this.setLevel(0);
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        break;
      case 1105:
        this.setStrings("Mad Dog Mattus", "Hero", "");
        this.baseStats(4, 1, 0, 0, 2);
        this.setLevel(0);
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        break;
      case 1106:
        this.setStrings("Jeremiah", "Hero", "");
        this.baseStats(4, 1, 0, 0, 2);
        this.setLevel(0);
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        break;
      case 1131:
        this.setStrings("Michael Fischer", "Hero", "");
        this.baseStats(4, 1, 0, 0, 2);
        this.setLevel(0);
        this.gearSlots("Weapon", "Head", "Chest", "Legs", "Feet");
        this.alliance = Alliance.BEN;
        break;

      // Zombies
      case 1201:
        this.setStrings("Broken Sick Zombie", "Zombie", "");
        this.baseStats(1, 1, 0, 0, 0.3f);
        this.setLevel(1);
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.SICK);
        break;
      case 1202:
        this.setStrings("Broken Zombie", "Zombie", "");
        this.baseStats(2.2f, 1.3f, 0, 0, 0.3f);
        this.setLevel(2);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1203:
        this.setStrings("Sick Zombie", "Zombie", "");
        this.baseStats(3.5f, 2, 0, 0, 0.4f);
        this.setLevel(3);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.SICK);
        break;
      case 1204:
        this.setStrings("Lazy Hungry Zombie", "Zombie", "");
        this.baseStats(5, 3, 0.3f, 0, 0.5f);
        this.setLevel(4);
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.HUNGRY);
        break;
      case 1205:
        this.setStrings("Hungry Zombie", "Zombie", "");
        this.baseStats(7, 3.2f, 0.3f, 0, 0.8f);
        this.setLevel(5);
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.HUNGRY);
        break;
      case 1206:
        this.setStrings("Lazy Zombie", "Zombie", "");
        this.baseStats(9, 3.5f, 0.3f, 0, 0.6f);
        this.setLevel(6);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1207:
        this.setStrings("Confused Franny Zombie", "Zombie", "");
        this.baseStats(11, 4, 0.6f, 0, 0.9f);
        this.setLevel(7);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.CONFUSED);
        break;
      case 1208:
        this.setStrings("Confused Zombie", "Zombie", "");
        this.baseStats(14, 4.3f, 0.6f, 0, 1);
        this.setLevel(8);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        this.addStatusEffect(StatusEffectCode.CONFUSED);
        break;
      case 1209:
        this.setStrings("Franny Zombie", "Zombie", "");
        this.baseStats(17, 4.7f, 0.6f, 0, 1.1f);
        this.setLevel(9);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1210:
        this.setStrings("Intellectual Zombie", "Zombie", "");
        this.baseStats(20, 5, 1, 0, 1.2f);
        this.setLevel(10);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1291:
        this.setStrings("Zombie", "Zombie", "");
        this.baseStats(3, 1, 0, 0, 0.8f);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1292:
        this.setStrings("Running Zombie", "Zombie", "");
        this.baseStats(3, 1, 0, 0, 1);
        this.gearSlots("Weapon");
        this.addStatusEffect(StatusEffectCode.RUNNING);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1293:
        this.setStrings("Armored Zombie", "Zombie", "");
        this.baseStats(3, 1, 2, 0, 0.8f);
        this.gearSlots("Weapon");
        this.alliance = Alliance.ZOMBIE;
        break;

      // Named Zombies
      case 1301:
        this.setStrings("Duggy", "Zombie", "");
        this.baseStats(6, 2.5f, 0.2f, 0, 1);
        this.setLevel(1);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1302:
        this.setStrings("Jacob Sanchez", "Zombie", "");
        this.baseStats(8, 5, 0, 0, 1.5f);
        this.setLevel(2);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1303:
        this.setStrings("Mike Olenchuk", "Zombie", "");
        this.baseStats(15, 4, 1, 0, 0.9f);
        this.setLevel(3);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1304:
        this.setStrings("Grady Stuckman", "Zombie", "");
        this.baseStats(12, 5.5f, 0.4f, 0.05f, 1.7f);
        this.setLevel(4);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1305:
        this.setStrings("Ethan Pitney", "Zombie", "");
        this.baseStats(15, 7, 0.4f, 0, 1.3f);
        this.setLevel(5);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1306:
        this.setStrings("James Sarlo", "Zombie", "");
        this.baseStats(20, 8, 0.4f, 0.12f, 1.4f);
        this.setLevel(6);
        this.alliance = Alliance.ZOMBIE;
        break;
      case 1307:
        this.setStrings("Matt Hair", "Zombie", "");
        this.baseStats(25, 6.5f, 2.2f, 0.03f, 1.1f);
        this.setLevel(7);
        this.alliance = Alliance.ZOMBIE;
        this.gearSlots("Weapon");
        break;
      case 1308:
        this.setStrings("Nick Belt", "Zombie", "");
        this.baseStats(22, 10, 0.8f, 0.15f, 1.4f);
        this.setLevel(8);
        this.alliance = Alliance.ZOMBIE;
        this.base_attackRange = 1.2f * Constants.unit_defaultBaseAttackRange;
        break;
      case 1311:
        this.setStrings("Cathy Heck", "Zombie", "");
        this.baseStats(50, 7.5f, 1.6f, 0.1f, 0.6f);
        this.magicStats(10, 1.2f, 0.05f);
        this.base_lifesteal = 0.08f;
        this.abilities.add(new Ability(1001));
        this.abilities.add(new Ability(1002));
        this.abilities.add(new Ability(1003));
        this.setLevel(11);
        this.alliance = Alliance.ZOMBIE;
        this.timer_ai_action1 = round(3000 + random(3000));
        this.timer_ai_action2 = round(9000 + random(9000));
        this.timer_ai_action3 = round(15000 + random(15000));
        break;

      default:
        global.errorMessage("ERROR: Unit ID " + ID + " not found.");
        break;
    }
  }

   public String display_name() {
    return this.display_name;
  }
   public String display_name_editor() {
    return this.display_name() + " (" + this.map_key + ")";
  }
   public String type() {
    return this.type;
  }
   public String description() {
    return this.description;
  }
   public String selectedObjectTextboxText() {
    String text = "-- " + this.type() + " (level " + this.level + ") --";
    if (this.statuses.size() > 0) {
      text += "\n";
    }
    text += "\n\nHealth: " + round(ceil(this.curr_health)) + "/" + round(ceil(this.health()));
    float attack = this.attack();
    if (attack > 0) {
      text += "\nAttack: " + round(attack * 10.0f) / 10.0f;
    }
    float magic = this.magic();
    if (magic > 0) {
      text += "\nMagic: " + round(magic * 10.0f) / 10.0f;
    }
    float defense = this.defense();
    if (defense > 0) {
      text += "\nDefense: " + round(defense * 10.0f) / 10.0f;
    }
    float resistance = this.resistance();
    if (resistance > 0) {
      text += "\nResistance: " + round(resistance * 10.0f) / 10.0f;
    }
    float piercing = this.piercing();
    if (piercing > 0) {
      text += "\nPiercing: " + round(piercing * 100) + "%";
    }
    float penetration = this.penetration();
    if (penetration > 0) {
      text += "\nPenetration: " + round(penetration * 100) + "%";
    }
    text += "\nSpeed: " + round(this.speed() * 10.0f) / 10.0f;
    float tenacity = this.tenacity();
    if (tenacity > 0) {
      text += "\nTenacity: " + round(tenacity * 100) + "%";
    }
    int agility = this.agility();
    if (attack > 0) {
      text += "\nAgility: " + agility;
    }
    float lifesteal = this.lifesteal();
    if (lifesteal > 0) {
      text += "\nLifesteal: " + round(lifesteal * 100) + "%";
    }
    return text + "\n\n" + this.description();
  }

   public void baseStats(float health, float attack, float defense, float piercing, float speed) {
    this.base_health = health;
    this.curr_health = health;
    this.base_attack = attack;
    this.base_defense = defense;
    this.base_piercing = piercing;
    this.base_speed = speed;
  }

   public void magicStats(float magic, float resistance, float penetration) {
    this.base_magic = magic;
    this.base_resistance = resistance;
    this.base_penetration = penetration;
  }

   public void gearSlots(String ... strings) {
    for (String string : strings) {
      this.gear.put(GearSlot.gearSlot(string), null);
    }
  }

   public void setLocation(float x, float y) {
    this.x = x;
    this.y = y;
  }

   public float xi() {
    return this.x - this.size;
  }
   public float yi() {
    return this.y - this.size;
  }
   public float xf() {
    return this.x + this.size;
  }
   public float yf() {
    return this.y + this.size;
  }
   public float xCenter() {
    return this.x;
  }
   public float yCenter() {
    return this.y;
  }
   public float width() {
    return 2 * this.size;
  }
   public float height() {
    return 2 * this.size;
  }
   public float xRadius() {
    return this.size;
  }
   public float yRadius() {
    return this.size;
  }

   public PImage getImage() {
    String path = "units/";
    switch(this.ID) {
      case 1001:
        path += "default.png";
        break;
      case 1002:
        path += "chicken.png";
        break;
      case 1003:
        path += "chick.png";
        break;
      case 1004:
        path += "john_rankin.png";
        break;
      case 1005:
        path += "rooster.png";
        break;
      case 1006:
        path += "father_dom.png";
        break;
      case 1007:
        path += "mike_schmiesing.png";
        break;
      case 1008:
        path += "molly_schmiesing.png";
        break;
      case 1101:
        if (global.profile.ben_has_eyes) {
          path += "ben.png";
        }
        else {
          path += "ben_noeyes.png";
        }
        break;
      case 1102:
        path += "dan.png";
        break;
      case 1103:
        path += "jf.png";
        break;
      case 1104:
        path += "spinny.png";
        break;
      case 1105:
        path += "mattus.png";
        break;
      case 1106:
        path += "patrick.png";
        break;
      case 1131:
        path += "michael_fischer.png";
        break;
      case 1201:
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291:
        path += "zombie1.png";
        break;
      case 1292:
        path += "zombie2.png";
        break;
      case 1293:
        path += "zombie3.png";
        break;
      case 1301:
        path += "duggy_zombie.png";
        break;
      case 1302:
        path += "jacob_sanchez_zombie.png";
        break;
      case 1303:
        path += "mike_olenchuk_zombie.png";
        break;
      case 1304:
        path += "grady_stuckman_zombie.png";
        break;
      case 1305:
        path += "ethan_pitney_zombie.png";
        break;
      case 1306:
        path += "james_sarlo_zombie.png";
        break;
      case 1307:
        path += "matt_hair_zombie.png";
        break;
      case 1308:
        path += "nick_belt_zombie.png";
        break;
      case 1311:
        path += "cathy_heck_zombie.png";
        break;
      default:
        global.errorMessage("ERROR: Unit ID " + ID + " not found.");
        path += "default.png";
        break;
    }
    return global.images.getImage(path);
  }


   public boolean targetable(Unit u) {
    if (this.alliance == u.alliance) {
      return false;
    }
    return true;
  }


   public void setLevel(int level) {
    this.level = level;
    float level_constant = 0.5f * level * (level + 1);
    switch(this.ID) {
      case 1291: // Zombie
      case 1292: // Running Zombie
        this.base_health = 3 + 0.4f * level_constant;
        this.curr_health = this.health();
        this.base_attack = 1 + 0.1f * level_constant;
        this.base_defense = 0.012f * level_constant;
        break;
      case 1293: // Armored Zombie
        this.base_health = 3 + 0.4f * level_constant;
        this.curr_health = this.health();
        this.base_attack = 1 + 0.1f * level_constant;
        this.base_defense = 2 + 0.022f * level_constant;
        break;
      default:
        break;
    }
  }


   public Item weapon() {
    if (this.gear.containsKey(GearSlot.WEAPON)) {
      return this.gear.get(GearSlot.WEAPON);
    }
    return null;
  }

   public Item headgear() {
    if (this.gear.containsKey(GearSlot.HEAD)) {
      return this.gear.get(GearSlot.HEAD);
    }
    return null;
  }

   public Item chestgear() {
    if (this.gear.containsKey(GearSlot.CHEST)) {
      return this.gear.get(GearSlot.CHEST);
    }
    return null;
  }

   public Item leggear() {
    if (this.gear.containsKey(GearSlot.LEGS)) {
      return this.gear.get(GearSlot.LEGS);
    }
    return null;
  }

   public Item footgear() {
    if (this.gear.containsKey(GearSlot.FEET)) {
      return this.gear.get(GearSlot.FEET);
    }
    return null;
  }

   public Item offhand() {
    if (this.gear.containsKey(GearSlot.OFFHAND)) {
      return this.gear.get(GearSlot.OFFHAND);
    }
    return null;
  }


   public boolean canEquip(GearSlot slot) {
    if (this.gear.containsKey(slot) && this.gear.get(slot) == null) {
      return true;
    }
    return false;
  }

   public boolean canPickup() {
    return this.canEquip(GearSlot.WEAPON);
  }

   public void pickup(Item i) {
    this.gear.put(GearSlot.WEAPON, i);
  }

  // True if holding one of these items
   public boolean holding(int ... item_ids) {
    if (this.weapon() == null) {
      return false;
    }
    for (int item_id : item_ids) {
      if (this.weapon().ID == item_id) {
        return true;
      }
    }
    return false;
  }


   public float health() {
    float health = this.base_health;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      health += gear_entry.getValue().health;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      health += this.weapon().health;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return health;
  }

  // To make abilities array in Unit instead of Hero
   public float currMana() {
    return 0;
  }
   public float mana() {
    return 0;
  }
   public void increaseMana(int amount) {}
   public void decreaseMana(int amount) {}

   public float attack() {
    float attack = this.base_attack;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      attack += gear_entry.getValue().attack;
    }
    if (this.weapon() != null) {
      if (this.weapon().shootable()) {
        attack += this.weapon().shootAttack();
      }
      else {
        attack += this.weapon().attack;
      }
    }
    if (this.weak()) {
      attack *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      attack *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      attack *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      attack *= Constants.status_relaxed_multiplier;
    }
    if (this.nelsonGlare()) {
      attack *= Constants.ability_103_debuff;
    }
    if (this.nelsonGlareII()) {
      attack *= Constants.ability_108_debuff;
    }
    if (this.rageOfTheBen()) {
      attack *= Constants.ability_105_buffAmount;
    }
    if (this.rageOfTheBenII()) {
      attack *= Constants.ability_110_buffAmount;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return attack;
  }

   public float magic() {
    float magic = this.base_magic;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      magic += gear_entry.getValue().magic;
    }
    if (this.weapon() != null) {
      if (this.weapon().shootable()) {
        magic += this.weapon().shootMagic();
      }
      else {
        magic += this.weapon().magic;
      }
    }
    if (this.weak()) {
      magic *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      magic *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      magic *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      magic *= Constants.status_relaxed_multiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return magic;
  }

   public float power(float attack_ratio, float magic_ratio) {
    return this.attack() * attack_ratio + this.magic() * magic_ratio;
  }

   public float defense() {
    float defense = this.base_defense;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      defense += gear_entry.getValue().defense;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      defense += this.weapon().defense;
    }
    if (this.weak()) {
      defense *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      defense *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      defense *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      defense *= Constants.status_relaxed_multiplier;
    }
    if (this.sick()) {
      defense *= Constants.status_sick_defenseMultiplier;
    }
    if (this.diseased()) {
      defense *= Constants.status_diseased_defenseMultiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return defense;
  }

   public float resistance() {
    float resistance = this.base_resistance;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      resistance += gear_entry.getValue().resistance;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      resistance += this.weapon().resistance;
    }
    if (this.weak()) {
      resistance *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      resistance *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      resistance *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      resistance *= Constants.status_relaxed_multiplier;
    }
    if (this.sick()) {
      resistance *= Constants.status_sick_defenseMultiplier;
    }
    if (this.diseased()) {
      resistance *= Constants.status_diseased_defenseMultiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return resistance;
  }

   public float piercing() {
    float piercing = this.base_piercing;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      piercing += gear_entry.getValue().piercing;
    }
    if (this.weapon() != null) {
      if (this.weapon().shootable()) {
        piercing += this.weapon().shootPiercing();
      }
      else {
        piercing += this.weapon().piercing;
      }
    }
    if (this.weak()) {
      piercing *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      piercing *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      piercing *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      piercing *= Constants.status_relaxed_multiplier;
    }
    if (piercing > 1) {
      piercing = 1;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return piercing;
  }

   public float penetration() {
    float penetration = this.base_penetration;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      penetration += gear_entry.getValue().penetration;
    }
    if (this.weapon() != null) {
      if (this.weapon().shootable()) {
        penetration += this.weapon().shootPenetration();
      }
      else {
        penetration += this.weapon().penetration;
      }
    }
    if (this.weak()) {
      penetration *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      penetration *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      penetration *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      penetration *= Constants.status_relaxed_multiplier;
    }
    if (penetration > 1) {
      penetration = 1;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return penetration;
  }

   public float attackRange() {
    return this.attackRange(false);
  }
   public float attackRange(boolean forceMelee) {
    float attackRange = this.base_attackRange;
    if (this.weapon() != null && this.weapon().weapon()) {
      if (!forceMelee && this.weapon().shootable()) {
        attackRange = this.weapon().shootRange();
      }
      else {
        attackRange += this.weapon().attackRange;
      }
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return attackRange;
  }

   public float attackCooldown() {
    return this.attackCooldown(false);
  }
   public float attackCooldown(boolean forceMelee) {
    float attackCooldown = this.base_attackCooldown;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      attackCooldown += gear_entry.getValue().attackCooldown;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      if (!forceMelee && this.weapon().shootable()) {
        attackCooldown = this.weapon().shootCooldown();
      }
      else {
        attackCooldown += this.weapon().attackCooldown;
      }
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            attackCooldown *= (1 - Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus);
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            attackCooldown *= (1 - Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus);
          }
          else {
            attackCooldown *= (1 - Constants.ability_101_bonusAmount * this.currMana());
          }
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            attackCooldown *= (1 - Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus);
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            attackCooldown *= (1 - Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus);
          }
          else {
            attackCooldown *= (1 - Constants.ability_106_bonusAmount * this.currMana());
          }
          break;
        default:
          break;
      }
    }
    return attackCooldown;
  }

   public float attackTime() {
    return this.attackTime(false);
  }
   public float attackTime(boolean forceMelee) {
    float attackTime = this.base_attackTime;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      attackTime += gear_entry.getValue().attackTime;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      if (!forceMelee && this.weapon().shootable()) {
        attackTime = this.weapon().shootTime();
      }
      else {
        attackTime += this.weapon().attackTime;
      }
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            attackTime *= (1 - Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus);
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            attackTime *= (1 - Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus);
          }
          else {
            attackTime *= (1 - Constants.ability_101_bonusAmount * this.currMana());
          }
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            attackTime *= (1 - Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus);
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            attackTime *= (1 - Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus);
          }
          else {
            attackTime *= (1 - Constants.ability_106_bonusAmount * this.currMana());
          }
          break;
        default:
          break;
      }
    }
    return attackTime;
  }

   public float sight() {
    float sight = this.base_sight;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      sight += gear_entry.getValue().sight;
    }
    if (this.weapon() != null) {
      sight += this.weapon().sight;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return sight;
  }

   public float speed() {
    float speed = this.base_speed;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      speed += gear_entry.getValue().speed;
    }
    if (this.weapon() != null) {
      speed += this.weapon().speedWhenHolding();
    }
    if (this.chilled()) {
      if (this.element == Element.CYAN) {
        speed *= Constants.status_chilled_speedMultiplierCyan;
      }
      else {
        speed *= Constants.status_chilled_speedMultiplier;
      }
    }
    if (this.frozen()) {
      return 0;
    }
    if (this.nelsonGlare()) {
      speed *= Constants.ability_103_debuff;
    }
    if (this.nelsonGlareII()) {
      speed *= Constants.ability_108_debuff;
    }
    if (this.senselessGrit()) {
      if (this.curr_action == UnitAction.TARGETING_UNIT) {
        speed *= Constants.ability_104_speedBuff;
      }
    }
    if (this.senselessGritII()) {
      if (this.curr_action == UnitAction.TARGETING_UNIT) {
        speed *= Constants.ability_109_speedBuff;
      }
    }
    if (this.tongueLash()) {
      speed *= Constants.ability_112_slowAmount;
    }
    if (this.running()) {
      speed *= Constants.status_running_multiplier;
    }
    if (this.slowed()) {
      speed *= Constants.status_slowed_multiplier;
    }
    if (this.relaxed()) {
      speed *= Constants.status_relaxed_multiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return speed;
  }

   public float tenacity() {
    float tenacity = this.base_tenacity;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      tenacity += gear_entry.getValue().tenacity;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      tenacity += this.weapon().tenacity;
    }
    if (this.weak()) {
      tenacity *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      tenacity *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      tenacity *= Constants.status_withered_multiplier;
    }
    if (this.relaxed()) {
      tenacity *= Constants.status_relaxed_multiplier;
    }
    if (this.sick()) {
      tenacity *= Constants.status_sick_defenseMultiplier;
    }
    if (this.diseased()) {
      tenacity *= Constants.status_diseased_defenseMultiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            tenacity += Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus;
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            tenacity += Constants.ability_101_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus;
          }
          else {
            tenacity += Constants.ability_101_bonusAmount * this.currMana();
          }
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBen() && this.currMana() == this.mana()) {
            tenacity += Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_105_fullRageBonus;
          }
          if (this.rageOfTheBenII() && this.currMana() == this.mana()) {
            tenacity += Constants.ability_106_bonusAmount * this.currMana() * Constants.ability_110_fullRageBonus;
          }
          else {
            tenacity += Constants.ability_106_bonusAmount * this.currMana();
          }
          break;
        default:
          break;
      }
    }
    if (tenacity > 1) {
      tenacity = 1;
    }
    return tenacity;
  }

   public int agility() {
    int agility = this.base_agility;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      agility += gear_entry.getValue().agility;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      agility += this.weapon().agility;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    if (agility < 0) {
      agility = 0;
    }
    if (agility > Constants.unit_maxAgility) {
      agility = Constants.unit_maxAgility;
    }
    return agility;
  }

   public float lifesteal() {
    float lifesteal = this.base_lifesteal;
    for (Map.Entry<GearSlot, Item> gear_entry : this.gear.entrySet()) {
      if (gear_entry.getKey() == GearSlot.WEAPON) {
        continue;
      }
      if (gear_entry.getValue() == null) {
        continue;
      }
      lifesteal += gear_entry.getValue().lifesteal;
    }
    if (this.weapon() != null && this.weapon().weapon()) {
      lifesteal += this.weapon().lifesteal;
    }
    if (this.weak()) {
      lifesteal *= Constants.status_weak_multiplier;
    }
    if (this.wilted()) {
      lifesteal *= Constants.status_wilted_multiplier;
    }
    if (this.withered()) {
      lifesteal *= Constants.status_withered_multiplier;
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        default:
          break;
      }
    }
    return lifesteal;
  }

   public int swimNumber() {
    int swimNumber = 0;
    if (this.element == Element.BLUE) {
      swimNumber += 2;
    }
    return swimNumber;
  }

   public float passiveHeal() {
    float passive_heal = 0;
    if (Hero.class.isInstance(this)) {
      passive_heal += Constants.hero_passiveHealPercent;
    }
    if (this.relaxed()) {
      passive_heal += Constants.status_relaxed_healMultiplier;
    }
    return passive_heal;
  }


   public void removeStatusEffect(StatusEffectCode code) {
    this.statuses.remove(code);
  }

   public void addStatusEffect(StatusEffectCode code) {
    if (this.statuses.containsKey(code)) {
      this.statuses.get(code).permanent = true;
    }
    else {
      this.statuses.put(code, new StatusEffect(code, true));
    }
  }
   public float calculateTimerFrom(StatusEffectCode code, float timer) {
    if (code == StatusEffectCode.SUPPRESSED) {
      return timer;
    }
    if (code.negative()) {
      timer *= this.element.resistanceFactorTo(code.element());
      timer *= 1 - this.tenacity();
    }
    return timer;
  }
   public void addStatusEffect(StatusEffectCode code, float timer) {
    timer = this.calculateTimerFrom(code, timer);
    if (this.statuses.containsKey(code)) {
      if (!this.statuses.get(code).permanent) {
        this.statuses.get(code).addTime(timer);
      }
    }
    else {
      this.statuses.put(code, new StatusEffect(code, timer));
      this.effectFromNewNegativeStatusEffect();
    }
  }
   public void refreshStatusEffect(StatusEffectCode code, float timer) {
    timer = this.calculateTimerFrom(code, timer);
    if (this.statuses.containsKey(code)) {
      if (!this.statuses.get(code).permanent) {
        this.statuses.get(code).refreshTime(timer);
      }
    }
    else {
      this.statuses.put(code, new StatusEffect(code, timer));
      this.effectFromNewNegativeStatusEffect();
    }
  }
   public void effectFromNewNegativeStatusEffect() {
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_101_rageGain);
          }
          a.timer_other = Constants.ability_101_cooldownTimer;
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_106_rageGain);
          }
          a.timer_other = Constants.ability_106_cooldownTimer;
          break;
        default:
          break;
      }
    }
  }

   public boolean hasStatusEffect(StatusEffectCode code) {
    return this.statuses.containsKey(code);
  }
   public boolean invulnerable() {
    return this.hasStatusEffect(StatusEffectCode.INVULNERABLE);
  }
   public boolean unkillable() {
    return this.hasStatusEffect(StatusEffectCode.UNKILLABLE);
  }
   public boolean hungry() {
    return this.hasStatusEffect(StatusEffectCode.HUNGRY);
  }
   public boolean weak() {
    return this.hasStatusEffect(StatusEffectCode.WEAK);
  }
   public boolean thirsty() {
    return this.hasStatusEffect(StatusEffectCode.THIRSTY);
  }
   public boolean woozy() {
    return this.hasStatusEffect(StatusEffectCode.WOOZY);
  }
   public boolean confused() {
    return this.hasStatusEffect(StatusEffectCode.CONFUSED);
  }
   public boolean bleeding() {
    return this.hasStatusEffect(StatusEffectCode.BLEEDING);
  }
   public boolean hemorrhaging() {
    return this.hasStatusEffect(StatusEffectCode.HEMORRHAGING);
  }
   public boolean wilted() {
    return this.hasStatusEffect(StatusEffectCode.WILTED);
  }
   public boolean withered() {
    return this.hasStatusEffect(StatusEffectCode.WITHERED);
  }
   public boolean visible() {
    return this.hasStatusEffect(StatusEffectCode.VISIBLE);
  }
   public boolean suppressed() {
    return this.hasStatusEffect(StatusEffectCode.SUPPRESSED);
  }
   public boolean untargetable() {
    return this.hasStatusEffect(StatusEffectCode.UNTARGETABLE);
  }
   public boolean stunned() {
    return this.hasStatusEffect(StatusEffectCode.STUNNED);
  }
   public boolean invisible() {
    return this.hasStatusEffect(StatusEffectCode.INVISIBLE);
  }
   public boolean uncollidable() {
    return this.hasStatusEffect(StatusEffectCode.UNCOLLIDABLE);
  }
   public boolean running() {
    return this.hasStatusEffect(StatusEffectCode.RUNNING);
  }
   public boolean fertilized() {
    return this.hasStatusEffect(StatusEffectCode.FERTILIZED);
  }
   public boolean sneaking() {
    return this.hasStatusEffect(StatusEffectCode.SNEAKING);
  }
   public boolean relaxed() {
    return this.hasStatusEffect(StatusEffectCode.RELAXED);
  }
   public boolean ghosting() {
    return this.hasStatusEffect(StatusEffectCode.GHOSTING);
  }
   public boolean silenced() {
    return this.hasStatusEffect(StatusEffectCode.SILENCED);
  }
   public boolean slowed() {
    return this.hasStatusEffect(StatusEffectCode.SLOWED);
  }
   public boolean drenched() {
    return this.hasStatusEffect(StatusEffectCode.DRENCHED);
  }
   public boolean drowning() {
    return this.hasStatusEffect(StatusEffectCode.DROWNING);
  }
   public boolean burnt() {
    return this.hasStatusEffect(StatusEffectCode.BURNT);
  }
   public boolean charred() {
    return this.hasStatusEffect(StatusEffectCode.CHARRED);
  }
   public boolean chilled() {
    return this.hasStatusEffect(StatusEffectCode.CHILLED);
  }
   public boolean frozen() {
    return this.hasStatusEffect(StatusEffectCode.FROZEN);
  }
   public boolean sick() {
    return this.hasStatusEffect(StatusEffectCode.SICK);
  }
   public boolean diseased() {
    return this.hasStatusEffect(StatusEffectCode.DISEASED);
  }
   public boolean rotting() {
    return this.hasStatusEffect(StatusEffectCode.ROTTING);
  }
   public boolean decayed() {
    return this.hasStatusEffect(StatusEffectCode.DECAYED);
  }
   public boolean shaken() {
    return this.hasStatusEffect(StatusEffectCode.SHAKEN);
  }
   public boolean fallen() {
    return this.hasStatusEffect(StatusEffectCode.FALLEN);
  }
   public boolean shocked() {
    return this.hasStatusEffect(StatusEffectCode.SHOCKED);
  }
   public boolean paralyzed() {
    return this.hasStatusEffect(StatusEffectCode.PARALYZED);
  }
   public boolean unstable() {
    return this.hasStatusEffect(StatusEffectCode.UNSTABLE);
  }
   public boolean radioactive() {
    return this.hasStatusEffect(StatusEffectCode.RADIOACTIVE);
  }
   public boolean nelsonGlare() {
    return this.hasStatusEffect(StatusEffectCode.NELSON_GLARE);
  }
   public boolean nelsonGlareII() {
    return this.hasStatusEffect(StatusEffectCode.NELSON_GLAREII);
  }
   public boolean senselessGrit() {
    return this.hasStatusEffect(StatusEffectCode.SENSELESS_GRIT);
  }
   public boolean senselessGritII() {
    return this.hasStatusEffect(StatusEffectCode.SENSELESS_GRITII);
  }
   public boolean rageOfTheBen() {
    return this.hasStatusEffect(StatusEffectCode.RAGE_OF_THE_BEN);
  }
   public boolean rageOfTheBenII() {
    return this.hasStatusEffect(StatusEffectCode.RAGE_OF_THE_BENII);
  }
   public boolean aposematicCamouflage() {
    return this.hasStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGE);
  }
   public boolean aposematicCamouflageII() {
    return this.hasStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGEII);
  }
   public boolean tongueLash() {
    return this.hasStatusEffect(StatusEffectCode.TONGUE_LASH);
  }
   public boolean alkaloidSecretion() {
    return this.hasStatusEffect(StatusEffectCode.ALKALOID_SECRETION);
  }
   public boolean alkaloidSecretionII() {
    return this.hasStatusEffect(StatusEffectCode.ALKALOID_SECRETIONII);
  }

   public StatusEffectCode priorityStatusEffect() {
    return null;
  }


   public void refreshPlayerSight(AbstractGameMap map) {
    for (IntegerCoordinate coordinate : this.curr_squares_sight) {
      map.setTerrainVisible(false, coordinate.x, coordinate.y);
    }
    this.curr_squares_sight = this.getSquaresSight(map);
    for (IntegerCoordinate coordinate : this.curr_squares_sight) {
      map.exploreTerrainAndVisible(coordinate.x, coordinate.y);
    }
  }


   public void startPathfindingThread(AbstractGameMap map) {
    switch(this.curr_action) {
      case MOVING:
      case MOVING_AND_USING_ITEM:
        this.startPathfindingThread(this.curr_action_x, this.curr_action_y, map);
        break;
      case TARGETING_FEATURE:
      case TARGETING_FEATURE_WITH_ITEM:
      case TARGETING_UNIT:
      case TARGETING_ITEM:
        if (this.object_targeting == null) {
          break;
        }
        this.startPathfindingThread(this.object_targeting.xCenter(), this.object_targeting.yCenter(), map);
        break;
      default:
        break;
    }
  }
   public void startPathfindingThread(float targetX, float targetY, AbstractGameMap map) {
    this.waiting_for_pathfinding_thread = true;
    if (this.pathfinding_thread != null && this.pathfinding_thread.isAlive()) {
      this.pathfinding_thread.stop_thread = true;
    }
    this.pathfinding_thread = new PathFindingThread(targetX, targetY, map);
    this.pathfinding_thread.start();
  }

  // If unit choosing to move somewhere
   public void moveLogic(int time_elapsed, AbstractGameMap map) {
    if (this.waiting_for_pathfinding_thread) {
      if (this.pathfinding_thread == null) {
        this.waiting_for_pathfinding_thread = false;
      }
      else if (this.pathfinding_thread.isAlive()) {
        if (this.last_move_any_collision) { // only wait for thead when you actually collide
          return;
        }
      }
      else {
        this.move_stack = this.pathfinding_thread.move_stack;
        if (!this.move_stack.empty()) {
          this.using_current_move_stack = true;
        }
        this.pathfinding_thread = null;
        this.waiting_for_pathfinding_thread = false;
        return; // have to return so next loop the unit faces properly
      }
    }
    boolean collision_last_move = this.last_move_collision;
    if (this.sneaking()) {
      this.move(time_elapsed, map, MoveModifier.SNEAK);
    }
    else {
      this.move(time_elapsed, map, MoveModifier.NONE);
    }
    if (this.using_current_move_stack) {
      if (this.move_stack.empty()) {
        this.using_current_move_stack = false;
      }
      else if (this.distanceFromPoint(this.move_stack.peek().x, this.move_stack.peek().y) < this.last_move_distance) {
        this.move_stack.pop();
      }
      if (this.curr_action == UnitAction.TARGETING_UNIT) {
        this.timer_update_pathfinding -= time_elapsed;
        if (this.timer_update_pathfinding < 0) {
          this.timer_update_pathfinding += Constants.unit_update_pathfinding_timer;
          this.startPathfindingThread(map);
        }
      }
    }
    if (this.last_move_collision) {
      if (collision_last_move) {
        this.timer_actionTime -= time_elapsed;
      }
      else {
        this.timer_actionTime = Constants.unit_moveCollisionStopActionTime;
      }
      switch(this.ID) {
        case 1002: // Chicken
        case 1003: // Chick
        case 1005: // Rooster
          if (!this.falling) {
            this.jump(map);
          }
          break;
        default:
          break;
      }
      if (this.timer_actionTime < 0) { // colliding over and over
        this.stopAction(true);
      }
    }
    this.timer_walk -= time_elapsed;
    if (this.timer_walk < 0) {
      this.timer_walk += Constants.unit_timer_walk;
      GameMapSquare square = map.mapSquare(PApplet.parseInt(this.x), PApplet.parseInt(this.y));
      if (square != null) {
        this.walkSound(square.terrain_id);
      }
    }
  }


   public void update(int timeElapsed, AbstractGameMap map) {
    // timers
    this.update(timeElapsed);
    // ai logic for ai units
    if (this.ai_controlled) {
      this.aiLogic(timeElapsed, map);
    }
    if ((this.suppressed() || this.stunned()) && !this.curr_action_unstoppable) {
      this.stopAction();
    }
    // unit action
    switch(this.curr_action) {
      case MOVING:
        switch(this.curr_action_id) {
          case 1: // Anuran Appetite regurgitate
            this.move(timeElapsed, map, MoveModifier.ANURAN_APPETITE);
            if (this.last_move_any_collision) {
              this.stopAction(true);
            }
            break;
          default:
            if (this.using_current_move_stack) {
              if (this.move_stack.empty()) {
                this.using_current_move_stack = false;
                this.face(this.curr_action_x, this.curr_action_y);
              }
              else {
                this.face(this.move_stack.peek().x, this.move_stack.peek().y);
              }
            }
            else {
              this.face(this.curr_action_x, this.curr_action_y);
            }
            this.moveLogic(timeElapsed, map);
            break;
        }
        if (this.distanceFromPoint(this.curr_action_x, this.curr_action_y)
          < this.last_move_distance + Constants.small_number) {
          this.stopAction(true);
        }
        break;
      case CAST_WHEN_IN_RANGE:
        if (this.curr_action_id < 0 || this.curr_action_id >= this.abilities.size()) {
          this.stopAction();
          break;
        }
        Ability a = this.abilities.get(this.curr_action_id);
        if (a == null) {
          this.stopAction();
          break;
        }
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        Unit target_unit = (Unit)this.object_targeting;
        if (target_unit.untargetable()) {
          this.stopAction();
        }
        if (!target_unit.targetable(this)) {
          this.stopAction();
          break;
        }
        if (this.distance(target_unit) > a.castsOnTargetRange()) {
          this.face(target_unit);
          this.moveLogic(timeElapsed, map);
        }
        else {
          a.activate(this, map, target_unit);
        }
        break;
      case CASTING:
        if (this.curr_action_id < 0 || this.curr_action_id >= this.abilities.size()) {
          this.stopAction();
          break;
        }
        Ability a_casting = this.abilities.get(this.curr_action_id);
        if (a_casting == null) {
          this.stopAction();
          break;
        }
        switch(a_casting.ID) {
          case 113: // Amphibious Leap
          case 118: // Amphibious Leap II
            this.move(timeElapsed, map, MoveModifier.AMPHIBIOUS_LEAP);
            if (this.last_move_any_collision) {
              a_casting.timer_other = 0;
            }
            break;
          default:
            break;
        }
        break;
      case TARGETING_FEATURE:
      case TARGETING_FEATURE_WITH_ITEM:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        Feature f = (Feature)this.object_targeting;
        if (!f.targetable(this)) {
          this.stopAction();
          break;
        }
        if (this.distance(f) > f.interactionDistance()) {
          if (this.using_current_move_stack) {
            if (this.move_stack.empty()) {
              this.using_current_move_stack = false;
              this.face(f);
            }
            else {
              this.face(this.move_stack.peek().x, this.move_stack.peek().y);
            }
          }
          else {
            this.face(f);
          }
          this.moveLogic(timeElapsed, map);
          break;
        }
        this.face(f);
        if (f.onInteractionCooldown()) {
          break;
        }
        if (this.curr_action == UnitAction.TARGETING_FEATURE_WITH_ITEM) {
          this.curr_action = UnitAction.FEATURE_INTERACTION_WITH_ITEM;
        }
        else {
          this.curr_action = UnitAction.FEATURE_INTERACTION;
        }
        this.timer_actionTime = f.interactionTime();
        break;
      case FEATURE_INTERACTION:
      case FEATURE_INTERACTION_WITH_ITEM:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        this.timer_actionTime -= timeElapsed;
        if (this.timer_actionTime < 0) {
          boolean use_item = this.curr_action == UnitAction.FEATURE_INTERACTION_WITH_ITEM;
          this.curr_action = UnitAction.NONE; // must be before since interact() can set HERO_INTERACTING_WITH_FEATURE
          ((Feature)this.object_targeting).interact(this, map, use_item);
          if (this.curr_action == UnitAction.NONE) {
            this.stopAction();
          }
        }
        break;
      case HERO_INTERACTING_WITH_FEATURE:
      case HERO_INTERACTING_WITH_FEATURE_WITH_ITEM:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        break;
      case TARGETING_UNIT:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        Unit u = (Unit)this.object_targeting;
        if (u.untargetable()) {
          this.stopAction();
        }
        if (!u.targetable(this)) {
          this.stopAction();
          break;
        }
        float distance = this.distance(u);
        if (distance > this.attackRange()) {
          if (this.using_current_move_stack) {
            if (this.move_stack.empty()) {
              this.using_current_move_stack = false;
              this.face(u);
            }
            else {
              this.face(this.move_stack.peek().x, this.move_stack.peek().y);
            }
          }
          else {
            this.face(u);
          }
          this.moveLogic(timeElapsed, map);
        }
        else if (this.timer_attackCooldown <= 0) {
          this.face(u);
          if (this.weapon() != null && this.weapon().shootable()) {
            if (this.weapon().meleeAttackable() && distance < this.attackRange(true)) {
              this.curr_action = UnitAction.ATTACKING;
              this.timer_actionTime = this.attackTime(true);
            }
            else {
              this.curr_action = UnitAction.SHOOTING;
              this.timer_actionTime = this.attackTime();
            }
          }
          else {
            this.curr_action = UnitAction.ATTACKING;
            this.timer_actionTime = this.attackTime();
          }
        }
        break;
      case AIMING:
        if (this.weapon() == null || !this.weapon().shootable()) {
          this.stopAction();
          break;
        }
        this.face(this.curr_action_x, this.curr_action_y);
        if (this.timer_attackCooldown <= 0) {
          this.curr_action = UnitAction.SHOOTING;
          this.timer_actionTime = this.attackTime();
        }
        break;
      case TARGETING_ITEM:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        Item i = (Item)this.object_targeting;
        if (!i.targetable(this)) {
          this.stopAction();
          break;
        }
        if (this.distance(i) > i.interactionDistance()) {
          if (this.using_current_move_stack) {
            if (this.move_stack.empty()) {
              this.using_current_move_stack = false;
              this.face(i);
            }
            else {
              this.face(this.move_stack.peek().x, this.move_stack.peek().y);
            }
          }
          else {
            this.face(i);
          }
          this.moveLogic(timeElapsed, map);
        }
        else {
          this.face(i);
          if (this.gear.containsKey(GearSlot.WEAPON)) {
            if (this.weapon() == null) {
              this.gear.put(GearSlot.WEAPON, new Item(i));
              i.remove = true;
              if (!this.ai_controlled) {
                i.pickupSound();
              }
              if (this.map_key == 0) {
                map.selected_object = this.weapon();
              }
            }
            else if (this.weapon().ID == i.ID && this.weapon().maxStack() > this.weapon().stack) {
              int stack_to_pickup = min(this.weapon().maxStack() - this.weapon().stack, i.stack);
              i.removeStack(stack_to_pickup);
              this.weapon().addStack(stack_to_pickup);
              if (!this.ai_controlled) {
                i.pickupSound();
              }
              if (this.map_key == 0) {
                map.selected_object = this.weapon();
              }
            }
          }
          this.stopAction();
        }
        break;
      case ATTACKING:
        if (this.object_targeting == null || this.object_targeting.remove) {
          this.stopAction();
          break;
        }
        Unit unit_attacking = (Unit)this.object_targeting;
        if (unit_attacking.untargetable()) {
          this.stopAction();
        }
        if (this.frozen()) {
          this.stopAction();
          break;
        }
        else if (this.chilled()) {
          if (this.element == Element.CYAN) {
            this.timer_actionTime -= timeElapsed * Constants.status_chilled_cooldownMultiplierCyan;
          }
          else {
            this.timer_actionTime -= timeElapsed * Constants.status_chilled_cooldownMultiplier;
          }
        }
        else {
          this.timer_actionTime -= timeElapsed;
        }
        if (this.timer_actionTime < 0) {
          this.curr_action = UnitAction.TARGETING_UNIT;
          this.attack(unit_attacking);
        }
        break;
      case SHOOTING:
        if (this.weapon() == null || !this.weapon().shootable()) {
          this.stopAction();
          break;
        }
        if (this.object_targeting != null) {
          this.face(this.object_targeting);
        }
        this.timer_actionTime -= timeElapsed;
        if (this.timer_actionTime < 0) {
          this.shoot(map);
          if (this.weapon().shootable() && this.weapon().automatic() && global.holding_rightclick) {
            if (this.map_key == 0 && global.holding_ctrl) {
              this.curr_action = UnitAction.AIMING;
            }
            else {
              this.curr_action = UnitAction.TARGETING_UNIT;
            }
          }
          else {
            this.stopAction();
          }
        }
        break;
      case USING_ITEM:
        if (this.weapon() == null || !this.weapon().usable()) {
          this.stopAction();
          break;
        }
        this.timer_actionTime -= timeElapsed;
        if (this.timer_actionTime < 0) {
          this.useItem(map);
          this.stopAction();
        }
        break;
      case MOVING_AND_USING_ITEM:
        if (this.weapon() == null || !this.weapon().usable()) {
          this.curr_action = UnitAction.MOVING;
          break;
        }
        this.timer_actionTime -= timeElapsed;
        if (this.timer_actionTime < 0) {
          this.useItem(map);
          this.curr_action = UnitAction.MOVING;
        }
        if (this.using_current_move_stack) {
          if (this.move_stack.empty()) {
            this.using_current_move_stack = false;
            this.face(this.curr_action_x, this.curr_action_y);
          }
          else {
            this.face(this.move_stack.peek().x, this.move_stack.peek().y);
          }
        }
        else {
          this.face(this.curr_action_x, this.curr_action_y);
        }
        this.moveLogic(timeElapsed, map);
        if (this.distanceFromPoint(this.curr_action_x, this.curr_action_y)
          < this.last_move_distance + Constants.small_number) {
            this.curr_action = UnitAction.USING_ITEM;
        }
        break;
      case NONE:
        break;
    }
    // update gear items
    for (Map.Entry<GearSlot, Item> slot : this.gear.entrySet()) {
      if (slot.getValue() != null && slot.getValue().remove) {
        this.gear.put(slot.getKey(), null);
      }
    }
    // Update status effects
    Iterator status_iterator = this.statuses.entrySet().iterator();
    while(status_iterator.hasNext()) {
      Map.Entry<StatusEffectCode, StatusEffect> entry =
        (Map.Entry<StatusEffectCode, StatusEffect>)status_iterator.next();
      StatusEffect se = entry.getValue();
      if (!se.permanent) {
        se.timer_gone -= timeElapsed;
        if (se.timer_gone < 0) {
          status_iterator.remove();
          continue;
        }
      }
      switch(entry.getKey()) {
        case HUNGRY:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_hunger_tickTimer;
            this.calculateDotDamage(Constants.status_hunger_dot, false, Constants.status_hunger_damageLimit);
            if (randomChance(Constants.status_hunger_weakPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.WEAK, 8000);
            }
          }
          break;
        case THIRSTY:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_thirst_tickTimer;
            this.calculateDotDamage(Constants.status_thirst_dot, false, Constants.status_thirst_damageLimit);
            if (randomChance(Constants.status_thirst_woozyPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.WOOZY, 10000);
            }
            if (randomChance(Constants.status_thirst_confusedPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.CONFUSED, 10000);
            }
          }
          break;
        case WOOZY:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += random(Constants.status_woozy_tickMaxTimer);
            this.turn(Constants.status_woozy_maxAmount - 2 * random(Constants.status_woozy_maxAmount));
            this.stopAction();
          }
          break;
        case CONFUSED:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += random(Constants.status_confused_tickMaxTimer);
            this.moveTo(this.x + Constants.status_confused_maxAmount -
              2 * random(Constants.status_confused_maxAmount), this.y +
              Constants.status_confused_maxAmount - 2 * random(Constants.status_confused_maxAmount), null);
          }
          break;
        case BLEEDING:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_bleed_tickTimer;
            this.calculateDotDamage(Constants.status_bleed_dot, true, Constants.status_bleed_damageLimit);
            if (randomChance(Constants.status_bleed_hemorrhagePercentage)) {
              this.refreshStatusEffect(StatusEffectCode.HEMORRHAGING, 5000);
            }
          }
          break;
        case HEMORRHAGING:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_hemorrhage_tickTimer;
            this.calculateDotDamage(Constants.status_hemorrhage_dot, true, Constants.status_hemorrhage_damageLimit);
            if (randomChance(Constants.status_hemorrhage_bleedPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.BLEEDING, 5000);
            }
          }
          break;
        case DRENCHED:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_drenched_tickTimer;
            if (this.element == Element.RED) {
              this.calculateDotDamage(Constants.status_drenched_dot, true, Constants.status_drenched_damageLimit);
            }
          }
          break;
        case DROWNING:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_drowning_tickTimer;
            if (this.element == Element.BLUE) {
              this.calculateDotDamage(Constants.status_drowning_dot, true, Constants.status_drowning_damageLimitBlue);
            }
            else {
              this.calculateDotDamage(Constants.status_drowning_dot, true, Constants.status_drowning_damageLimit);
            }
            if (randomChance(Constants.status_drowning_drenchedPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.DRENCHED, 5000);
            }
          }
          break;
        case BURNT:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_burnt_tickTimer;
            if (this.element == Element.RED) {
              this.calculateDotDamage(Constants.status_burnt_dot, true, Constants.status_burnt_damageLimitRed);
            }
            else {
              this.calculateDotDamage(Constants.status_burnt_dot, true, Constants.status_burnt_damageLimit);
            }
            if (randomChance(Constants.status_burnt_charredPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.CHARRED, 5000);
            }
          }
          break;
        case CHARRED:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_charred_tickTimer;
            if (this.element == Element.RED) {
              this.calculateDotDamage(Constants.status_charred_dot, true, Constants.status_charred_damageLimitRed);
            }
            else {
              this.calculateDotDamage(Constants.status_charred_dot, true, Constants.status_charred_damageLimit);
            }
          }
          break;
        case FROZEN:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_frozen_tickTimer;
            if (this.element == Element.ORANGE) {
              this.calculateDotDamage(Constants.status_frozen_dot, true, Constants.status_frozen_damageLimit);
            }
          }
          break;
        case ROTTING:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_rotting_tickTimer;
            if (this.element == Element.BROWN) {
              this.calculateDotDamage(Constants.status_rotting_dot, true, Constants.status_rotting_damageLimitBrown);
            }
            else if (this.element == Element.BLUE) {
              this.calculateDotDamage(Constants.status_rotting_dot, true, Constants.status_rotting_damageLimitBlue);
            }
            else {
              this.calculateDotDamage(Constants.status_rotting_dot, true, Constants.status_rotting_damageLimit);
            }
            if (randomChance(Constants.status_rotting_decayedPercentage)) {
              this.refreshStatusEffect(StatusEffectCode.DECAYED, 5000);
            }
          }
          break;
        case DECAYED:
          se.number -= timeElapsed;
          if (se.number < 0) {
            se.number += Constants.status_decayed_tickTimer;
            if (this.element == Element.BROWN) {
              this.calculateDotDamage(Constants.status_decayed_dot, true, Constants.status_decayed_damageLimitBrown);
            }
            else {
              this.calculateDotDamage(Constants.status_decayed_dot, true, Constants.status_decayed_damageLimit);
            }
          }
          break;
        case APOSEMATIC_CAMOUFLAGE:
          if (this.visible()) {
            status_iterator.remove();
            continue;
          }
          for (Map.Entry<Integer, Unit> entryI : map.units.entrySet()) {
            if (entryI.getValue().alliance == this.alliance) {
              continue;
            }
            float distance = this.distance(entryI.getValue());
            if (distance < Constants.ability_111_distance) {
              status_iterator.remove();
              this.addStatusEffect(StatusEffectCode.VISIBLE, 1000);
              continue;
            }
          }
          break;
        case APOSEMATIC_CAMOUFLAGEII:
          if (this.visible()) {
            status_iterator.remove();
            continue;
          }
          for (Map.Entry<Integer, Unit> entryII : map.units.entrySet()) {
            if (entryII.getValue().alliance == this.alliance) {
              continue;
            }
            float distance = this.distance(entryII.getValue());
            if (distance < Constants.ability_116_distance) {
              status_iterator.remove();
              this.addStatusEffect(StatusEffectCode.VISIBLE, 1000);
              continue;
            }
          }
          break;
        default:
          break;
      }
    }
    // Update abilities
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      a.update(timeElapsed, this, map);
    }
    // Cast ability
    if (this.buffer_cast > -1) {
      this.cast(this.buffer_cast, map);
      this.buffer_cast = -1;
    }
    // Resolve location logic
    if (this.floor_height < this.curr_height) {
      if (this.falling) {
        this.timer_falling -= timeElapsed;
        if (this.timer_falling < 0) {
          this.timer_falling += Constants.unit_fallTimer;
          this.fall_amount++;
          this.curr_height--;
          this.resolveFloorHeight(map);
        }
      }
      else {
        this.falling = true;
        this.fall_amount = 0;
        this.timer_falling = Constants.unit_fallTimer;
      }
    }
    else if (this.falling) {
      this.falling = false;
      int no_damage_fall_amount = Constants.unit_noDamageFallHeight + 2 * this.agility();
      if (this.fall_amount > no_damage_fall_amount) { // removed until 3rd dimension visible
        //this.calculateDotDamage(Constants.unit_fallDamageMultiplier * (this.fall_amount - no_damage_fall_amount), true);
        //global.sounds.trigger_units("player/fall", this.x - map.viewX, this.y - map.viewY);
      }
      this.fall_amount = 0;
    }
    else {
      for (IntegerCoordinate coordinate : this.curr_squares_on) {
        try {
          switch(map.mapSquare(coordinate.x, coordinate.y).terrain_id) {
            case 181: // Very Shallow Water
            case 182:
              break;
            case 183: // Shallow Water
              this.refreshStatusEffect(StatusEffectCode.DRENCHED, 1000);
              break;
            case 184: // Medium Water
              this.refreshStatusEffect(StatusEffectCode.DRENCHED, 2000);
              if (this.swimNumber() < 1) {
                this.refreshStatusEffect(StatusEffectCode.DROWNING, 100);
              }
              break;
            case 185: // Deep Water
              this.refreshStatusEffect(StatusEffectCode.DRENCHED, 3000);
              if (this.swimNumber() < 2) {
                this.refreshStatusEffect(StatusEffectCode.DROWNING, 100);
              }
              break;
            case 191: // Lava
              this.refreshStatusEffect(StatusEffectCode.BURNT, 4000);
              this.refreshStatusEffect(StatusEffectCode.CHARRED, 1000);
              this.calculateDotDamage(timeElapsed * 0.00015f, true);
              this.damage(null, timeElapsed * 0.01f);
              break;
            default:
              break;
          }
        } catch(NullPointerException e) {}
      }
      if (this.timer_resolve_floor_height < 0) {
        this.timer_resolve_floor_height += Constants.unit_timer_resolve_floor_height_cooldown;
        this.resolveFloorHeight(map);
      }
    }
  }

  // timers independent of curr action
   public void update(int time_elapsed) {
    if (this.timer_last_damage > 0) {
      this.timer_last_damage -= time_elapsed;
    }
    if (this.timer_attackCooldown > 0) {
      if (this.frozen()) {
        this.timer_attackCooldown = this.attackCooldown();
      }
      else if (this.chilled()) {
        if (this.element == Element.CYAN) {
          this.timer_attackCooldown -= time_elapsed * Constants.status_chilled_cooldownMultiplierCyan;
        }
        else {
          this.timer_attackCooldown -= time_elapsed * Constants.status_chilled_cooldownMultiplier;
        }
      }
      else {
        this.timer_attackCooldown -= time_elapsed;
      }
    }
    this.timer_resolve_floor_height -= time_elapsed;
    this.timer_target_sound -= time_elapsed;
    this.timer_talk -= time_elapsed;
    if (this.timer_talk < 0) {
      this.timer_talk += Constants.unit_timer_talk + PApplet.parseInt(random(Constants.unit_timer_talk));
      this.talkSound();
    }
    this.healPercent(this.passiveHeal() * time_elapsed * 0.001f, true);
    this.updateItems();
  }

   public void updateItems() {
    for (Map.Entry<GearSlot, Item> entry : this.gear.entrySet()) {
      if (entry.getValue() == null) {
        continue;
      }
      switch(entry.getKey()) {
        case WEAPON:
          switch(entry.getValue().ID) {
            case 2928: // cigar
              if (entry.getValue().toggled) {
                this.refreshStatusEffect(StatusEffectCode.RELAXED, 2500);
              }
              break;
            default:
              break;
          }
          break;
        default:
          break;
      }
    }
  }


   public void useItem(AbstractGameMap map) {
    global.errorMessage("ERROR: Units cannot use Items, only Heroes can.");
  }


   public void dropWeapon(AbstractGameMap map) {
    if (this.weapon() == null) {
      return;
    }
    map.addItem(new Item(this.weapon(), this.frontX(), this.frontY()));
    this.gear.put(GearSlot.WEAPON, null);
    if (!this.ai_controlled) {
      global.sounds.trigger_player("player/drop", this.x - map.viewX, this.y - map.viewY);
    }
  }

   public float frontX() {
    return this.x + this.facingX * this.xRadius() - 0.5f * this.facingY * this.xRadius();
  }

   public float frontY() {
    return this.y + 0.5f * this.facingX * this.yRadius() + this.facingY * this.yRadius();
  }


   public void target(MapObject object, AbstractGameMap map) {
    this.target(object, map, false);
  }
   public void target(MapObject object, AbstractGameMap map, boolean use_item) {
    if (object == null) {
      return;
    }
    if (this.object_targeting == object) {
      return;
    }
    this.object_targeting = object;
    if (Feature.class.isInstance(this.object_targeting)) {
      if (this.weapon() != null && use_item) {
        this.curr_action = UnitAction.TARGETING_FEATURE_WITH_ITEM;
      }
      else {
        this.curr_action = UnitAction.TARGETING_FEATURE;
      }
    }
    else if (Unit.class.isInstance(this.object_targeting)) {
      this.curr_action = UnitAction.TARGETING_UNIT;
      this.targetSound();
    }
    else if (Item.class.isInstance(this.object_targeting)) {
      this.curr_action = UnitAction.TARGETING_ITEM;
    }
    else {
      this.curr_action = UnitAction.NONE;
      return;
    }
    if (map != null) {
      this.startPathfindingThread(object.xCenter(), object.yCenter(), map);
    }
  }


  // Aim at mouse
   public void aim(float targetX, float targetY) {
    this.curr_action = UnitAction.AIMING;
    this.object_targeting = null;
    this.curr_action_x = targetX;
    this.curr_action_y = targetY;
  }


   public void restartAbilityTimers() {
    for (Ability a : this.abilities) {
      if (a != null) {
        a.timer_cooldown = 0;
      }
    }
  }

  // Cast ability
   public void bufferCast(int index) {
    if (index < 0 || index >= this.abilities.size()) {
      return;
    }
    Ability a = this.abilities.get(index);
    if (a == null) {
      return;
    }
    this.buffer_cast = index;
  }

   public void cast(int index, AbstractGameMap map) {
    this.cast(index, map, null);
  }
   public void cast(int index , AbstractGameMap map, MapObject secondary_target) {
    this.cast(index, map, secondary_target, false);
  }
   public void cast(int index , AbstractGameMap map, MapObject secondary_target, boolean player_casting) {
    if (this.suppressed() || this.stunned() || this.silenced()) {
      return;
    }
    if (index < 0 || index >= this.abilities.size()) {
      return;
    }
    Ability a = this.abilities.get(index);
    if (a == null) {
      return;
    }
    if (a.timer_cooldown > 0) {
      return;
    }
    if (a.checkMana()) {
      if (a.manaCost() > this.currMana()) {
        if (player_casting) {
          map.addHeaderMessage("Not enough mana");
        }
        return;
      }
    }
    if (a.castsOnTarget()) {
      if (this.object_targeting == null) {
        if (secondary_target == null) {
          return;
        }
        else {
          this.object_targeting = secondary_target;
        }
      }
      if (!Unit.class.isInstance(this.object_targeting)) {
        return;
      }
      Unit u = (Unit)this.object_targeting;
      if (this.distance(u) > a.castsOnTargetRange()) {
        this.curr_action = UnitAction.CAST_WHEN_IN_RANGE;
        this.curr_action_id = index;
        return;
      }
      this.curr_action_id = index;
      if (this.map_key == 0) {
        this.curr_action_x = map.mX;
        this.curr_action_y = map.mY;
      }
      if (a.turnsCaster()) {
        this.face(u);
      }
      a.activate(this, map, u);
    }
    else {
      this.curr_action_id = index;
      if (this.map_key == 0) {
        this.curr_action_x = map.mX;
        this.curr_action_y = map.mY;
      }
      if (a.turnsCaster()) {
        if (this.object_targeting != null && this.ai_controlled) {
          this.face(this.object_targeting);
        }
        else if (!this.ai_controlled && this.map_key == 0) {
          this.face(map.mX, map.mY);
        }
      }
      a.activate(this, map);
    }
  }


  // Shoot projectile
   public void shoot(AbstractGameMap map) {
    if (this.weapon() == null || !this.weapon().shootable()) {
      return;
    }
    map.addProjectile(new Projectile(this.weapon().ID + 1000, this, this.weapon().shootInaccuracy()));
    switch(this.weapon().ID) {
      case 2118: // Chicken Egg
        global.sounds.trigger_units("items/throw", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2301: // Slingshot
        global.sounds.trigger_units("items/slingshot", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2311: // Recurve Bow
        global.sounds.trigger_units("items/recurve_bow", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2312: // M1911
        global.sounds.trigger_units("items/m1911", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2321: // War Machine
      case 2342:
      case 2331:
        global.sounds.trigger_units("items/war_machine", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2322: // Five-Seven
      case 2343:
        global.sounds.trigger_units("items/five_seven", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2323: // Type25
      case 2344:
        global.sounds.trigger_units("items/type25", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2332: // FAL
        global.sounds.trigger_units("items/FAL", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2333: // Python
      case 2354:
        global.sounds.trigger_units("items/python", this.x - map.viewX, this.y - map.viewY);
      case 2341: // RPG
      case 2362:
        global.sounds.trigger_units("items/RPG", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2345: // Executioner
      case 2364:
        global.sounds.trigger_units("items/executioner", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2351: // Galil
      case 2373:
        global.sounds.trigger_units("items/galil", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2353: // Ballistic Knife
      case 2374:
        global.sounds.trigger_units("items/ballistic_knife", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2352: // WN
        Projectile burst1 = new Projectile(this.weapon().ID + 1000, this, this.weapon().shootInaccuracy());
        Projectile burst2 = new Projectile(this.weapon().ID + 1000, this, this.weapon().shootInaccuracy());
        burst1.x -= 0.05f * this.facingX;
        burst1.y -= 0.05f * this.facingY;
        burst2.x -= 0.1f * this.facingX;
        burst2.y -= 0.1f * this.facingY;
        map.addProjectile(burst1);
        map.addProjectile(burst2);
        global.sounds.trigger_units("items/FAL", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2355: // MTAR
      case 2375:
        global.sounds.trigger_units("items/MTAR", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2361: // RPD
      case 2381: // Relativistic Punishment Device
        global.sounds.trigger_units("items/RPD", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2363: // DSR-50
      case 2382:
        global.sounds.trigger_units("items/DSR50", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2371: // HAMR
      case 2391:
        global.sounds.trigger_units("items/HAMR", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2372: // Ray Gun
        global.sounds.trigger_units("items/ray_gun", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2392: // Porter's X2 Ray Gun
        global.sounds.trigger_units("items/porters_x2_ray_gun", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2924: // Glass Bottle
      case 2931: // Rock
      case 2932: // Arrow
      case 2933: // Pebble
        global.sounds.trigger_units("items/throw", this.x - map.viewX, this.y - map.viewY);
        break;
      case 2944: // Grenade
        global.sounds.trigger_units("items/grenade_throw", this.x - map.viewX, this.y - map.viewY);
        break;
      default:
        break;
    }
    this.weapon().shot();
    this.move(this.weapon().shootRecoil(), map, MoveModifier.RECOIL);
    this.timer_attackCooldown = this.attackCooldown();
  }


  // Auto attack
   public void attack(Unit u) {
    float power = attack();
    if (this.aposematicCamouflage()) {
      power *= Constants.ability_111_powerBuff;
      this.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGE);
    }
    if (this.aposematicCamouflageII()) {
      power *= Constants.ability_116_powerBuff;
      this.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGEII);
    }
    u.damage(this, u.calculateDamageFrom(this, power, DamageType.PHYSICAL, this.element));
    this.timer_attackCooldown = this.attackCooldown(true);
    this.attackSound();
    if (this.weapon() != null) {
      this.weapon().attacked();
    }
  }


   public float calculateDamageFrom(Unit source, float power, DamageType damageType, Element element) {
    return this.calculateDamageFrom(power, damageType, element, source.piercing(), source.penetration());
  }
   public float calculateDamageFrom(float power, DamageType damageType, Element element, float piercing, float penetration) {
    float effectiveDefense = 0;
    switch(damageType) {
      case PHYSICAL:
        effectiveDefense = this.defense() * (1 - piercing);
        break;
      case MAGICAL:
        effectiveDefense = this.resistance() * (1 - penetration);
        break;
      case MIXED:
        effectiveDefense = this.defense() * (1 - piercing) + this.resistance() * (1 - penetration);
        break;
      case TRUE:
        effectiveDefense = 0;
        break;
    }
    float subtotal = max(0, power - effectiveDefense) * this.element.resistanceFactorTo(element);
    if (element == Element.BLUE && this.drenched()) {
      subtotal *= Constants.status_drenched_multiplier;
    }
    if (this.sick()) {
      subtotal *= Constants.status_sick_damageMultiplier;
    }
    if (this.diseased()) {
      subtotal *= Constants.status_diseased_damageMultiplier;
    }
    return subtotal;
  }


   public void calculateDotDamage(float percent, boolean max_health) {
    this.calculateDotDamage(percent, max_health, 0);
  }
   public void calculateDotDamage(float percent, boolean max_health, float damage_limit) {
    float damage = 0;
    if (max_health) {
      damage = percent * this.health();
    }
    else {
      damage = percent * this.curr_health;
    }
    if (damage < 0) {
      return;
    }
    float min_health = this.health() * damage_limit;
    if (this.curr_health - damage < min_health) {
      damage = this.curr_health - min_health;
    }
    this.damage(null, damage);
  }


   public void damage(Unit source, float amount) {
    float last_health = this.curr_health;
    if (this.remove || amount <= 0) {
      return;
    }
    if (this.invulnerable()) {
      return;
    }
    this.curr_health -= amount;
    if (this.unkillable()) {
      if (this.curr_health < this.statuses.get(StatusEffectCode.UNKILLABLE).number) {
        this.curr_health = this.statuses.get(StatusEffectCode.UNKILLABLE).number;
      }
    }
    if (this.curr_health <= 0) {
      this.curr_health = 0;
      this.remove = true;
      this.deathSound();
    }
    else if (source != null) {
      this.damagedSound();
    }
    this.last_damage_from = source;
    if (source != null) {
      source.damaged(this, amount);
      if (this.remove) {
        source.killed(this);
      }
    }
    if (this.headgear() != null) {
      this.headgear().lowerDurability();
    }
    if (this.chestgear() != null) {
      this.chestgear().lowerDurability();
    }
    if (this.leggear() != null) {
      this.leggear().lowerDurability();
    }
    if (this.footgear() != null) {
      this.footgear().lowerDurability();
    }
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_101_rageGain);
          }
          a.timer_other = Constants.ability_101_cooldownTimer;
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_106_rageGain);
          }
          a.timer_other = Constants.ability_106_cooldownTimer;
          break;
        default:
          break;
      }
    }
    if (this.ai_controlled) {
      switch(this.ID) {
        case 1001: // Target Dummy
          if (source == null) {
            this.description += "\n" + amount + " damage.";
          }
          else {
            this.description += "\n" + amount + " damage from " + source.display_name() + ".";
          }
          break;
        case 1002: // Chicken
        case 1003: // Chick
          if (source == null) {
            this.faceRandom();
          }
          else {
            this.faceAway(source);
          }
          this.addStatusEffect(StatusEffectCode.RUNNING, 3000);
          this.moveForward(4, null);
          this.ai_toggle = true;
          this.timer_ai_action3 = 300;
          break;
        case 1005: // Rooster
          if (source != null) {
            this.target(source, null);
            this.addStatusEffect(StatusEffectCode.RUNNING, 3000);
          }
          break;
        case 1201: // Tier I Zombie
        case 1202:
        case 1203:
        case 1204:
        case 1205:
        case 1206:
        case 1207:
        case 1208:
        case 1209:
        case 1210:
        case 1291: // Auto-spawned Zombies
        case 1292:
        case 1293:
        case 1301: // Tier I named zombies
        case 1302:
        case 1303:
        case 1304:
        case 1305:
        case 1306:
        case 1307:
          if (source != null && (this.curr_action == UnitAction.NONE || this.last_move_collision)) {
            this.target(source, null);
          }
          break;
        default:
          break;
      }
    }
    this.timer_last_damage = Constants.unit_healthbarDamageAnimationTime;
    this.last_damage_amount = last_health - this.curr_health;
  }


   public void damaged(Unit u, float damage) {
    this.heal(max(0, this.lifesteal() * damage), false);
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_101_rageGain);
          }
          a.timer_other = Constants.ability_101_cooldownTimer;
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGain * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_106_rageGain);
          }
          a.timer_other = Constants.ability_106_cooldownTimer;
          break;
        default:
          break;
      }
    }
  }


   public void killed(Unit u) {
    for (Ability a : this.abilities) {
      if (a == null) {
        continue;
      }
      switch(a.ID) {
        case 101: // Fearless Leader I
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGainKill * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_101_rageGainKill * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_101_rageGainKill);
          }
          a.timer_other = Constants.ability_101_cooldownTimer;
          break;
        case 106: // Fearless Leader II
          if (this.rageOfTheBenII()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGainKill * Constants.ability_110_rageGainBonus));
          }
          else if (this.rageOfTheBen()) {
            this.increaseMana(PApplet.parseInt(Constants.ability_106_rageGainKill * Constants.ability_105_rageGainBonus));
          }
          else {
            this.increaseMana(Constants.ability_106_rageGainKill);
          }
          a.timer_other = Constants.ability_106_cooldownTimer;
          break;
        case 113: // Amphibious Leap I
          a.timer_cooldown *= Constants.ability_113_killCooldownReduction;
          break;
        case 118: // Amphibious Leap II
          a.timer_cooldown *= Constants.ability_118_killCooldownReduction;
          break;
        default:
          break;
      }
    }
    this.killSound();
  }


   public void destroy(AbstractGameMap map) {
    for (Item i : this.drops()) {
      map.addItem(i, this.x + this.size - random(this.size), this.y + this.size - random(this.size));
    }
    for (Map.Entry<GearSlot, Item> entry : this.gear.entrySet()) {
      this.gear.put(entry.getKey(), null);
    }
    this.statuses.clear();
    this.stopAction();
    this.restartAbilityTimers();
  }


   public ArrayList<Item> drops() {
    ArrayList<Item> drops = new ArrayList<Item>();
    Item i;
    switch(this.ID) {
      case 1002: // Chicken
        if (randomChance(0.5f)) {
          drops.add(new Item(2116));
        }
        if (randomChance(0.5f)) {
          drops.add(new Item(2807));
        }
        break;
      case 1005: // Rooster
        if (randomChance(0.7f)) {
          drops.add(new Item(2116));
        }
        if (randomChance(0.7f)) {
          drops.add(new Item(2807));
        }
        if (randomChance(0.25f)) {
          drops.add(new Item(2807));
        }
        break;
      case 1004: // John Rankin
        drops.add(new Item(2991));
        break;
      case 1006: // Father Dom
        drops.add(new Item(2988));
        drops.add(new Item(2928));
        break;
      case 1201: // Base Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1291:
        if (randomChance(0.2f)) {
          drops.add(new Item(2119));
        }
        break;
      case 1210: // Intellectual Zombie
        if (randomChance(0.2f)) {
          drops.add(new Item(2119));
        }
        if (randomChance(0.15f)) {
          drops.add(new Item(2912));
        }
        if (randomChance(0.15f)) {
          drops.add(new Item(2913));
        }
        break;
      case 1292: // Running Zombie
        if (randomChance(0.2f)) {
          drops.add(new Item(2119));
        }
        if (randomChance(0.1f)) {
          drops.add(new Item(2712));
        }
        break;
      case 1293: // Armored Zombie
        if (randomChance(0.2f)) {
          drops.add(new Item(2119));
        }
        if (randomChance(0.1f)) {
          int ore_id = 0;
          if (this.tier() >= 9) {
            ore_id = 2872;
          }
          else if (this.tier() >= 7) {
            ore_id = 2862;
          }
          else if (this.tier() == 6) {
            ore_id = 2852;
          }
          else if (this.tier() == 5) {
            ore_id = 2842;
          }
          else if (this.tier() == 4) {
            ore_id = 2832;
          }
          else if (this.tier() == 3) {
            ore_id = 2822;
          }
          else if (this.tier() == 2) {
            ore_id = 2812;
          }
          else {
            ore_id = 2802;
          }
          drops.add(new Item(ore_id));
        }
        break;
      case 1311: // Cathy Heck
        i = new Item(2904);
        i.inventory.stash(new Item(2903));
        drops.add(i);
        break;
      default:
        break;
    }
    for (Map.Entry<GearSlot, Item> entry : this.gear.entrySet()) {
      if (entry.getValue() != null) {
        drops.add(entry.getValue());
      }
    }
    return drops;
  }


   public void healPercent(float amount, boolean max_heath) {
    if (max_heath) {
      this.heal(amount * this.health());
    }
    else {
      this.heal(amount * (this.health() - this.curr_health));
    }
  }
   public void heal(float amount) {
    this.heal(amount, false);
  }
   public void heal(float amount, boolean overheal) {
    this.curr_health += amount;
    if (this.curr_health < 0) {
      this.curr_health = 0;
    }
    if (!overheal && this.curr_health > this.health()) {
      this.curr_health = this.health();
    }
  }

   public void changeHealth(float amount) {
    this.setHealth(this.curr_health + amount);
  }
   public void setHealth(float amount) {
    this.curr_health = amount;
    if (this.curr_health <= 0) {
      this.curr_health = 0;
      this.remove = true;
    }
    if (this.curr_health > this.health()) {
      this.curr_health = this.health();
    }
  }


   public void stopAction() {
    this.stopAction(false);
  }
   public void stopAction(boolean forceStop) {
    if (!forceStop && this.curr_action_unstoppable && this.curr_action != UnitAction.NONE) {
      return;
    }
    this.curr_action = UnitAction.NONE;
    this.curr_action_x = this.x;
    this.curr_action_y = this.y;
    this.object_targeting = null;
    this.last_move_collision = false;
    this.last_move_any_collision = false;
    this.curr_action_unhaltable = false;
    this.curr_action_unstoppable = false;
    this.curr_action_id = 0;
  }


   public void turnDirection(int direction) {
    switch(direction) {
      case LEFT:
        this.turn(-HALF_PI);
        break;
      case RIGHT:
        this.turn(HALF_PI);
        break;
      default:
        global.errorMessage("ERROR: turn direction " + direction + " not recognized.");
        break;
    }
  }
   public void turn(float angle_change) {
    this.turnTo(this.facingA + angle_change);
  }
   public void turnTo(float facingA) {
    this.facingA = facingA;
    this.facingX = cos(this.facingA);
    this.facingY = sin(this.facingA);
  }

   public void faceRandom() {
    this.setFacing(random(1), random(1));
  }
   public void face(MapObject object) {
    this.face(object.xCenter(), object.yCenter());
  }
   public void faceAway(MapObject object) {
    this.faceAway(object.xCenter(), object.yCenter());
  }
   public void face(float faceX, float faceY) {
    this.setFacing(faceX - this.x, faceY - this.y);
  }
   public void faceAway(float faceX, float faceY) {
    this.setFacing(this.x - faceX, this.y - faceY);
  }
   public void face(int direction) {
    switch(direction) {
      case UP:
        this.setFacing(0, -1);
        break;
      case DOWN:
        this.setFacing(0, 1);
        break;
      case LEFT:
        this.setFacing(-1, 0);
        break;
      case RIGHT:
        this.setFacing(1, 0);
        break;
      default:
        global.errorMessage("ERROR: face direction " + direction + " not recognized.");
        break;
    }
  }
   public void setFacing(float facingX, float facingY) {
    float normConstant = sqrt(facingX * facingX + facingY * facingY);
    if (normConstant == 0.0f) {
      return; // happens when exactly on target location
    }
    this.facingX = facingX / normConstant;
    this.facingY = facingY / normConstant;
    this.facingA = (float)Math.atan2(this.facingY, this.facingX);
  }

   public float facingAngleModifier() {
    switch(this.curr_action) {
      case ATTACKING:
        return Constants.unit_attackAnimationAngle(1 - this.timer_actionTime / this.attackTime(true));
      case CASTING:
        if (this.curr_action_id < 0 || this.curr_action_id >= this.abilities.size()) {
          break;
        }
        Ability a_casting = this.abilities.get(this.curr_action_id);
        if (a_casting == null) {
          break;
        }
        switch(a_casting.ID) {
          case 1002: // Condom Throw
            return 2 * PI * (1.0f - a_casting.timer_other / Constants.ability_1002_castTime);
          default:
            break;
        }
        break;
      default:
        return 0;
    }
    return 0;
  }


   public void jump(AbstractGameMap map) {
    this.resolveFloorHeight(map);
    if (!this.falling && this.curr_height == this.floor_height) {
      this.curr_height += this.jumpHeight();
      this.falling = true;
    }
    this.resolveFloorHeight(map);
  }

   public int jumpHeight() {
    switch(this.agility()) {
      case 0:
        return 0;
      case 1:
        return 2;
      case 2:
        return 3;
      case 3:
        return 4;
      case 4:
        return 5;
      case 5:
        return 6;
    }
    return 0;
  }

   public int walkHeight() {
    if (this.falling) {
      return 0;
    }
    switch(this.agility()) {
      case 0:
        return 0;
      case 1:
        return 1;
      case 2:
        return 1;
      case 3:
        return 2;
      case 4:
        return 2;
      case 5:
        return 2;
    }
    return 0;
  }


   public void walkSound(int terrain_id) {
    if (!this.in_view || this.last_move_collision || this.sneaking()) {
      return;
    }
    // custom walk sounds
    switch(this.ID) {
      case 1001: // Target Dummy
        return;
      case 1002: // Chicken
      case 1003: // Chick
      case 1005: // Rooster
        global.sounds.trigger_units("units/walk/chicken");
        return;
      default:
        break;
    }
    // default walk sounds
    switch(terrain_id) {
      case 111:
      case 112:
      case 113:
        global.sounds.trigger_units("player/walk_wood");
        break;
      case 121:
      case 122:
      case 123:
      case 131:
      case 132:
      case 133:
      case 171:
      case 172:
      case 173:
      case 174:
      case 175:
      case 176:
      case 177:
      case 178:
      case 179:
        global.sounds.trigger_units("player/walk_hard");
        break;
      case 134:
        global.sounds.trigger_units("player/walk_gravel");
        break;
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
        global.sounds.trigger_units("player/walk_sand");
        break;
      case 151:
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
        global.sounds.trigger_units("player/walk_grass");
        break;
      case 161:
      case 162:
      case 163:
        global.sounds.trigger_units("player/walk_dirt");
        break;
      case 181:
      case 182:
        global.sounds.trigger_units("player/walk_water_very_shallow");
        break;
      case 183:
        global.sounds.trigger_units("player/walk_water_shallow");
        break;
      case 184:
        global.sounds.trigger_units("player/walk_water_medium");
        break;
      case 185:
        global.sounds.trigger_units("player/walk_water_deep");
        break;
      default:
        global.sounds.trigger_units("player/walk_stone");
        break;
    }
  }

   public void talkSound() {
    if (!this.in_view) {
      return;
    }
    String sound_name = "units/talk/";
    switch(this.ID) {
      case 1002: // Chicken
      case 1003: // Chick
      case 1005: // Rooster
        sound_name += "chicken" + randomInt(1, 3);
        break;
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 5);
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void targetSound() {
    if (!this.in_view) {
      return;
    }
    if (this.timer_target_sound > 0) {
      return;
    }
    if (this.ai_controlled) {
      this.timer_target_sound = 2 * Constants.unit_timer_target_sound + 2 * round(random(Constants.unit_timer_target_sound));
    }
    else {
      this.timer_target_sound = Constants.unit_timer_target_sound + round(random(Constants.unit_timer_target_sound));
    }
    String sound_name = "units/target/";
    switch(this.ID) {
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 8);
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void attackSound() {
    if (!this.in_view) {
      return;
    }
    if (this.weapon() != null) {
      this.weapon().attackSound();
      return;
    }
    String sound_name = "units/attack/";
    switch(this.ID) {
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 15);
        break;
      case 1311:
        sound_name += "heck" + randomInt(1, 5);
        break;
      default:
        sound_name += "default";
        break;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void damagedSound() {
    if (!this.in_view) {
      return;
    }
    String sound_name = "units/damaged/";
    switch(this.ID) {
      case 1002: // Chicken
      case 1003: // Chick
      case 1005: // Rooster
        sound_name += "chicken" + randomInt(1, 2);
        break;
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 11);
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void deathSound() {
    if (!this.in_view) {
      return;
    }
    String sound_name = "units/death/";
    switch(this.ID) {
      case 1002: // Chicken
      case 1003: // Chick
      case 1005: // Rooster
        sound_name += "chicken" + randomInt(1, 2);
        break;
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 10);
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void killSound() {
    if (!this.in_view) {
      return;
    }
    String sound_name = "units/kill/";
    switch(this.ID) {
      case 1201: // Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1301: // Named Zombies
      case 1302:
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        sound_name += "zombie" + randomInt(0, 6);
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }

   public void tauntSound() {
    if (!this.in_view) {
      return;
    }
    String sound_name = "units/taunt/";
    switch(this.ID) {
      case 1101: // Ben Nelson
        break;
      case 1102: // Dan Gray
        break;
      default:
        return;
    }
    global.sounds.trigger_units(sound_name);
  }


   public void moveForward(float distance, AbstractGameMap map) {
    this.moveTo(this.x + this.facingX * distance, this.y + this.facingY * distance, map);
  }

   public void moveTo(float targetX, float targetY, AbstractGameMap map) {
    if (this.curr_action == UnitAction.USING_ITEM || this.curr_action == UnitAction.MOVING_AND_USING_ITEM) {
      this.curr_action = UnitAction.MOVING_AND_USING_ITEM;
    }
    else {
      this.curr_action = UnitAction.MOVING;
    }
    if (map != null) {
      this.startPathfindingThread(targetX, targetY, map);
    }
    this.object_targeting = null;
    this.last_move_collision = false;
    this.last_move_any_collision = false;
    this.curr_action_x = targetX;
    this.curr_action_y = targetY;
    this.curr_action_id = 0;
  }

   public void move(float timeElapsed, AbstractGameMap map, MoveModifier modifier) {
    // remove camouflage
    if (this.aposematicCamouflage()) {
      this.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGE);
    }
    if (this.aposematicCamouflageII()) {
      this.removeStatusEffect(StatusEffectCode.APOSEMATIC_CAMOUFLAGEII);
    }
    // calculate attempted move distances
    float seconds = timeElapsed / 1000.0f;
    float effectiveDistance = 0;
    switch(modifier) {
      case NONE:
        effectiveDistance = this.speed() * seconds;
        break;
      case SNEAK:
        effectiveDistance = Constants.unit_sneakSpeed * seconds;
        break;
      case RECOIL:
        effectiveDistance = -timeElapsed; // just use timeElapsed as the distance
        break;
      case AMPHIBIOUS_LEAP:
        effectiveDistance = Constants.ability_113_jumpSpeed * seconds;
        this.curr_height += Constants.ability_113_jumpHeight;
        break;
      case ANURAN_APPETITE:
        effectiveDistance = Constants.ability_115_regurgitateSpeed * seconds;
        break;
    }
    float tryMoveX = effectiveDistance * this.facingX;
    float tryMoveY = effectiveDistance * this.facingY;
    float startX = this.x;
    float startY = this.y;
    this.last_move_collision = false;
    this.last_move_any_collision = false;
    // move in x direction
    this.moveX(tryMoveX, tryMoveY, map);
    // move in y direction
    this.moveY(tryMoveX, tryMoveY, map);
    // calculates squares_on and height
    this.curr_squares_on = this.getSquaresOn();
    this.resolveFloorHeight(map);
    this.timer_resolve_floor_height = Constants.unit_timer_resolve_floor_height_cooldown;
    // move stat
    float moveX = this.x - startX;
    float moveY = this.y - startY;
    this.last_move_distance = sqrt(moveX * moveX + moveY * moveY);
    this.footgear_durability_distance -= this.last_move_distance;
    if (this.footgear_durability_distance < 0) {
      this.footgear_durability_distance += Constants.unit_footgearDurabilityDistance;
      if (this.footgear() != null) {
        this.footgear().lowerDurability();
      }
    }
  }

   public void moveX(float tryMoveX, float tryMoveY, AbstractGameMap map) {
    if (tryMoveX == 0) {
      return;
    }
    float originalTryMoveX = tryMoveX;
    float moveCapRatio = Constants.map_moveLogicCap / tryMoveX;
    float equivalentMoveY = moveCapRatio * tryMoveY;
    while(abs(tryMoveX) > Constants.map_moveLogicCap) {
      if (tryMoveX > 0) {
        if (this.collisionLogicX(Constants.map_moveLogicCap, equivalentMoveY, map)) {
          this.last_move_collision = true;
          this.last_move_any_collision = true;
          return;
        }
        tryMoveX -= Constants.map_moveLogicCap;
      }
      else {
        if (this.collisionLogicX(-Constants.map_moveLogicCap, -equivalentMoveY, map)) {
          this.last_move_collision = true;
          this.last_move_any_collision = true;
          return;
        }
        tryMoveX += Constants.map_moveLogicCap;
      }
    }
    moveCapRatio = tryMoveX / originalTryMoveX;
    equivalentMoveY = moveCapRatio * tryMoveY;
    if (this.collisionLogicX(tryMoveX, equivalentMoveY, map)) {
      this.last_move_collision = true;
      this.last_move_any_collision = true;
      return;
    }
    if (abs(this.facingX) < Constants.unit_small_facing_threshhold) {
      this.last_move_collision = true;
      this.last_move_any_collision = true;
    }
  }

   public void moveY(float tryMoveX, float tryMoveY, AbstractGameMap map) {
    if (tryMoveY == 0) {
      return;
    }
    float originalTryMoveY = tryMoveY;
    float moveCapRatio = Constants.map_moveLogicCap / tryMoveY;
    float equivalentMoveX = moveCapRatio * tryMoveX;
    while(abs(tryMoveY) > Constants.map_moveLogicCap) {
      if (tryMoveY > 0) {
        if (this.collisionLogicY(Constants.map_moveLogicCap, equivalentMoveX, map)) {
          this.last_move_any_collision = true;
          return;
        }
        tryMoveY -= Constants.map_moveLogicCap;
      }
      else {
        if (this.collisionLogicY(-Constants.map_moveLogicCap, equivalentMoveX, map)) {
          this.last_move_any_collision = true;
          return;
        }
        tryMoveY += Constants.map_moveLogicCap;
      }
    }
    moveCapRatio = tryMoveY / originalTryMoveY;
    equivalentMoveX = moveCapRatio * tryMoveX;
    if (this.collisionLogicY(tryMoveY, equivalentMoveX, map)) {
      this.last_move_any_collision = true;
      return;
    }
    if (abs(this.facingY) > Constants.unit_small_facing_threshhold) {
      this.last_move_collision = false;
    }
  }

  // returns true if collision occurs
   public boolean collisionLogicX(float tryMoveX, float equivalentMoveY, AbstractGameMap map) {
    float startX = this.x;
    this.x += tryMoveX;
    // map collisions
    if (!this.inMapX(map.mapXI(), map.mapXF())) {
      this.x = startX;
      return true;
    }
    if (this.ghosting()) {
      return false;
    }
    // terrain collisions
    ArrayList<IntegerCoordinate> squares_moving_on = this.getSquaresOn();
    int max_height = this.curr_height + this.walkHeight();
    for (IntegerCoordinate coordinate : squares_moving_on) {
      int coordinate_height = map.heightOfSquare(coordinate, true);
      if (coordinate_height <= max_height) {
        continue;
      }
      if (!this.currentlyOn(coordinate)) {
        this.x = startX;
        return true;
      }
      float s_x = coordinate.x + 0.5f;
      if ( (this.x > s_x && this.facingX > 0) || (this.x < s_x && this.facingX < 0) ) {
        continue;
      }
      float s_y = coordinate.y + 0.5f;
      float original_xDif = s_x - startX;
      float original_yDif = s_y - this.y;
      float original_distance = sqrt(original_xDif * original_xDif + original_yDif * original_yDif);
      float new_xDif = s_x - this.x;
      float new_yDif = s_y - this.y - equivalentMoveY;
      float new_distance = sqrt(new_xDif * new_xDif + new_yDif * new_yDif);
      if (new_distance > original_distance) {
        continue;
      }
      this.x = startX;
      return true;
    }
    // unit collisions
    for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
      if (entry.getKey() == this.map_key) {
        continue;
      }
      Unit u = entry.getValue();
      if (u.uncollidable()) {
        continue;
      }
      if (this.zf() <= u.zi() || u.zf() <= this.zi()) {
        continue;
      }
      float distance_to = this.distance(u);
      if (distance_to > 0) {
        continue;
      }
      if ( (this.x > u.x && this.facingX > 0) || (this.x < u.x && this.facingX < 0) ) {
        continue;
      }
      this.x = startX;
      return true;
    }
    return false;
  }

  // returns true if collision occurs
   public boolean collisionLogicY(float tryMoveY, float equivalentMoveX, AbstractGameMap map) {
    float startY = this.y;
    this.y += tryMoveY;
    // map collisions
    if (!this.inMapY(map.mapYI(), map.mapYF())) {
      this.y = startY;
      return true;
    }
    if (this.ghosting()) {
      return false;
    }
    // terrain collisions
    ArrayList<IntegerCoordinate> squares_moving_on = this.getSquaresOn();
    int max_height = this.curr_height + this.walkHeight();
    for (IntegerCoordinate coordinate : squares_moving_on) {
      int coordinate_height = map.heightOfSquare(coordinate, true);
      if (coordinate_height <= max_height) {
        continue;
      }
      if (!this.currentlyOn(coordinate)) {
        this.y = startY;
        return true;
      }
      float s_y = coordinate.y + 0.5f;
      if ( (this.y > s_y && this.facingY > 0) || (this.y < s_y && this.facingY < 0) ) {
        continue;
      }
      float s_x = coordinate.x + 0.5f;
      float original_xDif = s_x - this.x;
      float original_yDif = s_y - startY;
      float original_distance = sqrt(original_xDif * original_xDif + original_yDif * original_yDif);
      float new_xDif = s_x - this.x - equivalentMoveX;
      float new_yDif = s_y - this.y;
      float new_distance = sqrt(new_xDif * new_xDif + new_yDif * new_yDif);
      if (new_distance > original_distance) {
        continue;
      }
      this.y = startY;
      return true;
    }
    for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
      if (entry.getKey() == this.map_key) {
        continue;
      }
      Unit u = entry.getValue();
      if (u.uncollidable()) {
        continue;
      }
      if (this.zf() <= u.zi() || u.zf() <= this.zi()) {
        continue;
      }
      float distance_to = this.distance(u);
      if (distance_to > 0) {
        continue;
      }
      if ( (this.y > u.y && this.facingY > 0) || (this.y < u.y && this.facingY < 0) ) {
        continue;
      }
      this.y = startY;
      return true;
    }
    return false;
  }


   public void resolveFloorHeight(AbstractGameMap map) {
    this.floor_height = map.maxHeightOfSquares(this.curr_squares_on, false);
    this.unit_height = -100;
    for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
      if (entry.getKey() == this.map_key) {
        continue;
      }
      Unit u = entry.getValue();
      float distance_to = this.distance(u);
      if (distance_to > Constants.small_number) {
        continue;
      }
      if (u.zf() > this.zi()) {
        continue;
      }
      if (u.zf() > this.unit_height) {
        this.unit_height = u.zf();
      }
    }
    if (this.unit_height > this.floor_height) {
      this.floor_height = this.unit_height;
    }
    if (this.floor_height > this.curr_height) {
      this.curr_height = this.floor_height;
    }
    if (this.unit_height > map.maxHeight) {
      this.unit_height = map.maxHeight;
    }
    if (this.floor_height > map.maxHeight) {
      this.floor_height = map.maxHeight;
    }
    if (this.curr_height > map.maxHeight) {
      this.curr_height = map.maxHeight;
    }
  }


   public ArrayList<IntegerCoordinate> getSquaresSight(AbstractGameMap map) {
    ArrayList<IntegerCoordinate> squares_sight = new ArrayList<IntegerCoordinate>();
    float unit_sight = this.sight();
    float inner_square_distance = Constants.inverse_root_two * unit_sight;
    boolean walls_dont_block = false; // feature flag to make walls not block
    float see_around_cutoff = Constants.inverse_root_two + Constants.small_number;
    float see_around_blocked_cutoff = 2 * see_around_cutoff;
    float see_around_distance = see_around_cutoff - this.size;
    for (int i = PApplet.parseInt(floor(this.x - unit_sight)) - 1; i <= PApplet.parseInt(ceil(this.x + unit_sight)); i++) {
      for (int j = PApplet.parseInt(floor(this.y - unit_sight)) - 1; j <= PApplet.parseInt(ceil(this.y + unit_sight)); j++) {
        float distanceX = abs(i + 0.5f - this.x);
        float distanceY = abs(j + 0.5f - this.y);
        if ( (distanceX < inner_square_distance && distanceY < inner_square_distance) ||
          (sqrt(distanceX * distanceX + distanceY * distanceY) < unit_sight) ) {
          if (walls_dont_block) {
            squares_sight.add(new IntegerCoordinate(i, j));
            continue;
          }
          boolean add_square = true;
          int xi = round(min(floor(this.xi() + Constants.small_number), i));
          int yi = round(min(floor(this.yi() + Constants.small_number), j));
          int xf = round(max(floor(this.xf() - Constants.small_number), i));
          int yf = round(max(floor(this.yf() - Constants.small_number), j));
          int my_x = PApplet.parseInt(floor(this.x));
          int my_y = PApplet.parseInt(floor(this.y));
          float left_blocked = 2 * Constants.inverse_root_two;
          float right_blocked = 2 * Constants.inverse_root_two;
          for (int a = xi; a <= xf; a++) {
            for (int b = yi; b <= yf; b++) {
              if (a == i && b == j) {
                continue;
              }
              if (a == my_x && b == my_y) {
                continue;
              }
              try {
                if (map.mapSquare(a, b).passesLight()) {
                  continue;
                }
                float p_x = a + 0.5f;
                float p_y = b + 0.5f;
                float x_dif = i + 0.5f - this.x;
                float y_dif = j + 0.5f - this.y;
                float area_parrallelogram = x_dif * (p_y - this.y) - y_dif * (p_x - this.x);
                boolean left_side = true;
                if (area_parrallelogram < 0) {
                  left_side = false;
                  area_parrallelogram = abs(area_parrallelogram);
                }
                float line_segment_distance = sqrt(x_dif * x_dif + y_dif * y_dif);
                float distance_from_line = area_parrallelogram / line_segment_distance;
                if (distance_from_line < see_around_distance) {
                  add_square = false;
                  break;
                }
                else if (distance_from_line < see_around_blocked_cutoff) {
                  if (left_side) {
                    if (distance_from_line < left_blocked) {
                      left_blocked = distance_from_line;
                    }
                  }
                  else {
                    if (distance_from_line < right_blocked) {
                      right_blocked = distance_from_line;
                    }
                  }
                  if (left_blocked + right_blocked < see_around_blocked_cutoff) {
                    add_square = false;
                    break;
                  }
                }
              } catch(Exception e) {}
            }
            if (!add_square) {
              break;
            }
          }
          if (add_square) {
            squares_sight.add(new IntegerCoordinate(i, j));
          }
        }
      }
    }
    return squares_sight;
  }

  // Only checks terrain collisions, used in pathfinding at end to patch initial collision artifact
   public boolean willCollideMovingTo(float target_x, float target_y, AbstractGameMap map) {
    int xi = round(min(floor(this.xi() + Constants.small_number), target_x));
    int yi = round(min(floor(this.yi() + Constants.small_number), target_y));
    int xf = round(max(floor(this.xf() - Constants.small_number), target_x));
    int yf = round(max(floor(this.yf() - Constants.small_number), target_y));
    for (int a = xi; a <= xf; a++) {
      for (int b = yi; b <= yf; b++) {
      }
    }
    return false;
  }


   public int zi() {
    return this.curr_height;
  }
   public int zf() {
    return this.curr_height + this.sizeZ;
  }
   public int zHalf() {
    return this.curr_height + PApplet.parseInt(ceil(this.sizeZ));
  }


   public boolean canMoveUp(int height_difference) {
    if (height_difference > this.walkHeight()) {
      return false;
    }
    return true;
  }

   public boolean currentlyOn(IntegerCoordinate coordinate) {
    for (IntegerCoordinate coordinate_on : this.curr_squares_on) {
      if (coordinate_on.equals(coordinate)) {
        return true;
      }
    }
    return false;
  }


   public void aiLogic(int timeElapsed, AbstractGameMap map) {
    switch(this.ID) {
      case 1002: // Chicken
        if (this.curr_action == UnitAction.NONE || this.last_move_collision) {
          this.curr_action = UnitAction.NONE;
          this.timer_ai_action1 -= timeElapsed;
          this.timer_ai_action2 -= timeElapsed;
          if (this.timer_ai_action3 > 0) {
            this.timer_ai_action3 -= timeElapsed;
            if (this.timer_ai_action3 <= 0) {
              this.ai_toggle = false;
            }
          }
          if (this.timer_ai_action1 < 0) {
            float other_chicken_face_x = 0;
            float other_chicken_face_y = 0;
            int other_chickens_moved_from = 0;
            if (!this.ai_toggle) {
              this.timer_ai_action3 = 0;
              for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
                if (entry.getKey() == this.map_key) {
                  continue;
                }
                Unit u = entry.getValue();
                if (u.ID != 1002 && u.ID != 1003) {
                  continue;
                }
                if (!u.ai_toggle) {
                  continue;
                }
                if (randomChance(0.3f)) {
                  continue;
                }
                if (this.distance(u) > this.sight()) {
                  continue;
                }
                this.ai_toggle = true;
                this.timer_ai_action3 = PApplet.parseInt(0.5f * (this.timer_ai_action3 + u.timer_ai_action3));
                other_chickens_moved_from++;
                other_chicken_face_x += u.facingX;
                other_chicken_face_y += u.facingY;
              }
            }
            this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
            if (other_chickens_moved_from > 0) {
              other_chicken_face_x /= other_chickens_moved_from;
              other_chicken_face_y /= other_chickens_moved_from;
              this.refreshStatusEffect(StatusEffectCode.RUNNING, 0.8f * Constants.ai_chickenTimer1);
              this.moveTo(this.x + other_chicken_face_x * Constants.ai_chickenMoveDistance +
                randomFloat(-1, 1), other_chicken_face_y * Constants.ai_chickenMoveDistance +
                randomFloat(-1, 1), map);
            }
            else {
              this.moveTo(this.x + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance),
                this.y + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance), map);
            }
          }
          if (this.timer_ai_action2 < 0) {
            this.timer_ai_action2 = PApplet.parseInt(Constants.ai_chickenTimer2 + random(Constants.ai_chickenTimer2));
            Item egg_item = new Item(2118, this.x, this.y);
            if (this.fertilized() || randomChance(0.2f)) {
              egg_item.toggled = true;
            }
            map.addItem(egg_item);
            if (this.in_view) {
              global.sounds.trigger_units("units/other/chicken_lay_egg");
            }
          }
        }
        break;
      case 1003: // Chick
        if (this.curr_action == UnitAction.NONE || this.last_move_collision) {
          this.timer_ai_action1 -= timeElapsed;
          this.timer_ai_action2 -= timeElapsed;
          if (this.timer_ai_action3 > 0) {
            this.timer_ai_action3 -= timeElapsed;
            if (this.timer_ai_action3 <= 0) {
              this.ai_toggle = false;
            }
          }
          if (this.timer_ai_action1 < 0) {
            float other_chicken_face_x = 0;
            float other_chicken_face_y = 0;
            int other_chickens_moved_from = 0;
            if (!this.ai_toggle) {
              this.timer_ai_action3 = 0;
              for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
                if (entry.getKey() == this.map_key) {
                  continue;
                }
                Unit u = entry.getValue();
                if (u.ID != 1002 && u.ID != 1003) {
                  continue;
                }
                if (!u.ai_toggle) {
                  continue;
                }
                if (randomChance(0.1f)) {
                  continue;
                }
                if (this.distance(u) > this.sight()) {
                  continue;
                }
                this.ai_toggle = true;
                this.timer_ai_action3 = PApplet.parseInt(0.5f * (this.timer_ai_action3 + u.timer_ai_action3));
                other_chickens_moved_from++;
                other_chicken_face_x += u.facingX;
                other_chicken_face_y += u.facingY;
              }
            }
            this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
            if (other_chickens_moved_from > 0) {
              other_chicken_face_x /= other_chickens_moved_from;
              other_chicken_face_y /= other_chickens_moved_from;
              this.refreshStatusEffect(StatusEffectCode.RUNNING, 0.8f * Constants.ai_chickenTimer1);
              this.moveTo(this.x + other_chicken_face_x * Constants.ai_chickenMoveDistance +
                randomFloat(-1, 1), other_chicken_face_y * Constants.ai_chickenMoveDistance +
                randomFloat(-1, 1), map);
            }
            else {
              this.moveTo(this.x + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance),
                this.y + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance), map);
            }
          }
          if (this.timer_ai_action2 < 0) {
            this.timer_ai_action2 = PApplet.parseInt(Constants.ai_chickenTimer2 + random(Constants.ai_chickenTimer2));
            if (randomChance(0.5f)) {
              this.setUnitID(1002);
            }
            else {
              this.setUnitID(1005);
            }
            this.size = Constants.unit_defaultSize;
          }
        }
        break;
      case 1005: // Rooster
        if (this.curr_action == UnitAction.NONE || this.last_move_collision) {
          this.timer_ai_action1 -= timeElapsed;
          this.timer_ai_action2 -= timeElapsed;
          if (this.timer_ai_action1 < 0) {
            boolean random_walk = true;
            for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
              if (entry.getKey() == this.map_key) {
                continue;
              }
              Unit u = entry.getValue();
              if (u.ID != 1002 && u.ID != 1003) {
                continue;
              }
              if (!u.ai_toggle) {
                continue;
              }
              if (u.timer_ai_action3 <= 0) {
                continue;
              }
              if (this.distance(u) > this.sight()) {
                continue;
              }
              if (u.last_damage_from == null || u.last_damage_from.remove) {
                continue;
              }
              if (this.distance(u.last_damage_from) > this.sight()) {
                continue;
              }
              try {
                this.target(u.last_damage_from, map);
                random_walk = false;
              } catch(Exception e) {}
              break;
            }
            if (random_walk) {
              this.timer_ai_action1 = PApplet.parseInt(Constants.ai_chickenTimer1 + random(Constants.ai_chickenTimer1));
              this.moveTo(this.x + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance),
                this.y + Constants.ai_chickenMoveDistance - 2 * random(Constants.ai_chickenMoveDistance), map);
            }
          }
          if (this.timer_ai_action2 < 0) {
            this.timer_ai_action2 = PApplet.parseInt(0.4f * Constants.ai_chickenTimer2 + 0.4f * random(Constants.ai_chickenTimer2));
            if (this.in_view) {
              global.sounds.trigger_units("units/other/rooster_crow" + randomInt(1, 3));
            }
          }
        }
        break;
      case 1201: // Tier I Zombies
      case 1202:
      case 1203:
      case 1204:
      case 1205:
      case 1206:
      case 1207:
      case 1208:
      case 1209:
      case 1210:
      case 1291: // Auto-spawned Zombies
      case 1292:
      case 1293:
      case 1302: // Tier I Named Zombies
      case 1303:
      case 1304:
      case 1305:
      case 1306:
      case 1307:
      case 1308:
        if (this.curr_action == UnitAction.NONE || this.last_move_collision) {
          this.timer_ai_action1 -= timeElapsed;
          if (this.timer_ai_action1 < 0) {
            this.timer_ai_action1 = 400;
            boolean no_target = true;
            for (Map.Entry<Integer, Unit> entry : map.units.entrySet()) {
              if (entry.getKey() == this.map_key) {
                continue;
              }
              Unit u = entry.getValue();
              if (u.alliance == this.alliance) {
                continue;
              }
              float distance = this.distance(u);
              if (distance > this.sight()) {
                continue;
              }
              if (no_target) {
                no_target = false;
                this.target(u, map);
              }
              else if (!u.ai_controlled) {
                this.target(u, map);
              }
            }
            if (no_target && randomChance(0.1f)) {
              this.moveTo(this.x + 3 - random(6), this.y + 3 - random(6), map);
            }
          }
        }
        break;
      case 1311: // Cathy Heck
        if (!this.ai_toggle) {
          break;
        }
        this.timer_ai_action1 -= timeElapsed;
        this.timer_ai_action2 -= timeElapsed;
        this.timer_ai_action3 -= timeElapsed;
        switch(this.curr_action) {
          case NONE:
            if (map.units.containsKey(0)) {
              this.target(map.units.get(0), map);
            }
            break;
          case TARGETING_UNIT:
            if (this.timer_ai_action3 < 0) {
              this.timer_ai_action3 = round(9000 + random(9000));
              if (this.object_targeting == null || this.object_targeting.remove) {
                break;
              }
              if (this.distance(this.object_targeting) > Constants.ability_1003_size_w * 1.3f) {
                break;
              }
              this.cast(2, map);
            }
            else if (this.timer_ai_action2 < 0) {
              this.timer_ai_action2 = round(9000 + random(9000));
              this.cast(1, map);
            }
            else if (this.timer_ai_action1 < 0) {
              this.timer_ai_action1 = round(9000 + random(9000));
              this.cast(0, map);
            }
            break;
        }
        break;
      default:
        break;
    }
  }


   public String fileString() {
    return this.fileString(true);
  }
   public String fileString(boolean include_headers) {
    String fileString = "";
    if (include_headers) {
      fileString += "\nnew: Unit: " + this.ID;
    }
    fileString += this.objectFileString();
    fileString += "\nsize: " + this.size;
    fileString += "\nlevel: " + this.level;
    fileString += "\nalliance: " + this.alliance.alliance_name();
    fileString += "\nelement: " + this.element.element_name();
    for (Map.Entry<GearSlot, Item> slot : this.gear.entrySet()) {
      fileString += "\ngearSlot: " + slot.getKey();
      if (slot.getValue() != null) {
        fileString += slot.getValue().fileString(slot.getKey());
      }
    }
    for (Map.Entry<StatusEffectCode, StatusEffect> entry : this.statuses.entrySet()) {
      fileString += "\nnext_status_code: " + entry.getKey().code_name();
      fileString += entry.getValue().fileString();
    }
    fileString += "\nfacingX: " + this.facingX;
    fileString += "\nfacingY: " + this.facingY;
    fileString += "\nfacingA: " + this.facingA;
    if (this.save_base_stats) {
      fileString += "\nsave_base_stats: " + this.save_base_stats;
      fileString += "\nbase_health: " + this.base_health;
      fileString += "\nbase_attack: " + this.base_attack;
      fileString += "\nbase_magic: " + this.base_magic;
      fileString += "\nbase_defense: " + this.base_defense;
      fileString += "\nbase_resistance: " + this.base_resistance;
      fileString += "\nbase_piercing: " + this.base_piercing;
      fileString += "\nbase_penetration: " + this.base_penetration;
      fileString += "\nbase_attackRange: " + this.base_attackRange;
      fileString += "\nbase_attackCooldown: " + this.base_attackCooldown;
      fileString += "\nbase_attackTime: " + this.base_attackTime;
      fileString += "\nbase_sight: " + this.base_sight;
      fileString += "\nbase_speed: " + this.base_speed;
      fileString += "\nbase_tenacity: " + this.base_tenacity;
      fileString += "\nbase_agility: " + this.base_agility;
      fileString += "\nbase_lifesteal: " + this.base_lifesteal;
    }
    if (this.save_base_stats || abs(this.curr_health - this.health()) > Constants.small_number) {
      fileString += "\ncurr_health: " + this.curr_health;
    }
    fileString += "\nfootgear_durability_distance: " + this.footgear_durability_distance;
    fileString += "\ntimer_attackCooldown: " + this.timer_attackCooldown;
    fileString += "\ntimer_actionTime: " + this.timer_actionTime;
    fileString += "\nai_toggle: " + this.ai_toggle;
    if (include_headers) {
      fileString += "\nend: Unit\n";
    }
    return fileString;
  }

   public void addData(String datakey, String data) {
    if (this.addObjectData(datakey, data)) {
      return;
    }
    switch(datakey) {
      case "size":
        this.size = toFloat(data);
        break;
      case "level":
        this.setLevel(toInt(data));
        break;
      case "alliance":
        this.alliance = Alliance.alliance(data);
        break;
      case "element":
        this.element = Element.element(data);
        break;
      case "gearSlot":
        this.gear.put(GearSlot.gearSlot(data), null);
        break;
      case "facingX":
        this.facingX = toFloat(data);
        break;
      case "facingY":
        this.facingY = toFloat(data);
        break;
      case "facingA":
        this.facingA = toFloat(data);
        break;
      case "addNullAbility":
        this.abilities.add(null);
        break;
      case "save_base_stats":
        this.save_base_stats = toBoolean(data);
        break;
      case "base_health":
        this.base_health = toFloat(data);
        break;
      case "base_attack":
        this.base_attack = toFloat(data);
        break;
      case "base_magic":
        this.base_magic = toFloat(data);
        break;
      case "base_defense":
        this.base_defense = toFloat(data);
        break;
      case "base_resistance":
        this.base_resistance = toFloat(data);
        break;
      case "base_piercing":
        this.base_piercing = toFloat(data);
        break;
      case "base_penetration":
        this.base_penetration = toFloat(data);
        break;
      case "base_attackRange":
        this.base_attackRange = toFloat(data);
        break;
      case "base_attackCooldown":
        this.base_attackCooldown = toFloat(data);
        break;
      case "base_attackTime":
        this.base_attackTime = toFloat(data);
        break;
      case "base_sight":
        this.base_sight = toFloat(data);
        break;
      case "base_speed":
        this.base_speed = toFloat(data);
        break;
      case "base_tenacity":
        this.base_tenacity = toFloat(data);
        break;
      case "base_agility":
        this.base_agility = toInt(data);
        break;
      case "base_lifesteal":
        this.base_lifesteal = toFloat(data);
        break;
      case "curr_health":
        this.curr_health = toFloat(data);
        break;
      case "footgear_durability_distance":
        this.footgear_durability_distance = toFloat(data);
        break;
      case "timer_attackCooldown":
        this.timer_attackCooldown = toFloat(data);
        break;
      case "timer_actionTime":
        this.timer_actionTime = toFloat(data);
        break;
      case "ai_toggle":
        this.ai_toggle = toBoolean(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for unit data.");
        break;
    }
  }


   public int tier() {
    return 1 + PApplet.parseInt(floor(this.level / 10));
  }
}
class VisualEffect extends MapObject {
  protected float size_width = 0;
  protected float size_height = 0;
  protected float timer = 0;
  protected boolean scale_size = true;

  VisualEffect(int ID) {
    this(ID, 0, 0);
  }
  VisualEffect(int ID, float x, float y) {
    super(ID);
    this.setLocation(x, y);
    switch(ID) {
      // gifs
      case 4001: // move gif
        this.setValues(1.3f * global.configuration.cursor_size,
          1.3f * global.configuration.cursor_size, Constants.gif_move_time);
        this.scale_size = false;
        break;
      case 4002: // chuck quizmo poof
        this.setValues(1, 1, 1200 + Constants.gif_poof_time);
        break;
      case 4003: // amphibious leap land
        this.setValues(2 * Constants.ability_113_splashRadius, 2 * Constants.
          ability_113_splashRadius, Constants.gif_amphibiousLeap_time);
        break;
      case 4004: // amphibious leap drenched land
        this.setValues(2 * Constants.ability_113_drenchedSplashRadius, 2 * Constants.
          ability_113_drenchedSplashRadius, Constants.gif_amphibiousLeap_time);
        break;
      case 4005: // amphibious leap II land
        this.setValues(2 * Constants.ability_118_splashRadius, 2 * Constants.
          ability_118_splashRadius, Constants.gif_amphibiousLeap_time);
        break;
      case 4006: // amphibious leap II drenched land
        this.setValues(2 * Constants.ability_118_drenchedSplashRadius, 2 * Constants.
          ability_118_drenchedSplashRadius, Constants.gif_amphibiousLeap_time);
        break;
      case 4007: // alkaloid secretion
        this.setValues(2 * Constants.ability_114_range, 2 * Constants.ability_114_range, 100);
        break;
      case 4008: // alkaloid secretion II
        this.setValues(2 * Constants.ability_119_range, 2 * Constants.ability_119_range, 100);
        break;
      case 4009: // chat bubble
        this.setValues(0.8f, 0.8f, 1000);
        break;
      case 4010: // war machine explosion
        this.setValues(2 * Constants.projectile_grenadeExplosionRadius, 2 *
          Constants.projectile_grenadeExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      case 4011: // mustang and sally explosion
        this.setValues(2 * Constants.projectile_mustangAndSallyExplosionRadius, 2 *
          Constants.projectile_mustangAndSallyExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      case 4012: // RPG explosion
        this.setValues(2 * Constants.projectile_rpgExplosionRadius, 2 *
          Constants.projectile_rpgExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      case 4013: // dystopic demolisher explosion
        this.setValues(2 * Constants.projectile_grenadeExplosionRadius, 2 *
          Constants.projectile_grenadeExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      case 4014: // rocket-propelled grievance
        this.setValues(2 * Constants.projectile_rpgIIExplosionRadius, 2 *
          Constants.projectile_rpgIIExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      case 4015: // ray gun explosion
        this.setValues(2 * Constants.projectile_rayGunExplosionRadius, 2 *
          Constants.projectile_rayGunExplosionRadius, Constants.gif_explosionGreen_time);
        break;
      case 4016: // porter's x2 ray gun explosion
        this.setValues(2 * Constants.projectile_rayGunIIExplosionRadius, 2 *
          Constants.projectile_rayGunIIExplosionRadius, Constants.gif_explosionGreen_time);
        break;
      case 4017: // grenade (thrown) explosion
        this.setValues(2 * Constants.projectile_grenadeExplosionRadius, 2 *
          Constants.projectile_grenadeExplosionRadius, Constants.gif_explosionNormal_time);
        break;
      default:
        global.errorMessage("ERROR: VisualEffect ID " + ID + " not found.");
        break;
    }
  }

   public void setValues(float size_width, float size_height, float timer) {
    this.size_width = size_width;
    this.size_height = size_height;
    this.timer = timer;
  }

   public String display_name() {
    return this.display_name;
  }
   public String type() {
    return this.type;
  }
   public String description() {
    return this.description;
  }
   public String selectedObjectTextboxText() {
    String text = "-- " + this.type() + " --";
    return text + "\n\n" + this.description();
  }

   public void setLocation(float x, float y) {
    this.x = x;
    this.y = y;
  }

   public float xi() {
    return this.x - 0.5f * this.size_width;
  }
   public float yi() {
    return this.y - 0.5f * this.size_height;
  }
   public float xf() {
    return this.x + 0.5f * this.size_width;
  }
   public float yf() {
    return this.y + 0.5f * this.size_height;
  }
   public float xCenter() {
    return this.x;
  }
   public float yCenter() {
    return this.y;
  }
   public float width() {
    return this.size_width;
  }
   public float height() {
    return this.size_height;
  }
   public float xRadius() {
    return 0.5f * this.size_width;
  }
   public float yRadius() {
    return 0.5f * this.size_height;
  }

  @Override public 
  float distance(MapObject object) {
    float xDistance = max(0, abs(this.xCenter() - object.xCenter()) - object.xRadius());
    float yDistance = max(0, abs(this.yCenter() - object.yCenter()) - object.yRadius());
    return sqrt(xDistance * xDistance + yDistance * yDistance);
  }

  @Override public 
  boolean touching(MapObject object) {
    if ( ((abs(this.xCenter() - object.xCenter()) - object.xRadius()) <= 0) ||
      ((abs(this.yCenter() - object.yCenter()) - object.yRadius()) <= 0) ) {
        return true;
    }
    return false;
  }

   public PImage getImage() {
    String path = "gifs/";
    int frame = 0;
    switch(this.ID) {
      case 4001:
        path += "move/";
        frame = PApplet.parseInt(floor(Constants.gif_move_frames *
          (1.0f - this.timer / (1 + Constants.gif_move_time))));
        path += frame + ".png";
        break;
      case 4002:
        if (this.timer > Constants.gif_poof_time) {
          path = "features/chuck_quizmo.png";
        }
        else {
          this.size_width = 1.6f;
          path += "poof/";
          frame = PApplet.parseInt(floor(Constants.gif_poof_frames *
            (1.0f - this.timer / (1 + Constants.gif_poof_time))));
          path += frame + ".png";
        }
        break;
      case 4003:
      case 4004:
      case 4005:
      case 4006:
        path += "amphibious_leap/";
        frame = PApplet.parseInt(floor(Constants.gif_amphibiousLeap_frames *
          (1.0f - this.timer / (1 + Constants.gif_amphibiousLeap_time))));
        path += frame + ".png";
        break;
      case 4009:
        path = "icons/chat.png";
        break;
      case 4010:
      case 4011:
      case 4012:
      case 4013:
      case 4014:
      case 4017:
        path += "explosion_normal/";
        frame = PApplet.parseInt(floor(Constants.gif_explosionNormal_frames *
          (1.0f - this.timer / (1 + Constants.gif_explosionNormal_time))));
        path += frame + ".png";
        break;
      case 4015:
      case 4016:
        path += "explosion_green/";
        frame = PApplet.parseInt(floor(Constants.gif_explosionGreen_frames *
          (1.0f - this.timer / (1 + Constants.gif_explosionGreen_time))));
        path += frame + ".png";
        break;
      default:
        global.errorMessage("ERROR: Visual Effect ID " + ID + " not found.");
        path = "default.png";
        break;
    }
    return global.images.getImage(path);
  }


   public boolean targetable(Unit u) {
    return false;
  }


   public void update(int timeElapsed) {
    this.timer -= timeElapsed;
    if (this.timer < 0) {
      this.remove = true;
    }
  }


   public void display(float zoom) {
    float range = 0;
    switch(this.ID) {
      case 4007:
      case 4008:
        ellipseMode(CENTER);
        fill(98, 52, 18, 130);
        noStroke();
        ellipse(0, 0, this.size_width * zoom, this.size_height * zoom);
        break;
      case 4003:
      case 4004:
      case 4005:
      case 4006:
        ellipseMode(CENTER);
        fill(98, 52, 18, 100);
        noStroke();
        ellipse(0, 0, this.size_width * zoom, this.size_height * zoom);
      default:
        if (this.scale_size) {
          image(this.getImage(), 0, 0, this.size_width * zoom, this.size_height * zoom);
        }
        else {
          image(this.getImage(), 0, 0, this.size_width, this.size_height);
        }
        break;
    }
  }


   public String fileString() {
    String fileString = "\nnew: VisualEffect: " + this.ID;
    fileString += this.objectFileString();
    fileString += "\nsize_width: " + this.size_width;
    fileString += "\nsize_height: " + this.size_height;
    fileString += "\ntimer: " + this.timer;
    fileString += "\nend: VisualEffect\n";
    return fileString;
  }

   public void addData(String datakey, String data) {
    if (this.addObjectData(datakey, data)) {
      return;
    }
    switch(datakey) {
      case "size_width":
        this.size_width = toFloat(data);
        break;
      case "size_height":
        this.size_height = toFloat(data);
        break;
      case "timer":
        this.timer = toFloat(data);
        break;
      default:
        global.errorMessage("ERROR: Datakey " + datakey + " not found for visual effect data.");
        break;
    }
  }
}


  public void settings() { fullScreen(FX2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "LNZ" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
