/* autogenerated by Processing revision 1281 on 2022-03-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.io.*;
import java.nio.file.*;
import processing.javafx.*;
import ddf.minim.*;
import ddf.minim.ugens.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class LNZ extends PApplet {








Global global;

 public void setup() {
  /* size commented out by preprocessor */;
  surface.setSize(Constants.initialInterface_size, Constants.initialInterface_size);
  surface.setLocation(PApplet.parseInt(0.5f * (displayWidth - Constants.initialInterface_size)),
    PApplet.parseInt(0.5f * (displayHeight - Constants.initialInterface_size)));
  frameRate(Constants.maxFPS);
  global = new Global(this);
  background(global.color_background);
  global.menu = new InitialInterface();
  deleteFolder("data/maps");
  //mkdir("data/maps", true);
}

 public void draw() {
  int timeElapsed = global.frame();
  // FPS counter
  global.timer_FPS -= timeElapsed;
  if (global.timer_FPS < 0) {
    global.timer_FPS = Constants.frameUpdateTime;
    global.lastFPS = (Constants.frameAverageCache * global.lastFPS + PApplet.parseFloat(frameCount - global.frameCounter) *
      (1000.0f / Constants.frameUpdateTime)) / (Constants.frameAverageCache + 1);
    global.frameCounter = frameCount + 1;
    //println(int(global.lastFPS) + " FPS");
  }
  // Program
  if (global.menu != null) {
    global.menu.update(millis());
  }
  switch(global.state) {
    case INITIAL_INTERFACE:
      break;
    case ENTERING_MAINMENU:
      global.state = ProgramState.MAINMENU_INTERFACE;
      global.menu = new MainMenuInterface();
      break;
    case MAINMENU_INTERFACE:
      break;
    case EXITING:
      global.timer_exiting -= timeElapsed;
      if (global.timer_exiting < 0) {
        exit();
      }
      break;
    default:
      break;
  }
}

 public void mouseDragged() {
  if (global.menu != null) {
    global.menu.mouseMove(mouseX, mouseY);
  }
}
 public void mouseMoved() {
  if (global.menu != null) {
    global.menu.mouseMove(mouseX, mouseY);
  }
}

 public void mousePressed() {
  if (global.menu != null) {
    global.menu.mousePress();
  }
}

 public void mouseReleased() {
  if (global.menu != null) {
    global.menu.mouseRelease();
  }
}
static class Constants {

  // Program constants
  static final String credits =
  "Liberal Nazi Zombies" +
  "20220303: v0.6.0r" +
  "Created by Daniel Gray" +
  "";
  static final String version_history =
  "Liberal Nazi Zombies" +
  "Created by Daniel Gray" +
  "???: v0.7: Recovery Version" +
  "20220228: v0.6: Advanced Mechanics" +
  "202202: v0.5: Recreate Logic" +
  "202201: v0.4: Recreate Program" +
  "2019: v0.3: Legacy Version" +
  "";
  static final int frameUpdateTime = 100;
  static final int frameAverageCache = 5;
  static final int maxFPS = 120;
  static final int exit_delay = 300;

  // Initial Interface
  static final int initialInterface_size = 400;
  static final int initialInterface_buttonWidth = 80;
  static final int initialInterface_buttonGap = 25;

}
class DImg {

  PImage img = null;
  int imgMode = CORNERS;
  int gridX = 0;
  int gridY = 0;

  // Constructor for blank image
  DImg(int x, int y) {
    this.img = createImage(x, y, ARGB);
  }
  DImg(PImage img) {
    this.img = img;
  }

   public void mode(int imgMode) {
    switch(imgMode) {
      case CORNERS:
      case CORNER:
      case CENTER:
        this.imgMode = imgMode;
        break;
      default:
        print("ERROR: imgMode invalid");
        break;
    }
  }

   public void setGrid(int x, int y) {
    this.gridX = x;
    this.gridY = y;
  }

  // Display functions
   public void display(float x, float y) {
    imageMode(this.imgMode);
    image(this.img, x, y);
  }
   public void display(float xi, float yi, float xf, float yf) {
    imageMode(this.imgMode);
    image(this.img, xi, yi, xf, yf);
  }

  // Return part of an image
   public PImage getImageSection(PImage img, int x, int y, int w, int h) {
    return img.get(x, y, w, h);
  }

  // Add image to part of this using width / height
   public void addImage(PImage newImg, int x, int y, int w, int h) {
   this.img.copy(newImg, 0, 0, newImg.width, newImg.height, x, y, w, h);
  }
  // Add image to part of this using percent of width / height
   public void addImagePercent(PImage newImg, float xP, float yP, float wP, float hP) {
    if (xP < 0.0f || yP < 0.0f || wP < 0.0f || hP < 0.0f || xP > 1.0f || yP > 1.0f || wP > 1.0f || hP > 1.0f) {
      println("ERROR: addImagePercent coordinates out of range");
      return;
    }
    this.img.copy(newImg, 0, 0, newImg.width, newImg.height,
      round(this.img.width * xP), round(this.img.height * yP),
      round(this.img.width * wP), round(this.img.height * hP));
  }
  // Add image to grid square
   public void addImageGrid(PImage newImg, int x, int y) {
    if (x < 0 || y < 0 || x >= this.gridX || y >= this.gridY) {
      println("ERROR: addImageGrid coordinate out of range");
      return;
    }
    this.img.copy(newImg, 0, 0, newImg.width, newImg.height,
      round(this.img.width * (PApplet.parseFloat(x) / this.gridX)),
      round(this.img.height * (PApplet.parseFloat(y) / this.gridY)),
      this.img.width / this.gridX, this.img.height / this.gridY);
  }
   public void addImageGrid(PImage newImg, int x, int y, int w, int h) {
    if (x < 0 || y < 0 || x >= this.gridX || y >= this.gridY) {
      println("ERROR: addImageGrid coordinate out of range");
      return;
    }
    if (w < 1 || h < 1 || x + w >= this.gridX || y + h >= this.gridY) {
      print("ERROR: addImageGrid coordinate our of range");
      return;
    }
    this.img.copy(newImg, 0, 0, newImg.width, newImg.height,
      round(this.img.width * (PApplet.parseFloat(x) / this.gridX)),
      round(this.img.height * (PApplet.parseFloat(y) / this.gridY)),
      w * (this.img.width / this.gridX), h * (this.img.height / this.gridY));
  }

  // convolution
   public void convolution(float[][] matrix) {
    if (matrix.length % 2 != 1 || matrix[0].length % 2 != 1) {
      println("ERROR: convolution matrix invalid size.");
      return;
    }
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        float r_total = 0;
        float g_total = 0;
        float b_total = 0;
        for (int i_offset = 0; i_offset < matrix[0].length; i_offset++) {
          for (int j_offset = 0; j_offset < matrix.length; j_offset++) {
            int i_corrected = constrain(i + i_offset - matrix[0].length / 2, 0, this.img.height);
            int j_corrected = constrain(j + j_offset - matrix.length / 2, 0, this.img.width);
            int index_offset = constrain(i_corrected * this.img.width + j_corrected, 0, this.img.pixels.length - 1);
            float factor = matrix[i_offset][j_offset];
            r_total += factor * (this.img.pixels[index_offset] >> 16 & 0xFF);
            g_total += factor * (this.img.pixels[index_offset] >> 8 & 0xFF);
            b_total += factor * (this.img.pixels[index_offset] & 0xFF);
          }
        }
        r_total = constrain(r_total, 0, 255);
        g_total = constrain(g_total, 0, 255);
        b_total = constrain(b_total, 0, 255);
        this.img.pixels[index] = color(r_total, g_total, b_total);
      }
    }
    this.img.updatePixels();
  }
   public void blur() {
    this.convolution(new float[][]{{1.0f/9, 1.0f/9, 1.0f/9}, {1.0f/9, 1.0f/9, 1.0f/9}, {1.0f/9, 1.0f/9, 1.0f/9}});
  }
   public void sharpen() {
    this.convolution(new float[][]{{-1, -1, -1}, {-1, 9, -1}, {-1, -1, -1}});
  }

  // Brighten
   public void brighten(float factor) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        int c = this.img.pixels[index];
        float r = constrain((c >> 16 & 0xFF) * factor, 0, 255);
        float g = constrain((c >> 8 & 0xFF) * factor, 0, 255);
        float b = constrain((c & 0xFF) * factor, 0, 255);
        float a = alpha(c);
        this.img.pixels[index] = color(r, g, b, a);
      }
    }
    this.img.updatePixels();
  }

   public void brightenGradient(float factor, float gradientDistance, float x, float y) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        float distance = sqrt((i - y) * (i - y) + (j - x) * (j - x));
        float curr_factor = factor;
        if (distance < gradientDistance) {
          curr_factor = 1 + (factor - 1) * distance / gradientDistance;
        }
        int c = this.img.pixels[index];
        float r = constrain((c >> 16 & 0xFF) * curr_factor, 0, 255);
        float g = constrain((c >> 8 & 0xFF) * curr_factor, 0, 255);
        float b = constrain((c & 0xFF) * curr_factor, 0, 255);
        int col = ccolor(PApplet.parseInt(r), PApplet.parseInt(g), PApplet.parseInt(b), 254);
        this.img.pixels[index] = col;
      }
    }
    this.img.updatePixels();
  }

  // transparent
   public void makeTransparent() {
    this.makeTransparent(0);
  }
   public void makeTransparent(int alpha) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        float r = this.img.pixels[index] >> 16 & 0xFF;
        float g = this.img.pixels[index] >> 8 & 0xFF;
        float b = this.img.pixels[index] & 0xFF;
        this.img.pixels[index] = ccolor(PApplet.parseInt(r), PApplet.parseInt(g), PApplet.parseInt(b), alpha);
      }
    }
    this.img.updatePixels();
  }
   public void transparencyGradientFromPoint(float x, float y, float distance) {
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        float r = this.img.pixels[index] >> 16 & 0xFF;
        float g = this.img.pixels[index] >> 8 & 0xFF;
        float b = this.img.pixels[index] & 0xFF;
        float curr_distance = sqrt((i - y) * (i - y) + (j - x) * (j - x));
        float alpha = 0;
        if (curr_distance < distance) {
          alpha = 255 * (1 - curr_distance / distance);
        }
        this.img.pixels[index] = color(r, g, b, alpha);
      }
    }
    this.img.updatePixels();
  }

  // color pixels
   public void colorPixels(int c) {
    /*float ref_r = c >> 16 & 0xFF;
    float ref_g = c >> 8 & 0xFF;
    float ref_b = c & 0xFF;
    float ref_a = alpha(c);*/
    this.img.loadPixels();
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        int index = i * this.img.width + j;
        if (index == 0) {
          continue;
        }
        this.img.pixels[index] = c; //color(ref_r, ref_g, ref_b, ref_a);
      }
    }
    this.img.updatePixels();
  }

   public void colorPixel(int x, int y, int c) {
    this.img.loadPixels();
    int index = x + y * this.img.width;
    if (index < 1 || index >= this.img.pixels.length) {
      return;
    }
    this.img.pixels[index] = c;
    this.img.updatePixels();
  }
}
abstract class Button {
  // state
  protected boolean hidden = false;
  protected boolean disabled = false;
  protected boolean hovered = false;
  protected boolean clicked = false;
  // colors
  protected int color_disabled = color(220, 180);
  protected int color_default = color(220);
  protected int color_hover = color(170);
  protected int color_click = color(120);
  protected int color_text = color(0);
  protected int color_stroke = color(0);
  // config
  protected String message = "";
  protected boolean show_message = false;
  protected int text_size = 14;
  protected boolean show_stroke = true;
  protected float stroke_weight = 0.5f;
  protected boolean stay_dehovered = false;
  // timer
  protected int hold_timer = 0;
  protected int lastUpdateTime = millis();

  Button() {
  }

   public void setColors(int c_dis, int c_def, int c_hov, int c_cli, int c_tex) {
    this.color_disabled = c_dis;
    this.color_default = c_def;
    this.color_hover = c_hov;
    this.color_click = c_cli;
    this.color_text = c_tex;
  }

   public void setStroke(int c_str, float stroke_weight) {
    this.color_stroke = c_str;
    this.stroke_weight = stroke_weight;
    this.show_stroke = true;
  }
   public void noStroke() {
    this.show_stroke = false;
  }

   public int fillColor() {
    if (this.disabled) {
      return this.color_disabled;
    }
    else if (this.clicked) {
      return this.color_click;
    }
    else if (this.hovered) {
      return this.color_hover;
    }
    else {
      return this.color_default;
    }
  }

   public void setFill() {
    fill(this.fillColor());
    if (this.show_stroke) {
      stroke(this.color_stroke);
      strokeWeight(this.stroke_weight);
    }
    else {
      strokeWeight(0.0001f);
      noStroke();
    }
  }

   public void writeText() {
    if (this.show_message) {
      fill(this.color_text);
      textAlign(CENTER, CENTER);
      textSize(this.text_size);
      text(this.message, this.xCenter(), this.yCenter());
    }
  }


   public void stayDehovered() {
    this.stay_dehovered = true;
    this.hovered = false;
  }

   public void update(int millis) {
    if (!this.hidden) {
      drawButton();
      if (this.clicked) {
        this.hold_timer += millis - this.lastUpdateTime;
      }
    }
    this.lastUpdateTime = millis;
  }

   public void mouseMove(float mX, float mY) {
    if (this.disabled) {
      return;
    }
    boolean prev_hover = this.hovered;
    this.hovered = this.mouseOn(mX, mY);
    if (this.stay_dehovered) {
      if (this.hovered) {
        this.hovered = false;
      }
      else {
        this.stay_dehovered = false;
      }
    }
    if (prev_hover && !this.hovered) {
      this.dehover();
    }
    else if (!prev_hover && this.hovered) {
      this.hover();
    }
  }

   public void mousePress() {
    if (this.disabled) {
      return;
    }
    if (this.hovered) {
      this.clicked = true;
      this.click();
    }
    else {
      this.clicked = false;
    }
  }

   public void mouseRelease() {
    if (this.disabled) {
      return;
    }
    if (this.clicked) {
      this.clicked = false;
      this.hold_timer = 0;
      this.release();
    }
    this.clicked = false;
  }

   public abstract float xCenter();
   public abstract float yCenter();
   public abstract float button_width();
   public abstract float button_height();
   public abstract void drawButton();
   public abstract void moveButton(float xMove, float yMove);
   public abstract boolean mouseOn(float mX, float mY);
   public abstract void hover();
   public abstract void dehover();
   public abstract void click();
   public abstract void release();
}



abstract class RectangleButton extends Button {
  protected float xi;
  protected float yi;
  protected float xf;
  protected float yf;
  protected int roundness = 8;
  protected float xCenter;
  protected float yCenter;

  RectangleButton(float xi, float yi, float xf, float yf) {
    super();
    this.setLocation(xi, yi, xf, yf);
  }

   public float xCenter() {
    return this.xCenter;
  }

   public float yCenter() {
    return this.yCenter;
  }

   public float button_width() {
    return this.xf - this.xi;
  }

   public float button_height() {
    return this.yf - this.yi;
  }

   public void drawButton() {
    this.setFill();
    rectMode(CORNERS);
    rect(this.xi, this.yi, this.xf, this.yf, this.roundness);
    this.writeText();
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    this.xCenter = this.xi + 0.5f * (this.xf - this.xi);
    this.yCenter = this.yi + 0.5f * (this.yf - this.yi);
  }

   public void moveButton(float xMove, float yMove) {
    this.xi += xMove;
    this.yi += yMove;
    this.xf += xMove;
    this.yf += yMove;
    this.xCenter = this.xi + 0.5f * (this.xf - this.xi);
    this.yCenter = this.yi + 0.5f * (this.yf - this.yi);
  }

   public void stretchButton(float amount, int direction) {
    switch(direction) {
      case UP:
        this.setLocation(this.xi, this.yi - amount, this.xf, this.yf);
        break;
      case DOWN:
        this.setLocation(this.xi, this.yi, this.xf, this.yf + amount);
        break;
      case LEFT:
        this.setLocation(this.xi - amount, this.yi, this.xf, this.yf);
        break;
      case RIGHT:
        this.setLocation(this.xi, this.yi, this.xf + amount, this.yf);
        break;
      default:
        break;
    }
  }

   public boolean mouseOn(float mX, float mY) {
    if (mX >= this.xi && mY >= this.yi &&
      mX <= this.xf && mY <= this.yf) {
      return true;
    }
    return false;
  }
}


abstract class ImageButton extends RectangleButton {
  protected PImage img;
  protected int color_tint = color(255);

  ImageButton(PImage img, float xi, float yi, float xf, float yf) {
    super(xi, yi, xf, yf);
    this.img = img;
  }

  @Override public 
  void drawButton() {
    tint(this.color_tint);
    imageMode(CORNERS);
    image(this.img, this.xi, this.yi, this.xf, this.yf);
    noTint();
    this.writeText();
  }
}


abstract class RippleRectangleButton extends ImageButton {
  class Pixel {
    private int x;
    private int y;
    private float x_pixel;
    private float y_pixel;
    Pixel(int x, int y, float x_pixel, float y_pixel) {
      this.x = x;
      this.y = y;
      this.x_pixel = x_pixel;
      this.y_pixel = y_pixel;
    }
     public float distance(float mX, float mY) {
      return sqrt((mX - this.x_pixel) * (mX - this.x_pixel) +
        (mY - this.y_pixel) * (mY - this.y_pixel));
    }
  }

  protected int rippleTime = 250;
  protected int rippleTimer = 0;
  protected int number_buckets = 50;
  protected HashMap<Integer, ArrayList<Pixel>> buckets;
  protected float clickX = 0;
  protected float clickY = 0;
  protected float maxRippleDistance;

  RippleRectangleButton(float xi, float yi, float xf, float yf) {
    super(createImage(PApplet.parseInt(xf - xi), PApplet.parseInt(yf - yi), ARGB), xi, yi, xf, yf);
    this.refreshColor();
    this.maxRippleDistance = max(this.button_width(), this.button_height());
  }

  @Override public 
  void update(int millis) {
    int timeElapsed = millis - this.lastUpdateTime;
    super.update(millis);
    if (this.rippleTimer > 0) {
      this.rippleTimer -= timeElapsed;
      if (this.rippleTimer <= 0) {
        this.refreshColor();
      }
      else {
        this.colorPixels();
      }
    }
  }

   public void refreshColor() {
    DImg dimg = new DImg(this.img);
    dimg.colorPixels(this.fillColor());
    this.img = dimg.img;
    this.rippleTimer = 0;
  }

   public void initializeRipple() {
    this.buckets = new HashMap<Integer, ArrayList<Pixel>>();
    for (int i = 0; i < this.number_buckets; i++) {
      this.buckets.put(i, new ArrayList<Pixel>());
    }
    float keyMultiplier = PApplet.parseFloat(this.rippleTime) / this.number_buckets;
    for (int i = 0; i < this.img.height; i++) {
      for (int j = 0; j < this.img.width; j++) {
        float x = this.xi + this.button_width() * j / this.img.width;
        float y = this.yi + this.button_height() * i / this.img.height;
        Pixel p = new Pixel(j, i, x, y);
        float distance = p.distance(this.clickX, this.clickY);
        int timer = PApplet.parseInt(floor(this.rippleTime * (1 - distance / this.maxRippleDistance) / keyMultiplier));
        if (this.buckets.containsKey(timer)) {
          this.buckets.get(timer).add(p);
        }
      }
    }
    this.rippleTimer = this.rippleTime;
  }

   public void colorPixels() {
    DImg dimg = new DImg(this.img);
    float currDistance = this.maxRippleDistance * (this.rippleTime - this.rippleTimer) / this.rippleTime;
    float keyMultiplier = PApplet.parseFloat(this.rippleTime) / this.number_buckets;
    for (Map.Entry<Integer, ArrayList<Pixel>> entry : this.buckets.entrySet()) {
      if (entry.getKey() * keyMultiplier > this.rippleTimer) {
        for (Pixel p : entry.getValue()) {
          dimg.colorPixel(p.x, p.y, this.color_click);
        }
        entry.getValue().clear();
      }
    }
  }

   public void hover() {
    this.refreshColor();
  }

   public void dehover() {
    this.refreshColor();
  }

   public void click() {
    this.clickX = mouseX;
    this.clickY = mouseY;
    this.initializeRipple();
  }

   public void release() {
    this.refreshColor();
  }
}




abstract class EllipseButton extends Button {
  protected float xc;
  protected float yc;
  protected float xr;
  protected float yr;

  EllipseButton(float xc, float yc, float xr, float yr) {
    super();
    this.xc = xc;
    this.yc = yc;
    this.xr = xr;
    this.yr = yr;
  }

   public float xCenter() {
    return this.xc;
  }

   public float yCenter() {
    return this.yc;
  }

   public float button_width() {
    return 2 * this.xr;
  }

   public float button_height() {
    return 2 * this.yr;
  }

   public void drawButton() {
    this.setFill();
    ellipseMode(RADIUS);
    ellipse(this.xc, this.yc, this.xr, this.yr);
    this.writeText();
  }

   public void moveButton(float xMove, float yMove) {
    this.xc += xMove;
    this.yc += yMove;
  }

   public boolean mouseOn(float mX, float mY) {
    if (this.xr == 0 || this.yr == 0) {
      return false;
    }
    float xRatio = (mX - this.xc) / this.xr;
    float yRatio = (mY - this.yc) / this.yr;
    if (xRatio * xRatio + yRatio * yRatio <= 1) {
      return true;
    }
    return false;
  }
}



abstract class CircleButton extends EllipseButton {
  CircleButton(float xc, float yc, float r) {
    super(xc, yc, r, r);
  }
}



abstract class TriangleButton extends Button {
  protected float x1;
  protected float y1;
  protected float x2;
  protected float y2;
  protected float x3;
  protected float y3;
  protected float dotvv;
  protected float dotuu;
  protected float dotvu;
  protected float constant;
  protected float xCenter;
  protected float yCenter;

  TriangleButton(float x1, float y1, float x2, float y2, float x3, float y3) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.x3 = x3;
    this.y3 = y3;
    this.dotvv = (x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1);
    this.dotuu = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    this.dotvu = (x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1);
    this.constant = this.dotvv * this.dotuu - this.dotvu * this.dotvu;
    this.xCenter = (x1 + x2 + x3) / 3.0f;
    this.yCenter = (y1 + y2 + y3) / 3.0f;
  }

   public float xCenter() {
    return this.xCenter;
  }

   public float yCenter() {
    return this.yCenter;
  }

   public void drawButton() {
    this.setFill();
    triangle(this.x1, this.y1, this.x2, this.y2, this.x3, this.y3);
    this.writeText();
  }

   public void moveButton(float xMove, float yMove) {
    this.x1 += xMove;
    this.y1 += yMove;
    this.x2 += xMove;
    this.y2 += yMove;
    this.x3 += xMove;
    this.y3 += yMove;
  }

   public boolean mouseOn(float mX, float mY) {
    float dotvp = (this.x3 - this.x1) * (mX - this.x1) + (this.y3 - this.y1) * (mY - this.y1);
    float dotup = (this.x2 - this.y1) * (mX - this.x1) + (this.y2 - this.y1) * (mY - this.y1);
    if (this.constant == 0) {
      return false;
    }
    float t1 = (this.dotuu * dotvp - this.dotvu * dotup) / this.constant;
    float t2 = (this.dotvv * dotup - this.dotvu * dotvp) / this.constant;
    println(t1, t2);
    if (t1 >= 0 && t2 >= 0 && t1 + t2 < 1) {
      return true;
    }
    return false;
  }
}






class ScrollBar {
  class ScrollBarUpButton extends RectangleButton {
    ScrollBarUpButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
    }
  }

  class ScrollBarDownButton extends RectangleButton {
    ScrollBarDownButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
    }
  }

  class ScrollBarUpSpaceButton extends RectangleButton {
    ScrollBarUpSpaceButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
    }
  }

  class ScrollBarDownSpaceButton extends RectangleButton {
    ScrollBarDownSpaceButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
    }
  }

  class ScrollBarBarButton extends RectangleButton {
    ScrollBarBarButton(float xi, float yi, float xf, float yf) {
      super(xi, yi, xf, yf);
      this.roundness = 0;
    }
     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
    }
     public void release() {
    }
  }

  protected ScrollBarUpButton button_up = new ScrollBarUpButton(0, 0, 0, 0);
  protected ScrollBarDownButton button_down = new ScrollBarDownButton(0, 0, 0, 0);
  protected ScrollBarUpSpaceButton button_upspace = new ScrollBarUpSpaceButton(0, 0, 0, 0);
  protected ScrollBarDownSpaceButton button_downspace = new ScrollBarDownSpaceButton(0, 0, 0, 0);
  protected ScrollBarBarButton button_bar = new ScrollBarBarButton(0, 0, 0, 0);

  protected float minValue = 0;
  protected float maxValue = 0;
  protected float value = 0;

  protected float xi;
  protected float yi;
  protected float xf;
  protected float yf;
  protected boolean vertical;
  protected float bar_size = 0;
  protected float min_size = 0;
  protected float value_size = 0;
  protected float step_size = 10; // constant

  ScrollBar(float xi, float yi, float xf, float yf, boolean vertical) {
    this.vertical = vertical;
    this.setLocation(xi, yi, xf, yf);
  }

   public void setLocation(float xi, float yi, float xf, float yf) {
    this.xi = xi;
    this.yi = yi;
    this.xf = xf;
    this.yf = yf;
    if (this.vertical) {
      this.bar_size = this.xf - this.xi;
      if (3 * this.bar_size > this.yf - this.yi) {
        this.bar_size = (this.yf - this.yi) / 3.0f;
        this.min_size = 0.5f * this.bar_size;
      }
      else {
        this.min_size = min(this.bar_size, (this.yf - this.yi) / 9.0f);
      }
      this.button_up.setLocation(this.xi, this.yi, this.xf, this.yi + this.bar_size);
      this.button_down.setLocation(this.xi, this.yf - this.bar_size, this.xf, this.yf);
    }
    else {
      //
    }
    this.refreshBarButtonSizes();
  }

   public void refreshBarButtonSizes() {
    if (this.vertical) {
      float bar_height = this.yf - this.yi - 2 * this.bar_size;
      float bar_button_size = max(this.min_size, bar_height - this.step_size * (this.maxValue - this.minValue));
      if (this.maxValue == this.minValue) {
        this.value_size = 0;
      }
      else {
        this.value_size = (bar_height - bar_button_size) / (this.maxValue - this.minValue);
      }
    }
    else {
      //
    }
    this.refreshBarButtons();
  }

   public void refreshBarButtons() {
    if (this.vertical) {
      float cut_one = this.yi + this.bar_size + this.value_size * (this.value - this.minValue);
      float cut_two = this.yf - this.bar_size - this.value_size * (this.maxValue - this.value);
      this.button_upspace.setLocation(this.xi, this.yi + this.bar_size, this.xf, cut_one);
      this.button_downspace.setLocation(this.xi, cut_two, this.xf, this.yf - this.bar_size);
      this.button_bar.setLocation(this.xi, cut_one, this.xf, cut_two);
    }
    else {
      //
    }
  }

   public void updateMinValue(float minValue) {
    this.minValue = minValue;
    if (this.minValue > this.maxValue) {
      this.minValue = this.maxValue;
    }
    if (this.value < this.minValue) {
      this.value = this.minValue;
    }
    this.refreshBarButtonSizes();
  }

   public void updateMaxValue(float maxValue) {
    this.maxValue = maxValue;
    if (this.maxValue < this.minValue) {
      this.maxValue = this.minValue;
    }
    if (this.value > this.maxValue) {
      this.value = this.maxValue;
    }
    this.refreshBarButtonSizes();
  }

   public void updateValue(float value) {
    this.value = value;
    if (this.value < this.minValue) {
      this.value = this.minValue;
    }
    else if (this.value > this.maxValue) {
      this.value = this.maxValue;
    }
    this.refreshBarButtons();
  }

   public void update(int millis) {
    this.button_up.update(millis);
    this.button_down.update(millis);
    this.button_upspace.update(millis);
    this.button_downspace.update(millis);
    this.button_bar.update(millis);
  }

   public void mouseMove(float mX, float mY) {
    this.button_up.mouseMove(mX, mY);
    this.button_down.mouseMove(mX, mY);
    this.button_upspace.mouseMove(mX, mY);
    this.button_downspace.mouseMove(mX, mY);
    this.button_bar.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.button_up.mousePress();
    this.button_down.mousePress();
    this.button_upspace.mousePress();
    this.button_downspace.mousePress();
    this.button_bar.mousePress();
  }

   public void mouseRelease() {
    this.button_up.mouseRelease();
    this.button_down.mouseRelease();
    this.button_upspace.mouseRelease();
    this.button_downspace.mouseRelease();
    this.button_bar.mouseRelease();
  }
}
// default to if file does not exist create file
 public void mkFile(String path) {
  mkFile(path, false);
}
 public void mkFile(String path, boolean replace) {
  Path p = Paths.get(sketchPath(path));
  if (!Files.exists(p)) {
    try {
      Files.createFile(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkFile(" + path + ")");
    }
  }
  else if (replace && !Files.isDirectory(p)) {
    deleteFile(path);
    try {
      Files.createFile(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkFile(" + path + ")");
    }
  }
}

// delete file
 public void deleteFile(String path) {
  deleteFile(Paths.get(sketchPath(path)));
}
 public void deleteFile(Path p) {
  try {
    Files.deleteIfExists(p);
  } catch(IOException e) {
    println("ERROR: IOException at deleteFile(" + p + ")");
  }
}

// list all entries in directory
 public ArrayList<Path> listEntries(String path) {
  return listEntries(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listEntries(Path p) {
  ArrayList<Path> entries = new ArrayList<Path>();
  try {
    if (Files.isDirectory(p)) {
      Files.list(p).forEach(entry -> entries.add(entry));
    }
    else {
      println("ERROR: Not a directory at listEntries(" + p + ")");
    }
  } catch(IOException e) {
    println("ERROR: IOException at listEntries(" + p + ")");
  }
  return entries;
}

// list all files in directory
 public ArrayList<Path> listFiles(String path) {
  return listFiles(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listFiles(Path p) {
  ArrayList<Path> files = listEntries(p);
  for (int i = 0; i < files.size(); i++) {
    if (Files.isDirectory(files.get(i))) {
      files.remove(i);
      i--;
    }
  }
  return files;
}

// list all folder in directory
 public ArrayList<Path> listFolders(String path) {
  return listFolders(Paths.get(sketchPath(path)));
}
 public ArrayList<Path> listFolders(Path p) {
  ArrayList<Path> folders = listEntries(p);
  for (int i = 0; i < folders.size(); i++) {
    if (!Files.isDirectory(folders.get(i))) {
      folders.remove(i);
      i--;
    }
  }
  return folders;
}

// default to if folder does not exist create folder
 public void mkdir(String path) {
  mkdir(path, false);
}
 public void mkdir(String path, boolean replace) {
  Path p = Paths.get(sketchPath(path));
  if (!Files.exists(p)) {
    try {
      Files.createDirectory(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkdir(" + path + ")");
    }
  }
  else if (replace && Files.isDirectory(p)) {
    deleteFolder(path);
    try {
      Files.createDirectory(p);
    } catch (IOException e) {
      println("ERROR: IOException at mkdir(" + path + ")");
    }
  }
}

// recursively deletes folder
 public void deleteFolder(String path) {
  deleteFolder(Paths.get(sketchPath(path)));
}
 public void deleteFolder(Path p) {
  if (Files.isDirectory(p)) {
    for (Path filePath : listFiles(p)) {
      deleteFile(filePath);
    }
    for (Path folderPath : listFolders(p)) {
      deleteFolder(folderPath);
    }
    try {
      Files.delete(p);
    } catch(IOException e) {
      println("ERROR: IOException at deleteFolder(" + p + ")");
    }
  }
  else {
    deleteFile(p);
  }
}
enum ProgramState {
  INITIAL_INTERFACE, EXITING, ENTERING_MAINMENU, MAINMENU_INTERFACE;
}

class Global {
  // Program
  private InterfaceLNZ menu;
  private ProgramState state = ProgramState.INITIAL_INTERFACE;
  private int timer_exiting = Constants.exit_delay;
  private Images images;
  private Sounds sounds;
  // FPS
  private int lastFrameTime = millis();
  private float lastFPS = Constants.maxFPS;
  private int frameCounter = frameCount;
  private int timer_FPS = Constants.frameUpdateTime;
  // Colors
  private int color_background = color(180);

  Global(LNZ thisInstance) {
    this.images = new Images();
    this.sounds = new Sounds(thisInstance);
  }

   public int frame() {
    int elapsed = millis() - this.lastFrameTime;
    this.lastFrameTime = millis();
    return elapsed;
  }

   public void exit() {
    this.state = ProgramState.EXITING;
  }
}
 public int ccolor(int gray) {
  return ccolor(gray, gray, gray, 255);
}
 public int ccolor(int gray, int a) {
  return ccolor(gray, gray, gray, a);
}
 public int ccolor(int r, int g, int b) {
  return ccolor(r, g, b, 255);
}
 public int ccolor(int r, int g, int b, int a) {
  int max = 256;
  return max*max*max*a + max*max*r + max*g + b;
}


class Images {
  private HashMap<String, PImage> imgs = new HashMap<String, PImage>();
  private String basePath = sketchPath("data/images/");

  Images() {}

   public PImage getImage(String filePath) {
    if (this.imgs.containsKey(filePath)) {
      return this.imgs.get(filePath);
    }
    else {
      PImage img = loadImage(this.basePath + filePath);
      if (img == null) {
        println("ERROR: Missing image " + filePath + ".");
        return this.getBlackPixel();
      }
      else {
        this.imgs.put(filePath, img);
        return img;
      }
    }
  }

   public PImage getBlackPixel() {
    PImage img = new PImage(1, 1, RGB);
    img.loadPixels();
    img.pixels[0] = color(0);
    img.updatePixels();
    return img;
  }

   public PImage getTransparentPixel() {
    PImage img = new PImage(1, 1, RGB);
    img.loadPixels();
    img.pixels[0] = color(255, 1);
    img.updatePixels();
    return img;
  }
}
abstract class InterfaceLNZ {
  InterfaceLNZ() {
  }

   public abstract void update(int millis);
   public abstract void mouseMove(float mX, float mY);
   public abstract void mousePress();
   public abstract void mouseRelease();
}



class InitialInterface extends InterfaceLNZ {

  abstract class InitialInterfaceButton extends RectangleButton {
    InitialInterfaceButton(float yi, float yf) {
      super(Constants.initialInterface_size - Constants.initialInterface_buttonWidth -
        Constants.initialInterface_buttonGap, yi, Constants.initialInterface_size -
        Constants.initialInterface_buttonGap, yf);
      this.setColors(color(0, 100, 30, 200), color(0, 129, 50, 150), color(0, 129, 50, 190), color(0, 129, 50, 230), color(255));
      this.noStroke();
      this.show_message = true;
      this.text_size = 15;
    }

     public void hover() {
      global.sounds.trigger("interfaces/buttonOn1");
      InitialInterface.this.logo.release();
    }
     public void dehover() {
      this.clicked = false;
    }
     public void click() {
      InitialInterface.this.logo.release();
    }
     public void release() {
      this.stayDehovered();
      InitialInterface.this.logo.release();
      InitialInterface.this.logo.release();
    }
  }

  class InitialInterfaceButton1 extends InitialInterfaceButton {
    InitialInterfaceButton1(float buttonHeight) {
      super(Constants.initialInterface_buttonGap,
        Constants.initialInterface_buttonGap + buttonHeight);
      this.message = "Launch";
    }

    @Override public 
    void release() {
      global.sounds.trigger("interfaces/buttonClick4");
      global.state = ProgramState.ENTERING_MAINMENU;
      background(global.color_background);
      surface.setSize(displayWidth, displayHeight);
      surface.setLocation(0, 0);
      global.menu = null;
    }
  }

  class InitialInterfaceButton2 extends InitialInterfaceButton {
    InitialInterfaceButton2(float buttonHeight) {
      super(2 * Constants.initialInterface_buttonGap + buttonHeight,
        2 * Constants.initialInterface_buttonGap + 2 * buttonHeight);
      this.message = "Uninstall";
    }

    @Override public 
    void release() {
      global.sounds.trigger("interfaces/buttonClick3");
    }
  }

  class InitialInterfaceButton3 extends InitialInterfaceButton {
    InitialInterfaceButton3(float buttonHeight) {
      super(3 * Constants.initialInterface_buttonGap + 2 * buttonHeight,
        3 * Constants.initialInterface_buttonGap + 3 * buttonHeight);
      this.message = "Reset\nGame";
    }

    @Override public 
    void release() {
      global.sounds.trigger("interfaces/buttonClick3");
    }
  }

  class InitialInterfaceButton4 extends InitialInterfaceButton {
    InitialInterfaceButton4(float buttonHeight) {
      super(4 * Constants.initialInterface_buttonGap + 3 * buttonHeight,
        4 * Constants.initialInterface_buttonGap + 4 * buttonHeight);
      this.message = "Version\nHistory";
    }

    @Override public 
    void release() {
      global.sounds.trigger("interfaces/buttonClick3");
    }
  }

  class InitialInterfaceButton5 extends InitialInterfaceButton {
    InitialInterfaceButton5(float buttonHeight) {
      super(5 * Constants.initialInterface_buttonGap + 4 * buttonHeight,
        5 * Constants.initialInterface_buttonGap + 5 * buttonHeight);
      this.message = "Exit";
    }

    @Override public 
    void release() {
      global.sounds.trigger("interfaces/buttonClick3");
      super.release();
      global.exit();
    }
  }

  class LogoImageButton extends ImageButton {
    LogoImageButton() {
      super(global.images.getImage("logo.png"), 0, 0, 400, 400);
    }

     public void hover() {
    }
     public void dehover() {
    }
     public void click() {
      this.color_tint = color(255, 200, 200);
    }
     public void release() {
      this.color_tint = color(255);
    }
  }

  private InitialInterfaceButton[] buttons = new InitialInterfaceButton[5];
  private LogoImageButton logo = new LogoImageButton();

  private ScrollBar test = new ScrollBar(10, 10, 80, 380, true);

  InitialInterface() {
    super();
    float buttonHeight = (Constants.initialInterface_size - (this.buttons.length + 1) *
      Constants.initialInterface_buttonGap) / this.buttons.length;
    this.buttons[0] = new InitialInterfaceButton1(buttonHeight);
    this.buttons[1] = new InitialInterfaceButton2(buttonHeight);
    this.buttons[2] = new InitialInterfaceButton3(buttonHeight);
    this.buttons[3] = new InitialInterfaceButton4(buttonHeight);
    this.buttons[4] = new InitialInterfaceButton5(buttonHeight);
  }

   public void update(int millis) {
    this.logo.update(millis);
    for (InitialInterfaceButton button : this.buttons) {
      button.update(millis);
    }
    test.update(millis);
  }

   public void mouseMove(float mX, float mY) {
    this.logo.mouseMove(mX, mY);
    for (InitialInterfaceButton button : this.buttons) {
      button.mouseMove(mX, mY);
    }
    test.mouseMove(mX, mY);
  }

   public void mousePress() {
    this.logo.mousePress();
    for (InitialInterfaceButton button : this.buttons) {
      button.mousePress();
    }
    test.mousePress();
    this.test.updateMaxValue(this.test.maxValue + 1);
    this.test.updateMinValue(this.test.minValue - 1);
  }

   public void mouseRelease() {
    this.logo.mouseRelease();
    for (InitialInterfaceButton button : this.buttons) {
      button.mouseRelease();
    }
    test.mouseRelease();
  }
}

class MainMenuInterface extends InterfaceLNZ {

  abstract class MainMenuGrowButton extends RippleRectangleButton {
    protected float xf_grow;
    protected float ratio; // ratio when shrunk (can have it be > 1 to make it shrink when hovered)
    protected float grow_speed = 0.7f; // pixels / ms
    protected PImage icon;
    protected boolean collapsing = false;

    MainMenuGrowButton(float xi, float yi, float xf, float yf, float ratio) {
      super(xi, yi, xf * ratio, yf);
      this.xf_grow = xf;
      this.ratio = ratio;
      this.maxRippleDistance = xf - xi;
      this.icon = this.getIcon();
      this.text_size = 24;
      this.noStroke();
      this.setColors(color(170), color(0, 1), color(150, 90, 90, 150), color(240, 180, 180), color(255));
      this.refreshColor();
    }

     public abstract PImage getIcon();

    @Override public 
    void update(int millis) {
      int timeElapsed = millis - this.lastUpdateTime;
      float pixelsMoved = timeElapsed * this.grow_speed;
      super.update(millis);
      float pixelsLeft = 0;
      int pixelsToMove = 0;
      if (this.collapsing) {
        if (this.hovered) {
          pixelsLeft = this.xf_grow - this.xf;
          pixelsToMove = PApplet.parseInt(ceil(min(pixelsLeft, pixelsMoved)));
          if (pixelsToMove > 0) {
            this.stretchButton(pixelsToMove, RIGHT);
          }
          else {
            this.collapsing = false;
            this.refreshColor();
          }
        }
        else {
          pixelsLeft = this.xf_grow * this.ratio - this.xf;
          pixelsToMove = PApplet.parseInt(floor(max(pixelsLeft, -pixelsMoved)));
          if (pixelsToMove < 0) {
            this.stretchButton(pixelsToMove, RIGHT);
          }
          else {
            this.collapsing = false;
            this.refreshColor();
          }
        }
      }
      if (!this.hovered && !this.collapsing) {
        imageMode(CENTER);
        image(this.icon, this.xCenter(), this.yCenter(), this.button_width(), this.button_height());
      }
    }

    @Override public 
    int fillColor() {
      if (this.collapsing) {
        if (this.clicked) {
          return this.color_click;
        }
        else {
          return this.color_hover;
        }
      }
      return super.fillColor();
    }

     public void hover() {
      this.collapsing = true;
      super.hover();
      this.show_message = true;
    }

     public void dehover() {
      this.collapsing = true;
      super.dehover();
      this.show_message = false;
      this.clicked = false;
      this.color_text = color(255);
    }

     public void click() {
      super.click();
      this.color_text = color(0);
    }

     public void release() {
      super.release();
      this.color_text = color(255);
    }
  }


  class MainMenuGrowButton1 extends MainMenuGrowButton {
    MainMenuGrowButton1() {
      super(0, height - 60, 200, height, 0.3f);
      this.message = "Exit";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/power.png");
    }

    @Override public 
    void release() {
      super.release();
      global.exit();
    }
  }

  class MainMenuGrowButton2 extends MainMenuGrowButton {
    MainMenuGrowButton2() {
      super(0, height - 160, 200, height - 100, 0.3f);
      this.message = "Options";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/gear.png");
    }
  }

  class MainMenuGrowButton3 extends MainMenuGrowButton {
    MainMenuGrowButton3() {
      super(0, height - 260, 200, height - 200, 0.3f);
      this.message = "Achievements";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/achievements.png");
    }
  }

  class MainMenuGrowButton4 extends MainMenuGrowButton {
    MainMenuGrowButton4() {
      super(0, height - 360, 200, height - 300, 0.3f);
      this.message = "Map Editor";
    }
     public PImage getIcon() {
      return global.images.getImage("icons/map.png");
    }
  }



  class backgroundImageThread extends Thread {
    private PImage img = createImage(width, height, ARGB);
    private float distance_threshhold = 150;
    private float mX = mouseX;
    private float mY = mouseY;

    backgroundImageThread() {
      super("backgroundImageThread");
    }

    @Override public 
    void run() {
      DImg dimg = new DImg(this.img);
      dimg.makeTransparent(255);
      dimg.addImagePercent(global.images.getImage("hillary.png"), 0, 0, 1, 1);
      dimg.brightenGradient(0.02f, this.distance_threshhold, this.mX, this.mY);
      this.img = dimg.img;
    }
  }


  private MainMenuGrowButton[] growButtons = new MainMenuGrowButton[4];
  private PImage backgroundImage;
  backgroundImageThread thread = new backgroundImageThread();

  MainMenuInterface() {
    super();
    this.backgroundImage = createImage(width, height, RGB);
    this.growButtons[0] = new MainMenuGrowButton1();
    this.growButtons[1] = new MainMenuGrowButton2();
    this.growButtons[2] = new MainMenuGrowButton3();
    this.growButtons[3] = new MainMenuGrowButton4();
  }

   public void update(int millis) {
    // draw background
    imageMode(CORNER);
    image(this.backgroundImage, 0, 0);
    // update elements
    for (MainMenuGrowButton button : this.growButtons) {
      button.update(millis);
    }
    // restart thread
    if (!this.thread.isAlive()) {
      this.backgroundImage = this.thread.img;
      this.thread = new backgroundImageThread();
      this.thread.start();
    }
  }

   public void mouseMove(float mX, float mY) {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mouseMove(mX, mY);
    }
  }

   public void mousePress() {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mousePress();
    }
  }

   public void mouseRelease() {
    for (MainMenuGrowButton button : this.growButtons) {
      button.mouseRelease();
    }
  }
}


class Sounds {
  private Minim minim;
  private AudioOutput out;
  private HashMap<String, Sampler> soundEffects = new HashMap<String, Sampler>();
  private String basePath = sketchPath("data/sounds/");

  Sounds(LNZ thisInstance) {
    this.minim = new Minim(thisInstance);
    this.out = this.minim.getLineOut();
  }

   public void trigger(String soundPath) {
    if (this.soundEffects.containsKey(soundPath)) {
      this.soundEffects.get(soundPath).trigger();
    }
    else {
      String filePath = this.basePath + soundPath + ".wav";
      File f = new File(filePath);
      if (f.exists()) {
        Sampler s = new Sampler(filePath, 2, this.minim);
        s.patch(this.out);
        this.soundEffects.put(soundPath, s);
        s.trigger();
      }
      else {
        println("ERROR: Missing sound " + filePath + ".");
      }
    }
  }
}


  public void settings() { fullScreen(FX2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "LNZ" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
